---
layout: page
title: "PC-SIG Diskette Library (Disk #1983)"
permalink: /software/pcx86/sw/misc/pcsig/1000-1999/DISK1983/
machines:
  - id: ibm5170
    type: pcx86
    config: /machines/pcx86/ibm/5170/cga/1024kb/rev3/machine.xml
    diskettes: /machines/pcx86/diskettes.json,/disks/pcsigdisks/pcx86/diskettes.json
    autoGen: true
    autoMount:
      B: "PC-SIG Library Disk #1983"
    autoType: $date\r$time\rB:\rDIR\r
---

{% include machine.html id="ibm5170" %}

{% comment %}info_begin{% endcomment %}

## Information about "TURBOMENU SYSTEM"

    The TURBOMENU SYSTEM toolbox is a set of routines designed for use in
    the Turbo Pascal language to define and manipulate pull-down menus.  The
    menus can be defined in a text or graphics mode in one or two
    dimensions.
    
    This system supports an auto-tracking feature that helps the programmer
    by keeping menu-tracking to a minimum.  It also comes with support for
    mouse-tracking.  The data structure used by the system uses stack and
    heap memory very efficiently.
    
    A sample program is included on the disk to demonstrate the type of
    menus that may be defined.  The toolbox supports versions 4.0, 5.0, and
    5.5 although this version is not object-oriented.  The program is
    written in Pascal and is available to registered users.
{% comment %}info_end{% endcomment %}

{% comment %}samples_begin{% endcomment %}

## FILE1983.TXT

{% raw %}
```
Disk No: 1983                                                           
Disk Title: TurboMenu System                                            
PC-SIG Version: S1.1                                                    
                                                                        
Program Title: TurboMenu System                                         
Author Version: 07/89                                                   
Author Registration: $25.00                                             
Special Requirements: Turbo Pascal.                                     
                                                                        
The MAXX DATA TURBOMENU toolbox is a set of routines designed for use in
the Turbo Pascal language to define and manipulate pull-down menus.  The
menus can be defined in a text or graphics mode in one or two           
dimensions.                                                             
                                                                        
This system supports an auto-tracking feature that helps the programmer 
by keeping menu-tracking to a minimum.  It also comes with support for  
mouse-tracking.  The data structure used by the system uses stack and   
heap memory very efficiently.                                           
                                                                        
A sample program is included on the disk to demonstrate the type of     
menus that may be defined.  The toolbox supports versions 4.0, 5.0, and 
5.5 although this version is NOT object-oriented.  The product is       
written in Turbo Pascal so that source code the user can understand may 
be provided.  The source code is provided only when the product is      
registered.                                                             
                                                                        
PC-SIG                                                                  
1030D East Duane Avenue                                                 
Sunnyvale  Ca. 94086                                                    
(408) 730-9291                                                          
(c) Copyright 1989 PC-SIG, Inc.                                         
```
{% endraw %}

## MENU.DOC

{% raw %}
```
Page 1MAXX DATA SYSTEMS, INC. PROGRAM LICENSE AGREEMENT

YOU SHOULD CAREFULLY READ THE FOLLOWING TERMS AND CONDITIONS
BEFORE OPENING, INSTALLING, AND/OR EXECUTING THIS
APPLICATION/DISKETTE(S) PACKAGE.  OPENING, INSTALLING, AND/OR
EXECUTING THIS APPLICATION/DISKETTE(S) INDICATES YOUR ACCEPTANCE
OF THESE TERMS AND CONDITIONS.  IF YOU DO NOT AGREE WITH THEM, 
YOU SHOULD PROMPTLY RETURN THE PACKAGE UNOPENED OR DESTROY ALL
COPIES IN YOUR POSSESION.

Maxx Data Systems, Inc. provides this program and licenses its
use in the United States and Puerto Rico.  Anyone wishing to license
this program for use outside the United States should contact
Maxx Data Systems, Inc. for licensing information.  You assume
responsibility for the selection of the program to achieve your
intended results, and for the installation, use, and results
obtained from the program.

SHAREWARE LICENSE

The following  is the shareware license agreement and understanding:

1. You are requested to make a shareware contribution of $25 U.S.
   dollars for use of this program (see REGISTRATION information);

2. Maxx Data Systems, Inc. retains the sole right to sell the program;

3. You are encouraged to copy and distribute the program within
   the following constraints:

        -  all program files remain unaltered and are distributed
           together in their entirety;
        -  only non-registered versions with the built-in
           time delays be distributed;
        -  no attempt is made to sell the program, or to make
           money from it or any modified version of it;

4. Continued use of the program (more than two weeks) by any
   individual, corporation, or institution without a Single User or
   Site license is prohibited and constitutes an infringement of 
   copyright;

5. Single User licenses are obtained by sending the $25 shareware 
   contribution (See REGISTRATION information);

6. Corporations and other institutions (including government and 
   educational) which desire a Site license should contact Maxx Data
   Systems, Inc. for more information.

REGISTRATION

1. Only those users who have registered the software are eligible for
   technical support.

Page 22. By paying the registration fee of $25 you will receive the
   source code without the delay screen, a manual which
   thoroughly explains the program, and unlimited technical support.

3. The registration fee may be paid by check, money order,
   American Express, MasterCard, or Visa.  Checks or money orders
   may be sent to
          Maxx Data Systems, Inc.
          1126 S. Cedar Ridge, Ste. 115
          Duncanville, Tx. 75137
   Credit card orders may be placed by calling
          1-800-622-8366

4. Technical support is available between the hours of 8:30 am to
   4:30 pm Central Time to registered users of the package by calling
          1-214-298-1384
   No technical support will be provided on the 800 number.

LIMITED WARRANTY

MAXX DATA SYSTEMS, INC. (MAXX DATA) WARRANTS THAT THE DISKETTE
AND DOCUMENTATION ARE FREE OF PHYSICAL DEFECTS IN MATERIALS AND
WORKMANSHIP UNDER NORMAL USE FOR A PERIOD OF 30 DAYS FROM THE
DATE OF PURCHASE.  IF YOU NOTIFY MAXX DATA WITHIN THE WARRANTY
PERIOD OF ANY PHYSICAL DEFECTS IN MATERIAL OR WORKMANSHIP AND
RETURN THE DEFECTIVE PRODUCT, MAXX DATA WILL REPLACE THE
DEFECTIVE DISKETTE OR DOCUMENTATION.  REPLACEMENT OF PHYSICALLY
DEFECTIVE MATERIALS CONSTITUTES THE ENTIRE REMEDY FOR BREACH OF
THIS WARRANTY, AND MAXX DATA SHALL NOT BE LIABLE FOR ANY OTHER
DAMAGES, INCLUDING, BUT NOT LIMITED TO, LOSS OF PROFIT, AND
SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGE CLAIMS.

OTHER THAN THE WARRANTIES AGAINST PHYSICAL DEFECTS SET OUT ABOVE,
THERE ARE NO WARRANTIES, EXPRESS OR IMPLIED WHICH EXTEND BEYOND
THE FACE OF THIS DOCUMENT AND MAXX DATA SPECIFICALLY DISCLAIMS
ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING, BUT NOT LIMITED
TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
PARTICULAR PURPOSE.  PURCHASER IS SOLELY RESPONSIBLE FOR
DETERMINIG THE DESIRED RESULTS FROM USE OF THE DISKETTE AND
DOCUMENTATION, FOR EVALUATING THEIR CAPABILITIES AND FOR
SUCCESSFULLY OPERATING THE PROGRAM.

THIS WARRANTY SHALL BE INTERPRETED UNDER THE LAWS OF THE STATE OF TEXAS.

THE PURCHASER AGREES THAT ANY CLAIM, CONTROVERSY OR DISPUTE
ARISING OUT OF OR RELATING TO THIS WARRANTY OR THE PERFORMANCE
THEREOF WHICH CANNOT BE AMICABLY SETTLED SHALL BE RESOLVED
EXCLUSIVELY BY A PROCEEDING IN A COURT IN DALLAS COUNTY, TEXAS
AND PURCHASER IRREVOCABLY ACCEPTS THE JURISDICTION OF THE COURTS
OF THE STATE OF TEXAS AND THE FEDERAL COURTS LOCATED IN DALLAS
COUNTY, TEXAS FOR SUCH CLAIMS, CONTROVERSIES OR DISPUTES.

Maxx Data and Maxx Data TurboMenu are trademarks of Maxx Data
Systems, Inc.  Other brand and product names are trademarks or
Page 3registered trademarks of their respective holders.

Copyright 1989 Maxx Data Systems, Inc.

GENERAL DESCRIPTION AND INFORMATION

	The Maxx Data TurboMenu system is based on a linked list type 
structure with a header block used for tracking.  Information that 
is common to the whole menu,such as color or shadow information, 
is held within the header block.  Data that is specific to an option, 
such as theoption output string, is held within a node of the list.  
This dynamic structure makes it possible for the configuration of a
menu to be changed at run-time.
	Due to the nature of the menu structure, commands have to be
given in a certain order.  The first command given is always
InitMenu or SetUpMenu.  The InitMenu command initializes the data
structure in preparation for your menu definition.  The SetUpMenu
command initializes the data structure too, but it also defines
the number of options, the screen mode of the menu, and loads the
text into the menu.  All of these things can be done with single
commands, SetUpMenu just does them for you.  The command set for
the Maxx Data TurboMenu system can be broken down into three 
categories. The first is commands that have to be given before the 
menu is built.  The second is commands that can be given at any time. 
The third is commands that have to be given after the menu is
built.  These commands are listed in the categories below.

	Before			After			Anytime

	InitMenu			SetMenuOptionCode	SetMenuRect
	SetMenuOptions		SetMenuText		SetMenuColors
	SetUpMenu			SetMenuSpacing		SetMenuShadow
									SetMenuSpaces
									FreeList

	The commands listed above are used to define the menus for
an application.  The remaining commands are used to display,
control and track the menus in the application.  There are three
display commands: OpenMenu, CloseMenu, and Invert.  There are two
control commands: MoveCursor and JumpCursor.  There are two
tracking commands: MenuBackOut and MenuToggle.  The tracking is
done by means of two global variables declared in the menu unit. 
They are: MenuList, an array of pointers to menus, and MenuNum,
which tracks the current open menu and the number of open menus.
	The automatic tracking does not have to be used but
simplifies things if it is.  When a menu is opened it is added to
the MenuList and MenuNum is incremented.  The first menu opened
assigns the value zero to MenuNum.  This menu is considered the
main menu from that point on.  The identifier MenuList[MenuNum]^
marks the current menu.  If this identifier is passed to the
MoveCursor or JumpCursor procedures the menu affected will always
be the current menu.  MenuBackOut closes the current menu and
resets the next higher menu to active.  The menuToggle command
closes all menus but the main menu.
Page 4	To use the Maxx Data TurboMenu system simply load the menu 
unit to your hard disk or your unit floppy.  Include the menu 
directory in your Pascal directories setup.  Include the menu 
unit in the Uses statement of your program.  Menu variables are 
declared of type MenuType.


REFERENCE GUIDE - Menu Unit

Procedure CursorOn;

	The CursorOn command enables the flashing text cursor if it
has been turned off;


Procedure CursorOff;

	This procedure disables the flashing cursor on text screens.  This 
command is useful when you want to write something to the screen
without the cursor appearing.


Procedure Invert(Name : MenuType);

	This is the routine used to invert or highlight the
currently active option in a menu.


Procedure InitMenu(Var Name : MenuType; Mode : Boolean);

	The InitMenu procedure initializes the menu data structure
using the default values for menus and defines the screen mode
of the menu, either text or graphics.  Two constants are defined
for use with this command.  The constants are shown below with
the example.

Ex:
   Const
     TextMenu  = False;
     GraphMenu = True;

   Var MainMenu : MenuType;

   Begin
     InitMenu(MainMenu,GraphMenu);
   End;


Procedure BuildMenu(Var Name : MenuType);

	The BuildMenu command builds the list structure the menu
system is based on.  This command is necessary before many others
can be used.


Page 5Procedure FreeList(Var Name : MenuType);

	This command releases the memory used by the menu.  This
allows you to dispose of a menu that is no longer going to be used.



Procedure SetMenuRect(Var Name : MenuType; X1,Y1,X2,Y2 : Integer);

	The menu rectangle is automatically calculated in the
SetMenuSpacing command.  You may wish to override these
coordinates with some of your own.  Be very careful how you alter
these values.  The OpenMenu command accepts an (X,Y) coordinate
to position the upper left corner of the menu at.  If you change
the X1,Y1 coordinates from 0,0 the offset will change
accordingly.  For instance, if you change the X1,Y1 values to
25,25 and try to open the menu at 25,25 the menu will actually
open at screen location 50,50.  Another thing to be aware of is
that if you are depending on the automatic calculation of the
spacing within the menu, do not change the menu rectangle values. 
The spacing of the option strings will not recalculate to match
the new rectangle coordinates.  An example is shown of the
possible use for the SetMenuRect command.  In this instance a
horizontal menu has been calculated for use as a main menu bar. 
The calculations did not stretch the menu all the way across the
screen though.  Here is how to correct that, without altering
anything important.

Ex: 
   Var MainMenu : MenuType;

   Begin
     SetMenuSpacing(MainMenu);
     SetMenuRect(MainMenu,MenuMinX(MainMenu),MenuMinY(MainMenu),
                          GetMaxX - 1,MenuMaxY(MainMenu));
   End;


Procedure SetMenuColors(Var Name : MenuType; Fore,Back : Byte);

	This command sets the foreground and background colors of the
menu.  The border and text are drawn in the foreground color and
the menu rectangle is filled in the background color.

Ex:
   Var MainMenu : MenuType;

   Begin
     SetMenuColors(MainMenu,Black,LightBlue);
   End;


Procedure SetMenuOptions(Var Name : MenuType; OptionsX,OptionsY : Byte);

Page 6	The menu system must know how many options in any direction
the menu will have.  This command is very important since it not
only tells the system how many options will be needed, but also
derives from those values the direction and dimensional size of
the menu.

Ex:
   Var MainMenu : MenuType;

   Begin
     SetMenuOptions(MainMenu,5,0);  { Defines a one dimensional, 
                                      horizontal menu }
     
     SetMenuOptions(MainMenu,0,5);  { Defines a one dimensional,
                                      vertical menu }

     SetMenuOptions(MainMenu,5,5);  { Defines a two dimensional
                                      menu }
   End.


Procedure SetMenuOptionCode(Var Name : MenuType; X,Y,Code : Integer);

	Since the menu system is based on the concept of integer
return codes the programmer must have a means of assigning these
integer codes to the menu options.  The SetMenuOptionCode command
does the trick.  By passing the procedure the menu, the X,Y
location of the option, and the code to be assigned the option
you can assign the necessary return codes.

Ex:
   Var MainMenu : MenuType;
       I        : Integer;

   Begin
     For I := 1 to OptionsX(MainMenu) do
       SetMenuOptionCode(MainMenu,I,0,100 + I);
   End;


Procedure SetMenuShadow(Var Name : MenuType; Shadow,ShadowColor : Byte);

	The menu system supports shadowing of the menu rectangles. 
The Shadow parameter defines the direction of the shadow and the
ShadowColor parameter defines the color of the shadow.  The
following constants are defined for assigning the shadow direction:

   NoShadow         = 0;
   ShadowUpperLeft  = 1;
   ShadowUpperRight = 2;
   ShadowLowerLeft  = 3;
   ShadowLowerRight = 4;


Page 7Procedure SetMenuText(Var Name : MenuType; Var Text);

	This procedure takes the strings listed in an array and
loads them into the menu.  The Text parameter is untyped so that
the procedure can accept both one and two dimensional arrays to
support both type of menus.  The predeclared types of OneList
and TwoList are used to define the option list for the menu system.
The OneList type is used to define string lists for one
dimensional menus and the TwoList array is used to define the
lists for two dimensional menus. This command can only be given
after the BuildMenu command.

Ex:
   Var Options  : OneList;
       MainMenu : MenuType;

   Begin
     BuildMenu(MainMenu);
     Options[1] := 'File';
     Options[2] := 'Mode';
     Options[3] := 'Edit';
     Options[4] := 'Print';
     Options[5] := 'Options';
     SetMenuText(MainMenu,Options);
   End;


Procedure SetMenuSpaces(Var Name : MenuType; X,Y : Byte);

	The SetMenuSpaces procedure changes the value of the spacing 
constants used to calculate the size of the menu rectangle and
the location of the text strings.


Procedure SetMenuSpacing(Var Name : MenuType);

	This command actually does the spacing calculations and sets
the location for the inversion rectangles.


Procedure JumpCursor(Var Name : MenuType; Location : Byte);

	The JumpCursor command allows you to jump to the first or
last options in a menu.  A good example is to program the Home
and End keys to jump to the beginning and end of the menu.  Two
constants are defined for use in this command.

   Const
     First = 1;
     Last  = 2;


Procedure MoveCursor(Var Name : MenuType; Direction : Byte);

Page 8	This command moves you through a menu on the screen.  The
direction parameter defines which way the inversion rectangle
will move.  The command is defined such that no horizontal
movement is allowed on a vertical menu, and vice versa. 
Direction constants are defined for use with this procedure.

   Const
     Left  = 1;
     Right = 2;
     Up    = 3;
     Down  = 4;


Procedure OpenMenu(Var Name : MenuType; X,Y : Integer);

	The OpenMenu command opens a menu on the screen with the
upper left corner at the X,Y coordinates.


Procedure CloseMenu(Var Name : MenuType);

	Closes the specified menu and restores the previous image to
the screen.


Procedure MenuBackOut(Var List : MenuList);

	This command will close a sub-menu and set the next higher
menu active.  This command is designed for use with the Escape
key to back out of sub-menus to the main menu.


Procedure MenuToggle;

	The MenuToggle command closes all sub-menus and resets the
main menu to the active menu.



Function ScreenMode : Boolean;

	Returns a True for graphics mode and a False for text mode.


Function MenuMouse(Var List : MenuList; X,Y : Integer) : Integer;

	Performs automatic menu tracking of the mouse.  Returns the
integer code of an option if cursor is in an option rectangle.


Function ReturnCode(Name : MenuType) : Integer;

	Returns the integer code of the current option.


Page 9Function MenuMinX(Name : MenuType) : Integer;

	Returns the X coordinate of the upper left corner of the
menu rectangle.


Function MenuMinY(Name : MenuType) : Integer;

	Returns the Y coordinate of the upper left corner of the
menu rectangle.


Function MenuMaxX(Name : MenuType) : Integer;

	Returns the X coordinate of the lower right corner of the
menu rectangle.


Function MenuMaxY(Name : MenuType) : Integer;

	Returns the Y coordinate of the lower right corner of the
menu rectangle.


Function OptMinX(Name : MenuType) : Integer;

	Returns the X coordinate of the upper left corner of the
current option rectangle.


Function OptMinY(Name : MenuType) : Integer;

	Returns the Y coordinate of the upper left corner of the
current option rectangle.


Function OptMaxX(Name : MenuType) : Integer;

	Returns the X coordinate of the lower right corner of the
current option rectangle.


Function OptMaxY(Name : MenuType) : Integer;

	Returns the Y coordinate of the lower right corner of the
current option rectangle.


Function MenuSpacesX(Name : MenuType) : Integer;

	Returns the horizontal spacing value used by the
SetMenuSpacing procedure's calculations.


Page 10Function MenuSpacesY(Name : MenuType) : Integer;

	Returns the vertical spacing value used by the
SetMenuSpacing procedure's calculations.


Function MenuForeColor(Name : MenuType) : Integer;

	Returns the foreground color for the menu.


Function MenuBackColor(Name : MenuType) : Integer;

	Returns the background color for the menu.


Function MenuShadow(Name : MenuType) : Integer;

	Returns the shadow direction for the menu.


Function MenuShadowColor(Name : MenuType) : Integer;

	Returns the color of the shadow for the menu.


Function MenuActive(Name : MenuType) : Integer;

	Returns true if the current option is the active highlight
on the screen.


Function MenuDirection(Name : MenuType) : Integer;

	Returns the direction, horizontal or vertical, of one
dimensional menus.


Function MenuString(Name : MenuType) : String;

	Returns the output string of the current option.


Function MenuDimensions(Name : MenuType) : Boolean;

	Returns False for one dimensional menu and True for a two
dimensional menu.


Function MenuOpen(Name : MenuType) : Boolean;

	Returns true if the menu is open on the screen.


Page 11Function MenuMode(Name : MenuType) : Boolean;

	Returns False for a text menu and True for a graphics menu.


Function OptionsX(Name : MenuType) : Integer;

	Returns the number of options in the horizontal direction.

Function OptionsY(Name : MenuType) : Integer;

	Returns the number of options in the vertical direction.


REFERENCE GUIDE - Mouse Unit

Procedure ResetMouse;

	This procedure initializes the mouse and resets its position 
to the center of the screen.  It also checks to see if the mouse is 
installed and sets the global variable MouseExists true if the mouse 
is installed.


Procedure ShowMouse;

	Activates the mouse cursor on the screen and makes it visible.

Procedure HideMouse;

	Makes the mouse cursor invisible on the screen.

Procedure ReadMouse(Var Mouse : MouseType);

	Checks the position and button status of the mouse and loads
the information into the MouseType record.  The type definition
of MouseType is :

   Type MouseType = Record
                      Buttons : 0..7;
                      Count,
                      Column,
                      Row     : Integer;
                    End;

Procedure MoveMouse(Column,Row : Integer);

	Moves the mouse cursor to the specified location on the screen.

Procedure Released(Button : Integer; Var Mouse : MouseType);

	Returns the numbers of times the specified button has been
released in the Count field of the MouseType parameter.

Procedure SetXRange(XMin,XMax : Integer);

	Limits the operational range of the mouse cursor along the 
X axis. 

Procedure SetYRange(Ymin,YMax : Integer);

	Limits the operational range of the mouse cursor along the
Y axis.

Procedure TextCursor(CursorType,P1,P2 : Integer);

	This allows you to change the default text mouse cursor or,
assume control of the hardware cursor.  P1 is the screen mask.
It should have the value 77FFh if the cursor is a see through
rectangle, and 0000h if the cursor uses one of the 256 characters
as its shape.  P2 defines the cursor.  The high order byte of the
parameter holds the foreground/background attribute byte and the 
low order byte holds the ASCII value of the character.  For an
independent cursor CursorType must be set to 0.  If the CursorType
is set to 1 then the mouse simply assumes control of the hardware
cursor.

Procedure LPenOn;

	Activates a light pen emulation.

Procedure LPenOff;

	Disable the light pen emulation.

Procedure GraphRatio(X,Y : Integer);

	Sets the motion to pixel ratio.  Defines the number of pixels 
moved per mickey or 1/100 of an inch.

```
{% endraw %}

{% comment %}samples_end{% endcomment %}

### Directory of PC-SIG Library Disk #1983

     Volume in drive A has no label
     Directory of A:\

    MENUVER4 TPU     29952   8-08-89  11:18a
    MENUVER5 TPU     36128   8-08-89  10:40a
    MENUTEST EXE     75623   7-24-89   8:44a
    MENUV5_5 TPU     47824   8-08-89  11:18a
    MENU     DOC     21139   7-24-89   1:59p
    MENUTEST PAS     23815   8-08-89  11:10a
    MOUSEV55 TPU      4272   7-24-89  12:08p
    MOUSEV5  TPU      3680   7-24-89  12:15p
    MOUSEV4  TPU      2640   7-24-89  12:15p
    GO       BAT        38   1-01-80   1:37a
    GO       TXT       386   1-12-90  10:20a
    FILE1983 TXT      2295   4-04-90   4:37p
           12 file(s)     247792 bytes
                           67584 bytes free
