---
layout: page
title: "PC-SIG Diskette Library (Disk #108)"
permalink: /software/pcx86/sw/misc/pcsig/0001-0999/DISK0108/
machines:
  - id: ibm5150
    type: pcx86
    config: /machines/pcx86/ibm/5150/cga/256kb/machine.xml
    diskettes: /machines/pcx86/diskettes.json,/disks/pcsigdisks/pcx86/diskettes.json
    autoGen: true
    autoMount:
      B: "PC-SIG Library Disk #0108"
    autoType: $date\r$time\rB:\rDIR\r
---

{% include machine.html id="ibm5150" %}

{% comment %}info_begin{% endcomment %}

## Information about "PRGMR UTILITIES #1"

    This disk contains a collection of utilites for the APL or DOS
    programmer.  All APL programs on this disk require the IBM APL compiler
    or similar APL interpreter/compiler.  BATMENU is a simple batch file
    enhancement which will allow the user to inquire choices within a
    specified range of options.  Provided documentation should be adequate
    for even the non-programmer to make sucessful use of this utility.
    Programmer's Utilities is a toolbox- like group of software. Contained
    within a well documented menu program are four handy APL programs
    including a depreciation routine, a forecasting model and a Determinant
    function.
    
    How to Start: To read DOC files, enter TYPE filename.ext and press
    <ENTER>.  To run an EXE or COM program, just type its name and press
    <ENTER>.  For instructions on running BASIC programs, please refer to
    the GETTING STARTED section in this catalog.  For instructions on ASM
    listings, refer to your Assembler manual.
    
    File Descriptions:
    
    BASTODOS BAS  Subroutines for BASIC to access DOS 1.1 and 2.0 functions
    BATMENU  COM  Flexible menu prompting for batch files
    DEPRE___ APL  Depreciation functions in APL
    BATMENU  DOC  Documentation for above
    DISKTYPE EXE  Tells you a diskette's format  (Sides, sectors/track)
    DISKTYPE DOC  Documentation for above
    MATH____ APL  Determinant, integrate by Simpson's rule, in APL
    FORECAST APL  Forecasting model in APL
    MUSIC    DOC  Documentation for above
    MUSIC    BAS  Color graphics music editor/player
    NOECHO   DOC  Tells how to make DOS 2.0 batch default to no echo
    PMODE    COM  Command to set EPSON printer modes and fonts
    PEPATCHS DOC  Add color to Personal Editor and other improvements
    PRTSCFX  ASM  Source for above
    PRTSCFX  DOC  Documentation for above
    PRTSCFX  COM  Allows PrtSc to print the FULL monochrome character set
    PMODE    ASM  Source and documentation for above
    UNDOC    DOC  Lots of undocumented DOS 2.0 bugs and gotchas
    UTILITY_ APL  String, time/date, and other utility functions in APL
    README        Listing of included files
{% comment %}info_end{% endcomment %}

{% comment %}samples_begin{% endcomment %}

## BASTODOS.BAS

{% raw %}
```bas
10 '*
15 '*************************************************************************
20 '*
25 '*                     BASIC WORKSHOP SERIES
30 '*
35 '*                           NUMBER   1
40 '*
45 '*                              BY
50 '*
55 '*                         JAMES P. MORGAN
60 '*                   1749 AMERICANA BLVD APT 23-G
65 '*                         ORLANDO FLA, 32809
70 '*
75 '*                     WORK PH:(305) 826-7297
80 '*
85 '*  I HAVE PUT TOGETHER, FOR YOU, A SET OF CALLABLE ASSEMBLER SUBROUTINES
90 '* FROM BASIC, TO ALLOW YOU MORE CONTROL OVER YOUR SYSTEM. THESE ROUTINES
95 '* ENABLE YOU TO ACCESS DOS FUNCTIONS NOT SUPPORTED BY THE INTERPRETER OR
100 '* THE BASIC COMPILER, FOR MOST OF THE NEW EXTENDED DOS 2.0 FUNCTIONS.
105 '*
110 '*  I HAVE DEBUGGED THE ROUTINES AS MUCH AS MY LIMITED TIME WOULD PERMIT.
115 '* PLEASE EXCUSE THE TYPING ERROR, I COME FROM THE HUNT AND PEEK SCHOOL
120 '* OF TYPING. ALSO I SCRATCHED MY MASTER FILE AND HAD TO REKEY ALL OF THIS.
125 '* THE LESSON LEARNED , ALWAYS KEEP A BACK UP OF LARGE FILES, EVEN IF
130 '* NOT A TOTAL CURRENT ONE.
135 '*
140 '*  A NOTE OF WARNING, THESE SUBROUTINES DO LITTLE OR NO VALIDITY CHECKING
145 '* AS TO THE FORMAT, TYPE AND RANGE OF VARIABLES PASSED, SO BE WARNED IF
150 '* YOU DO NOT FOLLOW THE RULES AND YOUR MACHINE LOCKS UP TIGHT.
155 '*
160 '*  THERE ARE MORE SUBROUTINES FORTHCOMING, SO LOOK FOR THEM, SUCH AS
165 '* GETTING/SETTING THE INTERRUPT VECTORS, PARSEING A FILENAME, PASSING
170 '* RETURN CODES FROM A PROGRAM TO BATCH JOBS, AND MORE.
175 '*
180 '*                        DOS 2.0 DEFINITIONS
185 '*                      -----------------------
190 '*
195 '*       ASCIIZ STRING - NORMAL TEXT STRING, USUALLY CONSISTING OF A DRIVE,
200 '*                      PATH , AND/OR FILENAME (EXP:"A:\COBOL\COBPGM.COB")
205 '*                      TERMINATED BY A HEX 00/(CHR$(0)).
210 '*
215 '*   THERE ARE MORE RETURN CODES OUTPUT BY THE NEW DOS 2.0 FUNCTION CALLS.
220 '*
225 '*   1 - INVALID FUNCTION NUMBER
230 '*   2 - FILE NOT FOUND
235 '*   3 - PATH NOT FOUND
240 '*   4 - TOO MANY OPEN FILES
245 '*   5 - ACCESS DENIED
250 '*   6 - INVALID HANDLE
255 '*   7 - MEMORY CONTROL BLOCKS DESTROYED
260 '*   8 - INSUFFICIENT MEMORY
265 '*   9 - INVALID MEMORY BLOCK ADDRESS
270 '*  10 - INVALID ENVIRONMENT
275 '*  11 - INVALID FORMAT
280 '*  12 - INVALID ACCESS CODE
285 '*  15 - INVALID DRIVE WAS SPECIFIED
290 '*  16 - ATTEMPTED TO REMOVE THE CURRENT DIRECTORY
295 '*  17 - NOT SAME DEVICE
300 '*  18 - MO MORE FILES
305 '*
310 '*   SOME SUBROUTINES STILL DO CALLS TO THE DOS 1.1 FUNCTION CALLS
315 '*  AND THEY RETURN THEIR OWN PARTICULAR RESULT CODES.
320 '*
325 '*   AS ALWAYS, IF IN DOUBT, CONSULT THE TECHNICAL GUIDE AND THE TECHNICAL
330 '*  SECTION OF THE DOS MANUAL AS TO THE FORMAT AND OBJECTIVE OF ANY OF THE
335 '*  FUNCTION CALLS.
340 '*
345 '*  NOTE:
350 '*       THE PROGRAMS WILL CREATE A .COM TYPE FILE, IF YOU TEST RUN EACH
360 '*    ONE SEPARATELY. THESE .COM TYPE FILES MAY THEN BE READ BY OTHER
370 '*    PROGRAMS AND POKED INTO A VARIABLE ARRAY IN THE NEW PROGRAM, AS WAS
380 '*    DONE IN THE TEST PROGRAMS.
390 '*       BOTH THE INTERPERTER AND BASIC COMPILER ARE SUPPORTED IN THE DATA
400 '*    STATEMENTS IN THE PROGRAMS. YOU MUST, I REPEAT, YOU MUST COMMENT OUT
405 '*    THE DATA STATEMENTS FLAGGED THAT DO NOT APPLY TO THE MODE YOU ARE
410 '*    RUNNING IN. YOU CANNOT RUN THE BASIC COMPILER DATA STATEMENTS WHILE
415 '*    RUNNING THE INTERPERTER. YOU MAY HOWEVER CREATE THE .COM TYPE FILES
420 '*    FOR USE BY COMPILED PROGRAMS. BY CHANGING THE DATA STATEMENTS AS
425 '*    ADVISED AND PUTTING AN "END' STATEMENT JUST AFTER THE 'GOSUB' THAT
430 '*    CREATES THE DISK .COM FILE.
435 '*
440 '*   'KEEP ON COMPUTING AND SHARING'
500 '**********************************************************************
501 '*
502 '* SUBROUTINE FUNCTION : CNTL-BREAK CHECK
503 '*
504 '* VERSION             : 1.0
505 '*
506 '* DATE LAST UPDATED   : SEPT 25, 1983
507 '*
508 '* AUTHOR              : JAMES P MORGAN
509 '*
510 '* CALL FORMAT         :
511 '* ---------------------
512 '* CALL OFFSET%(CNTL.BREAK.STATE%,RETURN.CODE%)
513 '*
514 '* PARAMETERS PASSED   : CNTL.BREAK.STATE% (00=REQUEST CURRENT STATE
515 '*                                          01=FLIP/FLOP CURRENT STATE
516 '*
517 '*                       RETURN.CODE%=0
518 '*
519 '* PARAMETERS RETURNED : CNTL.CREAK.STATE%
520 '*
521 '*                       RETURN.CODE%       (00=CNTL-BREAK ON
522 '*                                           01=CNTL-BREAK OFF)
523 '*
524 '* COMMENTS            :
525 '*
526 '*                       THIS SUBROUTINE WILL FLIP/FLOP THE CNTL-BREAK
527 '*                     SWITCH FROM ON/OFF OR OFF/ON AND RETURN THE CURRENT
528 '*                     STATE OR JUST RETURN THE CURRENT STATE OF THE
529 '*                     CNTL-BREAK SWITCH.
530 '*
531 '**************************************************************************
537 CLS
538 CLOSE
539 DEF SEG
540 DEFINT A-Z
541 DIM SUBRT%(40)
542 OFFSET%=0
543 CNTL.BREAK.STATE%=0
544 CURRENT.STATE%=0
545 RETURN.CODE%=0
546 GOSUB 576
547 GOSUB 555
548 OFFSET%=VARPTR(SUBRT%(0))
549 CALL OFFSET%(CNTL.BREAK.STATE%,RETURN.CODE%)
550 CURRENT.STATE%=RETURN.CODE%
551 PRINT "CNTL BREAK REQUEST= ";CNTL.BREAK.STATE%
552 PRINT "CURRENT STATE     = ";CURRENT.STATE%
553 PRINT "RETURN CODE       = ";RETURN.CODE%
554 END
555 FOR I=0 TO 31
556 READ J
557 POKE (VARPTR(SUBRT%(0))+I),J
558 NEXT
559 RETURN
560 DATA &H55
561 DATA &H89,&HE5
562 DATA &HB0,&H00
563 DATA &HB2,&H00
564 DATA &HB4,&H33
565 DATA &HCD,&H21
566 DATA &H8B,&H76,&H08
567 DATA &H8A,&H04
568 DATA &H80,&HF2,&H01
569 DATA &HB4,&H33
570 DATA &HCD,&H21
571 DATA &H8B,&H76,&H06
572 DATA &H88,&H14
573 DATA &H5D
574 DATA &HCA,&H04,&H00
575 END
576 RESTORE
577 FILENAME$="A:"+"CNTLBRK.EMU"
578 PGM.LEN=31
579 OPEN FILENAME$ AS #1 LEN=1
580 FIELD #1, 1 AS PGM.BYTE$
581 FOR I=0 TO PGM.LEN
582 READ J
583 LSET PGM.BYTE$=CHR$(J)
584 PUT #1
585 NEXT
586 CLOSE
587 RESTORE
588 RETURN
1000 '**********************************************************************
1001 '*
1002 '* SUBROUTINE FUNCTION : GET DRIVE TYPE
1003 '*
1004 '* VERSION             : 1.0
1005 '*
1006 '* DATE LAST UPDATED   : SEPT 25, 1983
1007 '*
1008 '* AUTHOR              : JAMES P MORGAN
1009 '*
1010 '* CALL FORMAT         :
1011 '* ---------------------
1012 '* CALL OFFSET%(DRIVE%,RETURN.CODE%)
1013 '*
1014 '* PARAMETERS PASSED   : DRIVE%            (00=DEFAULT,1=A,2=B..ECT)
1015 '*
1016 '*                       RETURN.CODE%=0
1017 '*
1018 '* PARAMETERS RETURNED : DRIVE%
1019 '*
1020 '*                       RETURN.CODE%       (255=INVALID DRIVE)
1021 '*
1022 '* COMMENTS            :
1023 '*
1024 '*                       THIS ROUTINE RETURNS THE DRIVE TYPE. THE DOS
1025 '*                     FUNCTION CALL '1CH' ID USED. THIS DOS FUNCTION CALL
1026 '*                     DOES NOT FUNCTION UNDER 2.0 AS IT DID UNDER 1.1.
1027 '*                       UNDER 1.1 THE FATS (FILE ALLOCATION TABLES) WERE
1028 '*                     MAINTAINED IN MEMORY AND THIS CALL WOULD POINT YOU
1029 '*                     TO THE FAT IN MEMORY.
1030 '*                       UNDER 2.0 THIS CALL NOW ONLY POINTS YOU TO THE
1031 '*                     DRIVE TYPE CODE IN MEMORY.
1032 '**************************************************************************
1033 CLS
1034 CLOSE
1035 DEF SEG
1036 DEFINT A-Z
1037 DIM SUBRT%(40)
1038 OFFSET%=0
1039 DRIVE%=0
1040 DUAL.8.SECTORS=255            'FF
1041 SINGLE.8.SECTORS=254          'FE
1042 DUAL.9.SECTORS=253            'FD
1043 SINGLE.9.SECTORS=252          'FC
1044 FIXED.DISK=248                'F8
1045 RETURN.CODE%=0
1046 GOSUB 1086
1047 GOSUB 1062
1048 REQUESTED.DRIVE%=DRIVE%
1049 OFFSET%=VARPTR(SUBRT%(0))
1050 CALL OFFSET%(DRIVE%,RETURN.CODE%)
1051 PRINT "DRIVE   REQUESTED = ";REQUESTED.DRIVE%
1052 PRINT "DRIVE TYPE CODE   = ";DRIVE%
1053 IF RETURN.CODE%=255 THEN DRIVE.TYPE$="INVALID DRIVE SPECIFIED":GOTO 1059
1054 IF DRIVE%=255 THEN DRIVE.TYPE$="DUAL.SIDED, 8 SECTORS PER TRACK"
1055 IF DRIVE%=254 THEN DRIVE.TYPE$="SINGLE SIDED, 8 SECTORS PER TRACK"
1056 IF DRIVE%=253 THEN DRIVE.TYPE$="DUAL SIDED, 9 SECTORS PER TRACK"
1057 IF DRIVE%=252 THEN DRIVE.TYPE$="SINGLE SIDED, 9 SECTORS PER TRACK"
1058 IF DRIVE%=248 THEN DRIVE.TYPE$="FIXED DISK"
1059 PRINT "DRIVE TYPE        = ";DRIVE.TYPE$
1060 PRINT "RETURN CODE       = ";RETURN.CODE%
1061 END
1062 FOR I=0 TO 37
1063 READ J
1064 POKE (VARPTR(SUBRT%(0))+I),J
1065 NEXT
1066 RETURN
1067 DATA &H55
1068 DATA &H89,&HE5
1069 DATA &H31,&HC0
1070 DATA &H31,&HDB
1071 DATA &H31,&HC9
1072 DATA &H31,&HD2
1073 DATA &H8B,&H76,&H08
1074 DATA &H8A,&H14
1075 DATA &HB4,&H1C
1076 DATA &H1E
1077 DATA &HCD,&H21
1078 DATA &H8A,&H27
1079 DATA &H1F
1080 DATA &H8B,&H76,&H08
1081 DATA &H88,&H24
1082 DATA &H8B,&H76,&H06
1083 DATA &H88,&H04
1084 DATA &H5D
1085 DATA &HCA,&H04,&H00
1086 RESTORE
1087 FILENAME$="A:"+"DRIVETYP.EMU"
1088 PGM.LEN=37
1089 OPEN FILENAME$ AS #1 LEN=1
1090 FIELD #1, 1 AS PGM.BYTE$
1091 FOR I=0 TO PGM.LEN
1092 PGM.LEN=37
1093 PUT #1
1094 NEXT
1095 CLOSE
1096 RESTORE
1097 RETURN
1500 '**********************************************************************
1501 '*
1502 '* SUBROUTINE FUNCTION : GET FIRST/NEXT MATCHING FILE
1503 '*
1504 '* VERSION             : 1.0
1505 '*
1506 '* DATE LAST UPDATED   : SEPT 25, 1983
1507 '*
1508 '* AUTHOR              : JAMES P MORGAN
1509 '*
1510 '* CALL FORMAT         :
1511 '* ---------------------
1512 '* CALL OFFSET%(FUNCTION.CODE%,ATTRIBUTE%,ASCIIZ.STRING$,DTA%(0),RETURN.CODE%)
1513 '*
1514 '* PARAMETERS PASSED   : FUNCTION.CODE%    (&H4E=FIND FIRST MATCHING FILE
1515 '*                                          &H4F=FIND NEXT MATCHING FILE)
1516 '*
1517 '*                       ATTRIBUTE%         (ATTRIBUTE TO BE USED IN
1518 '*                                           SEARCHING FOR THE FILE)
1519 '*
1520 '*                       ASCIIZ.STRING$     (DRIVE,PATH, AND FILENAME)
1521 '*
1522 '*                       DTA%(0)            (PSEUDO DTA TO HOLD MATCHING
1523 '*                                           FILE INFORMATION)
1524 '*
1525 '*                       RETURN.CODE%=0
1526 '*
1527 '* PARAMETERS RETURNED : FUNCTION.CODE%
1528 '*
1529 '*                       ATTRIBUTE%
1530 '*
1531 '*                       ASCIIZ.STRING$
1532 '*
1533 '*                       DTA%(0)            (FILLED WITH MATCHING DTA INFO)
1534 '*
1535 '*                       RETURN.CODE%
1536 '*
1537 '* COMMENTS            :
1538 '*
1539 '*                       THIS SUBROUTINE SEARCHS A DIRECTORY FOR A
1540 '*                     FILE WITH MATCHING FILE ATTRIBUTE AND CHARACTERS.
1541 '*                       THE ASCIIZ STRING CONSISTS OF A DRIVE , PATH ,
1542 '*                     AND FILENAME. GLOBAL FILENAME CHARACTERS ARE ALLOWED
1543 '*                     IN THE FILENAME PORTION OF THE STRING.
1544 '*                       IF A FILE IS FOUND THAT MATCHES THE SPECIFIED
1545 '*                      DRIVE, PATH, AND FILENAME AND ATTRIBUTE, THE DTA
1546 '*                      IS FILLED IN AS FOLLOWS:
1547 '*
1548 '*                      21 BYTES - RESERVED FOR DOS USE ON SUBSEQUENT
1549 '*                                 FIND NEXT CALLS
1550 '*
1551 '*                       2 BYTES - FILES CREATE/UPDATE TIME
1552 '*
1553 '*                       2 BYTES - FILES CREATE/UPDATE DATE
1554 '*
1555 '*                       2 BYTES - LOW WORD OF FILE SIZE
1556 '*
1557 '*                       2 BYTES - HIGH WORD OF FILE SIZE
1558 '*
1559 '*                      13 BYTES - NAME AND EXTENTION OF FILE FOUND
1560 '*                                 FOLLOWED BY A BYTE OF HEX 00.
1561 '*
1562 '*                                 ALL BLANKS ARE REMOVED FROM THE NAME
1563 '*                                AND EXTENTION, AND IF AN EXTENTION IS
1564 '*                                PRESENT, IT IS PRECEEDED BY A PERIOD.
1565 '*                                 THE NAME WOULD BE RETURNED JUST AS YOU
1566 '*                                HAD ENTERED IT AS A COMMAND PARAMETER,
1567 '*                                SUCH AS 'TREE.COM'.
1568 '*                                 IF YOU ASK FOR ALL FILES IN A SUB-DIREC-
1569 '*                                TORY, THIS ROUTINE WILL RETURN THE '.'
1570 '*                                THE '..' THAT YOU SEE WHEN YOU DO A 'DIR'
1571 '*                                ON A SUB-DIRECTORY.
1572 '*                                 YOU CAN USE THE GET FIRST OPTION TO
1573 '*                                RETURN THE VOLUMN LABEL, SINCE IT IS
1574 '*                                BASICALLY AN EMPTY FILE WITH A SPECIAL
1575 '*                                ATTRIBUTE IN THE DIRECTORY.
1576 '*
1577 '**************************************************************************
1578 CLS
1579 CLOSE
1580 DEF SEG
1581 DEFINT A-Z
1582 DIM SUBRT%(40)
1583 OFFSET%=0
1584 DIM DTA%(40)
1585 FOR I=0 TO 40:DTA%(I)=-1:NEXT
1586 FUNCTION.CODE%=&H4E
1587 PATH$="A:*.*"
1588 ASCIIZ.STRING$=PATH$+CHR$(0)
1589 ATTRIBUTE%=255
1590 RETURN.CODE%=0
1591 GOSUB 1652
1592 GOSUB 1608
1593 GOSUB 1598
1594 FUNCTION.CODE%=&H4F
1595 GOSUB 1598
1596 IF RETURN.CODE%=0 GOTO 1595
1597 END
1598 OFFSET%=VARPTR(SUBRT%(0))
1599 CALL OFFSET%(FUNCTION.CODE%,ATTRIBUTE%,ASCIIZ.STRING$,DTA%(0),RETURN.CODE%)
1600 PRINT "RETURN CODE        = ";RETURN.CODE%
1601 IF RETURN.CODE%=18 THEN PRINT :RETURN
1602 FOR I=30 TO 43
1603 PRINT CHR$(PEEK(VARPTR(DTA%(0))+I));
1604 NEXT
1605 PRINT
1606 RETURN
1607 END
1608 FOR I=0 TO 65
1609 READ J
1610 POKE (VARPTR(SUBRT%(0))+I),J
1611 NEXT
1612 RETURN
1613 DATA &H55
1614 DATA &H89,&HE5
1615 DATA &H31,&HC0
1616 DATA &H31,&HC9
1617 DATA &H31,&HD2
1618 DATA &H8B,&H76,&H0E
1619 DATA &H8A,&H24
1620 DATA &H8B,&H76,&H0C
1621 DATA &H8B,&H0C
1622 DATA &H8B,&H76,&H0A
1623 '********COMMENT OUT THE NEXT DATA STATEMENT IF USED WITH THE BASIC COMPILER
1624 DATA &H8B,&H54,&H01
1625 '********COMMENT OUT THE NEXT DATA STATEMENT IF USED WITH THE BASIC INTERPRETER
1626 'DATA &H8B,&H54,&H02
1627 DATA &HCD,&H21
1628 DATA &H8B,&H76,&H06
1629 DATA &H88,&H04
1630 DATA &H8B,&H76,&H08
1631 DATA &H89,&HF7
1632 DATA &H06
1633 DATA &H31,&HDB
1634 DATA &HB4,&H2F
1635 DATA &HCD,&H21
1636 DATA &HFC
1637 DATA &HB9,&H2C,&H00
1638 DATA &H89,&HDE
1639 DATA &H90,&H90,&H90
1640 DATA &H1E
1641 DATA &H06
1642 DATA &H1F
1643 DATA &H07
1644 DATA &HF3
1645 DATA &HA4
1646 DATA &H06
1647 DATA &H1F
1648 DATA &H07
1649 DATA &H5D
1650 DATA &HCA,&H0A,&H00
1651 END
1652 RESTORE
1653 FILENAME$="A:"+"FRSTNEXT.EMU"
1654 PGM.LEN=65
1655 OPEN FILENAME$ AS #1 LEN=1
1656 FIELD #1,1 AS PGM.BYTE$
1657 FOR I=0 TO PGM.LEN
1658 READ J
1659 LSET PGM.BYTE$=CHR$(J)
1660 PUT #1
1661 NEXT
1662 CLOSE
1663 RESTORE
1664 RETURN
2000 '**********************************************************************
2001 '*
2002 '* SUBROUTINE FUNCTION : GET VERIFY STATE
2003 '*
2004 '* VERSION             : 1.0
2005 '*
2006 '* DATE LAST UPDATED   : SEPT 25, 1983
2007 '*
2008 '* AUTHOR              : JAMES P MORGAN
2009 '*
2010 '* CALL FORMAT         :
2011 '* ---------------------
2012 '* CALL OFFSET%(RETURN.CODE%)
2013 '*
2014 '* PARAMETERS PASSED   : RETURN.CODE%=0
2015 '*
2016 '* PARAMETERS RETURNED : RETURN.CODE%       (00=VERIFY OFF,01=VERIFY ON)
2017 '*
2018 '**************************************************************************
2019 CLS
2020 CLOSE
2021 DEF SEG
2022 DEFINT A-Z
2023 DIM SUBRT%(40)
2024 OFFSET%=0
2025 VERIFY.STATE%=0
2026 RETURN.CODE%=0
2027 GOSUB 2051
2028 GOSUB 2035
2029 OFFSET%=VARPTR(SUBRT%(0))
2030 CALL OFFSET%(RETURN.CODE%)
2031 VERIFY.STATE%=RETURN.CODE%
2032 PRINT "VERIFY STATE      = ";VERIFY.STATE%
2033 PRINT "RETURN CODE       = ";RETURN.CODE%
2034 END
2035 RESTORE
2036 FOR I=0 TO 17
2037 READ J
2038 POKE (VARPTR(SUBRT%(0))+I),J
2039 NEXT
2040 RETURN
2041 DATA &H55
2042 DATA &H89,&HE5
2043 DATA &H30,&HC0
2044 DATA &HB4,&H54
2045 DATA &HCD,&H21
2046 DATA &H8B,&H76,&H06
2047 DATA &H88,&H04
2048 DATA &H5D
2049 DATA &HCA,&H02,&H00
2050 END
2051 RESTORE
2052 FILENAME$="A:"+"VERSTATE.EMU"
2053 PGM.LEN=17
2054 OPEN FILENAME$ AS #1 LEN=1
2055 FIELD #1, 1 AS PGM.BYTE$
2056 FOR I=0 TO PGM.LEN
2057 READ J
2058 LSET PGM.BYTE$=CHR$(J)
2059 PUT #1
2060 NEXT
2061 CLOSE
2062 RESTORE
2063 RETURN
2500 '**********************************************************************
2501 '*
2502 '* SUBROUTINE FUNCTION : SET/RESET VERIFY SWITCH
2503 '*
2504 '* VERSION             : 1.0
2505 '*
2506 '* DATE LAST UPDATED   : SEPT 25, 1983
2507 '*
2508 '* AUTHOR              : JAMES P MORGAN
2509 '*
2510 '* CALL FORMAT         :
2511 '* ---------------------
2512 '* CALL OFFSET%(RETURN.CODE%)
2513 '*
2514 '* PARAMETERS PASSED   : RETURN.CODE%=0
2515 '*
2516 '* PARAMETERS RETURNED : RETURN.CODE%       (00=VERIFY OFF,01=VERIFY ON)
2517 '*
2518 '* COMMENTS           :
2519 '*                     THIS ROUTINE WILL FLIP/FLOP THE VERIFY STATE
2520 '*                    SWITCH FROM ON/OFF OR OFF/ON AND RETURN THE CURRENT
2521 '*                    STATE.
2522 '*                     WHEN ON,DOS WILL PERFORM A VERIFY OPERATION EACH
2523 '*                    TIME IT PERFORMS A DISKETTE WRITE TO ASSURE PROPER
2524 '*                    DATA RECORDING. ALTHOUGH RECORDING ERRORS ARE VERY
2525 '*                    RARE, THIS FUNCTION IS PROVIDED FOR THOSE USER
2526 '*                    APPLICATIONS IN WHICH YOU MAY WISH TO VERIFY THE
2527 '*                    PROPER RECORDING OF CRITICAL DATA.
2528 '**************************************************************************
2529 CLS
2530 CLOSE
2531 DEF SEG
2532 DEFINT A-Z
2533 DIM SUBRT%(40)
2534 OFFSET%=0
2535 VERIFY.STATE%=0
2536 RETURN.CODE%=0
2537 GOSUB 2566
2538 GOSUB 2545
2539 OFFSET%=VARPTR(SUBRT%(0))
2540 CALL OFFSET%(RETURN.CODE%)
2541 VERIFY.STATE%=RETURN.CODE%
2542 PRINT "VERIFY STATE      = ";VERIFY.STATE%
2543 PRINT "RETURN CODE       = ";RETURN.CODE%
2544 END
2545 RESTORE
2546 FOR I=0 TO 27
2547 READ J
2548 POKE (VARPTR(SUBRT%(0))+I),J
2549 NEXT
2550 RETURN
2551 DATA &H55
2552 DATA &H89,&HE5
2553 DATA &HB4,&H54
2554 DATA &HCD,&H21
2555 DATA &H34,&H01
2556 DATA &HB2,&H00
2557 DATA &HB4,&H2E
2558 DATA &HCD,&H21
2559 DATA &HB4,&H54
2560 DATA &HCD,&H21
2561 DATA &H8B,&H76,&H06
2562 DATA &H88,&H04
2563 DATA &H5D
2564 DATA &HCA,&H02,&H00
2565 END
2566 RESTORE
2567 FILENAME$="A:"+"VERRESET.EMU"
2568 PGM.LEN=17
2569 OPEN FILENAME$ AS #1 LEN=1
2570 FIELD #1, 1 AS PGM.BYTE$
2571 FOR I=0 TO PGM.LEN
2572 READ J
2573 LSET PGM.BYTE$=CHR$(J)
2574 PUT #1
2575 NEXT
2576 CLOSE
2577 RESTORE
2578 RETURN
3000 '**********************************************************************
3001 '*
3002 '* SUBROUTINE FUNCTION : GET SYSTEM TIME
3003 '*
3004 '* VERSION             : 1.0
3005 '*
3006 '* DATE LAST UPDATED   : SEPT 25, 1983
3007 '*
3008 '* AUTHOR              : JAMES P MORGAN
3009 '*
3010 '* CALL FORMAT         :
3011 '* ---------------------
3012 '* CALL OFFSET%(HOURS%,MINUTES%,SECONDS%,HUNDREDS.SECONDS%,RETURN.CODE%)
3013 '*
3014 '* PARAMETERS PASSED   : HOURS%=0
3015 '*                       MINUTES%=0
3016 '*                       SECONDS%-0
3017 '*                       HUNDREDS.SECONDS%=0
3018 '*                       RETURN.CODE%=0
3019 '*
3020 '* PARAMETERS RETURNED : HOURS%             (0-23)
3021 '*                       MINUTES%           (0-59)
3022 '*                       SECONDS%           (0-59)
3023 '*                       HUNDREDS.SECONDS%  (0-99)
3024 '*                       RETURN.CODE%
3025 '*
3026 '* COMMENTS           :
3027 '*                     THIS FORMAT IS READILY CONVERTED TO A PRINTABLE
3028 '*                    FORM YET CAN BE USED FOR CALCULATIONS , SUCH AS
3029 '*                    SUBTRACTING ONE TIME VALUE FROM ANOTHER.
3030 '*
3031 '**************************************************************************
3032 CLS
3033 CLOSE
3034 DEF SEG
3035 DEFINT A-Z
3036 DIM SUBRT%(40)
3037 OFFSET%=0
3038 HOURS%=0
3039 MINUTES%=0
3040 SECONDS%=0
3041 HUNDREDS.SECONDS%=0
3042 RETURN.CODE%=0
3043 GOSUB 3080
3044 GOSUB 3054
3045 OFFSET%=VARPTR(SUBRT%(0))
3046 CALL OFFSET%(HOURS%,MINUTES%,SECONDS%,HUNDREDS.SECONDS%,RETURN.CODE%)
3047 PRINT "HOURS             = ";HOURS%
3048 PRINT "MINUTES           = ";MINUTES%
3049 PRINT "SECONDS           = ";SECONDS%
3050 PRINT "1/100 SECONDS     = ";HUNDREDS.SECONDS%
3051 PRINT "RETURN CODE       = ";RETURN.CODE%
3052 PRINT "CURRENT TIME      = ";TIME$
3053 END
3054 RESTORE
3055 FOR I=0 TO 41
3056 READ J
3057 POKE (VARPTR(SUBRT%(0))+I),J
3058 NEXT
3059 RETURN
3060 DATA &H55
3061 DATA &H89,&HE5
3062 DATA &H31,&HC9
3063 DATA &H31,&HD2
3064 DATA &HB4,&H2C
3065 DATA &HCD,&H21
3066 DATA &H8B,&H76,&H0E
3067 DATA &H88,&H2C
3068 DATA &H8B,&H76,&H0C
3069 DATA &H88,&H0C
3070 DATA &H8B,&H76,&H0A
3071 DATA &H88,&H34
3072 DATA &H8B,&H76,&H08
3073 DATA &H88,&H14
3074 DATA &H30,&HD2
3075 DATA &H8B,&H76,&H06
3076 DATA &H88,&H14
3077 DATA &H5D
3078 DATA &HCA,&H0A,&H00
3079 END
3080 RESTORE
3081 FILENAME$="A:"+"GETTIME.EMU"
3082 PGM.LEN=41
3083 OPEN FILENAME$ AS #1 LEN=1
3084 FIELD #1, 1 AS PGM.BYTE$
3085 FOR I=0 TO PGM.LEN
3086 READ J
3087 LSET PGM.BYTE$=CHR$(J)
3088 PUT #1
3089 NEXT
3090 CLOSE
3091 RESTORE
3092 RETURN
3500 '**********************************************************************
3501 '*
3502 '* SUBROUTINE FUNCTION : GET SYSTEM DATE
3503 '*
3504 '* VERSION             : 1.0
3505 '*
3506 '* DATE LAST UPDATED   : SEPT 25, 1983
3507 '*
3508 '* AUTHOR              : JAMES P MORGAN
3509 '*
3510 '* CALL FORMAT         :
3511 '* ---------------------
3512 '* CALL OFFSET%(CENTURY%,YEAR%,MONTH%,DAY%,RETURN.CODE%)
3513 '*
3514 '* PARAMETERS PASSED   : CENTURY%=0
3515 '*                       YEAR%=0
3516 '*                       MONTH%=0
3517 '*                       DAY%=0
3518 '*                       RETURN.CODE%=0
3519 '*
3520 '* PARAMETERS RETURNED : CENTURY%
3521 '*                       YEAR%
3522 '*                       MONTH%
3523 '*                       DAY%
3524 '*                       RETUURN.CODE%
3525 '*
3526 '* COMMENTS           :
3527 '*                     IF THE TIME-OF-DAY CLOCK ROLLS OVER TO THE NEXT
3528 '*                    DAY, THE DATA IS ADJUSTED ACCORDINGLY, TAKING
3529 '*                    INTO ACCOUNT THE NUMBER OF DAYS IN EACH MONTH AND
3530 '*                    LEAP YEARS.
3531 '**************************************************************************
3532 CLS
3533 CLOSE
3534 DEF SEG
3535 DEFINT A-Z
3536 DIM SUBRT%(40)
3537 OFFSET%=0
3538 CENTURY%=0
3539 YEAR%=0
3540 MONTH%=0
3541 DAY%=0
3542 RETURN.CODE%=0
3543 GOSUB 3581
3544 GOSUB 3555
3545 OFFSET%=VARPTR(SUBRT%(0))
3546 CALL OFFSET%(CENTURY%,YEAR%,MONTH%,DAY%,RETURN.CODE%)
3547 PRINT "CENTURY           = ";CENTURY%
3548 PRINT "YEAR              = ";YEAR%
3549 PRINT "CENTURY + YEAR    = ";CENTURY%+YEAR%
3550 PRINT "MONTH             = ";MONTH%
3551 PRINT "DAY               = ";DAY%
3552 PRINT "RETURN CODE       = ";RETURN.CODE%
3553 PRINT "CURRENT DATE      = ";DATE$
3554 END
3555 RESTORE
3556 FOR I=0 TO 42
3557 READ J
3558 POKE (VARPTR(SUBRT%(0))+I),J
3559 NEXT
3560 RETURN
3561 DATA &H55
3562 DATA &H89,&HE5
3563 DATA &H31,&HC9
3564 DATA &H31,&HD2
3565 DATA &HB4,&H2A
3566 DATA &HCD,&H21
3567 DATA &H8B,&H76,&H0E
3568 DATA &H88,&H6C,&H01
3569 DATA &H8B,&H76,&H0C
3570 DATA &H88,&H0C
3571 DATA &H8B,&H76,&H0A
3572 DATA &H88,&H34
3573 DATA &H8B,&H76,&H08
3574 DATA &H88,&H14
3575 DATA &H8B,&H76,&H06
3576 DATA &H31,&HD2
3577 DATA &H89,&H14
3578 DATA &H5D
3579 DATA &HCA,&H0A,&H00
3580 END
3581 RESTORE
3582 FILENAME$="A:"+"GETDATE.EMU"
3583 PGM.LEN=42
3584 OPEN FILENAME$ AS #1 LEN=1
3585 FIELD #1, 1 AS PGM.BYTE$
3586 FOR I=0 TO PGM.LEN
3587 READ J
3588 LSET PGM.BYTE$=CHR$(J)
3589 PUT #1
3590 NEXT
3591 CLOSE
3592 RESTORE
3593 RETURN
4000 '**********************************************************************
4001 '*
4002 '* SUBROUTINE FUNCTION : GET DOS VERSION NUMBER
4003 '*
4004 '* VERSION             : 1.0
4005 '*
4006 '* DATE LAST UPDATED   : SEPT 25, 1983
4007 '*
4008 '* AUTHOR              : JAMES P MORGAN
4009 '*
4010 '* CALL FORMAT         :
4011 '* ---------------------
4012 '* CALL OFFSET%(MAJOR.VERSION%,MINOR.VERSION%,RETURN.CODE%)
4013 '*
4014 '* PARAMETERS PASSED   : MAJOR.VERSION%=0
4015 '*                       MINOR.VERSION%=0
4016 '*                       RETURN.CODE%=0
4017 '*
4018 '* PARAMETERS RETURNED : MAJOR.VERSION%  (MAJOR DOS VERSION NUMBER)
4019 '*                       MINOR.VERSION%  (MINOR DOS VERSION NUMBER)
4020 '*                       RETURN.CODE%
4021 '*
4022 '* COMMENTS           :
4023 '*                     IF THE MAJOR.VERSION% RETURNS ZERO(0), IT IS
4024 '*                    ASSUMED THAT THIS IS A PRE-DOS 2.0 SYSTEM.
4025 '*
4026 '**************************************************************************
4027 CLS
4028 CLOSE
4029 DEF SEG
4030 DEFINT A-Z
4031 DIM SUBRT%(40)
4032 OFFSET%=0
4033 MAJOR.VERSION%=0
4034 MINOR.VERSION%=0
4035 RETURN.CODE%=0
4036 GOSUB 4064
4037 GOSUB 4044
4038 OFFSET%=VARPTR(SUBRT%(0))
4039 CALL OFFSET%(MAJOR.VERSION%,MINOR.VERSION%,RETURN.CODE%)
4040 PRINT "MAJOR.VERSION     = ";MAJOR.VERSION%
4041 PRINT "MINOR VERSION     = ";MINOR.VERSION%
4042 PRINT "RETURN CODE       = ";RETURN.CODE%
4043 END
4044 RESTORE
4045 FOR I=0 TO 27
4046 READ J
4047 POKE (VARPTR(SUBRT%(0))+I),J
4048 NEXT
4049 RETURN
4050 DATA &H55
4051 DATA &H89,&HE5
4052 DATA &HB4,&H30
4053 DATA &HCD,&H21
4054 DATA &H8B,&H76,&H0A
4055 DATA &H88,&H04
4056 DATA &H8B,&H76,&H08
4057 DATA &H88,&H24
4058 DATA &H8B,&H76,&H06
4059 DATA &H31,&HDB
4060 DATA &H89,&H1C
4061 DATA &H5D
4062 DATA &HCA,&H06,&H00
4063 END
4064 RESTORE
4065 FILENAME$="A:"+"DOSVER.EMU"
4066 PGM.LEN=27
4067 OPEN FILENAME$ AS #1 LEN=1
4068 FIELD #1, 1 AS PGM.BYTE$
4069 FOR I=0 TO PGM.LEN
4070 READ J
4071 LSET PGM.BYTE$=CHR$(J)
4072 PUT #1
4073 NEXT
4074 CLOSE
4075 RESTORE
4076 RETURN
4500 '**********************************************************************
4501 '*
4502 '* SUBROUTINE FUNCTION : GET DISK FREE SPACE
4503 '*
4504 '* VERSION             : 1.0
4505 '*
4506 '* DATE LAST UPDATED   : SEPT 25, 1983
4507 '*
4508 '* AUTHOR              : JAMES P MORGAN
4509 '*
4510 '* CALL FORMAT         :
4511 '* ---------------------
4512 '* CALL OFFSET%(DRIVE%,NUM.ALLOC.UNITS%,NUM.SEC.PER.UNIT%,SECTOR.SIZE%,AVAIL.CLUSTERS%,RETURN.CODE%)
4513 '*
4514 '* PARAMETERS PASSED   : DRIVE%                (0=DEFAULT,1=A,2=B..ECT)
4515 '*                       NUM.ALLOC.UNITS%=0
4516 '*                       NUM.SEC.PER.UNIT%=0
4517 '*                       SECTOR.SIZE%=0
4518 '*                       AVAIL.CLUSTERS%=0
4519 '*                       RETURN.CODE%=0
4520 '*
4521 '* PARAMETERS RETURNED : DRIVE%
4522 '*                       NUM.ALLOC.UNITS%      (TOTAL CLUSTERS ON THE
4523 '*                                             DRIVE)
4524 '*
4525 '*                       NUM.SEC.PER.UNIT%     (NUMBER OF SECTORS PER
4526 '*                                             CLUSTER)
4527 '*
4528 '*                       SECTOR.SIZE%          (BYTES PER SECTOR)
4529 '*
4530 '*                       AVAIL.CLUSTERS%       (NUMBER OF AVAILABLE CLUSTERS)
4531 '*
4532 '*                       RETURN.CODE%          (255=INVALID DRIVE)
4533 '*
4534 '*
4535 '* COMMENTS           :
4536 '*                     THIS DOS FUNCTION CALL RETURNS THE SANE INFO
4537 '*                    (EXCEPT FOR THE FAT POINTER) AS THE GET FAT POINTER
4538 '*                    CALL (1BH) DID UNDER PREVIOUS VERSIONS OF DOS.
4539 '**************************************************************************
4540 CLS
4541 CLOSE
4542 DEF SEG
4543 DEFINT A-Z
4544 DIM SUBRT%(40)
4545 OFFSET%=0
4546 DRIVE%=1
4547 NUM.ALLOC.UNITS%=0
4548 NUM.SEC.PER.UNIT%=0
4549 SECTOR.SIZE%=0
4550 AVAIL.CLUSTERS%=0
4551 RETURN.CODE%=0
4552 GOSUB 4596
4553 GOSUB 4564
4554 OFFSET%=VARPTR(SUBRT%(0))
4555 CALL OFFSET%(DRIVE%,NUM.ALLOC.UNITS%,NUM.SEC.PER.UNIT%,SECTOR.SIZE%,AVAIL.CLUSTERS%,RETURN.CODE%)
4556 PRINT "DRIVE REQUESTED   = ";DRIVE%
4557 PRINT "ALLOC CLUSTERS    = ";NUM.ALLOC.UNITS%
4558 PRINT "SECTORS PER CLUSTE= ";NUM.SEC.PER.UNIT%
4559 PRINT "BYTES PER SECTOR  = ";SECTOR.SIZE%
4560 PRINT "AVAIL. CLUSTERS   = ";AVAIL.CLUSTERS%
4561 PRINT "FREE SPACE        = ";SECTOR.SIZE%*NUM.SEC.PER.UNIT%*AVAIL.CLUSTERS%
4562 PRINT "RETURN CODE       = ";RETURN.CODE%
4563 END
4564 RESTORE
4565 FOR I=0 TO 60
4566 READ J
4567 POKE (VARPTR(SUBRT%(0))+I),J
4568 NEXT
4569 RETURN
4570 DATA &H55
4571 DATA &H89,&HE5
4572 DATA &H31,&HC0
4573 DATA &H31,&HDB
4574 DATA &H31,&HC9
4575 DATA &H31,&HD2
4576 DATA &H8B,&H76,&H10
4577 DATA &H8A,&H14
4578 DATA &HB4,&H36
4579 DATA &HCD,&H21
4580 DATA &H8B,&H76,&H0E
4581 DATA &H88,&H14
4582 DATA &H88,&H74,&H01
4583 DATA &H8B,&H76,&H0C
4584 DATA &H88,&H04
4585 DATA &H88,&H64,&H01
4586 DATA &H8B,&H76,&H0A
4587 DATA &H88,&H0C
4588 DATA &H88,&H6C,&H01
4589 DATA &H8B,&H76,&H08
4590 DATA &H88,&H1C
4591 DATA &H88,&H7C,&H01
4592 DATA &H8B,&H76,&H06
4593 DATA &H89,&H04
4594 DATA &H5D
4595 DATA &HCA,&H0C,&H00
4596 RESTORE
4597 FILENAME$="A:"+"FREESPAC.EMU"
4598 PGM.LEN=60
4599 OPEN FILENAME$ AS #1 LEN=1
4600 FIELD #1, 1 AS PGM.BYTE$
4601 FOR I=0 TO PGM.LEN
4602 READ J
4603 LSET PGM.BYTE$=CHR$(J)
4604 PUT #1
4605 NEXT
4606 CLOSE
4607 RESTORE
4608 RETURN
5000 '**********************************************************************
5001 '*
5002 '* SUBROUTINE FUNCTION : CHANGE/CREATE/REMOVE A DIRECTORY
5003 '*
5004 '* VERSION             : 1.0
5005 '*
5006 '* DATE LAST UPDATED   : SEPT 25, 1983
5007 '*
5008 '* AUTHOR              : JAMES P MORGAN
5009 '*
5010 '* CALL FORMAT         :
5011 '* ---------------------
5012 '* CALL OFFSET%(FUNCTION.CALL%,ASCIIZ.STRING$,RETURN.CODE%)
5013 '*
5014 '* PARAMETERS PASSED   : FUNCTION.CALL%        (&H39 - MKDIR
5015 '*                                              &H3A - RMDIR
5016 '*                                              &H3B - CHDIR)
5017 '*
5018 '*                       ASCIIZ.STRING$        (THE ASCII STRING  OF THE
5019 '*                                             DIRECTORY TO BE USED)
5020 '*
5021 '*                       RETURN.CODE%=0
5022 '*
5023 '* PARAMETERS RETURNED : FUNCTION.CALL%
5024 '*                       ASCIIZ.STRING$
5025 '*                       RETURN.CODE%          (SEE ERROR CODE LIST)
5026 '*
5027 '*
5028 '* COMMENTS           :
5029 '*
5030 '* EACH OF THE DIRECTORY MAINTENANCE FUNCTIONS ARE DISCUSSED SEPARATELY
5031 '*
5032 '*         MKDIR   ------------- CREATE A DIRECTORY
5033 '*
5034 '*                THE ASCIIZ STRING CONTAINS THE DRIVE AND DIRECTORY
5035 '*               PATH NAMES. IF ANY MEMBER OF THE DIRECTORY PATH DOES NOT
5036 '*               EXIST THEN THE DIRECTORY PATH IS NOT CHANGED. ON RETURN
5037 '*               A NEW DIRECTORY IS CREATED AT THE END OF THE SPECIFIED
5038 '*               PATH.
5039 '*
5040 '*         RMDIR   ------------- REMOVE A SUB-DIRECTORY
5041 '*
5042 '*                THE ASCIIZ STRING CONTAINS THE DRIVE AND DIRECTORY
5043 '*               PATH NAMES. THE SPECIFIED DIRECTORY IS REMOVED FROM THE
5044 '*               STRUCTURE. THE CURRENT DIRECTORY CANNOT BE REMOVED.
5045 '*
5046 '*         CHDIR   ------------- CHANGE THE CURRENT DIRECTORY
5047 '*
5048 '*                THE ASCIIZ STRING CONTAINS THE DRIVE AND DIRECTORY
5049 '*               PATH NAMES. IF ANY MEMBER OF THE DIRECTORY DOES NOT EXIST
5050 '*               THEN THE DIRECTORY PATH IS NOT CHANGED.
5051 '*
5052 '*************************************************************************
5053 CLS
5054 CLOSE
5055 DEF SEG
5056 DEFINT A-Z
5057 DIM SUBRT%(40)
5058 OFFSET%=0
5059 FUNCTION.CALL%=&H3B
5060 FUNCTION.TYPE$=""
5061 PATH.NAME$="C:\EMULATOR"
5062 ASCIIZ.STRING$=PATH.NAME$+CHR$(0)
5063 RETURN.CODE%=0
5064 GOSUB 5099
5065 GOSUB 5076
5066 OFFSET%=VARPTR(SUBRT%(0))
5067 CALL OFFSET%(FUNCTION.CALL%,ASCIIZ.STRING$,RETURN.CODE%)
5068 IF FUNCTION.CALL%=&H39 THEN FUNCTION.TYPE$="CREATE A SUB-DIRECTORY"
5069 IF FUNCTION.CALL%=&H3A THEN FUNCTION.TYPE$="REMOVE A DIRECTORY"
5070 IF FUNCTION.CALL%=&H3B THEN FUNCTION.TYPE$="CHANGE THE CURRENT DIRECTORY"
5071 PRINT "FUNCTION CALL CODE= ";FUNCTION.CALL%
5072 PRINT "FUNCTION TYPE     = ";FUNCTION.TYPE$
5073 PRINT "PATH IS           = ";PATH.NAME$
5074 PRINT "RETURN CODE       = ";RETURN.CODE%
5075 END
5076 RESTORE
5077 FOR I=0 TO 30
5078 READ J
5079 POKE (VARPTR(SUBRT%(0))+I),J
5080 NEXT
5081 RETURN
5082 DATA &H55
5083 DATA &H89,&HE5
5084 DATA &H31,&HC0
5085 DATA &H8B,&H76,&H0A
5086 DATA &H8A,&H24
5087 DATA &H8B,&H76,&H08
5088 '********COMMENT OUT THE FOLLOWING DATA STATEMENT IF USED WITH THE BASIC COMPILER
5089 DATA &H8B,&H54,&H01
5090 '********COMMENT OUT THE FOLLOWING DATA STATEMENT IF USED WITH THE BASIC INTERPRETER
5091 'DATA &H8B,&H54,&H02
5092 DATA &HCD,&H21
5093 DATA &H72,&H02
5094 DATA &H30,&HC0
5095 DATA &H8B,&H76,&H06
5096 DATA &H88,&H04
5097 DATA &H5D
5098 DATA &HCA,&H06,&H00
5099 RESTORE
5100 FILENAME$="A:"+"DIRMAINT.EMU"
5101 PGM.LEN=30
5102 OPEN FILENAME$ AS #1 LEN=1
5103 FIELD #1, 1 AS PGM.BYTE$
5104 FOR I=0 TO PGM.LEN
5105 READ J
5106 LSET PGM.BYTE$=CHR$(J)
5107 PUT #1
5108 NEXT
5109 CLOSE
5110 RESTORE
5111 RETURN
5500 '**********************************************************************
5501 '*
5502 '* SUBROUTINE FUNCTION : GET/SET CURRENT DEFAULT DISK DRIVE
5503 '*
5504 '* VERSION             : 1.0
5505 '*
5506 '* DATE LAST UPDATED   : SEPT 25, 1983
5507 '*
5508 '* AUTHOR              : JAMES P MORGAN
5509 '*
5510 '* CALL FORMAT         :
5511 '* ---------------------
5512 '* CALL OFFSET%(DRIVE%,LOGICAL.DRIVES%,RETURN.CODE%)
5513 '*
5514 '* PARAMETERS PASSED   : DRIVE%                (0=A,2=B..ECT)
5515 '*                       LOGICAL.DRIVES%=0
5516 '*                       RETURN.CODE%=0
5517 '*
5518 '* PARAMETERS RETURNED : DRIVE%
5519 '*                       LOGICAL.DRIVES%       (0-MAX LOGICAL DRIVES)
5520 '*                       RETURN.CODE%          (CURRENT DEFAULT DRIVE)
5521 '*
5522 '*
5523 '* COMMENTS           :
5524 '*                     THIS SUBROUTINE WILL ASSIGN, DRIVE%, AS THE
5525 '*                    DEFAULT DRIVE (IF VALID). THE NUMBER OF LOGICAL
5526 '*                    DRIVES (TOTAL DISKETTE AND FIXED) ARE RETURNED.
5527 '*                     IF THE SYSTEM HAS ONLY ONE DISKETTE DRIVE, IT WILL
5528 '*                    BE COUNTED AS TWO TO BE CONSISTANT WITH THE
5529 '*                    PHILOSOPHY OF THINKING OF THE SYSTEM AS HAVING
5530 '*                    LOGICAL DRIVES "A" AND "B".
5531 '*                     AS A SIDE EFFECT, IF YOU GIVE THIS SUBROUTINE
5532 '*                    AN INVALID DRIVE (255), IT WILL ONLY RETURN THE
5533 '*                    CURRENT DEFAULT DRIVE SO YOU DO NOT NEED TO DO
5534 '*                    A DOS FUNCTION CALL &H19, CURRENT DISK.
5535 '*
5536 '*                      BIOS EQUIPMENT CHECK DETERMINATION (INT 11H)
5537 '*                    CAN BE USED TO DETERMINE THE NUMBER OF ACTUAL
5538 '*                    PHYSICAL DRIVES.
5539 '*
5540 '*************************************************************************
5541 CLS
5542 CLOSE
5543 DEF SEG
5544 DEFINT A-Z
5545 DIM SUBRT%(40)
5546 OFFSET%=0
5547 DRIVE%=0
5548 LOGICAL.DRIVES%=0
5549 RETURN.CODE%=0
5550 GOSUB 5578
5551 GOSUB 5558
5552 OFFSET%=VARPTR(SUBRT%(0))
5553 CALL OFFSET%(DRIVE%,LOGICAL.DRIVES%,RETURN.CODE%)
5554 PRINT "DEFAULT REQUESTED = ";DRIVE%
5555 PRINT "LOGICAL DRIVES    = ";LOGICAL.DRIVES%
5556 PRINT "NEW DEFAULT DRIVE = ";RETURN.CODE%
5557 END
5558 RESTORE
5559 FOR I=0 TO 29
5560 READ J
5561 POKE (VARPTR(SUBRT%(0))+I),J
5562 NEXT
5563 RETURN
5564 DATA &H55
5565 DATA &H89,&HE5
5566 DATA &H8B,&H76,&H0A
5567 DATA &H8A,&H14
5568 DATA &HB4,&H0E
5569 DATA &HCD,&H21
5570 DATA &H8B,&H76,&H08
5571 DATA &H88,&H04
5572 DATA &HB4,&H19
5573 DATA &HCD,&H21
5574 DATA &H8B,&H76,&H06
5575 DATA &H88,&H04
5576 DATA &H5D
5577 DATA &HCA,&H06,&H00
5578 RESTORE
5579 FILENAME$="A:"+"DRIVEDEF.EMU"
5580 PGM.LEN=29
5581 OPEN FILENAME$ AS #1 LEN=1
5582 FIELD #1, 1 AS PGM.BYTE$
5583 FOR I=0 TO PGM.LEN
5584 READ J
5585 LSET PGM.BYTE$=CHR$(J)
5586 PUT #1
5587 NEXT
5588 CLOSE
5589 RESTORE
5590 RETURN
6000 '**********************************************************************
6001 '*
6002 '* SUBROUTINE FUNCTION : GET CURRENT DIRECTORY
6003 '*
6004 '* VERSION             : 1.0
6005 '*
6006 '* DATE LAST UPDATED   : SEPT 25, 1983
6007 '*
6008 '* AUTHOR              : JAMES P MORGAN
6009 '*
6010 '* CALL FORMAT         :
6011 '* ---------------------
6012 '* CALL OFFSET%(DRIVE%,ASCIIZ.STRING$,RETURN.CODE%)
6013 '*
6014 '* PARAMETERS PASSED   : DRIVE%                (0=DEFAULT,1=A,2=B..ECT)
6015 '*                       ASCIIZ.STRING$        (AT LEAST A 64 BYTE
6016 '*                                             CHARACTER STRING RETURN
6017 '*                                             AREA)
6018 '*
6019 '*                       RETURN.CODE%=0
6020 '*
6021 '* PARAMETERS RETURNED : DRIVE%
6022 '*                       ASCIIZ.STRING$        (CURRENT DIRECTORY)
6023 '*                       RETURN.CODE%          (SEE ERROR CODE LIST)
6024 '*
6025 '*
6026 '* COMMENTS           :
6027 '*                     THIS SUBROUTINE WILL RETURN THE CURRENT DIRECTORY
6028 '*                    FOR THE SPECIFIED DRIVE. THE FULL PATH NAME ,
6029 '*                    STARTING WITH THE ROOT DIRECTORY IS RETURNED.
6030 '*                     THE DRIVE LETTER WILL NOT BE PART OF THE RETURNED
6031 '*                    STRING. THE STRING WILL NOT BEGIN WITH THE "\" AND
6032 '*                    WILL BE TERMINATED WITH A BYTE CONTAINING A HEX 00.
6033 '*
6034 '*************************************************************************
6035 CLS
6036 CLOSE
6037 DEF SEG
6038 DEFINT A-Z
6039 DIM SUBRT%(40)
6040 OFFSET%=0
6041 DRIVE%=0
6042 ASCIIZ.STRING$=STRING$(80,0)
6043 CURRENT.DIRECTORY$=""
6044 RETURN.CODE%=0
6045 GOSUB 6079
6046 GOSUB 6057
6047 OFFSET%=VARPTR(SUBRT%(0))
6048 CALL OFFSET%(DRIVE%,ASCIIZ.STRING$,RETURN.CODE%)
6049 IF RETURN.CODE%<>0 THEN CURRENT.DIRECTORY$="INVALID DRIVE SPECIFIED":GOTO 6053
6050 INSTR.LOC=INSTR(ASCIIZ.STRING$,CHR$(0))
6051 IF INSTR.LOC<2 THEN CURRENT.DIRECTORY$="\":GOTO 6053
6052 CURRENT.DIRECTORY$="\"+LEFT$(ASCIIZ.STRING$,INSTR.LOC-1)
6053 PRINT "DRIVE REQUESTED   = ";DRIVE%
6054 PRINT "CURRENT DIRECTORY = ";CURRENT.DIRECTORY$
6055 PRINT "RETURN CODE       = ";RETURN.CODE%
6056 END
6057 RESTORE
6058 FOR I=0 TO 28
6059 READ J
6060 POKE (VARPTR(SUBRT%(0))+I),J
6061 NEXT
6062 RETURN
6063 DATA &H55
6064 DATA &H89,&HE5
6065 DATA &H8B,&H76,&H0A
6066 DATA &H8A,&H14
6067 DATA &H8B,&H5E,&H08
6068 '********COMMENT OUT THE FOLLOWING DATA STATEMENT IF USED WITH THE BASIC COMPILER
6069 DATA &H8B,&H77,&H01
6070 '********COMMENT OUT THE FOLLOWING DATA STATEMENT IF USED WITH THE BASIC INTERPRETER
6071 'DATA &H8B,&H77,&H02
6072 DATA &H31,&HC0
6073 DATA &HB4,&H47
6074 DATA &HCD,&H21
6075 DATA &H8B,&H76,&H06
6076 DATA &H88,&H04
6077 DATA &H5D
6078 DATA &HCA,&H06,&H00
6079 RESTORE
6080 FILENAME$="A:"+"DIRCURR.EMU"
6081 PGM.LEN=28
6082 OPEN FILENAME$ AS #1 LEN=1
6083 FIELD #1, 1 AS PGM.BYTE$
6084 FOR I=0 TO PGM.LEN
6085 READ J
6086 LSET PGM.BYTE$=CHR$(J)
6087 PUT #1
6088 NEXT
6089 CLOSE
6090 RESTORE
6091 RETURN
6500 '**********************************************************************
6501 '*
6502 '* SUBROUTINE FUNCTION : RENAME A FILE
6503 '*
6504 '* VERSION             : 1.0
6505 '*
6506 '* DATE LAST UPDATED   : SEPT 25, 1983
6507 '*
6508 '* AUTHOR              : JAMES P MORGAN
6509 '*
6510 '* CALL FORMAT         :
6511 '* ---------------------
6512 '* CALL OFFSET%(ASCIIZ.STRING1$,ASCIIZ.STRING2$,RETURN.CODE%)
6513 '*
6514 '* PARAMETERS PASSED   : ASCIIZ.STRING1$       (THE ASCII STRING  OF THE
6515 '*                                             CURRENT FILE NAME)
6516 '*
6517 '*                       ASCIIZ.STRING2$       (THE ASCII STRING  OF THE
6518 '*                                             NEW FILE NAME)
6519 '*
6520 '*                       RETURN.CODE%=0
6521 '*
6522 '* PARAMETERS RETURNED : ASCIIZ.STRING1$
6523 '*                       ASCIIZ.STRING2$
6524 '*                       RETURN.CODE%          (SEE ERROR CODE LIST)
6525 '*
6526 '*
6527 '* COMMENTS           :
6528 '*                     THIS SUBROUTINE WILL RENAME A DIRECTORY ENTRY
6529 '*                    ASSOCIATED WITH A FILE NAME.
6530 '*                     THE ASCIIZ.STRING CONSISTS OF A DRIVE, PATH AND
6531 '*                    FILE NAME .GLOBAL FILE NAME CHARACTERS ARE NOT
6532 '*                    ALLOWED IN ANY PART OF THE STRING.
6533 '*                     IF A DRIVE IS SPECIFIED IN THE SECOND STRING, IT
6534 '*                    MUST BE THE SAME AS THE DRIVE SPECIFIED OR IMPLIED
6535 '*                    IN THE FIRST STRING. THE DIRECTORY PATHS NEED NOT BE
6536 '*                    THE SAME, ALLOWING A FILE TO BE MOVED TO ANOTHER
6537 '*                    DIRECTORY AND RENAMED IN THE PROCESS.
6538 '*
6539 '*
6540 '*************************************************************************
6541 CLS
6542 CLOSE
6543 DEF SEG
6544 DEFINT A-Z
6545 DIM SUBRT%(40)
6546 OFFSET%=0
6547 ASCIIZ.STRING2$="A:\CNTLBRK.EMU"+CHR$(0)
6548 ASCIIZ.STRING1$="A:\CNTLBRAK.EMU"+CHR$(0)
6549 RETURN.CODE%=0
6550 GOSUB 6587
6551 GOSUB 6558
6552 OFFSET%=VARPTR(SUBRT%(0))
6553 CALL OFFSET%(ASCIIZ.STRING1$,ASCIIZ.STRING2$,RETURN.CODE%)
6554 PRINT "OLD FILE NAME     = ";LEFT$(ASCIIZ.STRING1$,LEN(ASCIIZ.STRING1$)-1)
6555 PRINT "NEW FILE NAME     = ";LEFT$(ASCIIZ.STRING2$,LEN(ASCIIZ.STRING2$)-1)
6556 PRINT "RETURN CODE       = ";RETURN.CODE%
6557 END
6558 RESTORE
6559 FOR I=0 TO 37
6560 READ J
6561 POKE (VARPTR(SUBRT%(0))+I),J
6562 NEXT
6563 RETURN
6564 DATA &H55
6565 DATA &H89,&HE5
6566 DATA &H31,&HC0
6567 DATA &H31,&HD2
6568 DATA &H31,&HFF
6569 DATA &H8B,&H76,&H0A
6570 '********COMMENT OUT THE FOLLOWING DATA STATEMENT IF USED WITH THE BASIC COMPILER
6571 DATA &H8B,&H54,&H01
6572 '********COMMENT OUT THE FOLLOWING DATA STATEMENT IF USED WITH THE BASIC INTERPRETER
6573 'DATA &H8B,&H54,&H02
6574 DATA &H8B,&H76,&H08
6575 '********COMMENT OUT THE FOLLOWING DATA STATEMENT IF USED WITH THE BASIC COMPILER
6576 DATA &H8B,&H7C,&H01
6577 '********COMMENT OUT THE FOLLOWING DATA STATEMENT IF USED WITH THE BASIC INTERPRETER
6578 'DATA &H8B,&H7C,&H02
6579 DATA &HB4,&H56
6580 DATA &HCD,&H21
6581 DATA &H72,&H02
6582 DATA &H30,&HC0
6583 DATA &H8B,&H76,&H06
6584 DATA &H88,&H04
6585 DATA &H5D
6586 DATA &HCA,&H06,&H00
6587 RESTORE
6588 FILENAME$="A:"+"RENFILE.EMU"
6589 PGM.LEN=37
6590 OPEN FILENAME$ AS #1 LEN=1
6591 FIELD #1, 1 AS PGM.BYTE$
6592 FOR I=0 TO PGM.LEN
6593 READ J
6594 LSET PGM.BYTE$=CHR$(J)
6595 PUT #1
6596 NEXT
6597 CLOSE
6598 RESTORE
6599 RETURN
7000 '**********************************************************************
7001 '*
7002 '* SUBROUTINE FUNCTION : DELETE A FILE FROM A SPECIFIC DIRECTORY (UNLINK)
7003 '*
7004 '* VERSION             : 1.0
7005 '*
7006 '* DATE LAST UPDATED   : SEPT 25, 1983
7007 '*
7008 '* AUTHOR              : JAMES P MORGAN
7009 '*
7010 '* CALL FORMAT         :
7011 '* ---------------------
7012 '* CALL OFFSET%(ASCIIZ.STRING$,RETURN.CODE%)
7013 '*
7014 '* PARAMETERS PASSED   : ASCIIZ.STRING$        (THE ASCII STRING  OF THE
7015 '*                                             FILE TO BE DELETED)
7016 '*
7017 '*                       RETURN.CODE%=0
7018 '*
7019 '* PARAMETERS RETURNED : ASCIIZ.STRING$
7020 '*                       RETURN.CODE%          (SEE ERROR CODE LIST)
7021 '*
7022 '*
7023 '* COMMENTS           :
7024 '*                     THIS SUBROUTINE WILL REMOVE A DIRECTORY ENTRY
7025 '*                    ASSOCIATED WITH A FILE NAME.
7026 '*                     THE ASCIIZ.STRING CONSISTS OF A DRIVE, PATH AND
7027 '*                    FILE NAME .GLOBAL FILE NAME CHARACTERS ARE NOT
7028 '*                    ALLOWED IN ANY PART OF THE STRING.
7029 '*                     READ-ONLY FILES CANNOT BE DELETED WITH THIS CALL.
7030 '*                    TO DELETE ONE OF THESE FILES, FIRST USE AN INT 43H
7031 '*                    CALL (OR THE CHANGE MODE SUBROUTINE INCLUDED WITH
7032 '*                    THIS SERIES OF SUBROUTINES) TO CHANGE THE FILES
7033 '*                    ATTRIBUTE TO ZERO(0) , THEN DELETE THE FILE.
7034 '*************************************************************************
7035 CLS
7036 CLOSE
7037 DEF SEG
7038 DEFINT A-Z
7039 DIM SUBRT%(40)
7040 OFFSET%=0
7041 ASCIIZ.STRING$="C:\CNTLBRK.EMU"+CHR$(0)
7042 RETURN.CODE%=0
7043 GOSUB 7073
7044 GOSUB 7050
7045 OFFSET%=VARPTR(SUBRT%(0))
7046 CALL OFFSET%(ASCIIZ.STRING$,RETURN.CODE%)
7047 PRINT "DELETED FILE NAME = ";LEFT$(ASCIIZ.STRING$,LEN(ASCIIZ.STRING$)-1)
7048 PRINT "RETURN CODE       = ";RETURN.CODE%
7049 END
7050 RESTORE
7051 FOR I=0 TO 29
7052 READ J
7053 POKE (VARPTR(SUBRT%(0))+I),J
7054 NEXT
7055 RETURN
7056 DATA &H55
7057 DATA &H89,&HE5
7058 DATA &H31,&HC0
7059 DATA &H31,&HD2
7060 DATA &H8B,&H76,&H08
7061 '********COMMENT OUT THE FOLLOWING DATA STATEMENT IF USED WITH THE BASIC COMPILER
7062 DATA &H8B,&H54,&H01
7063 '********COMMENT OUT THE FOLLOWING DATA STATEMENT IF USED WITH THE BASIC INTERPRETER
7064 'DATA &H8B,&H54,&H02
7065 DATA &HB4,&H41
7066 DATA &HCD,&H21
7067 DATA &H72,&H02
7068 DATA &H30,&HC0
7069 DATA &H8B,&H76,&H06
7070 DATA &H88,&H04
7071 DATA &H5D
7072 DATA &HCA,&H04,&H00
7073 RESTORE
7074 FILENAME$="A:"+"DELFILE.EMU"
7075 PGM.LEN=29
7076 OPEN FILENAME$ AS #1 LEN=1
7077 FIELD #1, 1 AS PGM.BYTE$
7078 FOR I=0 TO PGM.LEN
7079 READ J
7080 LSET PGM.BYTE$=CHR$(J)
7081 PUT #1
7082 NEXT
7083 CLOSE
7084 RESTORE
7085 RETURN
7500 '**********************************************************************
7501 '*
7502 '* SUBROUTINE FUNCTION : CHANGE A FILE'S MODE (ATTRIBUTE)
7503 '*
7504 '* VERSION             : 1.0
7505 '*
7506 '* DATE LAST UPDATED   : SEPT 25, 1983
7507 '*
7508 '* AUTHOR              : JAMES P MORGAN
7509 '*
7510 '* CALL FORMAT         :
7511 '* ---------------------
7512 '* CALL OFFSET%(FUNCTION.CODE%,ATTRIBUTE%,ASCIIZ.STRING$,RETURN.CODE%)
7513 '*
7514 '* PARAMETERS PASSED   : FUNCTION.CODE%        (00=RETURN ATTRIBUTE
7515 '*                                              01=CHANGE ATTRIBUTE
7517 '*
7518 '*                       ATTRIBUTE%            (FILE ATTRIBUTE)
7519 '*
7520 '*                       ASCIIZ.STRING$        (THE ASCII STRING  OF THE
7521 '*                                             FILE)
7522 '*
7523 '*                       RETURN.CODE%=0
7524 '*
7525 '* PARAMETERS RETURNED : FUNCTION.CODE%
7526 '*                       ATTRIBUTE%            (FILE ATTRIBUTE)
7527 '*                       ASCIIZ.STRING$
7528 '*                       RETURN.CODE%          (SEE ERROR CODE LIST)
7529 '*
7530 '*
7531 '* COMMENTS           :
7532 '*                     IF THE FUNCTION.CODE% IS SET TO 00 THEN THE FILES
7533 '*                    CURRENT ATTRIBUTE WILL BE RETURNED, ELSE IF THE
7534 '*                    FUNCTION.CODE% IS SET TO 01, THE FILE'S ATTRIBUTE
7535 '*                    WILL BE CHANGED TO THE ATTRIBUTE% PASSED TO THE
7536 '*                    SUBROUTINE.
7537 '*                     THE ASCIIZ STRING CONSISTS OF THE DRIVE, PATH, AND
7538 '*                    FILENAME.
7539 '*                     SEEMS THAT THIS DOS FUNCTION CALL WILL NOT LET YOU
7540 '*                    CHANGE A FILES MODE TO THAT OF A VOLUME LABEL (&H8).
7541 '*
7542 '*
7543 '*************************************************************************
7544 '*
7545 '*************** FILE ATTRIBUTE BYTES - VALUES IN HEXADECIMAL ***********
7546 '*
7547 '*            01H - FILE IS READ ONLY          (CAN BE USED WITH OTHERS)
7548 '*            02H - HIDDEN FILE
7549 '*            04H - SYSTEM FILE
7550 '*            08H - VOLUME LABEL               (ONLY FIRST 11 CHARACTERS)
7551 '*            10H - SUB-DIRECTORY ENTRY
7552 '*            20H - ARCHIVE BIT                (CAN BE USED WITH OTHERS
7553 '*                                  SET WHEN FILE WRITTEN TO AND CLOSED)
7554 CLS
7555 CLOSE
7556 DEF SEG
7557 DEFINT A-Z
7558 DIM SUBRT%(40)
7559 OFFSET%=0
7560 FUNCTION.CODE%=1
7561 ATTRIBUTE%=0
7562 ATTRIBUTE.SENT%=ATTRIBUTE%
7563 PATH.NAME$="C:DOSVER.EMU"
7564 ASCIIZ.STRING$=PATH.NAME$+CHR$(0)
7565 RETURN.CODE%=0
7566 GOSUB 7606
7567 GOSUB 7576
7568 OFFSET%=VARPTR(SUBRT%(0))
7569 CALL OFFSET%(FUNCTION.CODE%,ATTRIBUTE%,ASCIIZ.STRING$,RETURN.CODE%)
7570 PRINT "FUNCTION REQUESTED= ";FUNCTION.CODE%
7571 PRINT "FILE PATH         = ";PATH.NAME$
7572 PRINT "ATTRIBUTE SENT    = ";ATTRIBUTE.SENT%
7573 PRINT "ATTRIBUTE RETURNED= ";ATTRIBUTE%
7574 PRINT "RETURN CODE       = ";RETURN.CODE%
7575 END
7576 RESTORE
7577 FOR I=0 TO 46
7578 READ J
7579 POKE (VARPTR(SUBRT%(0))+I),J
7580 NEXT
7581 RETURN
7582 DATA &H55
7583 DATA &H89,&HE5
7584 DATA &H31,&HC0
7585 DATA &H31,&HC9
7586 DATA &H31,&HD2
7587 DATA &H8B,&H76,&H0C
7588 DATA &H8A,&H04
7589 DATA &H8B,&H76,&H08
7590 '********COMMENT OUT THE FOLLOWING DATA STATEMENT IF USED WITH THE BASIC COMPILER
7591 DATA &H8B,&H54,&H01
7592 '********COMMENT OUT THE FOLLOWING DATA STATEMENT IF USED WITH THE BASIC INTERPRETER
7593 'DATA &H8B,&H54,&H02
7594 DATA &H8B,&H76,&H0A
7595 DATA &H8B,&H0C
7596 DATA &HB4,&H43
7597 DATA &HCD,&H21
7598 DATA &H72,&H02
7599 DATA &H30,&HC0
7600 DATA &H8B,&H76,&H06
7601 DATA &H88,&H04
7602 DATA &H8B,&H76,&H0A
7603 DATA &H89,&H0C
7604 DATA &H5D
7605 DATA &HCA,&H08,&H00
7606 RESTORE
7607 FILENAME$="A:"+"CHNGMODE.EMU"
7608 PGM.LEN=46
7609 OPEN FILENAME$ AS #1 LEN=1
7610 FIELD #1, 1 AS PGM.BYTE$
7611 FOR I=0 TO PGM.LEN
7612 READ J
7613 LSET PGM.BYTE$=CHR$(J)
7614 PUT #1
7615 NEXT
7616 CLOSE
7617 RESTORE
7618 RETURN
```
{% endraw %}

## CRC.TXT

{% raw %}
```
PC-SIG Disk No. #108, version v1 

The following is a list of the file checksums which should be produced by
the CRCK4 program on disk #9 (and others).  If the CRC numbers do not match
you may have a bad file.  To use type:  CRCK4 <filespec>

CRCK4 output for this disk:


CRCK ver 4.2B (MS DOS VERSION )
CTL-S pauses, CTL-C aborts

--> FILE:  BASTODOS.BAS         CRC = ED 82

--> FILE:  BATMENU .COM         CRC = C8 D3

--> FILE:  BATMENU .DOC         CRC = 57 38

--> FILE:  DEPRE___.APL         CRC = 44 24

--> FILE:  DISKTYPE.DOC         CRC = 8F 54

--> FILE:  DISKTYPE.EXE         CRC = 62 C0

--> FILE:  FORECAST.APL         CRC = F9 51

--> FILE:  MATH____.APL         CRC = DC AF

--> FILE:  MUSIC   .BAS         CRC = EF 35

--> FILE:  MUSIC   .DOC         CRC = 42 50

--> FILE:  NOECHO  .DOC         CRC = 0C 6D

--> FILE:  PEPATCHS.DOC         CRC = 69 E0

--> FILE:  PMODE   .ASM         CRC = 22 53

--> FILE:  PMODE   .COM         CRC = 54 B5

--> FILE:  PRTSCFX .ASM         CRC = FD C9

--> FILE:  PRTSCFX .COM         CRC = F7 6F

--> FILE:  UTILITY_.APL         CRC = 8E 3F

--> FILE:  READ    .ME          CRC = A2 0A

--> FILE:  UNDOC   .DOC         CRC = AF EA

--> FILE:  PRTSCFX .DOC         CRC = CB 01

 ---------------------> SUM OF CRCS = D9 0B

DONE

These and other Public Domain and user-supported programs from:

PC Software Interest Group
1125 Stewart Ct  Suite G
Sunnyvale, CA 94086
(408) 730-9291
```
{% endraw %}

## DISKTYPE.DOC

{% raw %}
```
0 '===START OF FILE=== 			DISKTYPE.EXE

	  Duncan.Ray.  1983.  The Right to Assemble.
          Softalk.  11:203-209

This utility is a handy one to have when you're not sure of the
format of a particular diskette.  When invoked, it reports whether
the diskette in question is single-sided or double-sided and for-
matted to hold 320 KB or 360 KB worth of data.

The command syntax is:

	A>disktype [d:]

		where d: = drive id

Use it....it comes in handy!!

65529 '===END OF FILE=== comm
```
{% endraw %}

## MUSIC.BAS

{% raw %}
```bas
10 REM DSNAME = MUSIC.BAS
20 REM This version completed on 6/20/82.  For comments and suggestions,
30 REM please contact Bruce Guthrie by mail at
40 REM   P.O. Box 710
50 REM   Washington, D.C. 20044
60 REM Copyright 1982 by Bruce Guthrie
70 DEF FNCT(I)=BEAT+1/L*(1+0.5*ABS(DOTTED=1))
80 DIM WHOLE%(19),HALF%(19),QUARTER%(19),EIGHTH%(37),SIXTEENTH%(37)
90 DIM WREST%(4),QREST%(25),EREST%(19),SREST%(21)
100 DIM CURSOR%(19),DOT%(37),FORBID%(25),NULL%(19),TIED%(10)
110 DIM FLAT%(15),NATURAL%(16),SHARP%(15)
120 DIM TREBLE%(73),BASE%(39)
130 DIM ONE%(39),TWO%(39),THREE%(39),FOUR%(39),EIGHT%(39)
140 DIM P$(1000),P(1000),KEYS(7)
150 SCREEN 1:KEY OFF:FOR I=1 TO 10:KEY I,"":NEXT I
160 BEAT=0:CUREND=0:TIE=0:DOTTED=0:SHARP=0:FLAT=0:NATURAL=0:NOTE=2:REPEAT=-1:POINTER=0
170 CLS:PRINT TAB(10);"Music package":PRINT TAB(3);"(c) Bruce Guthrie June, 1982"
180 INPUT "Need instructions [Y/N]? ",A$:IF A$="n" OR A$="N" THEN 220:ELSE IF A$<>"y" AND A$<>"Y" THEN 180
190 OPEN "music.ins" FOR INPUT AS #1:I=0
200 I=I+1:IF EOF(1) THEN 220
210 INPUT #1,A$:PRINT A$:IF I<22 THEN 200:ELSE I=0:INPUT "Press RETURN? ",A$:GOTO 200
220 GOSUB 1350  'read in PUT definitions for notes
230 PLAY "MB":CLS:INPUT "Is composition saved already [Y/N]? ",A$:IF A$<>"Y" AND A$<>"y" AND A$<>"N" AND A$<>"n" THEN 230:ELSE IF A$="Y" OR A$="y" THEN GOTO 1190:ELSE CLS:P$(0)="T120":P(0)=-1
240 GOSUB 2020:NOTE=12 'draw clefs
250 GOSUB 890        'set key
260 GOSUB 830        'set bar measure
270 GOSUB 300        'enter notes
280 NEWPAGE=0:GOSUB 2050:IF NEWPAGE=1 THEN GOTO 270:ELSE GOSUB 320:GOTO 280
290 'INPUT NOTE****************************************************************
300 GOSUB 1910:PRINT"Enter note: sharp(+),flat(-),nat(N),":PRINT "rest(P), 1,2,4,8,S(16th)":PRINT"change key(K),measure(M),tempo(T)"
310 LOCATE 20,1:PRINT "'1 play, '3 save, '2 tie notes":PRINT ". (dotted note)":' print "[ (begin) and ] (end) repeat"
320 LOCATE 4,1:PRINT "Use cursor controls to position note. ":GOSUB 1890:PAUSE=0
330 X$=INKEY$:IF X$="" THEN 330:ELSE IF LEN(X$)=1 THEN 390:ELSE X=ASC(MID$(X$,2))
340 IF X=59 THEN GOSUB 1890:BEAT=0:GOSUB 1920:GOSUB 1020:GOTO 300 'SF 1 (play song)
350 IF X=60 THEN GOSUB 1950:IF TIE=1 THEN TIE=0:GOSUB 1950:GOTO 330:ELSE TIE=1:GOSUB 1950:GOTO 330 'SF 2 (tie notes)
360 IF X=61 THEN GOSUB 1150:GOSUB 1940:NEWPAGE=1:GOTO 300 'SF 3 (save it)
370 IF X=72 THEN GOSUB 1890:GOSUB 1950:NOTE=NOTE-1:IF NOTE=0 THEN NOTE=25:GOSUB 1890:GOSUB 1950:GOTO 330:ELSE GOSUB 1890:GOSUB 1950:GOTO 330 'cursor up
380 IF X=80 THEN GOSUB 1890:GOSUB 1950:NOTE=NOTE+1:IF NOTE=26 THEN NOTE=1:GOSUB 1890:GOSUB 1950:GOTO 330:ELSE GOSUB 1890:GOSUB 1950:GOTO 330 'cursor down
390 A1$=X$:IF A1$="#" THEN A1$="+":ELSE IF A1$>="a" AND A1$<="z" THEN A1$=CHR$(ASC(A1$)-32)
400 ON INSTR("+-.1248KMNSPT[]",A1$)+1 GOTO 330,520,520,410,440,440,440,440,460,470,520,450,420,500,480,490
410 GOSUB 1950:IF DOTTED=1 THEN DOTTED=0:GOSUB 1950:GOTO 330:ELSE DOTTED=1:GOSUB 1950:GOTO 330  'dotted note
420 GOSUB 1920:PRINT "Enter length for this rest? ";:PAUSE=1
430 A1$=INKEY$:IF LEN(A1$)<>1 THEN 430:ELSE ON INSTR("1248Ss",A1$)+1 GOTO 430,440,440,440,440,450,450
440 L=VAL(A1$):A1$="0":GOTO 580
450 L=16:A1$="0":GOTO 580
460 C=0:GOSUB 1890:GOSUB 890:GOTO 300 'change key
470 C=0:GOSUB 1890:GOSUB 830:GOTO 300 'change bar measure
480 'BEGIN REPEAT
490 'END REPEAT
500 GOSUB 1920:INPUT "New tempo [32<=x<=255]? ",TEMPO:IF TEMPO<32 OR TEMPO>255 THEN 500
510 GOSUB 1890:GOSUB 1920:P1$="T"+MID$(STR$(TEMPO+1000),3):INPUT "Play all with this [Y/N]? ",A$:IF A$="Y" THEN P$(0)=P1$:GOTO 300:ELSE IF A$="N" THEN POINTER=CUREND:GOSUB 780:GOTO 300:ELSE GOTO 510
520 IF A1$="+" AND FORBID%(NOTE)=1 THEN BEEP:GOTO 330:ELSE IF A1$="-" AND FORBID%(NOTE)=2 THEN BEEP:GOTO 330    'checking on flats and sharps
530 GOSUB 1950:IF A1$="+" THEN IF SHARP=1 THEN SHARP=0:GOSUB 1950:GOTO 330:ELSE SHARP=1:FLAT=0:NATURAL=0:GOSUB 1950:GOTO 330  'sharp
540 IF A1$="-" THEN IF FLAT=1 THEN FLAT=0:GOSUB 1950:GOTO 330:ELSE FLAT=1:SHARP=0:NATURAL=0:GOSUB 1950:GOTO 330              'flat
550 IF FLAT=1 THEN NATURAL=0:GOSUB 1950:GOTO 330:ELSE NATURAL=1:FLAT=0:SHARP=0:GOSUB 1950:GOTO 330                           'natural
560 GOSUB 1920:INPUT "Enter length for this note/rest? ",L:IF L=0 THEN GOSUB 1890:GOTO 320
570 'DRAW NOTE*****************************************************************
580 GOSUB 1890:IF FNCT(I)>TOP/BOTTOM THEN GOSUB 1920:PRINT "Note of this length doesn't fit in bar":BEEP:GOSUB 1930:GOTO 320:ELSE GOSUB 590:GOTO 720
590 IF PAUSE=0 THEN ON L GOTO 660,670,590,680,590,590,590,690,590,590,590,590,590,590,590,700
600 ON L GOTO 610,620,600,630,600,600,600,640,600,600,600,600,600,600,600,650   'REST NOTES
610 PUT(WHERE-4,61),WREST%,OR:RETURN
620 PUT(WHERE-4,67),WREST%,OR:RETURN
630 PUT(WHERE-4,60),QREST%,OR:RETURN
640 PUT(WHERE-4,60),EREST%,OR:RETURN
650 PUT(WHERE-4,60),SREST%,OR:RETURN
660 PUT (WHERE-4,NOTE*5+38),NULL%,PSET:PUT (WHERE-4,NOTE*5+38),NULL%,>=:PUT(WHERE-4,NOTE*5+25),WHOLE%,OR:RETURN
670 PUT (WHERE-4,NOTE*5+38),NULL%,PSET:PUT (WHERE-4,NOTE*5+38),NULL%,>=:PUT(WHERE-4,NOTE*5+25),HALF%,OR:RETURN
680 PUT (WHERE-4,NOTE*5+25),QUARTER%,OR:RETURN
690 PUT (WHERE-4,NOTE*5+25),EIGHTH%,OR:RETURN
700 PUT (WHERE-4,NOTE*5+25),SIXTEENTH%,OR:RETURN
710 'FIGURE OUT WHAT TO PLAY***************************************************
720 IF PAUSE=1 THEN P1$="O3P ":GOTO 740:ELSE P2$=MID$("GFEDCBAGFEDCBAGFEDCBAGFEDCBA",NOTE,1):P1$=P2$:IF NOTE<6 THEN P1$="O4"+P1$:ELSE IF NOTE<13 THEN P1$="O3"+P1$:ELSE IF NOTE<20 THEN P1$="O2"+P1$:ELSE P1$="O1"+P1$
730 IF FLAT=1 THEN P1$=P1$+"-":ELSE IF SHARP=1 THEN P1$=P1$+"+":ELSE IF NATURAL=1 THEN P1$=P1$+" ":ELSE P1$=P1$+MID$("- +",KEYS(ASC(P2$)-64)+2,1)
740 IF TIE=1 THEN P1$="ML"+P1$:ELSE P1$="MN"+P1$
750 P1$=P1$+MID$(STR$(100+L),3):IF DOTTED=1 THEN P1$=P1$+".":ELSE P1$=P1$+" "
760 ON ERROR GOTO 820:PLAY P1$:ON ERROR GOTO 0
770 'INSERT NOTE AFTER POINTER*************************************************
780 N1=P(POINTER):CUREND=CUREND+1:P(POINTER)=CUREND:POINTER=P(POINTER):P$(POINTER)=P1$:P(POINTER)=N1:RETURN
790 'DELETE NOTE AFTER POINTER*************************************************
800 P$(P(POINTER))="":P(POINTER)=P(P(POINTER)):RETURN
810 'ERROR*********************************************************************
820 GOSUB 1920:PRINT "Sorry.  That note's incorrect.":RESUME 300
830 'SET TEMPO****************************************************************
840 GOSUB 1910:INPUT "Bar measure, e.g. 4/4? ",A$
850 X=INSTR(A$,"/"):IF X=0 THEN PRINT "No division symbol [/].  Re-enter.":GOTO 840:ELSE IF X=1 OR LEN(A$)=X THEN 840
860 TOP=VAL(MID$(A$,1,X-1)):BOTTOM=VAL(MID$(A$,X+1)):IF MID$("XXXX   X",BOTTOM,1)+MID$("XXXX   X",TOP,1)<>"XX" THEN PRINT "Illegal numbers.  Re-enter.":GOTO 830
870 P1$="B"+RIGHT$(STR$(TOP),2)+"/"+RIGHT$(STR$(BOTTOM),2):POINTER=CUREND:GOSUB 780:GOTO 2120
880 'SET KEY******************************************************************
890 GOSUB 1910:PRINT "Use cursor controls [up/down] and +/-":PRINT "keys to position/set flats and sharps.":PRINT "Use CR to stop.  Do top clef only."
900 FOR I=1 TO 7:KEYS(I)=0:NEXT I:NOTE=2
910 GOSUB 1900
920 X$=INKEY$:IF X$="" THEN 920
930 IF X$="+" OR X$="#" THEN IF FORBID%(NOTE)=1 THEN BEEP:GOTO 920:ELSE I=1:GOSUB 1000:PUT(WHERE+4,NOTE*5+32),SHARP%,>=:GOTO 920
940 IF X$="-" THEN IF FORBID%(NOTE)=2 THEN BEEP:GOTO 920:ELSE I=-1:GOSUB 1000:PUT(WHERE+4,NOTE*5+32),FLAT%,>=:GOTO 920
950 IF ASC(X$)=13 THEN P1$="K":FOR I=0 TO 7:P1$=P1$+STR$(KEYS(I)):NEXT I:POINTER=CUREND:GOSUB 780:GOSUB 1900:GOSUB 2080:WHERE=WHERE+4:NOTE=12:RETURN  'carriage return
960 IF LEN(X$)<2 THEN 920:ELSE X=ASC(MID$(X$,2))
970 IF X=72 THEN GOSUB 1900:NOTE=NOTE-1:IF NOTE=0 THEN NOTE=7:GOSUB 1900:ELSE GOSUB 1900
980 IF X=80 THEN GOSUB 1900:NOTE=NOTE+1:IF NOTE=8 THEN NOTE=1:GOSUB 1900:ELSE GOSUB 1900
990 GOTO 920
1000 IF KEYS(8-NOTE)=I THEN KEYS(0)=KEYS(0)-1:KEYS(8-NOTE)=0:RETURN:ELSE IF KEYS(8-NOTE)=-I THEN KEYS(8-NOTE)=I:RETURN:ELSE KEYS(8-NOTE)=I:KEYS(0)=KEYS(0)+1:RETURN
1010 'PLAY IT WHILE DRAWING IT*************************************************
1020 GOSUB 2020:E=0:WHILE E>-1:A$=P$(E):A1$=MID$(A$,1,1)
1030 IF A1$="T" THEN PLAY A$:GOTO 1130
1040 IF A1$="B" THEN TOP=VAL(MID$(A$,2,2)):BOTTOM=VAL(MID$(A$,5,2)):GOSUB 2120:GOTO 1130
1050 IF A1$="K" THEN FOR I=0 TO 7:KEYS(I)=VAL(MID$(A$,I*2+2,2)):NEXT I:GOSUB 2080:GOTO 1130
1060 IF A1$="R" THEN  'repeats
1070 IF MID$(A$,1,2)="ML" THEN TIE=1:ELSE TIE=0
1080 L=VAL(MID$(A$,7,2)):A1$=MID$(A$,5,1):IF A1$="P" THEN PAUSE=1:GOTO 1110
1090 PAUSE=0:NOTE=(4-VAL(MID$(A$,4,1)))*7-2+INSTR("BAGFEDC",A1$):T1$=MID$(A$,6,1):IF T1$="+" THEN SHARP=1:ELSE IF T1$="-" THEN FLAT=1
1100 IF MID$(A$,9,1)="." THEN DOTTED=1
1110 WHERE=WHERE+(SHARP+FLAT+NATURAL)*4:GOSUB 1950:GOSUB 590
1120 PLAY A$:GOSUB 2050
1130 E=P(E):WEND:RETURN
1140 'SAVE IT******************************************************************
1150 CLS:I1=0:ON ERROR GOTO 1280:INPUT "Name of composition? ",N$:PRINT "Name of file to save as":GOSUB 1240:IF A$="Q" THEN 1940
1160 OPEN FI$ FOR OUTPUT AS #1:WRITE #1,DATE$,N$,CUREND
1170 FOR I=0 TO CUREND:WRITE#1,P(I),P$(I):NEXT I:CLOSE #1:PRINT "Saved!!":BEEP:GOSUB 1930:ON ERROR GOTO 0:RETURN
1180 'LOAD IT******************************************************************
1190 CLS:I1=1:ON ERROR GOTO 1280:PRINT "Name of file to load composition from?":GOSUB 1240:IF A$="Q" THEN 230
1200 OPEN FI$ FOR INPUT AS #1:INPUT #1,A$,N$,CUREND
1210 FOR I=0 TO CUREND:INPUT#1,P(I),P$(I):NEXT I:CLOSE #1
1220 PRINT "The name of this composition is:":PRINT N$:PRINT "File was last saved on ";A$:GOSUB 1930
1230 PRINT "Loaded!":BEEP:GOSUB 1930:ON ERROR GOTO 0:GOSUB 1020:GOTO 270
1240 INPUT "(DEF ext=MUS)? ",FI$:IF INSTR(FI$,".") = 0 THEN FI$=FI$+".MUS"
1241 IF FI$=".MUS" THEN PRINT "Expecting file name.":PRINT "File name ";:GOTO 1240
1250 IF INSTR(FI$,":")=0 THEN INPUT "Device A or B? ",A$:IF LEN(A$)<>1 THEN 1250:ELSE FI$=A$+":"+FI$
1260 INPUT "Insert disk.  Press RETURN (Q=quit)? ",A$:IF A$="Q" THEN ON ERROR GOTO 0:RETURN:ELSE RETURN
1270 'ERROR-TRAPPING ROUTINE***************************************************
1280 IF ERR=53 THEN PRINT "File of this name is not on disk.":PRINT "Try another disk or give up.":GOTO 1330
1290 IF ERR=61 THEN PRINT "Ran out of room on the disk for this":PRINT "file.  Try another disk or give up.":GOTO 1330
1300 IF ERR=62 THEN PRINT "Hmm.  It says we're out of data.":PRINT "Perhaps your file was created by an":PRINT "earlier version of this routine.":PRINT "Skip loading it here.":GOTO 1330
1310 IF ERR=64 THEN PRINT "What the hell was that name you input?":PRINT "It didn't go over at all!":PRINT "Try again or give up.":GOTO 1330
1320 ON ERROR GOTO 0:RESUME
1330 GOSUB 1930:IF I1=1 THEN RESUME 1190:ELSE RESUME 1150
1340 'READ NOTE VALUES*********************************************************
1350 PRINT:PRINT "Reading note character definitions..."
1360 DATA 16,05,-241,-193,-193,-193,-1009
1370 FOR I=0 TO 6:READ NULL%(I):NEXT I 'USED AS PUT(X,Y),NULL%,PRESET TO CLEAR OUT FOR WHOLE% AND HALF%
1380 DATA 3,2,1,3,2,1,3,3,2,1,3,2,1,3,3,2,1,3,2,1,3,3,2,1,3
1390 FOR I=1 TO 25:READ FORBID%(I):NEXT I
1400 DATA 16,18,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-193,-193,-193,0
1410 FOR I=0 TO 19:READ CURSOR%(I):NEXT I
1420 DATA 16,18,0,0,0,0,0,0,0,0,0,0,0,0,0,-241,816,816,816,-1009
1430 FOR I=0 TO 19:READ WHOLE%(I):NEXT I
1440 DATA 16,18,768,768,768,768,768,768,768,768,768,768,768,768,768,-241,816,816,816,-1009
1450 FOR I=0 TO 19:READ HALF%(I):NEXT I
1460 DATA 16,18,768,768,768,768,768,768,768,768,768,768,768,768,768,-241,-193,-193,-193,-1009
1470 FOR I=0 TO 19:READ QUARTER%(I):NEXT I
1480 DATA 32,18,768,192,768,48,768,12,768,3,768,-16384,768,-16384,768,-16384,768,-16384,768,-16384,768,0,768,0,768,0,768,0,-241,0,-193,0,-193,0,-193,0,-1009,0
1490 FOR I=0 TO 37:READ EIGHTH%(I):NEXT I
1500 DATA 32,18,768,192,768,48,768,12,768,3,768,-16192,768,-16336,768,-16372,768,-16381,768,-16384,768,-16384,768,-16384,768,-16384,768,-16384,-241,0,-193,0,-193,0,-193,0,-1009,0
1510 FOR I=0 TO 37:READ SIXTEENTH%(I):NEXT I
1520 DATA 32,18,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,60,0,60,0,0,0,0
1530 FOR I=0 TO 37:READ DOT%(I):NEXT I
1540 DATA 16,3,-961,-961,-961
1550 FOR I=0 TO 4:READ WREST%(I):NEXT I
1560 DATA 18,16,0,0,192,-4096,0,60,-4096,768,192,15,3840,0,-16381,0,240,-1021,3840,0,60,15360,0,12,0,0
1570 FOR I=0 TO 25:READ QREST%(I):NEXT I
1580 DATA 18,12,0,0,0,3072,15360,48,12348,3840,192,-16384,768,0,3,3072,0,12,0,0
1590 FOR I=0 TO 19:READ EREST%(I):NEXT I
1600 DATA 22,13,0,0,-16384,-15613,768,195,-1024,15360,12,12348,3840,240,-16384,0,192,3,768,0,0,0
1610 FOR I=0 TO 21:READ SREST%(I):NEXT I
1620 DATA 12,14,0,-16384,-4084,-4081,-16321,-16324,-16372,-16372,-4084,-4081,-16321,-16324,12,0
1630 FOR I=0 TO 15:READ SHARP%(I):NEXT I
1640 DATA 14,14,0,48,48,48,48,48,-16333,12348,12336,-16336,51,60,48,0
1650 FOR I=0 TO 15:READ FLAT%(I):NEXT I
1660 DATA 12,15,0,0,48,48,63,63,51,51,51,63,63,3,3,0,0
1670 FOR I=0 TO 16:READ NATURAL%(I):NEXT I
1680 DATA 30,36,0,0,0,0,768,192,3840,240,15360,60,15360,60,15360,60,15360,240,3840,192
1690 DATA 3840,0,16128,0,-256,0,-3325,0,-15613,0,-15601,0,831,0,828,0,828,192,60,192
1700 DATA 60,192,3900,255,15420,-16177,12303,-16189,15,-16189,15,-16189,-16381,207,-4093,252,-256,240,0,48
1710 DATA 0,48,0,48,-1024,48,-1024,48,-256,192,0,0,0,0
1720 FOR I=0 TO 73:READ TREBLE%(I):NEXT I
1730 DATA 30,19,0,0,0,0,-253,192,783,-3856,12,-3844,-16369,60,-16369,60,-16369,-4036,0,-4036
1740 DATA 0,240,0,240,768,192,3840,0,15360,0,-4096,0,-16381,0,15,0,12,0,0,0
1750 FOR I=0 TO 39:READ BASE%(I):NEXT I
1760 DATA 48,3,240,0,-4096,63,0,-16369,-253,-1,252
1770 FOR I=0 TO 10:READ TIED%(I):NEXT I
1780 DATA 26,19,-4093,0,-1009,0,-1024,0,-1024,0,-1024,0,-1024,0,-1024,0,-1024,0,-1024,0,-1024,0,-1024,0,-1024,0,-1024,0,-1024,0,-1024,0,-1024,0,-1024,0,-241,192,-241,192
1790 FOR I=0 TO 39:READ ONE%(I):NEXT I
1800 DATA 26,19,-241,0,-193,192,828,192,828,192,768,192,768,192,3840,0,15360,0,-4096,0,-16381,0,15,0,60,0,60,0,60,0,60,0,60,0,828,192,-193,192,-193,192
1810 FOR I=0 TO 39:READ TWO%(I):NEXT I
1820 DATA 26,19,-1009,0,-193,0,3900,0,3840,0,3840,0,3840,0,3840,0,3840,0,-1009,0,-1009,0,3840,0,3840,0,3840,0,3840,0,3840,0,3840,0,3900,0,-193,0,-1009,0
1830 FOR I=0 TO 39:READ THREE%(I):NEXT I
1840 DATA 26,19,16128,0,-256,0,-256,0,-12541,0,-12541,0,3855,0,3855,0,3900,0,3900,0,-1,192,-1,192,3840,0,3840,0,3840,0,3840,0,3840,0,3840,0,3840,0,3840,0
1850 FOR I=0 TO 39:READ FOUR%(I):NEXT I
1860 DATA 26,19,-253,0,-253,0,783,192,783,192,783,192,783,192,783,192,783,192,-253,0,-253,0,783,192,783,192,783,192,783,192,783,192,783,192,783,192,-241,192,-253,0
1870 FOR I=0 TO 39:READ EIGHT%(I):NEXT I
1880 RETURN
1890 PUT(WHERE-4,NOTE*5+25),CURSOR%,>=:RETURN   'draw cursor for notes
1900 PUT(WHERE+1,NOTE*5+25),CURSOR%,>=:RETURN   'draw cursor for keys
1910 LOCATE 1,1:PRINT SPACE$(160):LOCATE 1,1:RETURN    'clear top 4 lines
1920 LOCATE 4,1:PRINT SPACE$(39):LOCATE 4,1:RETURN     'clear line 4
1930 FOR I=1 TO 1000:NEXT I:RETURN                     'time waster
1940 GOSUB 2020:GOSUB 2080:GOSUB 2120:RETURN           'draws in screen
1950 IF TIE=1 THEN PUT(WHERE-5,NOTE*5+47),TIED%        'draws ties if needed
1960 IF DOTTED=1 THEN PUT(WHERE-4,NOTE*5+25),DOT%  'draws dotted notes if needed
1970 IF SHARP=1 THEN PUT(WHERE-8,NOTE*5+32),SHARP%     'draws sharps
1980 IF FLAT=1 THEN PUT(WHERE-8,NOTE*5+32),FLAT%       'draws flats
1990 IF NATURAL=1 THEN PUT(WHERE-8,NOTE*5+32),NATURAL% 'draws naturals
2000 RETURN
2010 'DRAW CLEFS***************************************************************
2020 CLS:FOR I=50 TO 150 STEP 10:IF I<>100 THEN LINE(0,I)-STEP(319,0),2
2030 NEXT I:LINE (0,50)-(0,150):PUT(0,50),TREBLE%,OR:PUT(0,115),BASE%,OR:WHERE=10:RETURN
2040 'ADDS BARS, REDRAWS AS NECESSARY******************************************
2050 BEAT=FNCT(L):IF BEAT>=TOP/BOTTOM THEN LINE(WHERE+10,50)-STEP(0,100):BEAT=0
2060 WHERE=WHERE+14+DOTTED*4:TIE=0:DOTTED=0:SHARP=0:NATURAL=0:FLAT=0:IF WHERE>305 THEN GOSUB 1940:NEWPAGE=1:RETURN:ELSE RETURN
2070 'DRAW EXISTING KEY STRUCTURE**********************************************
2080 IF KEYS(0)=0 THEN RETURN
2090 FOR I=1 TO 7:IF KEYS(8-I)=1 THEN FOR N1=I TO 25 STEP 7:PUT(WHERE+4,N1*5+32),SHARP%,OR:NEXT N1:ELSE IF KEYS(8-I)=-1 THEN FOR N1=I TO 25 STEP 7:PUT(WHERE+4,N1*5+32),FLAT%,OR:NEXT N1
2100 NEXT I:WHERE=WHERE+10:RETURN
2110 'DRAW MEASURES************************************************************
2120 I1=0:ON TOP GOSUB 2130,2140,2150,2160,2160,2160,2160,2170:I1=20:ON BOTTOM GOSUB 2130,2140,2150,2160,2160,2160,2160,2170:WHERE=WHERE+20:RETURN
2130 FOR I=50+I1 TO 110+I1 STEP 60:PUT(WHERE+4,I),ONE%,OR:NEXT I:RETURN
2140 FOR I=50+I1 TO 110+I1 STEP 60:PUT(WHERE+4,I),TWO%,OR:NEXT I:RETURN
2150 FOR I=50+I1 TO 110+I1 STEP 60:PUT(WHERE+4,I),THREE%,OR:NEXT I:RETURN
2160 FOR I=50+I1 TO 110+I1 STEP 60:PUT(WHERE+4,I),FOUR%,OR:NEXT I:RETURN
2170 FOR I=50+I1 TO 110+I1 STEP 60:PUT(WHERE+4,I),EIGHT%,OR:NEXT I:RETURN
```
{% endraw %}

## MUSIC.DOC

{% raw %}
```
"     The MUSIC package is a"
"preliminary attempt to provide some"
"easy keyboard-access to the built-in"
"IBM PC 'PLAY' command.  The package"
"allows you to enter one 'voice' (note)"
"at a time, letting you select the"
"note on a regular music-sheet-type"
"display."
"     You may have whole, half, quarter,"
"eighth, or sixteenth notes or rests."
"They may be natural, sharp, or flat."
"You can set the key before beginning"
"as well as the measure (e.g. 4/4) as"
"well as the tempo (quarter notes per"
"second).  You can also change any of"
"these within the piece itself.  The"
"piece can be saved and recalled at any"
"time."
"     Some cautions:"
"* When you want a note to be tied,"
"  dotted, or made flat, sharp, or"
"  natural, you must indicate this by"
"  pressing the proper key before"
"  entering the note itself."
"* You must select notes that fit within"
"  the measure selected.  Since thirty-"
"  second notes are not allowed, you"
"  would be wise to avoid unpaired"
"  dotted sixteenth notes."
"* The routine plays the notes with"
"  the 'music background' option ('MB'"
"  in the PLAY command).  This was done"
"  to avoid awkward pauses while"
"  playing the tune."
"  This does, however, result in the"
"  music occasionally being played out"
"  of synch with what's being drawn."
"     Changes due in later revisions:"
"* Editing.  At the moment, once you"
"  enter a note, you're stuck with it."
"* Repeats.  You have to manually re-"
"  enter every note over again to do a"
"  repeat now."
ote, you're stuck with it."
"* Repeats.  You have to manually re-"
"  enter every note over again t
```
{% endraw %}

## PMODE.ASM

{% raw %}
```
	name	pmode
	page	55,80
	title	'PMODE - set printing mode directly from DOS
;	
;	PMODE utility to set printing modes directly from DOS for LPT1
;
;	by	Chris Lindberg
;
;	Uncopyright 1982
;
;	Command syntax is 
;
;		A>pmode [c,c,c...]
;
;			and c is one or more characters
;			in upper or lower case
;			from the following list:
;
;			I = Italics on
;			C = Compressed on
;			E = Emphasized on
;			X = Expanded on
;			D = Double strike on
;
;			Pmode without any arguments resets the printer
;			to a cold start setting.
;
;		PMODE is a simple assembly language program that sends 
;		escape sequences to the printer for the various print
;		modes available.  This version is set up for the IBM
;		equivalents of the MX-80 and MX-100.  It should work as
;		well for the MX-80, MX-100 and other Epson models.  If
;		your printer uses other escape sequences, I've provided
;		the assembler listing so that you can make the necessary
;		changes.  If you don't have an assembler, you can use
;		DEBUG to change the program.  The escape sequences used
;		in this program are:
;
;					CODES SENT
;		MODE		HEXADECIMAL		DECIMAL
;		---------	-----------           -----------
;
;		Italics on	  1b + 34		27 + 52
;		Compressed on	  1b + 50		27 + 80
;		Expanded on	  1b + 53		27 + 83
;		Emphasized on	  1b + 45		27 + 69
;		Double strike on  1b + 47		27 + 71
;
;
;	The actual code segment star4s here:
;
	input	equ	08h	;command tail line buffer address
	cr	equ	0dh	;ASCII carraige return
;
	cseg	segment	byte
		assume	cs:cseg,ds:cseg
;
		org	0100h	;since this will be a .COM file
;
	reset:	mov	al,0	;reset the printer to a cold
		mov	ah,1	;start setting
		mov	dx,0
		int	17h
;
		mov	si,offset input
		cld		;get address of command tail and...
		lodsb		;move it forward.  Check length
		or 	al,al	;of buffer.  
		jz	done 	;If zero, then we're done
;
	read:	lodsb		;get next byte of buffer
		cmp	al,cr	;Is it a CR?
		je	done	;if it is, then we're done
		or	al,20h	;otherwise, fold it to lower case
		cmp	al,'a'  ;make sure it's between 'a'
		jb	read
		cmp	al,'z'	;and 'z'
		ja	read	;otherwise, skip it.
;
		cmp	al,'i'	;Is it 'i
		jne	emph	;if it isn't, go on
		mov	al,1bh	;send escape sequence...
		call 	print	;...to printer
		mov	al,34h	;and send code for italics...
		call 	print	;.... to printer
		jmp	short read
;
	emph:	cmp	al,'e'	;is it 'e'?
		jne	double
		mov	al,1bh
		call	print
		mov	al,45h
		call	print
		jmp	short read
;
	double:	cmp	al,'d'	;is it 'd'?
		jne	compr
		mov	al,1bh
		call	print
		mov	al,47h
		call	print
		jmp	short read
;
	compr:	cmp	al,'c'	;is it a 'c'?
		jne	expan	
		mov	al,1bh
		call	print
		mov	al,50h
		call	print
		jmp	short read
;
	expan:	cmp	al,'x'	;is it a 'x'?
		jne	read	
		mov	al,1bh
		call	print
		mov	al,53h
		call	print
		jmp	sh/rt read
;
	done:	int	20h	;all done...return to DOS
;
	print	proc	near	;routine to send contents of 
		push	dx	;al to printer
		mov	dx,0
		mov	ah,0
		int	17h
		pop	dx
		ret
	print	endp
;
	cseg	ends
;
```
{% endraw %}

## PRTSCFX.ASM

{% raw %}
```
	page	60,132

	title	PrtScFX  - FX-80 monochrome graphics print screen patch

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Written by:	Michael Geary					    ;;
;;		Software Wizards				    ;;
;;		P.O. Box 1479					    ;;
;;		Los Gatos, CA 95031				    ;;
;;		(408) 354-4400					    ;;
;;								    ;;
;; This program is placed in the public domain without restriction. ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; character codes
CR	equ	13
LF	equ	10
ESC	equ	27

; interrupt numbers
PrtSc	equ	05h
video	equ	10h
keyboard equ	16h
time	equ	1Ah

; interrupt vector locations in absolute zero segment
absSeg	segment at 0
	org	PrtSc * 4
PrtScIntOffset	dw	?
PrtScIntSeg	dw	?
	org	500h
statusByte	db	?
absSeg	endS

; screen addresses & stuff
monoSeg     equ     0B000h
graphSeg    equ     0B800h
row25offset equ     24 * 160

monoBigCrs  equ     000Dh
graphBigCrs equ     0007h

monoNrmCrs  equ     0C0Dh
graphNrmCrs equ     0607h

codeSeg segment para public 'code'

	extrn	cgData:byte

theEnd	equ	offset cgData + 4096

	org	100h

printScreen	proc	far

	assume	cs:codeSeg, ds:codeSeg, ss:codeSeg, es:absSeg

	xor	ax, ax
	mov	es, ax

	mov	ax, theEnd + 512
	mov	sp, ax

	mov	ax, PrtScIntOffset
	mov	SaveIntOffset, ax
	mov	ax, PrtScIntSeg
	mov	SaveIntSeg, ax

	mov	PrtScIntOffset, offset doPrint
	push	cs
	pop	PrtScIntSeg

	mov	dx, theEnd
	int	27h


scrSeg		dw	?	; B000 or B800 screen segment
pageNo		db	?	; BIOS's page #

crsPos		dw	?	; user's cursor row & column
crsType 	dw	?	; user's cursor type (size)

bigCrs		dw	?	; our big cursor

saveInt 	label	dword	; holds the "other" PrtSc interrupt vector
SaveIntOffset	dw	?
SaveIntSeg	dw	?

paper216ths	db	?	; paper advance after pass (12/216 or 24/216 ")
dotsPerPass	db	?	; # dot rows covered in a pass (4 or 8)

lastCol 	db	?	; last nonblank char col in this print row

prompt		db	' G = text graphics dump, D = darker grap'
		db	'hics, SPACE = normal dump, Esc = cancel '

save25		dw	80 dup (?)

; PrtSc entry point

doPrint:
	assume	cs:codeSeg, ds:nothing, ss:nothing, es:nothing

	sti
	push	ds
	push	es
	push	ax
	push	bx
	push	cx
	push	dx
	push	si
	push	di
	push	bp

	xor	dx, dx
	mov	es, dx
	cmp	es:statusByte, 1	; check for PrtSc already in progress
	jne	notBusy
	  jmp	exit
notBusy:
	mov	es:statusByte, 1

	mov	ah, 15
	int	video			; get CRT mode in AL
	mov	pageNo, bh
	mov	dx, monoSeg
	mov	cx, monoBigCrs
	mov	si, monoNrmCrs
	cmp	al, 7			; must be monochrome
	je	newDump
	mov	dx, graphSeg
	xor	bl, bl
	add	dx, bx			; (current page segment)
	mov	cx, graphBigCrs
	mov	si, graphNrmCrs
	and	al, 0FEh
	cmp	al, 2			; or 80 column text mode (2 or 3)
	je	newDump
	  jmp	oldDump
newDump:
	mov	scrSeg, dx
	mov	bigCrs, cx
	mov	crsType, si

	mov	ah, 3
	int	video			; save cursor
	mov	crsPos, dx
	cmp	cx, 0067h		; avoid weird bug - incorrect cursor
	je	weirdCrs		; type of 67h
	mov	crsType, cx
weirdCrs:

	or	ch, 20h
	mov	ah, 1
	int	video			; turn cursor off

	mov	ds, scrSeg
	mov	si, row25offset
	push	cs
	pop	es
	mov	di, offset save25
	mov	cx, 80
	rep movsw			; save row 25

	push	cs
	pop	ds
	mov	si, offset prompt
	mov	es, scrSeg
	mov	di, row25offset
	mov	cx, 80
	mov	ah, 70h 		; reverse video
promptLoop:
	lodsb
	stosw				; display prompt message
	loop	promptLoop

kbdClr: mov	ah, 1			; clear keyboard buffer
	int	keyboard
	pushf
	xor	ah, ah			; and read a key
	int	keyboard
	popf
	jnz	kbdClr

	push	cs
	pop	ds
	assume	ds:codeSeg		; leave DS alone from now on
	mov	si, offset save25
	mov	es, scrSeg
	mov	di, row25offset
	mov	cx, 80
	rep	movsw			; restore row 25

	cmp	al, 27			; exit if Esc
	jne	notEsc
	  jmp	prtDone
notEsc:
	and	al, 0DFh		; convert lower case --> upper

	xor	ch, ch			; CH = char row
	xor	dh, dh			; DH = dot row
	mov	paper216ths, 24
	mov	dotsPerPass, 8
	cmp	al, 'G'
	je	doGraphics

	dec	ch			; double strike starts at char row -1
	mov	dh, 10			; dot row 10 (to do the first strike
	mov	paper216ths, 12 	; of the top 4 dot lines of row 0)
	mov	dotsPerPass, 4
	cmp	al, 'D'
	je	doGraphics

oldDump:
	call	oldCursor
	xor	dx, dx
	mov	es, dx
	mov	es:statusByte, 0
	pushf
	call	SaveInt 		; call the other dump routine
	jmp	exit

doGraphics:
	mov	al, CR
	call	prtChar 		; CR-LF to tension paper
	mov	al, LF
	call	prtChar

nextRow:				; here to begin a character row
	push	cx
	push	dx
	mov	dh, ch
	xor	dl, dl
	mov	bh, pageNo
	mov	ah, 2
	int	video			; put a big cursor on current row
	mov	cx, bigCrs
	mov	ah, 1
	int	video
	pop	dx
	pop	cx

	mov	cl, 79
chkNxtChr:				; here to check a char col for nonblank
	mov	dl, 7
chkNxtDotCol:				; here to check a dot col for nonblank
	call	getDotCol
	test	al, al
	jnz	startRow
	dec	dl
	jge	chkNxtDotCol
	dec	cl
	jge	chkNxtChr
	jmp	advPaper		; nothing at to print on this row
startRow:
	mov	lastCol, cl
	inc	cl
	mov	al, 9
	mul	cl
	mov	bx, ax			; bx = number of dot cols to print

	mov	al, ESC
	call	prtChar
	mov	al, '*'
	call	prtChar 		; set 720 dot graphics mode
	mov	al, 6
	call	prtChar
	mov	al, bl			; with the exact number of dots
	call	prtChar
	mov	al, bh
	call	prtChar

	mov	cl, 0			; CL = char col
nextChar:				; here to dump one character column
	mov	dl, 7			; DL = dot col
nextCol:				; here for each dot column
	call	getDotCol
	call	prtChar

	dec	dl
	cmp	dl, -1
	jge	nextCol

	inc	cl
	cmp	cl, lastCol
	jle	nextChar

advPaper:
	mov	al, CR
	call	prtChar
	mov	al, ESC
	call	prtChar
	mov	al, "J"
	call	prtChar
	mov	al, paper216ths
	call	prtChar

	add	dh, dotsPerPass
	cmp	dh, 14
	jge	sub14
	  jmp	nextRow
sub14:
	sub	dh, 14
	inc	ch
	cmp	ch, 25
	jge	prtDone
	  jmp	nextRow

prtDone:
	call	oldCursor
	xor	al, al
	jmp short getOut
prtErr:
	call	oldCursor
	mov	al, 0FFh
getOut:
	xor	dx, dx
	mov	es, dx
	mov	es:statusByte, al
exit:
	pop	bp
	pop	di
	pop	si
	pop	dx
	pop	cx
	pop	bx
	pop	ax
	pop	es
	pop	ds
	iRet

printScreen	endP


; Call with CH=char row, CL=char col, DH=topmost dot row, DL=dot col.
; Returns with the dot column byte for printing in AL.
getDotCol   proc    near

	push	bx
	xor	bx, bx			; BH=dot row offset, BL=dot accumulator
nextDot:				; here for each dot vertically
	push	dx
	add	dh, bh
	call	getDot
	pop	dx

	shl	bl, 1
	or	bl, al
	inc	bh
	cmp	bh, 8
	jl	nextDot

	mov	al, bl
	pop	bx
	ret

getDotCol   endP


; Call with CH=char row, CL=char col, DH=dot row, DL=dot col.
; Returns with the dot in AL bit 0.
getDot	proc	near

	push	bx
	push	cx
	push	dx

	cmp	dh, 14			; are we really in next char row?
	jl	gd1
	inc	ch			; yes, adjust char and dot rows
	sub	dh, 14
gd1:
	xor	al, al
	or	ch, ch
	jl	gdRet
	cmp	ch, 25
	jge	gdRet			; return 0 if outside screen bounds

	call	getCA			; AH = attr, AL = char

	or	dl, dl			; special check for dot col "-1"
	jge	gd2
	cmp	al, 192
	jl	gd3
	cmp	al, 223
	jle	gd4
gd3:	xor	al, al			; col -1 not in 192..223 is 0
	jmp	gd5
gd4:	xor	dl, dl			; col -1 in 192..223 duplicates col 0
gd2:
	mov	bl, al
	xor	bh, bh
	shl	bx, 1
	shl	bx, 1
	shl	bx, 1
	push	dx
	mov	dl, dh
	xor	dh, dh
	add	bx, dx			; BX = (chr*8) + dotRow
	pop	dx

	cmp	dh, 8
	jl	gd6
	add	bx, 2040		; dot rows 8-13 are higher in ROM
gd6:
	mov	al, cgData[bx]		; get the character data
	mov	cl, dl
	shr	al, cl			; shift dot into position
	and	al, 1
gd5:
	and	ah, 77h
	cmp	ah, 70h 		; check for reverse video
	jne	gdRet
	xor	al, 1			; yes, toggle the dot
gdRet:
	pop	dx
	pop	cx
	pop	bx
	ret

getDot	endP


; Call with CH=row, CL=col.  Returns with AH=attribute, AL=character.
getCA	proc	near

	push	bx
	push	cx

	mov	al, 80
	imul	ch
	xor	ch, ch
	add	ax, cx
	shl	ax, 1
	mov	bx, ax
	mov	ax, scrSeg
	mov	es, ax
	mov	ax, es:[bx]

	pop	cx
	pop	bx
	ret

getCA	endP


;prints the character in AL
prtChar proc	near

	push	dx
	xor	dx, dx
	xor	ah, ah
	int	17h
	pop	dx
	test	ah, 25h
	jz	prtRet
	pop	dx		; get rid of our return address
	jmp	prtErr

prtRet: ret

prtChar endP


; restores user's cursor
oldCursor   proc    near

	push	cs
	pop	ds

	mov	bh, pageNo
	mov	dx, crsPos
	mov	ah, 2
	int	video			; restore cursor position

	mov	cx, crsType
	mov	ah, 1
	int	video			; and type

	ret

oldCursor   endP

codeSeg endS

	end	printScreen
```
{% endraw %}

## UNDOC.DOC

{% raw %}
```
	 D O S   A N D    M S D O S    P R O B L E M S

	This is a list of PCDOS and MSDOS peculiarities,
etc. You will have to guess from the text what the
particular questions were, but you systems programmers will
find it worth your while to rummage through it all.

........................................

There is a problem of compatibility between MS-DOS and IBM
PC-DOS having to do with FCB Open and Create which has
finally been tracked.

The IBM 1.0, 1.1, and 2.0 documentation of OPEN (call 0FH)
contains the following statement.

        "The current block field (FCB bytes C-D) is
         set to zero [when an FCB is opened]."

This statement is NOT true of MS-DOS 1.25 or MS-DOS 2.00.
The difference is intentional, and the reason is CP/M 1.4
compatibility. Zeroing that field is not CP/M compatible.
Some CP/M programs will not run when machine translated if
that field is zeroed. The reason it is zeroed in the IBM
versions is that IBM specifically requested that it be
zeroed. 

This is the reason for the complaints from some vendors
about the fact that IBM MultiPlan will not run under MS-DOS.
It is probably the reason that some other IBM programs don't
run under MS-DOS.


PROGRAMMERS NOTE:
        Do what all MS/PC-DOS  Systems programs do: Set
every single FCB field you want to use regardless of what        
the documentation says is initialized.

........................................

    a)  It seems there is a maximum of 19 handles, no matter
what the files parameter is set to.  Is this really the
case?  What does one gain by setting files to less than 19? 
Is memory for handles allocated dynamically?

	There is a maximum of 20 handles per process no
matter what the files parameter is set to. There has to be a
table in your process header for your handles, there is a
limited amount of space down there. 40 bytes or so are taken
up by each system FCB, setting files to less than 20 saves a
little bit of memory. Memory for handles is not allocated
dynamically, in general an attempt to do so would fail
anyway. Recall that .COM files and most .EXE files are given
the biggest piece of memory possible when they are EXECed
because the DOS cannot make assumptions about how much
memory these programs really use. This means they typically
get ALL of the free memory, that means there is no free
memory to allocate dynamically. You will find that almost
all operating systems (CP/M is about the only exception)
have a limit on the number of open files. MS-DOS has a limit
of 20. CP/M has no such limits because it requires the user
to keep FCBs in his own address space, managing FCBs is a
pain. You get simplicity and you give up very little. What
program needs more than 20 open files? If you can think of
one, it is probably a poorly written program in that it
probably only needs a few open files at a time and doesn't
bother to close files after it's done with them.

    b)  Execing a program eats 5 (I think) handles per try. 
Is this the passing of parent's environment that is
mentioned (very briefly) in the documentatio n?  What are
these handles?  They don't seem to be allocated with system
calls,  either.  Is that true? 
 
   std-in, std-out, std-err, std-aux, std-prn. I suppose you
would like your program to be able to use the 1-12 system
calls? That means there have to be 5, the first three are
standard UNIX style fair and are required for the software
tools approach to programming. Std-aux and Std-prn are
required for system calls 3,4, and 5. Just because you are
handed these default handles doesn't mean you can't close
them.

........................................


    "...  1) what exactly is meant by the dos being in an    
unstable state.  (This is what the documentation says    
happens if one returns to a user program directly from    
an int 24 handler.)..." 

It means that the DOS has the notion of an error being in
effect. All printer echoing is turned off, and some other
stuff doesn't work. Also, there are dirty buffers that are
not correctly flushed out.  Thus the disks may not be
consistent.

    "...  2) my experimentation shows that an abort from    
a hard error handler causes an int 22 without the value    
for int 22 being sucked out of the program header.  every    
other way out of a program uses the terminate address in the
header.  is this difference intentional?  Why? DOes one
expect the value at int 22 to be different from the value in
the header ever?..."

False.  No INT 22h is ever issued.  The header is only used
to save the previous process' vectors.  The address
contained in INT 22 is saved in a temp spot, the contents of
INTs 22-24 are restored from the header, and then an
indirect jump is taken through the temp location.  Certain
programs (such as COMMAND) may want to intercept themselves
from terminating.

Consider this case:  You create a file on a write-protected
drive.  The system will read in a directory sector and
modify it.  It will then attempt to write it out, causing a
write-protect error.  If you catch the INT 24 and do not
return, the dirty buffer still exists. To clear out the
dirty buffer, you MUST return from the INT 24 saying to
abort the process.  You can then catch the terminate and
restore your stack (you will be running on your parent's
stack). 

........................................


    "...  1) Why does PCDOS exec function 3 (overlay) demand
that there be some free memory that it can allocate...."

It doesn't. IBM specifically requested that the Exec code be
overlayable in the MSDOS.  As a result, it lives in the
transient piece of COMMAND.COM and gets loaded when needed: 
thus the requidement for enough free space to laod the Exec
loader (about 1.5K).

Under other MSDOS's there is no such problem as the Exec
system call lives in system space.  A general rule of thumb
is: if you are not going to use some space, free it.  You
can do this either via SetBlock system call, or by twiddling
the EXE file header. You should avoid .COM format files.


    "...  what happens if I try to overlay an .EXE file with
the high/low switch set to load the thing for high
memory..." 

Nothing.  The HIGH/LOW switch is only for process creation,
not for overlays.

    "...  Are all these answeres the same for MSDOS?..."

Yes.

........................................

    "... zeroing of the current record field ..."

That incompatability existed between 1.1 PC-DOS and 1.25
MSDOS.  2.0 versions of both function identically (like 1.1
PC-DOS).

........................................


The Shell command on PC-DOS 2.0 works just fine.

	CONFIG.SYS
		shell = b:\command.com b:\ /P

Putting a disk with command.com in drive B: when the system
boots causes COMMAND to be read from drive B: and the
COMSPEC in  the environment is "B:\COMMAND.COM". If you are
having trouble it's because you are doing something wrong.
Recall that your given COMSPEC is checked, if you give it a
bad one it will try to go back to the default which is the
root directory on the default drive. Recall also that this
is an undocumented 2.0 feature so even if it doesn't work
nobody is going to be all that hot to do something about it.

........................................

 My error on the shell stuff, IBM hid it real well. The
"b:\" is also documented on page 10-9 (the [d:][path] part).
They did an equally poor job here.

The /P and the path spec have absolutely nothing to do with
the SHELL command, they are arguments to command. Expecting
SHELL to know stuff particular to command is not reasonable
because you are not restricted to running command as your
top level shell. You can run DEBUG as your top level shell
by saying

        SHELL = debug.com

But watch out!! debug is not designed to run as a top level
shell. if you ever say "q" to this debug the system will
crash. Command on the other hand is smart enough to run as a
top level shell. If you give the /P switch to it Command
does some special things to insure that typing EXIT to it
will not cause the system to crash as with debug. There is
absolutely no way for command to assume the /P switch
because he must run as a top level shell, and as a utility.
The smart user has to tell him what to do. Similarly the
"b:\" tells command where to look for himself. For instance:

        SHELL = A:\BIN\COMMAND.COM D:\COMMAND\BIN /P

The "A:\BIN\COMMAND.COM" tells SYSINIT where to load the
initial command.com, the "D:\COMMAND\BIN" tells command
where to look for himself when he needs to locate his
transient. As you can see they are not restricted to being
the same things. I suggest you foreward any complaints about
the manual to 

........................................

 The volume ID attribute is very special, and is treated
differently from all the other attributes. It is very
"sticky", in order to find one you must look for it and it
alone. And when you do look for it, you find only it and
nothing else.

The volume ID is constrained to be in the ROOT directory,
and there can be only one file in the ROOT with the
attribute. The FCB flavor calls have special code to enforce
these rules.

The new calls were supposed to enforce the same rules, but
they are not working correctly, and unexpected results are
possible. You should use the old FCB calls to diddle with
volume ID for the moment.

........................................

Thanks for the info.  The causes of your problems are:

(a) ^Z on output to a device in cooked mode will terminate    
the output.  This is for CPM-compatability:  you don't want
stuff after the ^Z output to your printer for example. 

    As a result COMMAND.COM issues a write to stdout and    
then checks to see if the number written is equal to the    
number requested.  If they are not the same, then a
redirection error is assumed.  ECHO ^Z is supposed to    
output a single character.  It outputs NO characters and    
thus the strange message.

    Programs that use old function calls, get redirected,    
and then read more than is expected will behave    
bizarrely: how do you indicate EOF on a read-byte-from-    
console system call?  I believe that it returns ^Z. Most of
these programs were never expecting to get redirected and
thus, the failure to handle the boundary conditions
properly. 

(b) The main crock about CP/M is that the extention on a    
file name determined the type of the file.  This is    
bogus: a file should be distinguished by its contents,    
not by its name.  When you are loading a file with the    
name *.EXE, it does NOT assume that it is an EXE format    
file.  It looks at the first two bytes for a signature    
telling it that it is an EXE file.  If it has the proper    
signature, then the load proceeds. otherwise, it    
presumes the file to be a COM-format file.

    If the file has the EXE signature, then the internal    
consistency IS checked.

    Pre-2.0 versions of MSDOS did not check the signature    
byte for EXE files.
```
{% endraw %}

{% comment %}samples_end{% endcomment %}

### Directory of PC-SIG Library Disk #0108

     Volume in drive A has no label
     Directory of A:\

    BASTODOS BAS     46592  12-05-83   1:22a
    BATMENU  COM       384  12-26-83   2:26a
    BATMENU  DOC      3200  12-26-83   2:27a
    CRC      TXT      1499  11-09-84   2:17p
    DEPRE___ APL     11264  12-11-83   1:46a
    DISKTYPE DOC       512  12-25-83   3:51a
    DISKTYPE EXE      1408  12-25-83   3:51a
    FORECAST APL     12672  12-11-83   1:49a
    MATH____ APL      6912  11-27-83   3:45a
    MUSIC    BAS     14464  12-25-83   2:40a
    MUSIC    DOC      1664  12-25-83   2:41a
    NOECHO   DOC       512  12-25-83   3:49a
    PEPATCHS DOC     14976  12-03-83  11:54p
    PMODE    ASM      3200  12-25-83   3:50a
    PMODE    COM       384  12-25-83   3:50a
    PRTSCFX  ASM      8576  12-05-83   1:05a
    PRTSCFX  COM      4096  12-05-83   1:55a
    PRTSCFX  DOC      2944  12-05-83   1:06a
    READ     ME       1301  12-26-83   4:22a
    UNDOC    DOC     11212  12-25-83   5:10a
    UTILITY_ APL      8832  11-27-83   3:44a
           21 file(s)     156604 bytes
                               0 bytes free
