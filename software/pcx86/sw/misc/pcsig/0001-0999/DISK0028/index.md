---
layout: page
title: "PC-SIG Library Disk #28"
permalink: /software/pcx86/sw/misc/pcsig/0001-0999/DISK0028/
machines:
  - id: ibm5150
    type: pcx86
    config: /machines/pcx86/ibm/5150/cga/256kb/machine.xml
    diskettes: /machines/pcx86/diskettes.json,/disks/pcsigdisks/pcx86/diskettes.json
    autoGen: true
    autoMount:
      B: "PC-SIG Library Disk 0028"
    autoType: $date\r$time\rB:\rDIR\r
---

{% include machine.html id="ibm5150" %}

{% comment %}info_begin{% endcomment %}

## Information about "DISKMODF"

    A variety of BASIC and DOS tools, directory listers, machine
    tutorials, graphics and games.  Utilities are included to let you
    design your own graphics characters, generate a resident COMMAND.COM,
    or generate a large block font set from BASIC.  Some amusing games are
    here as well.  DOS utilities include directory handlers, diskette
    speed-up, one to confirm files when doing wildcard deletes, a function
    to give status info on all drives, and others.
    
    System Requirements: Programs marked "+" require color
    graphics.
    
    How to Start: To run an EXE or COM program simply type its name and
    press <ENTER>.  For instructions on running BASIC programs, please
    refer to the GETTING STARTED section in this catalog.  To read DOC
    files simply enter TYPE filename.ext and press <ENTER>.
    
    File Descriptions:
    
    BIGTYPE  BAS  Displays character set in large block font
    DISKMODF BAS  Improved version of disk sector modifier program
    DDATE    COM  Allows quick updating of date and time on bootup
    PALLETTE BAS  Displays colors available in low-res (160x200) graphics
    JUMBLE   BAS  Permutes jumbled words
    LF       COM  Directory lister sorted by extension & filename
    HALS     DOC  Doc on above files
    TIMING   BAS  Accurately times the execution of short BASIC programs
    SPEED411 COM  Sets disk step rate to 4 ms - test with format and copy
    VDEL     COM  Provides for OK's when doing wildcard deletes
    CD       COM  Sets default drive, file information, & sorts directory
    WAIT     COM  Batch file PAUSE for three seconds
    GUMUP1   DOC  Doc on LF, VDEL, CD, WAIT
    SYSTAT   DOC  Documentation on SYSTAT.COM
    SYSTAT   COM  Status report on all drives
    FK       COM  Function key handler (with reset) for DOS 1.0 & 1.1
    FK       DOC  Documentation on FK.COM
    SD       COM  Directory lister, 4 up
    UNPROT2  TXT  Ultra simple technique for unprotecting BASIC programs
    SDIR     EXE  Directory lister, 2 up - upgrade of SDIR.COM on Disk #2
    ARTILL   BAS  Artillery for 2, random terrain & winds - Quite good
    GRAFGE   BAS  Uses graphic screen to develop your own upper ASCII set
    RESCMDCK BAS  Resident COMMAND.COM with BEEP, PAGE, CLS
    RESCMD   DOC  Documentation on resident COMMAND.COM
    CPCPRO   DOC  Tutorials -BASIC PrtSc, Printer bit graphics, Keyloc
    RESCMD   BAS  Generates resident COMMAND.COM
    GSDUMP   BAS  Graphics Sideways memory DUMP (C.Itoh 8510 or NEC8023)
    COLOUR   DOC  Tutorial + small routines re: Artifacting, high-res
    SQUISH   EXE  Compresses BASIC programs, removes REM's, etc
    SQUISH   SRC  Upgrade of SQUISH on Disk No 9, modified for compiler
    MEMPEEK  BAS  Similiar to disk modify programs except for RAM memory
    GRAFGE   DOC  Documentation for GRAFGE.BAS
    SQUISH   DOC  Documentation on SQUISH
{% comment %}info_end{% endcomment %}

{% comment %}samples_begin{% endcomment %}

## ARTILL.BAS

```bas
1 ' THE PORTLAND IBM PERSONAL COMPUTER CLUB
2 ' ARTILL.BAS
3 ' Submitted by Joe Lipska,  July 1982
4 '
30 DEF SEG=0
40 IF (PEEK(&H410) AND &H30)<>&H30 THEN DEF SEG:GOTO 110
50 WIDTH 80:CLS:LOCATE 3,1
60 PRINT "HOLD IT!"
70 PRINT "YOU'RE NOT USING THE COLOR/GRAPHICS MONITOR ADAPTER!"
80 PRINT "THIS PROGRAM USES GRAPHICS AND REQUIRES THAT ADAPTER."
90 PRINT "SORRY,BUT THIS PROGRAM WILL NOT CONTINUE."
100 END
110 TIM$=RIGHT$(TIME$,2)
120 RIM=ASC(RIGHT$(TIM$,1))
130 RIM=RIM+ASC(LEFT$(TIM$,1))
140 RANDOMIZE(RIM)
150 DEF SEG=0:POKE &H417,96
160 DEG=.017745329#
170 KEY OFF:CLS:WIDTH 40
180 INPUT "A 0=MONOCROME  1=COLOR";A
190 CLS
200 PRINT  "              ARTILLARY"
210 PRINT " To shoot shells input ANGLE,VELOCITY "
220 PRINT " an example is  70,100"
230 PRINT
240 PRINT " Wind can vary both in direction and in"
250 PRINT " strength if you choose this option"
260 PRINT
270 PRINT " Each gun company starts with 100 men."
280 PRINT " After each shot there is a deserter"
290 PRINT " on each side.  Near misses can cause"
300 PRINT " casualties, dependent on distance and"
310 PRINT " # of men remaining. A near miss which"
320 PRINT " would bring a gun company to less than"
330 PRINT " 10 men is treated as a direct hit. A"
340 PRINT " running total of base strength is"
350 PRINT " maintained between battles for each "
360 PRINT " side. Misses leaves craters; therefore"
370 PRINT " shots can be used to lower a large"
380 PRINT " mountain!"
390 PRINT " If desertion brings your gun company"
400 PRINT " to less than 5 men, your gun misfires"
410 INPUT " (PRESS RETURN TO CONTINUE)";ZZZ$: CLS
420 PRINT
430 INPUT "TYPE Y IF YOU WANT VARYING WIND";Q$:Q$=LEFT$(Q$,1)
440  Q1=0
450 SCREEN 1:COLOR A,1
460  IF Q$<>"Y" THEN 500
470 Q1=1
480 PRINT "LEVEL OF DIFFICULTY":INPUT"     1=EASY,20=DIFFICULT";LEVEL
490 IF LEVEL <1 OR LEVEL>20 THEN 480
500 DIM H(320),A1(2),A2(2), B1(4),B2(4),L(2),T1(2),M1(2)
510 DIM E1(2),V1(2),WINDOW(18)
520 N=1.5+-1^ INT(100*RND(1))*.5
530 CLS
540 LINE (0,0)-(14,14),3,B
550 PAINT (1,1),3,3
560 GET (1,1)-(13,13),WINDOW
570 PLAY "MBO2T230L3CL5MSFP8FL4ACL2FL4CL5MSFAL4O3CO2AP14FP14L1C"
580 CLS
590 PLAY "MBP6L3CL4MSFFFFP4L3CL4MSFFFF"
600 PLAY "MBT230P3O3L3CO2L2AL4FL3CCL1F"
610 RESTORE
620 DATA -1,1,1,-1,-1,-1,1,1
630 T1(1)=0
640 T1(2)=0
650 M1(1)=101
660 M1(2)=101
670 A1(1)=2
680 A1(2)=2
690 A2(1)=4
700 A2(2)=27
710 FOR L=1 TO 4
720 READ B1(L)
730 NEXT L
740 FOR L=1 TO 4
750 READ B2(L)
760 NEXT L
770 E1(1)=0
780 E1(2)=0
790 V1(1)=0
800 V1(2)=0
810 N2=0
820 E3=0
830 V3=0
840 REM ESTABLISH BASE LOCATIONS
850 X1=INT(53+RND(1)*60)
860 X2=INT(198+RND(1)*60)
870 L(1)=INT(20+(X1-20)*RND(1))
880 L(2)=INT(X2+(300-X2)*RND(1))
890 REM ESTABLISH LEFT & RIGHT ELEVATIONS
900 HGT1=RND(1)*98+2
910 HGT2=RND(1)*98+2
920 IF HGT1<>HGT2 THEN 960
930 HGT1=15
940 HGT2=15
950 GOTO 1020
960 IF HGT1>HGT2 THEN 1000
970 HGT2=15+(HGT2-HGT1)
980 HGT1=15
990 GOTO 1020
1000 HGT1=15+(HGT1-HGT2)
1010 HGT2=15
1020 FOR I=1 TO X1
1030 H(I)=HGT1
1040 NEXT I
1050 H9=RND(1)*98+2
1060 FOR I=X2 TO 320
1070 H(I)=HGT2
1080 NEXT I
1090 REM PEAK ELEVATION
1100 X3=X1+INT(RND(1)*(X2-X1-20))+10
1110 H(X3)=RND(1)*90+50
1120 TOP=X3
1130 REM SLOPE OF FLAT LAND TO PEAK
1140 D1=(H(X3)-H(1))/2
1150 D2=(H(X3)-H(320))/2
1160 IF D1*D2<0 THEN 1360
1170 REM DRAW CURVE TO PEAK
1180 J=-180
1190 K=180/(X3-X1+1)
1200 H9=H(1)+D1
1210 FOR I=X1+1 TO X3-1
1220 J=J+K
1230 H(I)=H9+COS(J*DEG)*D1
1240 NEXT I
1250 J=0
1260 K=180/(X2-X3+1)
1270 H9=H(320)+D2
1280 REM DRAW CURVE FROM PEAK
1290 FOR I=X3+1 TO X2-1
1300 J=J+K
1310 IF I=321 THEN 1340
1320 H(I)=H9+COS(J*DEG)*D2
1330 NEXT I
1340 GOTO 1440
1350 REM DRAW CURVE FROM LEFT TO RIGHT
1360 D=(H(1)-H(320))/2
1370 J=0
1380 K=180/(X2-X1+1)
1390 H9=H(320)+D
1400 FOR I=X1+1 TO X2-1
1410 J=J+K
1420 H(I)=H9+COS(J*DEG)*D
1430 NEXT I
1440 REM DRAW TERAIN
1450 CLS
1460 LINE (X2,(200-H(X2)))-(319,(200-H(X2))),1
1470 LINE (0,(200-H(1)))-(X1,(200-H(X1))),1
1480 FOR I=X1 TO X2
1490 LINE -(I,(200-H(I))),1
1500 NEXT I
1510 PAINT (100,199),1
1520 REM DETERMINE WIND
1530 WIND=100*RND(1)-50
1540 W=((LEVEL*2)*RND(1))-LEVEL+WIND
1550 W=INT(W)
1560 IF W<1 THEN ARROW=27 ELSE ARROW=26
1570 IF W=0 THEN 1540
1580 N=3-N
1590 M1(N)=M1(N)-1
1600 M1(3-N)=M1(3-N)-1
1610 REM DRAW BASES
1620 XX=L(1)
1630 YY=200-H(L(1))
1640 LINE (XX-2,YY-2)-(XX+2,YY+2),,BF
1650 XX=L(2)
1660 YY=200-H(L(2))
1670 LINE (XX-2,YY-2)-(XX+2,YY+2),,BF
1680 REM PRINT TITLES
1690 LOCATE 1,2
1700 PRINT "ANGLE,SPEED MEN"
1710 LOCATE 1,25
1720 PRINT "ANGLE,SPEED MEN"
1730 LOCATE 2,14:PRINT USING "###";M1(1)
1740 LOCATE 2,37:PRINT USING "###";M1(2)
1750 LOCATE 1,19
1760 PRINT "Wind"
1770 LOCATE 2,18
1780 PRINT USING "##";ABS(W):LOCATE 2,21:PRINT "mph";
1790 LOCATE 3,12
1800 PRINT "              "
1810 LOCATE 3,20
1820 PRINT CHR$(ARROW)
1830 LOCATE A1(N),A2(N)
1840 PRINT USING "###";E1(N);
1850 PRINT ",";:PRINT USING "###";V1(N)
1860 LOCATE A1(N)+1,A2(N)-1
1870 PRINT "           "
1880 LOCATE A1(N)+1,A2(N)-1
1890 INPUT E$,V$
1900 E=VAL(E$):V=VAL(V$)
1910 IF E=0 OR V=0 THEN 1860
1920 E1(N)=E:V1(N)=V
1930 V=V/10
1940 IF M1(N)>5 THEN 1980
1950 E=90
1960 V=0
1970 W=1
1980 REM
1990 E=90-E
2000 C=1
2010 IF N=1 THEN 2040
2020 E=-E
2030 E3=-E3
2040 X1=L(N)
2050 Y1=H(L(N))
2060 T=0
2070 V1=SIN(E*DEG)*V
2080 V2=COS(E*DEG)*V
2090 T=T+.3
2100 IF T=.3 THEN 2120
2110 PRESET (X,200-Y)
2120 V1=V1+(V1+W)/1500
2130 X=X1+(V1+W/50)*T
2140 IF X<1 OR X>320 THEN 2670
2150 REM account for gravity and accelerarion
2160 Y=Y1+(V2-T/2.5)*T
2170 PSET (X,200-Y)
2180 IF Y-H(X)=>1 THEN 2090
2190 PRESET (X,200-Y)
2200 IF ABS(X-L(N))<1 AND T>.5 THEN 2710
2210 IF ABS (X-L(3-N))<1 THEN 2690
2220 IF T<.5 THEN 2090
2230 REM miss
2240 IF X<6 THEN 2570
2250 IF X>314 THEN 2570
2260 SOUND 179,3
2270 LINE (X-3,(200-H(X-3)))-(X-2,(200-H(X-2))),0
2280 FOR L=X-2 TO X+3
2290 LINE -(L,(200-H(L))),0
2300 NEXT L
2310 TMY=195-Y
2320 IF TMY>186 THEN 2570
2330 REM CHANGE LANDSCAPE
2340 PUT (X-6,TMY),WINDOW,PRESET
2350 TMPX=X-6:TMPY=205-Y
2360 H(X-3)=H(X-3)-1
2370 H(X-2)=H(X-2)-2
2380 H(X-1)=H(X-1)-3.5
2390 H(X)=H(X)-4
2400 H(X+1)=H(X+1)-3.5
2410 H(X+2)=H(X+2)-2
2420 H(X+3)=H(X+3)-1
2430 MIN=X-12
2440 MAX=X+12
2450 IF MIN<1 THEN MIN=1
2460 IF MAX>320 THEN MAX=320
2470 LINE (MIN,(200-H(MIN)))-(MIN+1,(200-H(MIN+1))),1
2480 FOR L=MIN+1 TO MAX
2490 LINE -(L,(200-H(L))),1
2500 NEXT L
2510 FOR PNTX=X-2 TO X+2
2520 PNTY=205-H(PNTX)
2530 IF PNTY>199 THEN PNTY=199
2540 PAINT (PNTX,PNTY),1,1
2550 PAINT (PNTX,201-H(PNTX)),1,1
2560 NEXT PNTX
2570 IF ABS(X-L(3-N))>8 THEN 2670
2580 REM near miss
2590 D9=2*ABS(X-L(3-N))
2600 D9=INT(M1(3-N)/D9)
2610 M1(3-N)=M1(3-N)-D9
2620 T1(3-N)=T1(3-N)+D9
2630 N2=1
2640 IF M1(3-N)<10 THEN 2690
2650 N2=0
2660 SOUND 179,5
2670 IF Q1=1 THEN 1540 ELSE 1580
2680 REM hit and explotion
2690 N=3-N
2700 PLAY "MBO1L16FP16FP16F"
2710 PSET (X,200-Y),2
2720 DRAW "H15E2F2E2F2E2F2E2F2E2F2E2F2E2F2E2F2G16C2"
2730 PAINT (X,199-Y),2,2
2740 LOCATE 1,1
2750 PRINT "                                       "
2760 PRINT "                                       "
2770 PRINT "                                      "
2780 LOCATE 1,1
2790 T1(N)=T1(N)+M1(N)
2800 PRINT  " CASUALTIES   left=" ;T1(1);" right=";T1(2)
2810 IF N2=1 THEN 2830
2820 N=3-N
2830 LOCATE 2,1
2840 PRINT " AGAIN?";
2850 INPUT A$:A$=LEFT$(A$,1)
2860 IF A$="N" THEN 2880
2870 PRINT "PLEASE WAIT 5 SECONDS":GOTO 610
2880 END
```

## BIGTYPE.BAS

```bas
9 'BIGTYPE  18 DEC 82  Hal Sampson
10 'add: roam thru larger screen
20 ' print screen translation to Epson, multiple character sets
30 ' scrolling
40 ' cursor off during screen print
50 ' absorb auto repeat when type too fast?
1000 REM Program to display dot matrix characters from ROM patterns
1010 REM Will Fastie -- 19 Nov 81     Creative Computing  March 1982
1020 REM Entered by Patrick Leabo    Tuscon
1030 DEFINT A-Z
1035 DIM B$(256),C$(256)
1040 DOTCHAR = 219
1065 CUR$=STRING$(7,DOTCHAR)
1070 GOSUB 1410
1072 KEY OFF
1075 DEF SEG:POKE 106,0   'FOR USE OF RUN SOFT KEY
1080 DEF SEG=&HF000
1090 BASEADR=&HFA6E
1100 BYTESPERCHAR=8
1115 FOR I=0 TO 15:M=1:D$="":FOR B=1 TO 4:D$=CHR$((I AND M)>0 AND DOTCHAR OR 32 AND (I AND M)=0)+D$:M=M+M:NEXT B:C$(I)=D$:C$(I16)=D$:I16=I16+16:NEXT I
1122 FOR I=0 TO 255:B$(I)=C$(I AND &HF0)+C$(I AND &HF):NEXT I
1130 CLS:LOCATE ,,0
1140 FOR X=1 TO 19 STEP 9
1150 FOR Y=1 TO 73 STEP 8
1160 RM=7+(X=19):CM=8+(X=19 AND Y=73)
1162 CHAR$=INKEY$:IF CHAR$<>"" THEN 1180
1165 LOCATE X+6,Y:PRINT CUR$;:FOR R=RM TO 0 STEP -1:LOCATE X+R,Y:PRINT LEFT$(   "        ",CM);:NEXT R
1170 CHAR$=INKEY$: IF CHAR$="" THEN 1165
1180 CODE =ASC(CHAR$):IF CODE=0 THEN CODE=ASC(RIGHT$(CHAR$,1))+300
1190 IF (CODE = 8 OR CODE=375) AND Y>8 THEN Y=Y-8:GOTO 1160
1195 IF CODE = 372 AND X>9  THEN X=X-9:GOTO 1160
1197 IF CODE = 377 AND Y<66 THEN Y=Y+8:GOTO 1160
1198 IF CODE = 380 AND X<19 THEN X=X+9:GOTO 1160
1199 IF CODE>=300 OR CODE =8 THEN 1160
1200 ADR = BASEADR + (CODE*BYTESPERCHAR)
1260 FOR ROW=0 TO RM:LOCATE X+ROW,Y:PRINT LEFT$(B$(PEEK(ADR+ROW)),CM);:NEXT ROW
1265 NEXT Y:NEXT X
1270 GOTO 1140
1410 REM Initialize display
1420 SCREEN 0:SCREENWIDTH=80
1430 RETURN
```

## DISKMODF.BAS

```bas
100 'diskmodf v1.2
110 GOTO 280
140 '
150 ' The following are the slow subroutines which might be converted to ASM
160 COLOR 7,0
170 BM24=BYTE MOD 24:LOCATE BYTE\24+2,BM24*2+1:PRINT HX$(CHAR);:LOCATE ,BM24+51:PRINT AS$(CHAR);:RETURN
180 LOCATE 24,21:PRINT Z;"  ";:RETURN
190 LOCATE 1,42:PRINT BYTE:CHAR=PEEK(BUF+BYTE):LOCATE 24,35:PRINT CHAR;" ";:RETURN
280 CLEAR ,&H4B00:KEY OFF
300 DEFINT A-Z
390 DATA &h55
400 DATA &h8b,&hec
420 DATA &hbb,&h00
430 DATA &h4c,&h8b,&h76,&h06,&h8b
440 DATA &h0c,&h8b,&h76,&h08,&h8b
445 DATA &h14,&h8b,&h76,&h0a,&h8b,&h04,&h8a,&he0,&hb0,&h01
450 DATA &hcd,&h13,&h8a,&hc4,&hb4,&h00,&h89,&h04,&h5d
460 DATA &hca,&h06,&h00
500 INT13=&H4B00:FOR I=INT13 TO INT13+36:READ J:POKE I,J:NEXT I
505 BUF=&H4C00
512 DATA &h8b,&hdc,&hb4,&h08,&hcd,&h21,&h84,&hc0,&h74,&hf8,&h32,&he4,&h8b,&h5f,&h04,&h89,&h07,&hca,&h02,&h00
514 IN=&H4B80:FOR I=IN TO IN+19:READ J:POKE I,J:NEXT I
515 CLS:COLOR 7,0:LOCATE 12,13
517 PRINT "DiskModf V1.2 - Disk sector viewing and modification"
518 LOCATE 15,7:PRINT "Improved by Hal Sampson from original program by John Vandegrift"
520 DIM HX$(255):DIM AS$(255)
530 FOR I=0 TO 255:HX$(I)=RIGHT$("0"+HEX$(I),2):AS$(I)=CHR$(I):NEXT I
540 FOR I=7 TO 13:AS$(I)=CHR$(I+64):NEXT I
550 AS$(28)="\":AS$(29)="]":AS$(30)=CHR$(24):AS$(31)=CHR$(25)
560 NOTREAD=1
570 GOSUB 910
650 CLS:LOCATE 2,37:PRINT"DiskModf"
660 IF NOTREAD THEN LOCATE 23,30:PRINT "Sector not declared!!":GOTO 690
670 LOCATE 23,30:IF NOSIDES=1 THEN PRINT "Single-sided diskette":GOTO 690
680 PRINT "Double-sided diskette"
690 LOCATE 10,30:PRINT "(S)elect diskette sector"
700 LOCATE 11,30:PRINT "(V)iew/alter sector"
710 LOCATE 12,30:PRINT "(W)rite sector back to diskette"
730 LOCATE 13,30:PRINT"(Q)uit"
740 LOCATE 16,30:PRINT "Choice?";
745 CALL IN(I):I=I AND &H5F
747 IF I=83 THEN GOSUB 910
748 IF I=86 THEN GOSUB 1210
749 IF I=87 THEN GOSUB 790
750 IF I=81 THEN STOP
770 GOTO 650
790 REM         Put Sector on diskette
860 IF NOTREAD THEN RETURN
865 PRINT:PRINT:PRINT "Are you sure you want to alter disk? [N]";
868 CALL IN(I): IF (I AND &H5F) <>89  THEN RETURN
870 OP=3
880 CALL INT13 (OP,HDDR,TRSC)
885 IF OP<>0 THEN PRINT " retry";:OP=0:CALL INT13(OP,HDDR,TRSC):GOTO 870
890 RETURN
910 '
960 CLS:LOCATE 2,37:PRINT"DiskModf"
970 LOCATE 10,10:INPUT "Select drive (A-D)";DRIVE$
975 IF DRIVE$="" THEN 970
980 DRIVE=(ASC(DRIVE$) AND &H5F)-&H41
1000 IF DRIVE <0 OR DRIVE >3 THEN 970
1010 HDDR=256+DRIVE:TRSC=1:TRIES=3:NOTREAD=1
1020 OP=2:CALL INT13 (OP,HDDR,TRSC) 'check for single/double sided
1040 IF OP = 0 THEN NOSIDES=HDDR/256 +1:GOTO 1080
1050 TRIES=TRIES-1:IF TRIES=0 THEN 1055 ELSE OP=0: CALL INT13(OP,HDDR,TRSC):GOTO 1020
1055 IF HDDR>255 THEN TRIES=3:HDDR=DRIVE:GOTO 1020
1060 LOCATE 15,10:INPUT "Diskette error. C/R to go on.";I
1080 LOCATE 11,10:INPUT "Select track (0-39)";TRACK
1090 IF TRACK<0 OR TRACK>39 THEN 1080
1100 LOCATE 12,10:INPUT "Select sector (1-8)";SECTOR
1110 IF SECTOR<1 OR SECTOR>8 THEN 1100
1120 HEAD=0:IF NOSIDES=1 THEN 1150
1130 LOCATE 13,10:INPUT "Select side (0-1)";HEAD
1140 IF HEAD<0 OR HEAD>1 THEN 1130
1150 LOCATE 20,10:PRINT "Inputs satisfactory [Y]?"
1160 I$=INKEY$:IF I$="" THEN 1160 ELSE IF I$="N" OR I$="n" THEN 960
1170 HDDR=(HEAD*256)+DRIVE:TRSC=(TRACK*256)+SECTOR
1180 OP=2:CALL INT13(OP,HDDR,TRSC)
1185 IF OP<>0 THEN PRINT " retry";CHR$(7):OP=0:CALL INT13(OP,HDDR,TRSC):GOTO 1180
1187 NOTREAD=0
1190 GOSUB 1210 'always display it
1200 RETURN
1210 '
1280 IF NOTREAD THEN RETURN
1290 CLS
1300 LOCATE 1,1:PRINT"Drive ";DRIVE$;"  Side";HEAD;" Track";TRACK TAB(28) "Sector";SECTOR;" Byte";0
1310 BYTE=0
1320 GOSUB 1630
1330 GOSUB 190
1340 LOCATE 24,1:PRINT "New Value (Decimal)";
1350 COLOR 0,7:LOCATE 25,1:FOR II=24 TO 27:PRINT CHR$(II);:NEXT
1360 PRINT " - Cursor    No.+C/R - new no.    X - eXit";
1370 COLOR 0,7:GOSUB 170:GOSUB 180
1380 CALL IN(A)
1390 IF A=13 THEN CHAR=Z:Z=0:GOSUB 160:GOSUB 1520:GOTO 1370
1400 GOSUB 160
1430 IF A=77 THEN IF BYTE<511 THEN BYTE=BYTE+1:GOTO 1475
1440 IF A=80 THEN IF BYTE<488 THEN BYTE=BYTE+24:GOTO 1475
1450 IF A=75 THEN IF BYTE>0 THEN BYTE=BYTE-1:GOTO 1475
1460 IF A=72 THEN IF BYTE>24 THEN BYTE=BYTE-24:GOTO 1475
1470 IF A=88 OR A=120 THEN RETURN
1475 GOSUB 190
1480 IF A<48 OR A>57 THEN 1370
1490 Z=Z*10+A-48
1500 IF Z>255 THEN Z=0
1510 GOTO 1370
1520 POKE (BUF+BYTE),CHAR
1530 IF BYTE<511 THEN BYTE=BYTE+1
1540 GOSUB 190
1550 RETURN
1630 LOCATE 2,1:FOR A=BUF TO BUF+511 STEP 24:FOR B=A TO A+23:PRINT HX$(PEEK(B));:NEXT B:PRINT TAB(51);:FOR B=A TO A+23:PRINT AS$(PEEK(B));:NEXT B:PRINT:NEXT A
1640 LOCATE 23,17:PRINT "                                ";:LOCATE 23,59:PRINT "                ";:RETURN
```

## GRAFGE.BAS

```bas
1 '      *************
2 '      ** GRAFGEN **
3 '      *************
4 '
5 '      by Wes Meier
6 '      230 B Park Lake Circle
7 '      Walnut Creek, CA 94598
8 '
9 '      June/July 1982
10 '
11 '     Requires Color Adapter, BASICA,
12 '     and, optionally, IBM or Epson
13 '     (MX-80 or MX-100) equipped with
14 '     the GRAFTRAX ROMs.
15 '
16 KEY OFF
17 WIDTH 40
18 SCREEN 1,0
19 COLOR 1,0
20 DEFINT A-Z
21 DIM GRID (700),REDBOX (20), YELLOWBOX (17)
22 CLS
23 DEF FNGC(G,C)=(G-128)*8+C
24 DEF FNEXC(C)=2^(7-C)
25 Q$=CHR$(34)' Quote Marks
26 ' Set up graphics grid.
27 FOR X=0 TO 73 STEP 9
28 LINE (X,0)-(X,72),1
29 NEXT
30 FOR Y= 0 TO 73 STEP 9
31 LINE (0,Y)-(72,Y),1
32 NEXT
33 GET (0,0)-(72,72),GRID
34 CLS
35 ' Set up cursor.
36 LINE (2,2)-(7,7),2,BF
37 GET (1,1)-(8,8),REDBOX
38 CLS
39 ' Set up graphics block.
40 LINE (1,1)-(8,8),3,BF
41 GET (1,1)-(8,8),YELLOWBOX
42 GOSUB 45
43 GOTO 225
44 ' Set up Main Menu Key Vectors.
45 ON KEY(1) GOSUB 66
46 ON KEY(2) GOSUB 73
47 ON KEY(3) GOSUB 80
48 ON KEY(4) GOSUB 86
49 ON KEY(5) GOSUB 89
50 ON KEY(6) GOSUB 100
51 ON KEY(7) GOSUB 97
52 ON KEY(8) GOSUB 108
53 ON KEY(9) GOSUB 111
54 ON KEY(10) GOSUB 122
55 ON KEY(11) GOSUB 199
56 ON KEY(12) GOSUB 209
57 ON KEY(13) GOSUB 214
58 ON KEY(14) GOSUB 219
59 ' Turn on Key Trapping.
60 FOR X=1 TO 14
61 KEY (X) ON
62 NEXT
63 RETURN
64 ' Main Menu Key Subroutines
65 ' F1 Sub. Set Block.
66 T=PEEK(FNGC(GN,ROW))
67 IF T AND FNEXC(COL) THEN 71' Block already set.
68 PUT (COL*9+1,ROW*9+1),YELLOWBOX,PSET'Set block.
69 T=T+FNEXC(COL)
70 POKE(FNGC(GN,ROW)),T'Put it in memory.
71 RETURN
72 ' F2 Sub. Reset block.
73 T=PEEK(FNGC(GN,ROW))
74 IF (T AND FNEXC(COL))=0 THEN 71' Cell not set. Return.
75 PUT (COL*9+1,ROW*9+1),YELLOWBOX' Reset Block (XOR).
76 T=T-FNEXC(COL)
77 GOSUB 204' Put cursor there.
78 GOTO 70'Put in mem. and return.
79 ' F3 Sub. Fill grid.
80 K=255' All dots on.
81 FOR ROW=0 TO 7
82 POKE FNGC(GN,ROW),K
83 NEXT
84 RETURN 277
85 ' F4 Sub. Clear grid.
86 K=0' All dots off.
87 GOTO 81' Use fill routine.
88 ' F5 Sub. Fill Current column.
89 FOR ROW=0 TO 7
90 P=PEEK(FNGC(GN,ROW))
91 IF (P AND FNEXC(COL)) THEN 94
92 P=P+FNEXC(COL)
93 POKE FNGC(GN,ROW),P
94 NEXT
95 GOTO 84
96 ' F7 Sub. Fill Current Row.
97 POKE FNGC(GN,ROW),255
98 GOTO 84
99 ' F6 Sub. Reset Current Column.
100 FOR ROW=0 TO 7
101 P=PEEK (FNGC(GN,ROW))
102 IF (P AND FNEXC(COL))=0 THEN 105
103 P=P-FNEXC(COL)
104 POKE FNGC(GN,ROW),P
105 NEXT
106 GOTO 84
107 ' F8 Sub. Reset Current Row.
108 POKE FNGC(GN,ROW),0
109 GOTO 84
110 ' F9 Sub. Save Set on Disk.
111 CLS
112 LOCATE 12,1
113 INPUT "Enter Filespec ";FS$
114 IF LEN(FS$)>14 THEN BEEP:GOTO 111
115 PRINT"Is "Q$FS$Q$" correct (Y/N) ?";
116 A$=INKEY$:IF A$="" THEN 116
117 IF A$="Y" OR A$="y" OR A$=CHR$(13) THEN 119
118 IF A$="N" OR A$="n" OR A$="0" THEN 111 ELSE BEEP:GOTO 116
119 BSAVE FS$,0,1024
120 RETURN 249
121 ' F10 Sub. Select Alternate Menu.
122 RETURN 124
123 ' Set up Alternate Menu.
124 LINE (1,100)-(318,163),0,BF
125 LOCATE 14,13
126 PRINT"Alternate Menu"
127 LOCATE 15,3:PRINT"F1 Main Menu.      F2  Display Set."
128 LOCATE 16,3:PRINT"F3 Print Set.      F4  End Program."
129 ' Set up Alternate Menu Keys.
130 ON KEY (1) GOSUB 140
131 ON KEY (2) GOSUB 143
132 ON KEY (3) GOSUB 160
133 ON KEY (4) GOSUB 190
134 ' Turn off Keys 5-14.
135 FOR X=5 TO 14
136 KEY (X) OFF
137 NEXT
138 GOTO 138' Pressing the proper "F" key will break this loop.
139 ' F1 Sub. Return to Main Menu.
140 GOSUB 45' Restore Main Key Vectors.
141 RETURN 264
142 ' F2 Sub. Display Set on CRT.
143 CLS
144 FOR X=128 TO 255 STEP 3
145 FOR Y=0 TO 2
146 IF X+Y>255 THEN 148
147 PRINT"#";:PRINT USING "### = "+Q$+"!"+Q$+" ";X+Y;CHR$(X+Y);
148 NEXT:PRINT
149 IF X<>191 THEN 153
150 PRINT"Press any key to continue..."
151 A$=INKEY$
152 IF A$=""THEN 151
153 NEXT
154 PRINT"Press any key to continue..."
155 A$=INKEY$
156 IF A$="" THEN 155
157 CLS
158 GOTO 140
159 '
160 ' F3 Sub. Display Character Set on Printer.
161 ' This routine will function only
162 ' with an IBM or EPSON (MX-80 or 100)
163 ' equipped with the GRAFTRAX graphics
164 ' ROMS!!
165 ' Also, use this routine only if you
166 ' have IBM DOS Version 1.10. Version
167 ' 1.00 has a bug in its printer
168 ' I/O routine.
169 LPRINT CHR$(27)"@"' Reset Printer.
170 FOR X=128 TO 255 STEP 4
171  FOR Y=0 TO 3
172   IF Y+X>254 THEN 183
173   LPRINT "#";:LPRINT USING "### = "+Q$;X+Y;
174   LPRINT CHR$(27)"K"CHR$(8)CHR$(0);
175   FOR Z=0 TO 7
176    BYTE=0
177    FOR B=0 TO 7
178     IF PEEK(FNGC(X+Y,B)) AND FNEXC(Z) THEN BYTE=BYTE + FNEXC(B)
179    NEXT B
180   LPRINT CHR$(BYTE);
181   NEXT Z
182  LPRINT Q$SPACE$(3);
183  NEXT Y
184 LPRINT
185 NEXT X
186 LPRINT CHR$(12)
187 CLS
188 GOTO 140
189 ' F4 Sub. End Program.
190 CLS
191 RETURN 192
192 ' Turn Key Trapping off.
193 FOR X=1 TO 14
194 KEY (X) OFF
195 NEXT
196 END
197 ' Cursor Positioning Subroutines.
198 ' F11 Sub. Cursor Up.
199 IF ROW-1<0 THEN RETURN' At top of grid already.
200 GOSUB 204'XOR Cursor.
201 ROW=ROW-1'Go Up.
202 ' This Sub. erases cursor, if there,
203 ' or sets it, if not there.
204 PUT (COL*9+1,ROW*9+1),REDBOX
205 X=RND*6
206 PLAY"MBMSL64O=X;T255A"' Just for the fun of it.
207 RETURN
208 ' F12 Sub. Cursor Left.
209 IF COL-1<0 THEN RETURN' Already at left side of grid.
210 GOSUB 204' XOR Current cursor.
211 COL=COL-1' Go left.
212 GOTO 204' Set Cursor.
213 ' F13 Sub. Cursor Right.
214 IF COL+1>7 THEN RETURN
215 GOSUB 204
216 COL=COL+1
217 GOTO 204
218 ' F14 Sub. Cursor Down.
219 IF ROW+1>7 THEN RETURN
220 GOSUB 204
221 ROW=ROW+1
222 GOTO 204
223 'Point graphics vector to area just
224 'above BASICA in a 128K system.
225 DEF SEG=0' Point to Bottom of RAM.
226 POKE 124,0
227 POKE 125,0
228 POKE 126,PEEK(&H510)+1
229 POKE 127,PEEK(&H511)+16
230 'The vector at 0000:0510H-0511H points to the start of BASICA's
231 '64K segment.
232 '
233 'Point to Graphics table 64K+1 bytes
234 'above beginning of BASICA.
235 DEF SEG=256*PEEK(127)+PEEK(126)
236 CLS
237 LOCATE 12,1
238 PRINT"Do you want to load a previously saved"
239 PRINT"character set (Y/N) ?"
240 A$=INKEY$:IF A$="" THEN 240
241 IF A$="N" OR A$="n" OR A$="0" THEN 249
242 IF A$<>CHR$(13) AND A$<>"Y" AND A$<>"y" THEN BEEP:GOTO 240
243 INPUT "Enter filespec ";FS$
244 ON ERROR GOTO 246'Trap "File not found" error. ERR=53.
245 GOTO 248
246 IF ERR=53 THEN PRINT Q$FS$Q$" was not found.":BEEP:RESUME 243
247 ON ERROR GOTO 0' Crash if any other error.
248 BLOAD FS$,0
249 CLS
250 LOCATE 12,1
251 PRINT"Last Character number generated ="GN
252 X=GN
253 PRINT "Enter Character number to"
254 INPUT "generate (128-255)(EN=Next) ";GN
255 IF GN=0 THEN GN=X+1
256 IF GN<128 THEN GN=128
257 IF GN>255 THEN GN=255
258 IF GN<>255 THEN 263
259 PRINT
260 PRINT"CHR$(255) is always null and cannot be"
261 PRINT"modified."
262 GOTO 253
263 CLS
264 LOCATE 14,1
265 LINE (1,100)-(318,163),0,BF
266 LOCATE 14,3:PRINT"Use Arrow Keys to move Cursor."
267 LOCATE 15,3:PRINT"F1 Sets Dot.    F2  Resets Dot."
268 LOCATE 16,3:PRINT"F3 Fills Grid.  F4  Clears Grid."
269 LOCATE 17,3:PRINT"F5 Fills Col.   F6  Clears Col."
270 LOCATE 18,3:PRINT"F7 Fills Row.   F8  Clears Row."
271 LOCATE 19,3:PRINT"F9 Saves Set.   F10 Alternate Menu."
272 LOCATE 20,3:PRINT"Press Enter to Accept Character."
273 LINE (0,99)-(319,164),2,B
274 FOR X=0 TO 7
275 LINE(73,X*9+4)-(152,X*8+3),2
276 NEXT
277 PUT (0,0),GRID,PSET' Overwrite the existing grid.
278 FOR ROW=0 TO 7
279 P=PEEK(FNGC(GN,ROW))
280 IF P=0 THEN 284' Skip a blank row.
281 FOR COL=0 TO 7
282 IF P AND FNEXC(COL) THEN GOSUB 204:PUT(COL*9+1,ROW*9+1),YELLOWBOX
283 NEXT
284 NEXT
285 ROW=0
286 COL=0
287 PUT(1,1),REDBOX
288 GOTO 294
289 ROW=0
290 COL=0
291 PUT (0,0),GRID
292 PUT (1,1),REDBOX
293 REM *** Main Strobe Loop ***
294 LOCATE 12,1
295 PRINT"CHR$("RIGHT$(STR$(GN),3)") = "Q$CHR$(GN)Q$" ";
296 PRINT"STRING$(5,"RIGHT$(STR$(GN),3)") = "Q$STRING$(5,GN)Q$;
297 A$=INKEY$
298 IF A$=CHR$(13) THEN 249' "Enter" key? Get a new Character if so.
299 FOR X=0 TO 7
300 LOCATE X+1,20
301 PRINT"Byte"X"= "RIGHT$("0"+HEX$(PEEK(FNGC(GN,X))),2)
302 NEXT
303 GOTO 294
304 END ' of program.


```

## GSDUMP.BAS

```bas
0 'Prog = -------SCMDUMP-------
1 'no nonsense Graphics Sideways memory DUMP for C.ITOH 8510 PROWRITER
2 'Author: Herb Shear;
11 'NEC 8023 may require `[' (incremental) rather than `>" (unidirectional).
20 KEY OFF:DEFINT A-Z:DEF SEG=&HB800:WIDTH"LPT1:",255:E$=CHR$(27)
30 LPRINT CHR$(29)" "E$"A"STRING$(4,10)E$"T16"E$"N"E$"L010"E$">"CHR$(15)E$"P";
40 FOR Y=1 TO 80:LPRINT E$"S1000";:FOR X=80 TO 8000 STEP 80:K=X-Y:LPRINT STRING$(5,PEEK(K))STRING$(5,PEEK(K+8192));:NEXT:LPRINT:NEXT:LPRINT CHR$(10)E$"A"STRING$(8,10)CHR$(29)" "E$"<"CHR$(15)E$"N"E$"L000";:WIDTH"LPT1:",80:END
```

## JUMBLE.BAS

```bas
100 'jumble - solves jumbles
120 'This is 10 lines in PASCAL but the EXE file is huge!
130 'There's got to be a better way in BASIC to do recursion
140 '   or some other permutation algorithm
145 '--Oh well, it works as fast as it can be read.
147 '
148 ' Hal Sampson (408) 866-7840
149 '
150 DEFINT A-Z
200 INPUT "Jumbled word to permute";A$(0)
300 I=0:L=LEN(A$(0))
350 FOR J=1 TO 16:IF 80\(L+J)=80/(L+J) THEN 375 ELSE NEXT J
375 B$=STRING$(J,32)
400 GOSUB 1000
600 PRINT
700 GOTO 200
1000 IF A$(I)="" THEN FOR K=0 TO I-1:PRINT O$(K);:NEXT K:PRINT B$;:RETURN
1050 J(I)=0
1100 IF J(I)=LEN(A$(I)) THEN RETURN ELSE J(I)=J(I)+1
1200 O$(I)=LEFT$(A$(I),1)
1300 A$(I+1)=MID$(A$(I),2)
1400 I=I+1
1500 GOSUB 1000
1600 I=I-1
1700 A$(I)=MID$(A$(I),2)+LEFT$(A$(I),1)
1800 GOTO 1100
```

## MEMPEEK.BAS

```bas
1000 'MEMPEEK.BAS - John Schnell - Nov. 1982...Used by permission of N.Y.P.C.
1001 'From MICROCOMPUTING, March 1983, pg 18.
1010 ' A program to display memory
1020 KEY OFF : COLOR 7,0 : CLS
1030 PRINT TAB(25)"*** Memory Lister ***"
1040 PRINT :PRINT :PRINT
1050 PRINT "Memory Lister will display the contents of a selected segment of memory in"
1060 PRINT "256 byte blocks per screen.  The contents are displayed in HEXIDECIMAL and in"
1070 PRINT "ASCII format.  From the menu, select the segment you wish to examine."
1080 PRINT :PRINT
1090 PRINT TAB(25)"U = User selected segment."
1100 PRINT TAB(25)"D = DOS segment of memory."
1110 PRINT TAB(25)"P = This program in memory."
1120 PRINT TAB(25)"R = ROM contents in memory."
1125 PRINT TAB(25)"C + Color screen buffer."
1130 PRINT TAB(25)"M = Monochrome screen buffer."
1140 PRINT TAB(25)"E = End program."
1150 PRINT :PRINT :PRINT
1160 PRINT TAB(25)"Please enter your choice : ";
1170 DEF SEG = 0: POKE 1047,PEEK(1047) OR 64
1180 RESP$ = INPUT$(1)
1190 CHOICE = INSTR("UDPRCME",RESP$) : IF CHOICE = 0 THEN BEEP:GOTO 1170
1200 CLS: ON CHOICE GOTO 1210,1300,1330,1390,1412,1420: GOTO 1830
1210 'user selection
1220 INPUT "Enter start of segment in hexadecimal (0000 to FFFF ) : ";SEGMENT$
1230 IF LEN(SEGMENT$)<1 OR LEN(SEGMENT$)>4 THEN BEEP: GOTO 1220
1240 FOR LOOP=1 TO 4: IF MID$(SEGMENT$,LOOP,1)<"0" OR MID$(SEGMENT$,LOOP,1)>"F" THEN BEEP: GOTO 1220 ELSE NEXT LOOP
1250 PRINT :PRINT
1260 INPUT "Enter memory offset in hexadecimal ( 0000 to FFFF ) : ";OFFSET$
1270 IF LEN(OFFSET$)<1 OR LEN(OFFSET$)>4 THEN BEEP: GOTO 1260
1280 FOR LOOP=1 TO 4: IF MID$(OFFSET$,LOOP,1)<"0" OR MID$(OFFSET$,LOOP,1)>"F" THEN BEEP: GOTO 1260 ELSE NEXT LOOP
1290 LOCATE 19,23:PRINT ">>  User Selected Segment  <<":GOTO 1450
1300 'display of DOS
1310 SEGMENT$ = "0000": OFFSET$ ="0000"
1320 LOCATE 19,23:PRINT ">>    Display of DOS    <<":GOTO 1450
1330 'display of program in memory
1340 DEF SEG = 0: BASIC = PEEK(&H510)+PEEK(&H511)*256
1350 DEF SEG: PROGRAM = PEEK(&H30)+PEEK(&H31)*256
1360 SEGMENT$=RIGHT$("0000"+HEX$(BASIC),4)
1370 OFFSET$=RIGHT$("0000"+HEX$(PROGRAM),4)
1380 LOCATE 19,23:PRINT ">>  Display program in Mem.  <<":GOTO 1450
1390 ' beginning of rom in high memory
1400 SEGMENT$="F000":OFFSET$="E000"
1410 LOCATE 19,23:PRINT ">> Display ROM in High Mem. <<":GOTO 1450
1411 'color screen buffer
1412 SEGMENT$="B800":OFFSET$="0000"
1413 LOCATE 19,23:PRINT">> Display Color ScreenBuff. <<":GOTO 1450
1420 'monochrome screen buffer
1430 SEGMENT$="B000":OFFSET$="0000"
1440 LOCATE 19,23:PRINT ">> Display Mono Screen Buff. <<":GOTO 1450
1450 'press spacebar to start
1460 LOCATE 21,1:PRINT TAB(25)"SEGMENT starts at : &H" SEGMENT$
1470 PRINT TAB(25)"OFFSET starts at : &H" OFFSET$
1480 PRINT :PRINT TAB(25)"Press <SPACE-BAR> TO START :";
1490 RESP$=INPUT$(1): IF RESP$<>" " THEN BEEP, GOTO 1490
1500 'routine for displaying the contents of memory on the screen
1510 CUR.SEG$="&H"+SEGMENT$: CUR.OFF$="&H"+OFFSET$
1520 HEXVAL$="0123456789ABCDEF01234567890ABCDE": HEXHEADING=VAL("&H"+RIGHT$(OFFSET$,1))+1
1530 LINECOUNT=1:ADDR.FMT$="\  \ =":BYTE.FMT$="\\ "
1540 FOR LOOP=VAL(CUR.OFF$) TO 65336. STEP 16:DEF SEG=VAL(CUR.SEG$)
1550 IF LINECOUNT =1 THEN CLS:DIVIDER=3:PRINT TAB(25);"SEGMENT STARTS AT :  "CUR.SEG$ ELSE 1620
1560 PRINT "offset";TAB(28)"hexidecimal values";TAB(69)"ASCII code";
1570 COLOR 0,7:PRINT "hex   ";
1580 FOR LOOP1=HEXHEADING TO HEXHEADING+15
1590  DIVIDER = DIVIDER+1:IF DIVIDER = 4 THEN PRINT CHR$(221);:DIVIDER=0
1600  PRINT MID$(HEXVAL$,LOOP1,1)+"  ";
1610 NEXT LOOP1:PRINT CHR$(221)+" "MID$(HEXVAL$,HEXHEADING,16):COLOR 7,0:DIVIDER=3
1620 ADDR$=RIGHT$("0000"+HEX$(LOOP),4)
1630 PRINT USING ADDR.FMT$;ADDR$;
1640 FOR LOOP2 = LOOP TO LOOP+15
1650   BYTECONTENT$=RIGHT$("00"+HEX$(PEEK(LOOP2)),2)
1660   DIVIDER=DIVIDER+1:IF DIVIDER=4 THEN PRINT CHR$(221);:DIVIDER =0
1670   PRINT USING BYTE.FMT$;BYTECONTENT$;
1680 NEXT LOOP2
1690 PRINT CHR$(221)+" ";
1700 FOR LOOP3=LOOP TO LOOP+15
1710   CHAR$=CHR$(PEEK(LOOP3)): IF CHAR$=>" " THEN PRINT CHAR$;ELSE PRINT ".";
1720 NEXT LOOP3
1730 PRINT
1740 LINECOUNT=LINECOUNT+1: IF LINECOUNT<17 THEN 1810
1750 PRINT
1760 COLOR 0,7:PRINT " < SPACE-BAR > continues forward, < - > backward, < M > returns to menu ";: COLOR 7,0
1770 DEF SEG = 0:POKE 1047, PEEK(1047) OR 64
1780 RESP$=INPUT$(1)
1790   IF RESP$="M" THEN BEEP:GOTO 1020
1795   IF RESP$="-" THEN LOOP=LOOP-512: LINECOUNT=1:GOTO 1810
1800   IF RESP$<>" " THEN BEEP:GOTO 1770 ELSE LINECOUNT=1
1810 NEXT LOOP
1820 GOTO 1020
1830 END
```

## PALLETTE.BAS

```bas
10 'Pallette - 7 FEB 83 - Hal Sampson - (408) 866-7840
20 'Demonstrates Pallette of >64 colors available in 160 X 200 composite mode
27 KEY 9,"goto 210"+CHR$(13)
28 PRINT"Press Break then F9 then F10 to exit"
30 DEF SEG=0
40 OUT &H3D8,&H1A
50 OUT &H3D9,31
60 DEFINT A-Z
70 FOR I=0 TO 13
80 OUT &H3D4,I
90 READ S
100 OUT &H3D5,S
110 NEXT
120 DATA &H38,&H28,&H2d,10,127,3,100,112,2,1,0,0,0,0
130 DEF SEG = &HB800
140 FOR K=0 TO 15:M=K*17
150 FOR I=K*5 TO 8191 STEP 80:POKE I,M:POKE I+1,M:POKE I+2,M:POKE I+3,M:POKE I+4,M:POKE I+8192,M:POKE I+8193,M:POKE I+8194,M:POKE I+8195,M:POKE I+8196,M:NEXT
160 NEXT K
190 A=INP(33):OUT 33,A OR 1  'turn off timer interrupt
200 OUT 985,1:OUT 985,2:OUT 985,3:OUT 985,4:OUT 985,5:OUT 985,6:OUT 985,7:OUT 985,9:OUT 985,10:OUT 985,11:OUT 985,13:OUT 985,14:OUT 985,15:GOTO 200
210 A=INP(33):OUT 33,A AND 254  'turn on timer interrupt
220 STOP
```

## RESCMD.BAS

```bas
100 '
200 ' COMMAND.COM   MODIFICATION TRANSFER PROGRAM
300 '               "RESCMD.BAS"                   Last Update 11/26/82
350 '                                              John Chapman
351 '                                              CIS 70205,1217
400 '
500 'This program will read in an unmodified COMMAND.COM (Release 1.1)
600 '     and produce an output file called COMMAND.CMD.. which can be
700 '     renamed to COMMAND.COM.. This output file will contain all of 
800 '     the modifications to COMMAND.COM currently available from the
900 '     author. See COMMAND.DOC for complete list and limitations.
910 '
950 DEFINT A-Z
1000 BFIL$ = "COMMAND.COM"
1100 CFIL$ = "COMMAND.CMD"
1200 INPUT "Enter Drive where COMMAND.COM resides followed by a colon ?",DRV$
1210 BFIL$=DRV$+BFIL$
1220 CFIL$=DRV$+CFIL$
1230 '
1240 OPEN BFIL$ FOR INPUT AS #1:CLOSE #1
1250 OPEN BFIL$ AS #1 LEN=1
1260 V= VARPTR(#1)
1270 L0=PEEK(V)
1280 IF L0 <>4 THEN GOTO 5000
1290 L1=PEEK(V+17) + 256 * PEEK(V+18) 'FILESIZE IN BYTES
1300 LIMIT = L1: IF LIMIT>6800 THEN PRINT "file too large":GOTO 5000 :
2000 'check base and change files for random, size and
2100 ' equal length .. abort if not correct conditions
2200 PRINT "BASE    FILE SIZE = ",LIMIT
2300 READ T:PRINT "ORIGIN  FILE SIZE = ",T
3000 DIM BB%(6800)
3100 '
3200 FIELD #1,1 AS INB$
3300 '
3400 FOR I = 1 TO LIMIT
3410 GET #1,I
3420 BB%(I) = ASC(INB$)
3430 NEXT I
3431 CLOSE #1
3432 '
3440 READ BYTES:
3500 FOR I = 1 TO BYTES
3600 READ IKJ%,XOLD%,XNEW%
3700 IF BB%(IKJ%) <> XOLD% THEN GOTO 3950
3800 BB%(IKJ%) = XNEW%
3900 GOTO 4300
3950 PRINT "VERIFY REJECT AT ";IKJ%," (";XOLD%;" / ";XNEW%;") ":
4100 PRINT "TARGET FILE COMMAND.CMD UNUSABLE":
4200 END
4300 NEXT I
4500 '
4501 PRINT "last byte = ";IKJ%;" was ";XOLD%;" now ";XNEW%
4600 '
4610 OPEN CFIL$ FOR OUTPUT AS #2:CLOSE #2
4620 OPEN CFIL$ AS #2 LEN=1
4630 FIELD #2,1 AS INC$
4700 '
4710 FOR I = 1 TO LIMIT
4712 IF BB%(I)>255 THEN PRINT "FORMAT ERROR AT";I;" = ";BB%(I):
4720 LSET INC$ = CHR$(BB%(I))
4730 PUT #2,I
4740 NEXT I
4741 PRINT I;" Bytes Written to COMMAND.CMD"
4750 CLOSE #2
4760 '
4800 PRINT "File COMMAND.CMD Created .. Rename to Use"
4900 END
4990 ' ** DATA STATEMENT WRITE SUBROUTINE
4991 '
4999 DATA  4959,  34
5000 DATA  865, 70, 84, 868, 3, 79, 869, 1, 4
5010 DATA  870, 161, 5, 871, 2, 12, 872, 0, 1
5020 DATA  877, 163, 64, 878, 82, 163, 879, 4, 3
5030 DATA  880, 45, 1, 881, 12, 161, 882, 1, 2
5040 DATA  883, 144, 0, 885, 79, 82, 890, 232, 184
5050 DATA  1369, 140, 144, 1370, 200, 161, 1371, 43, 2
5060 DATA  1372, 6, 0, 1373, 159, 43, 1374, 15, 6
5070 DATA  1375, 186, 159, 1376, 16, 15, 1377, 0, 186
5080 DATA  1378, 247, 16, 1379, 226, 0, 1380, 11, 247
5090 DATA  1381, 210, 226, 1382, 116, 115, 4052, 140, 144
5100 DATA  4053, 200, 161, 4054, 5, 2, 4055, 192, 0
5110 DATA  4056, 0, 72
```

## RESCMDCK.BAS

```bas
50 '
100 '
200 ' COMMAND.COM   MODIFICATION TRANSFER PROGRAM
300 '               "RESCMDCK.BAS"                 Last Update 11/26/82
350 '                                     .        John Chapman
351 '                                              CIS 70205,1217
400 '
500 'This program will read in an unmodified COMMAND.COM (Release 1.1)
600 '     and produce an output file called COMMAND.CMD.. which can be
700 '     renamed to COMMAND.COM.. This output file will contain all of
800 '     the modifications to COMMAND.COM currently available from the
900 '     author. See COMMAND.DOC for complete list and limitations.
910 '
950 DEFINT A-Z
1000 BFIL$ = "COMMAND.COM"
1100 CFIL$ = "COMMAND.CMD"
1200 INPUT "Enter Drive where COMMAND.COM resides followed by a colon ?",DRV$
1210 BFIL$=DRV$+BFIL$
1220 CFIL$=DRV$+CFIL$
1230 '
1240 OPEN BFIL$ FOR INPUT AS #1:CLOSE #1
1250 OPEN BFIL$ AS #1 LEN=1
1260 V= VARPTR(#1)
1270 L0=PEEK(V)
1280 IF L0 <>4 THEN GOTO 5000
1290 L1=PEEK(V+17) + 256 * PEEK(V+18) 'FILESIZE IN BYTES
1300 LIMIT = L1: IF LIMIT>6800 THEN PRINT "file too large":GOTO 5000 :
2000 'check base and change files for random, size and
2100 ' equal length .. abort if not correct conditions
2200 PRINT "BASE    FILE SIZE = ",LIMIT
2300 READ T:PRINT "ORIGIN  FILE SIZE = ",T
3000 DIM BB%(6800)
3100 '
3200 FIELD #1,1 AS INB$
3300 '
3400 FOR I = 1 TO LIMIT
3410 GET #1,I
3420 BB%(I) = ASC(INB$)
3430 NEXT I
3431 CLOSE #1
3432 '
3440 READ BYTES:
3500 FOR I = 1 TO BYTES
3600 READ IKJ%,XOLD%,XNEW%
3700 IF BB%(IKJ%) <> XOLD% THEN GOTO 3950
3800 BB%(IKJ%) = XNEW%
3900 GOTO 4300
3950 PRINT "VERIFY REJECT AT ";IKJ%," (";XOLD%;" / ";XNEW%;") ":
4100 PRINT "TARGET FILE COMMAND.CMD UNUSABLE":
4200 END
4300 NEXT I
4500 '
4501 PRINT "last byte = ";IKJ%;" was ";XOLD%;" now ";XNEW%
4600 '
4610 OPEN CFIL$ FOR OUTPUT AS #2:CLOSE #2
4620 OPEN CFIL$ AS #2 LEN=1
4630 FIELD #2,1 AS INC$
4700 '
4710 FOR I = 1 TO LIMIT
4712 IF BB%(I)>255 THEN PRINT "FORMAT ERROR AT";I;" = ";BB%(I):
4720 LSET INC$ = CHR$(BB%(I))
4730 PUT #2,I
4740 NEXT I
4741 PRINT I;" Bytes Written to COMMAND.CMD"
4750 CLOSE #2
4760 '
4800 PRINT "File COMMAND.CMD Created .. Rename to Use"
4900 END
4990 ' ** DATA STATEMENT WRITE SUBROUTINE
4991 '
4999 DATA  4959,  203
5000 DATA  865, 70, 84, 868, 3, 79, 869, 1, 4
5010 DATA  870, 161, 5, 871, 2, 12, 872, 0, 1
5020 DATA  877, 163, 64, 878, 82, 163, 879, 4, 3
5030 DATA  880, 45, 1, 881, 12, 161, 882, 1, 2
5040 DATA  883, 144, 0, 885, 79, 82, 890, 232, 184
5050 DATA  1363, 0, 1, 1369, 140, 144, 1370, 200, 161
5060 DATA  1371, 43, 2, 1372, 6, 0, 1373, 159, 43
5070 DATA  1374, 15, 6, 1375, 186, 159, 1376, 16, 15
5080 DATA  1377, 0, 186, 1378, 247, 16, 1379, 226, 0
5090 DATA  1380, 11, 247, 1381, 210, 226, 1382, 116, 115
5100 DATA  3632, 232, 144, 3633, 6, 144, 3634, 0, 144
5110 DATA  3635, 232, 144, 3636, 150, 144, 3637, 0, 144
5120 DATA  3641, 190, 51, 3642, 129, 210, 3643, 0, 51
5130 DATA  3644, 232, 219, 3645, 191, 51, 3646, 255, 192
5140 DATA  3647, 60, 184, 3648, 13, 12, 3649, 116, 0
5150 DATA  3650, 9, 232, 3651, 187, 7, 3652, 45, 0
5160 DATA  3653, 47, 184, 3654, 232, 3, 3655, 7, 0
5170 DATA  3656, 1, 232, 3657, 235, 1, 3658, 61, 0
5180 DATA  3659, 144, 195, 3660, 186, 205, 3661, 87, 23
5190 DATA  3662, 14, 128, 3663, 180, 228, 3664, 9, 169
5200 DATA  3665, 205, 128, 3666, 33, 252, 3667, 180, 0
5210 DATA  3668, 42, 116, 3669, 205, 7, 3670, 33, 186
5220 DATA  3671, 152, 29, 3672, 139, 10, 3673, 240, 180
5230 DATA  3674, 209, 9, 3675, 230, 205, 3676, 3, 33
5240 DATA  3677, 240, 195, 3678, 129, 13, 3679, 198, 10
5250 DATA  3680, 51, 80, 3681, 14, 114, 3682, 139, 105
5260 DATA  3683, 217, 110, 3684, 185, 116, 3685, 3, 101
5270 DATA  3686, 0, 114, 3687, 232, 32, 3688, 9, 69
5280 DATA  3689, 251, 114, 3690, 176, 114, 3691, 32, 111
5290 DATA  3692, 232, 114, 3693, 92, 32, 3694, 1, 45
5300 DATA  3695, 139, 32, 3696, 195, 70, 3697, 139, 117
5310 DATA  3698, 202, 110, 3699, 178, 99, 3700, 100, 116
5320 DATA  3701, 246, 105, 3702, 242, 111, 3703, 134, 110
5330 DATA  3704, 196, 32, 3705, 146, 65, 3706, 179, 98
5340 DATA  3707, 45, 111, 3708, 232, 114, 3709, 17, 116
5350 DATA  3710, 1, 101, 3711, 186, 100, 3712, 104, 13
5360 DATA  3713, 14, 10, 3714, 187, 36, 3715, 45, 0
5370 DATA  3716, 47, 144, 3717, 232, 184, 3718, 178, 0
5380 DATA  3719, 0, 6, 3720, 116, 185, 3721, 151, 0
5390 DATA  3722, 114, 0, 3723, 55, 186, 3724, 172, 79
5400 DATA  3725, 58, 24, 3726, 195, 183, 3727, 116, 7
5410 DATA  3728, 4, 205, 3729, 58, 16, 3730, 199, 180
5420 DATA  3731, 117, 2, 3732, 46, 186, 3733, 232, 0
5430 DATA  3734, 216, 0, 3735, 0, 183, 3736, 114, 0
5440 DATA  3737, 41, 205, 3738, 185, 16, 3739, 108, 195
5450 DATA  3740, 7, 144, 3741, 128, 187, 3742, 60, 220
5460 DATA  3743, 13, 5, 3744, 116, 228, 3745, 11, 97
5470 DATA  3746, 176, 144, 3747, 100, 36, 3748, 246, 252
5480 DATA  3749, 228, 230, 3750, 139, 97, 3751, 200, 185
5490 DATA  3752, 232, 50, 3753, 197, 0, 3754, 0, 226
5500 DATA  3755, 114, 254, 3756, 22, 12, 3757, 138, 2
5510 DATA  3758, 196, 230, 3759, 180, 97, 3760, 0, 185
5520 DATA  3761, 3, 50, 3762, 200, 0, 3763, 172, 226
5530 DATA  3764, 60, 254, 3765, 13, 75, 3767, 11, 235
5540 DATA  3768, 180, 195, 3769, 43, 144, 3770, 205, 144
5550 DATA  3771, 33, 144, 3772, 10, 144, 3773, 192, 144
5560 DATA  3774, 117, 144, 3775, 3, 144, 3776, 233, 144
5570 DATA  3777, 94, 144, 3778, 255, 144, 3779, 186, 144
5580 DATA  3780, 72, 144, 3781, 14, 144, 3782, 180, 144
5590 DATA  3783, 9, 144, 3784, 205, 144, 3785, 33, 144
5600 DATA  3786, 235, 144, 3787, 179, 144, 4052, 140, 144
5610 DATA  4053, 200, 161, 4054, 5, 2, 4055, 192, 0
5620 DATA  4056, 0, 72, 4902, 68, 67, 4903, 69, 76
5630 DATA  4904, 76, 83, 4906, 176, 68, 4907, 5, 10
5640 DATA  4941, 68, 66, 4942, 65, 69, 4943, 84, 69
5650 DATA  4944, 69, 80, 4946, 248, 92, 4947, 9, 10
5660 DATA  4949, 84, 80, 4950, 73, 65, 4951, 77, 71
5670 DATA  4954, 139, 248, 4955, 10, 9
```

## TIMING.BAS

```bas
1 'TIMING - times statements accurately by interval averaging - Hal Sampson
2 SZ$="00:00:01":FZ$="00:00:11":QZ$=TIME$:TIME$="00":SOUND 37,1:SOUND 37,1
3 IF TIME$<SZ$ THEN 3 ELSE WHILE TIME$<FZ$:IZ%=IZ%+1
9 'Replace with statement(s) to be timed.  (e.g. this takes about 3 ms)
65527 WEND
65528 PRINT USING "##.###";10000/IZ%-5.2005;:PRINT " ms":TIME$=QZ$
```

{% comment %}samples_end{% endcomment %}

### Directory of PC-SIG Library Disk #0028

     Volume in drive A has no label
     Directory of A:\

    ARTILL   BAS      7680   3-03-83   1:31p
    BIGTYPE  BAS      1536   2-09-83  12:11a
    CD       COM       640   1-01-80  12:21a
    COLOUR   DOC      9088   3-02-83  10:31p
    CPCPRO   DOC     12800   3-04-83  12:01a
    CRC      TXT      2111  11-09-84   8:47a
    CRCK4    COM      1536  10-21-82   7:54p
    DDATE    COM       512   2-09-83  12:00a
    DISKMODF BAS      3712   2-09-83  12:10a
    FK       COM      2432  11-17-82   1:15a
    FK       DOC      8806   3-03-83  11:06p
    GRAFGE   BAS      8335   3-05-83   1:39a
    GRAFGE   DOC      1920   3-02-83  11:04p
    GSDUMP   BAS       512   3-09-83   2:48p
    GUMUP1   DOC      6089   3-09-83   1:34a
    HALS     DOC      1320   2-24-83   9:09a
    JUMBLE   BAS       768   2-09-83  12:18a
    LF       COM       512   1-01-80  12:22a
    MEMPEEK  BAS      3840   2-26-83  12:50a
    PALLETTE BAS       768   2-09-83  12:04a
    RESCMD   BAS      2688   3-03-83  10:45p
    RESCMD   DOC      4386   3-09-83   4:02p
    RESCMDCK BAS      5504   3-09-83   4:07p
    SD       COM      1505   2-02-82
    SDIR     EXE      1792   5-08-82
    SPEED411 COM        15  12-16-82  12:07a
    SQUISH   DOC      5541   3-09-83   6:11p
    SQUISH   EXE     28416   3-08-83  12:50a
    SQUISH   SRC      7175   3-09-84   5:11p
    SYSTAT   COM      1408   1-01-80  12:20a
    SYSTAT   DOC      1050  10-09-82   3:05p
    TIMING   BAS       384   2-09-83  12:21a
    UNPROT2  TXT      1117   2-24-83  12:18p
    VDEL     COM       768   1-01-80  12:20a
    WAIT     COM       128   1-01-80  12:24a
           35 file(s)     136794 bytes
                           15872 bytes free
