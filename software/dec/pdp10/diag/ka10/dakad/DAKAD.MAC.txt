SUBTTL	DIAGNOSTIC PARAMETERS

;ACCUMULATOR ASSIGNMENTS

;CONTROL WORDS

AROV=400000		;ARITHMETIC OVERFLOW
CRY0=200000		;CARRY 0
CRY1=100000		;CARRY 1
FOV=40000		;FLOATING OVERFLOW
BIS=20000		;BYTE INTERRUPT
USERF=10000		;USER MODE FLAG
EXIOT=4000		;USER PRIV I/O FLAG
FXU=100			;FLOATING UNDERFLOW
DCK=40			;DIVIDE CHECK

;MACROS

; STOP - USED FOR SCOPE LOOP, IF INSTRUCTION FAILS, CHANGE (JUMPA .+1)
;	 TO A (JUMPA X) TO CYCLE ON FAILING INSTRUCTION

DEFINE	STOP	(A)<
	HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
	JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
				;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
				;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
				;AND CHANGE HALT INSTRUCTION TO JUMPA .+1>

; SFLAG - USED TO CLEAR ALL FLAGS THEN TO SET REQUESTED FLAG

DEFINE	SFLAG	(A)<
	MOVSI	1,A
	JFCL	17,.+1		;RESET ALL FLAGS
	JRST	2,.+1(1)	;SET A FLAG>

SUBTTL	DIAGNOSTIC SECTION

START:	;SETZM	USER#		;CLEAR USER CONTROL WORD
	;JSP	0,.+1		;GET FLAGS
	;TLNE	USERF		;IN USER MODE?
	;SETOM	USER		;YES, SET USER CONTROL WORD
	;SKIPN	MONFLG		;SPECIAL USER MODE?
	;SETZM	USER		;YES, CLEAR USER CONTROL WORD
	;SKIPN	USER
	;JRST	C00
	;SKIPL	MONCTL
	;TTCALL	3,PGMNAM	;MENTION OUR NAME
	JRST	STARTA

PGMNAM:	ASCIZ/
PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (4) [DAKAD]
/

;BASIC INSTRUCTION TEST (3)
;THE TEST IS DESIGNED FOR INITIAL DEBUGGING OF
;PROCESSOR HARDWARE AND TO DETECT (SOLID) FAILURES
;IN THE FIELD.

STARTA:	JRST	.+1
C00:
;TESTING BEGINS HERE

;IF ANY LOADING PROBLEMS OCCUR, START PROGRAM HERE.

;NOTE:	AN "*" IN THE COMMENT FIELD OF AN INSTRUCTION INDICATES THAT
;	IT IS THE TESTED INSTRUCTION.

SUBTTL	TEST OF AC HARDWARE AND INDEX REGISTERS

;**********

;THIS TEST VERIFIES THAT AC1 IS ACCESSABLE
;IN THIS CASE, AC1 IS PRELOADED WITH 1.
;C(AC1) IS THEN CHECKED FOR A1.  THIS TEST PASSES IF C(AC1)=1.
;IF THIS TEST FAILS, THE AC HARDWARE IS PROBABLY FAULTY

C100:	SETZ			;CLEAR AC0
	MOVEI	1,1		;PRELOAD AC1 WITH 1
	CAIE	1,1		;PASS IF C(AC1)=1
	STOP

;**********

;THIS TEST VERIFIES THAT AC2 IS ACCESSABLE.
;IN THIS CASE, AC2 IS PRELOADED WITH 2.
;C(AC2) IS THEN CHECKED FOR 2.  THIS TEST PASSES IF C(AC2)=2.
;IF THIS TEST FAILS, THE AC HARDWARE IS PROBABLY FAULTY

C200:	MOVEI	2,2		;PRELOAD AC2 WITH 2
	CAIE	2,2		;PASS IF C(AC2)=2
	STOP

;**********
;THIS TEST VERIFIES THAT AC4 IS ACCESSABLE.
;IN THIS CASE, AC4 IS PRELOADED WITH 4.
;C(AC4) IS THEN CHECKED FOR 4.  THIS TEST PASSES IF C(AC4)=4.
;IF THIS TEST FAILS, THE AC HARDWARE IS PROBABLY FAULTY

C300:	MOVEI	4,4		;PRELOAD AC4 WITH 4
	CAIE	4,4		;PASS IF C(AC4)=4
	STOP

;**********

;THIS TEST VERIFIES THAT AC10 IS ACCESSABLE.
;IN THIS CASE, AC10 IS PRELOADED WITH 10.
;C(AC10) IS THEN CHECKED FOR 10.  THIS TEST PASSES IF C(AC10)=10.
;IF THIS TEST FAILS, THE AC HARDWARE IS PROBABLY FAULTY

C400:	MOVEI	10,10		;PRELOAD AC10 WITH 10
	CAIE	10,10		;PASS IF C(AC10)=10
	STOP

;**********
SN=500
	ZZ=-1

;THIS TEST VERIFIES THAT ALL ACS EXIST
;FIRST, EACH AC IS PRELOADED WITH ITS OWN ADDRESS;
;THEN, THE CONTENTS OF EACH AC IS CHECKED FOR ITS ADDRESS.
;IF ANY AC DOES NOT CONTAIN ITS ADDRESS, THIS TEST FAILS

C500:	REPEAT	^D16,
<	ZZ=ZZ+1
	MOVEI	ZZ,ZZ		;PRELOAD EACH AC WITH ITS ADDR>
PAGE
	ZZ=20

	REPEAT	^D16,<
;THIS TEST VERIFIES THAT ALL ACS EXIST.
;FIRST, EACH AC IS PRELOADED WITH ITS OWN ADDRESS;
;THEN, THE CONTENTS OF EACH AC IS CHECKED FOR ITS ADDRESS.
;IF ANY AC DOES NOT CONTAIN ITS ADDRESS, THIS TEST FAILS

SN=SN+1
	ZZ=ZZ-1
	CAIE	ZZ,ZZ		;CHECK THAT EACH AC CONTAINS ITS OWN ADDRESS
	STOP
				;IN CASE OF FAILURE, LOOP TO C500 ADDRESS

;**********
>
SN=600
	ZZ=0

;THIS TEST VERIFIES THAT AN ADDRESS WITHIN THE AC RANGE MAY BE ACCESSED AS
;EITHER AN AC OR A MEMORY LOCATION AND THAT EITHER REFERENCE REFERS TO THE
;SAME HARDWARE.  EACH AC IS PRELOADED WITH ITS ADDRESS; THEN THE CONTENTS OF EACH
;AC IS CHECKED FOR ITS ADDRESS.  IF ANY AC DOES NOT CONTAIN ITS ADDRESS, THIS TEST FAILS.

C600:	REPEAT	^D15,
<	ZZ=ZZ+1
	MOVEI	ZZ		;PRELOAD EACH AC WITH ITS ADDRESS
	MOVEM	ZZ		;BY REFERENCING EACH AC AS MEMORY.>

	ZZ=20

	REPEAT	^D15,<
;THIS TEST VERIFIES THAT AN ADDRESS WITHIN THE AC RANGE MAY BE ACCESSED AS
;EITHER AN AC OR A MEMORY LOCATION AND THAT EITHER REFERENCE REFERS TO THE
;SAME HARDWARE.  EACH AC IS PRELOADED WITH ITS ADDRESS
;THEN THE CONTENTS OF EACH AC IS CHECKED FOR ITS ADDRESS.
;IF ANY AC DOES NOT CONTAIN ITS ADDRESS, THIS TEST FAILS.

SN=SN+1
	ZZ=ZZ-1
	CAIE	ZZ,ZZ		;CHECK THAT EACH AC CONTAINS ITS OWN ADDRESS
	STOP
				;IN CASE OF FAILURE, LOOP TO C600 ADDRESS

;**********
>
SN=700
	ZZ=0

C700:	REPEAT	^D15,<
;THIS TEST VERIFIES THAT THE INDEX REGISTERS ARE ACCESSABLE.
;FIRST, AN INDEX REGISTER IS PRELOADED WITH ITS ADDRESS; THEN,
;IT IS REFERENCED AS AN INDEX REGISTER.  IF IT CONTAINS ITS ADDRESS, THIS TEST PASSES.
;THIS TEST IS REPEATED 15 TIMES IN ORDER TO TEST EACH INDEX REGISTER.

SN=SN+1
	ZZ=ZZ+1
	MOVEI	ZZ,ZZ		;PRELOAD INDEX REGISTER WITH ITS ADDRESS
	CAIE	ZZ,(ZZ)		;PASS IF INDEX REGISTER CONTAINS ITS ADDRESS
	STOP

;**********
>
SN=1000
	ZZ=0

C1000:	REPEAT	^D15,<
;THIS TEST VERIFIES THAT ALL INDEX REGISTERS INDEX CORRECTLY.
;FIRST, BOTH HALVES OF THE INDEX REGISTER ARE PRELOADED WITH ITS ADDRESS.
;THEN, THE INDEX REGISTER IS REFERENCED.  IT IS THEN CHECKED FOR ITS ADDRESS IN BOTH HALVES.
;IF IT CONTAINS ITS ADDRESS IN BOTH HALVES THIS TEST PASSES.
;THIS TEST IS REPEATED 15 TIMES IN ORDER TO TEST EACH INDEX REGISTER

SN=SN+1
	ZZ=ZZ+1
	MOVEI	ZZ,ZZ		;PRELOAD BOTH HALVES OF INDEX REG WITH ITS ADDRESS
	HRLI	ZZ,ZZ		;PASS IF INDEX REGISTER CONTAINS ITS ADDRESS
	CAME	ZZ,(ZZ)		;IN BOTH HALVES
	STOP

;**********
>
SUBTTL	TEST OF INDEX REGISTER ADDRESSING

;**********

;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A 0,
;THE FINAL RESULT IN AC3 SHOULD BE 0.  IF C(AC3)=0, THIS TEST PASSES.

C1100:	SETOM	3		;PRELOAD AC3 WITH -1,,1
	SETZM	1		;PRELOAD AC1 WITH 0
	MOVEI	2,1		;SETUP INDEX REGISTER 2 WITH 1
	MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
	SKIPE	3		;TEST INDEXING
	STOP

;**********

SN=1200
	ZZ=0

C1200:	REPEAT	^D18,<
;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
;FLOATING 1.  THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 1.
;IF C(AC3)=A FLOATING 1, THIS TEST PASSES.

SN=SN+1
	ZZ=ZZ+ZZ
	IFE	ZZ,<ZZ=1>
	SETOM	3		;PRELOAD AC3 WITH -1,,-1
	MOVEI	1,ZZ		;PRELOAD AC1 WITH FLOATING 1
	MOVEI	2,1		;SETUP INDEX REGISTER
	MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
	CAIE	3,ZZ		;TEST INDEXING
	STOP

;**********
>
SN=1300
	ZZ=0

C1300:	REPEAT	^D18,<
;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
;FLOATING 1, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 1.
;IF C(AC3)=A FLOATING 1, THIS TEST PASSES.

SN=SN+1
	ZZ=ZZ+ZZ
	IFE	ZZ,<ZZ=1>
	SETOM	3		;PRELOAD AC3 WITH -1,,-1
	MOVSI	1,ZZ		;PRELOAD AC1 WITH FLOATING 1
	MOVEI	2,1		;SETUP INDEX REGISTER
	MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
	CAME	3,[ZZ,,0]	;TEST INDEXING
	STOP

;**********
>
;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH -1,,-1,
;THE FINAL RESULT IN AC3 SHOULD BE -1,,-1.  IF C(AC3)=-1,,-1, THIS TEST PASSES.

C1400:	SETZM	3		;PRELOAD AC3 WITH 0
	SETOM	1		;PRELOAD AC1 WITH -1,,-1
	MOVEI	2,1		;SETUP INDEX REGISTER
	MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
	CAME	3,[-1,,-1]	;TEST INDEXING
	STOP

;**********

SN=1500
	ZZ=0

C1500:	REPEAT	^D18,<
;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
;FLOATING 0, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 0.
;IF C(AC3)=A FLOATING 0, THIS TEST PASSES.

SN=SN+1
	ZZ=<ZZ+ZZ+1>&777777
	IFE	<ZZ-1>,<ZZ=777776>
	SETZM	3		;PRELOAD AC3 WITH 0
	HRROI	1,ZZ		;PRELOAD AC1 WITH FLOATING 0
	MOVEI	2,1		;SETUP INDEX REGISTER
	MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
	CAME	3,[-1,,ZZ]	;TEST INDEXING
	STOP

;**********
>
SN=1600
	ZZ=0

C1600:	REPEAT	^D18,<
;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
;FLOATING 0, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 0.
;IF C(AC3)=A FLOATING 0, THIS TEST PASSES.

SN=SN+1
	ZZ=<ZZ+ZZ+1>&777777
	IFE	<ZZ-1>,<ZZ=777776>
	SETZM	3		;PRELOAD AC3 WITH 0
	HRLOI	1,ZZ		;PRELOAD AC1 WITH FLOATING 0
	MOVEI	2,1		;SETUP INDEX REGISTER
	MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
	CAME	3,[ZZ,,-1]	;TEST INDEXING
	STOP

;**********
>
;VERIFY INDEXING WHERE 'E' IS NON-ZERO

SN=1700
	ZZ=-1
	XX=-10

;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
;IN THIS TEST, THE INDEX REG IS SET-UP WITH MOVEI ZZ+1,ZZ-XX,
;WHERE ZZ+1 IS THE INDEX REG.  THE AC IS PRELOADED WITH ITS OWN ADDRESS, 0,,ZZ.
;CAIE IS USED TO TEST THE INDEXING OPERATION.
;IF THE RESULT IN C(AC)=XX+C(ZZ+1 - RIGHT), THIS TEST PASSES.
;XX+C(ZZ+1 - RIGHT) SHOULD = ZZ.

C1700:	REPEAT	^D15,
<SN=SN+1
	ZZ=ZZ+1
	XX=XX+3
	MOVEI	ZZ+1,ZZ-XX	;SETUP INDEX REGISTER
	MOVEI	ZZ,ZZ		;PRELOAD AC WITH 0,,ZZ
	CAIE	ZZ,XX(ZZ+1)	;*TEST INDEXING
	STOP

;**********
>
PAGE
SN=2000
	ZZ=-1
	XX=-20

;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
;IN THIS TEST, THE INDEX REG IS SET-UP WITH MOVEI ZZ+1,ZZ-XX,
;WHERE ZZ+1 IS THE INDEX REG.  INDEXING IS TESTED BY LOADING
;THE AC VIA MOVEI ZZ,XX(ZZ+1), WHERE XX+C(ZZ+1)=ZZ.
;IF THE RESULT IN THE AC EQUALS 0,,ZZ, THIS TEST PASSES.

C2000:	REPEAT	^D15,
<SN=SN+1
	ZZ=ZZ+1
	XX=XX+5
	MOVEI	ZZ+1,ZZ-XX	;SETUP INDEX REGISTER
	MOVEI	ZZ,XX(ZZ+1)	;*TEST INDEXING
	CAIE	ZZ,ZZ		;PASS IF C(AC)=0,,ADDRESS OF AC
	STOP

;**********
>
SUBTTL	TEST OF EXCH INSTRUCTION

;**********

;THIS TEST VERIFIES THAT EXCH MOVES C(E) INTO AC AND
;MOVES C(AC) INTO E.
;IN THIS CASE, AC=E=0 AND C(AC)=C(E).  HENCE, THE FINAL RESULT
;IN AC0 SHOULD BE 0.  IF C(AC)=0, THE TEST PASSES.

C2100:	SETZ			;PRELOAD AC,E WITH 0
	EXCH			;*EXCH SHOULD PLACE 0 INTO AC0
	SKIPE			;PASS IF C(AC0)=0
	STOP

;**********

;THIS TEST VERIFIES THAT EXCH MOVES C(E) INTO AC AND
;MOVES C(AC) INTO E.
;IN THIS CASE, AC=E=-1,,-1 AND C(AC)=C(E).  HENCE, THE FINAL RESULT
;IN AC0 SHOULD BE -1,,-1.  IF C(AC)=-1,,-1, THE TEST PASSES.

C2200:	SETO			;PRELOAD AC,E WITH -1,,-1
	EXCH			;*EXCH SHOULD PLACE -1,,-1 INTO AC0
	CAME	[-1]		;PASS IF C(AC0)=-1,,-1
	STOP

;**********
;THIS TEST VERIFIES THAT EXCH MOVES C(E) INTO AC AND
;MOVES C(AC) INTO E.
;IN THIS CASE, C(AC)=-1,,0 AND C(E)=0,,-1.  HENCE, THE FINAL RESULT
;IN THE AC SHOULD BE 0,,-1 AND THE RESULT IN E SHOULD BE -1,,0,
;IF THESE RESULTS OCCUR, THE TEST PASSES.

C2400:	MOVSI	-1		;PRELOAD AC WITH -1,,0
	MOVEI	1,-1		;PRELOAD E WITH 0,,-1
	EXCH	1		;*EXCH SHOULD PLACE 0,,-1 INTO THE AC AND -1,,0 INTO E
	CAME	1,[-1,,0]	;PASS IF C(E)=-1,,0
	STOP
C2410:	CAME	0,[0,,-1]	;PASS IF C(AC)=0,,-1
	STOP

;**********

;THIS TEST VERIFIES THAT EXCH MOVES C(E) INTO AC AND
;MOVES C(AC) INTO E.
;IN THIS CASE, C(AC)=0,,-1 AND C(E)=-1,,0.  HENCE, THE FINAL RESULT
;IN THE AC SHOULD BE -1,,0 AND THE RESULT IN E SHOULD BE 0,,-1.
;IF THESE RESULTS OCCUR, THE TEST PASSES.

C2700:	MOVEI	-1		;PRELOAD AC WITH 0,,-1
	MOVSI	1,-1		;PRELOAD E WITH -1,,0
	EXCH	1		;*EXCH SHOULD PLACE -1,,0 INTO THE AC AND 0,,-1 INTO E
	CAIE	1,-1		;PASS IF C(E)=0,,-1
	STOP
C2710:	CAME	,[XWD -1,0]	;PASS IF C(AC)=-1,,0
	STOP

;**********
;THIS TEST IS A RELIABILITY CHECK OF EXCH.
;FIRST, AC, E ARE PRELOADED WITH 252525,,252525.  THERE, EXCH IS
;EXECUTED 7 TIMES.  THE AC IS THEN CHECKED FOR 252525,,252525.
;IF C(AC)=C(E)=252525,,252525, THIS TEST PASSES.
;IN THIS TEST AC=E=AC0

C3000:	MOVE	[252525252525]	;PRELOAD AC,E WITH 252525,,252525
	REPEAT	7,
<	EXCH			;*EXCH SHOULD PLACE 252525,,252525 INTO AC0>
	CAME	[252525252525]	;PASS IF C(AC0)=252525,,252525
	STOP

;**********
PAGE
;THIS TEST VERIFIES THAT EXCH MOVES C(AC) INTO E AND C(E) INTO THE AC.
;IN THIS CASE, C(AC)=0 AND C(E)=-1,,-1.  EXCH IS EXECUTED 7 TIMES; THEN,
;THE AC IS CHECKED FOR -1,,-1 AND E IS CHECKED FOR 0.  IF EITHER OF THESE
;RESULTS ARE NOT FOUND, THIS TEST FAILS.

C3100:	SETZ			;PRELOAD AC WITH 0
	SETO	1,0		;PRELOAD E WITH -1,,-1
	REPEAT	7,
<	EXCH	1		;*EXCH SHOULD EXCHANGE C(AC) AND C(E)>
	CAME	[-1]		;PASS IF C(AC)=-1,,-1
	STOP
C3110:	CAME	1,[0]		;PASS IF C(E)=0
	STOP

;**********
SUBTTL	TEST OF MOVEM INSTRUCTION

;THIS TEST VERIFIES THAT MOVEM PLACES C(AC) INTO E AND DOES NOT MODIFY C(AC)
;IN THIS CASE, C(AC)=-1,,-1 AND C(E)=0.  HENCE, THE RESULT IN AC AND E SHOULD
;BE -1,,-1.  IF C(AC) AND C(E)=-1,,-1, THIS TEST PASSES

C3200:	SETO			;PRELOAD AC WITH -1,,-1
	SETZ	1,0		;PRELOAD E WITH 0
	MOVEM	1		;*MOVEM SHOULD PLACE -1,,-1 INTO E
	CAME	1,[-1]		;PASS IF C(E)=-1,,-1
	STOP
C3210:	CAME	0,[-1]		;PASS IF C(AC)=-1,,-1
	STOP

;**********
SUBTTL	TEST OF JFCL INSTRUCTION AND ARITHMETIC FLAGS

;**********

;THIS TEST VERIFIES THAT JFCL 17,.+1 ALWAYS RETURNS TO THE NEXT SEQUENTIAL INSTRUCTION
;IF JFCL SKIPS THE NEXT INSTRUCTION, THIS TEST FAILS

C3300:	MOVE	[HALT .+3]	;THIS INSTRUCTION SHOULD NOT AFFECT THE TEST
	JFCL	17,.+1		;*JFCL SHOULD RETURN TO NEXT SEQUENTIAL INSTRUCTION
	CAIA			;SKIP HALT INSTRUCTION IF JFCL PASSES
	STOP

;**********

;THIS TEST VERIFIES THAT JFCL 17,.+1 ALWAYS CLEARS THE CRY0 FLAG.
;ADDI IS USED TO SET CRY0.  THEN, JFCL 17,.+1 IS EXECUTED TO CLEAR CRY0.
;JFCL 4,.+2 IS EXECUTED TO DETERMINE WHETHER CRY0 WAS RESET BY THE PREVIOUS JFCL.
;THIS TEST FAILS IF JFCL 17,.+1 DID NOT CLEAR CRY0

C3400:	MOVE	[-1]		;PRELOAD AC WITH -1,,-1
	ADDI	1		;SET CRY0 FLAG
	JFCL	17,.+1		;*CLEAR ARITHMETIC FLAGS
	JFCL	4,.+2		;PASS IF CRY0 WAS RESET BY PREVIOUS INSTRUCTION
	SKIPA			;SKIP HALT IF CRY0 WAS CLEARED
	STOP

;**********
;THIS TEST VERIFIES THAT JFCL 17,.+1 ALWAYS CLEARS THE CRY1 FLAG.
;ADDI IS USED TO SET CRY1.  THEN, JFCL 17,.+1 IS EXECUTED TO CLEAR CRY1.
;JFCL 4,.+2 IS EXECUTED TO DETERMINE WHETHER CRY1 WAS RESET BY THE PREVIOUS JFCL.
;THIS TEST FAILS IF JFCL 17,.+1 DID NOT CLEAR CRY1

C3500:	MOVE	[-1]		;PRELOAD AC WITH -1,,-1
	ADDI	1		;SET CRY1 FLAG
	JFCL	17,.+1		;*CLEAR ARITHMETIC FLAGS
	JFCL	2,.+2		;PASS IF CRY1 WAS RESET BY PREVIOUS INSTRUCTION
	SKIPA			;SKIP HALT IF CRY1 WAS CLEARED
	STOP

;**********

;THIS TEST VERIFIES THAT JFCL 17,.+1 ALWAYS CLEARS THE AROV FLAG.
;ADDI IS USED TO SET AROV.  THEN, JFCL 17,.+1 IS EXECUTED TO CLEAR AROV.
;JFCL 4,.+2 IS EXECUTED TO DETERMINE WHETHER AROV WAS RESET BY THE PREVIOUS JFCL.
;THIS TEST FAILS IF JFCL 17,.+1 DID NOT CLEAR AROV

C3600:	MOVSI	400000		;PRELOAD AC WITH -1,,-1
	ADD	[XWD 400000,0]	;SET AROV FLAG
	JFCL	17,.+1		;*CLEAR ARITHMETIC FLAGS
	JFCL	10,.+2		;PASS IF AROV WAS RESET BY PREVIOUS INSTRUCTION
	SKIPA			;SKIP HALT IF AROV WAS CLEARED
	STOP

;**********
;THIS TEST VERIFIES THAT JFCL 0, IS A NO-OP.
;IN THIS TEST, ADD IS USED TO SET CRY0.  THEN JFCL 0,.+2 IS EXECUTED.
;IF JFCL 0,.+2 DOES NOT SKIP THE NEXT INSTRUCTION, THIS TEST PASSES

C3700:	MOVSI	400000		;PRELOAD AC WITH MOST NEGATIVE NUMBER
	ADD	[-1]		;SET CRY0 FLAG
	JFCL	.+2		;*JFCL SHOULD RETURN TO NEXT SEQUENTIAL INSTRUCTION
	SKIPA			;PASS IF JFCL DID NOT SKIP
	STOP

;**********

;THIS TEST VERIFIES THAT JFCL 0, IS A NO-OP.
;IN THIS TEST, ADD IS USED TO SET CRY1.  THEN JFCL 0,.+2 IS EXECUTED.
;IF JFCL 0,.+2 DOES NOT SKIP THE NEXT INSTRUCTION, THIS TEST PASSES

C4000:	MOVSI	200000		;PRELOAD AC WITH MOST NEGATIVE NUMBER
	ADD	[XWD 200000,0]	;SET CRY1 FLAG
	JFCL	.+2		;*JFCL SHOULD RETURN TO NEXT SEQUENTIAL INSTRUCTION
	SKIPA			;PASS IF JFCL DID NOT SKIP
	STOP

;**********
;THIS TEST VERIFIES THAT ADDI HAS THE ABILITY TO SET AN ARITHMETIC FLAG AND
;THAT 'JFCL 17,.+2' JUMPS WHENEVER ANY ARITHMETIC FLAG IS SET.
;IN THIS TEST, ADDI SHOULD SET CRY0 AND CRY1.  THEN, JFCL SHOULD SKIP
;BECAUSE A FLAG WAS SET BY ADDI
;IF THIS TEST FAILS, ADDI COULD HAVE FAILED TO SET A FLAG OR
;JFCL COULD HAVE FAILED TO JUMP WHEN A FLAG WAS SET

C4100:	MOVE	[-1]		;PRELOAD AC WITH ALL ONES
	ADDI	1		;*ADDI SHOULD SET CRY0/1 FLAGS
	JFCL	17,.+2		;*JFCL SHOULD JUMP BECAUSE FLAGS ARE SET
	STOP

;**********

;THIS TEST VERIFIES THAT CAI DOES NOT CLEAR ANY ARITHMETIC FLAGS.
;FIRST, CRY0 AND CRY1 ARE SET BY ADDI; THEN CAI IS EXECUTED.
;JFCL SHOULD JUMP BECAUSE FLAGS ARE SET.  IF JFCL DOES NOT JUMP,
;THE FLAGS WERE CLEARED BY CAI.  HENCE, CAI FAILED

C4200:	MOVE	[-1]		;PRELOAD AC WITH -1,,-1
	ADDI	1		;SET CYR0/1 FLAGS
	CAI	17,17		;*CAI SHOULD NOT CLEAR FLAGS
	JFCL	17,.+2		;PASS IF CAI CLEARED FLAGS
	STOP

;**********
;THIS TEST VERIFIES THAT ADDI HAS THE ABILITY TO SET AN ARITHMETIC FLAG AND
;THAT 'JFCL 17,.+2' JUMPS WHENEVER ANY ARITHMETIC FLAG IS SET.
;IN THIS TEST, ADDI SHOULD SET CRY0 AND CRY1.  THEN JFCL SHOULD SKIP
;BECAUSE A FLAG WAS SET BY ADDI
;IF THIS TEST FAILS, ADDI COULD HAVE FAILED TO SET A FLAG OR
;JFCL COULD HAVE FAILED TO JUMP WHEN A FLAG WAS SET

C4300:	MOVE	[-1]		;PRELOAD AC WITH ALL ONES
	ADDI	1		;*ADDI SHOULD SET CRY1 FLAGS
	JFCL	2,.+2		;*JFCL SHOULD JUMP BECAUSE CRY1 FLAG IS SET
	STOP

;**********

;THIS TEST VERIFIES THAT ADDI HAS THE ABILITY TO SET AN ARITHMETIC FLAG AND
;THAT 'JFCL 17,.+2' JUMPS WHENEVER ANY ARITHMETIC FLAG IS SET.
;IN THIS TEST, ADDI SHOULD SET CRY0 AND CRY1.  THEN, JFCL SHOULD SKIP
;BECAUSE A FLAG WAS SET BY ADDI
;IF THIS TEST FAILS, ADDI COULD HAVE FAILED TO SET A FLAG OR
;JFCL COULD HAVE FAILED TO JUMP WHEN A FLAG WAS SET

C4400:	MOVE	[-1]		;PRELOAD AC WITH ALL ONES
	ADDI	1		;*ADDI SHOULD SET CRY0 FLAG
	JFCL	4,.+2		;*JFCL SHOULD JUMP BECAUSE CRY0 FLAG IS SET
	STOP

;**********
;THIS TEST VERIFIES THAT ADDI HAS THE ABILITY TO SET AN ARITHMETIC FLAG AND
;THAT 'JFCL 17,.+2' JUMPS WHENEVER ANY ARITHMETIC FLAG IS SET.
;BECAUSE A FLAG WAS SET BY ADD
;IF THIS TEST FAILS, ADDI COULD HAVE FAILED TO SET A FLAG OR
;JFCL COULD HAVE FAILED TO JUMP WHEN A FLAG WAS SET

C4500:	MOVSI	400000		;PRELOAD AC WITH ALL ONES
	ADD	[XWD 400000,0]	;*ADD SHOULD SET AROV FLAG
	JFCL	10,.+2		;*JFCL SHOULD JUMP BECAUSE AROV FLAG IS SET
	STOP

;**********

;THIS TEST VERIFIES THAT JFCL 17,.+1 ALWAYS CLEARS THE FLOATING OVERFLOW FLAG (FOV).
;FIRST JFCL 17,.+1 IS EXECUTED TO CLEAR FOV.  THEN, JFCL 1,.+2 IS EXECUTED TO DETERMINE
;WHETHER FOV WAS CLEARED.  IF FOV WAS CLEAR, THIS TEST PASSES

C4600:	JFCL	17,.+1		;*CLEAR ARITHMETIC FLAGS
	JFCL	1,.+2		;PASS IF FOV WAS CLEARED
	SKIPA			;SKIP HALT IF TEST PASSED
	STOP

;**********
;THIS TEST VERIFIES THAT JFCL 13, DOES NOT RESET CRY0.
;FIRST CRY0 AND CRY1 ARE SET BY ADDI; THEN, JFCL 13,.+2 IS EXECUTED
;TO CLEAR ALL ARITHMETIC FLAGS EXCEPT CRY0.
;THIS TEST PASSES IF JFCL 13,.+1 DID NOT RESET CRY0.

C4700:	MOVE	[-1]		;RELOAD AC WITH -1,,-1
	ADDI	1		;SET CRY0/1
	JFCL	13,.+1		;*JFCL 13, SHOULD NOT RESET CRY0
	JFCL	4,.+2		;FAIL IF CRY 0 WAS RESET
	STOP

;**********

;THIS TEST VERIFIES THAT JFCL 15, DOES NOT RESET CRY1.
;FIRST CRY0 AND CRY1 ARE SET BY ADDI; THEN, JFCL15,.+2 IS EXECUTED
;TO CLEAR ALL ARITHMETIC FLAGS EXCEPT CRY1.
;THIS TEST PASSES IF JFCL 15,.+1 DID NOT RESET CRY1.

C5000:	MOVE	[-1]		;PRELOAD AC WITH -1,,-1
	ADDI	1		;SET CRY0/1
	JFCL	15,.+1		;*JFCL15, SHOULD NOT RESET CRY0
	JFCL	2,.+2		;FAIL IF CRY1 WAS RESET
	STOP

;**********
;THIS TEST VERIFIES THAT JFCL 17, DOES NOT RESET AROV.
;FIRST AROV IS SET BY ADD; THEN, JFCL 17,.+2 IS EXECUTED
;TO CLEAR ALL ARITHMETIC FLAGS EXCEPT AROV.
;THIS TEST PASSES IF JFCL 17,.+1 DID NOT RESET AROV.

C5100:	MOVSI	400000		;PRELOAD AC WITH -1,,-1
	ADD	[XWD 400000,0]	;SET AROV
	JFCL	7,.+1		;*JFCL 17, SHOULD NOT RESET AROV
	JFCL	10,.+2		;FAIL IF AROV WAS RESET
	STOP

;**********

;THIS TEST VERIFIES THAT ADD OF 0 TO 0 WILL NOT SET AROV.
;FIRST, ALL FLAGS ARE RESET, THEN 0 IS ADDED TO 0 VIA ADD.
;AROV IS THEN CHECKED.  IF AROV IS SET, THIS TEST FAILS.

C5200:	JFCL	17,.+1		;RESET ARITHMETIC FLAGS
	SETZ			;PRELOAD AC,E WITH 0
	ADD			;*ADD SHOULD NOT SET AROV
	JFCL	10,.+2		;PASS IF AROV WAS RESET
	SKIPA			;SKIP HALT IF ADD PASSED
	STOP

;**********
;THIS TEST VERIFIES THAT ADD OF 0 TO 0 WILL NOT SET CRY0.
;FIRST, ALL FLAGS ARE RESET, THEN 0 IS ADDED TO 0 VIA ADD.
;CRY0 IS THEN CHECKED.  IF CRY0 IS SET, THIS TEST FAILS.


C5300:	SETZ			;RESET ARITHMETIC FLAGS
	JFCL	17,.+1		;PRELOAD AC,E WITH 0
	ADD			;*ADD SHOULD NOT SET CRY0
	JFCL	4,.+2		;PASS IF CRY0 WAS RESET
	SKIPA			;SKIP HALT IF ADD PASSED
	STOP

;**********

;THIS TEST VERIFIES THAT ADD OF 0 TO 0 WILL NOT SET CRY1.
;FIRST, ALL FLAGS ARE RESET, THEN 0 IS ADDED TO 0 VIA ADD.
;CRY1 IS THEN CHECKED.  IF CRY1 IS SET, THIS TEST FAILS.

C5400:	SETZ			;RESET ARITHMETIC FLAGS
	JFCL	17,.+1		;PRELOAD AC,E WITH 0
	ADD			;*ADD SHOULD NOT SET CRY1
	JFCL	2,.+2		;PASS IF CRY1 WAS RESET
	SKIPA			;SKIP HALT IF ADD PASSED
	STOP

;**********
;THIS TEST VERIFIES THAT THE 30X AND THE 31X INSTRUCTION GROUPS DO NOT AFFECT
;THE ARITHMETIC FLAGS.  FIRST, THE FLAGS ARE CLEARED AND AC0 IS CLEARED; THEN, CAI
;AND CAM ARE EXECUTED.  THE FLAGS ARE THEN CHECKED.  IF ANY OF THE FLAGS ARE SET,
;THIS TEST FAILS AND CAI OR CAM IS CONSIDERED TO HAVE ERRONEOUSLY SET THE FLAGS

C5500:	JFCL	17,.+1		;CLEAR ALL FLAGS
	SETZ			;CLEAR AC,0
	CAI			;*CAI SHOULD NOT SET ANY ARITHMETIC FLAG
	CAM	[-1]		;*CAM SHOULD NOT SET ANY ARITHMETIC FLAG
	JFCL	17,.+2		;FAIL IF ANY FLAG WAS SET
	SKIPA			;SKIP HALT IF TEST PASSED
	STOP

;**********

;THIS TEST VERIFIES THAT THE BOOLEAN INSTRUCTION GROUPS DO NOT AFFECT
;THE ARITHMETIC FLAGS.  FIRST THE FLAGS ARE CLEARED AND AC0 IS CLEARED; THEN, XOR [0]
;AND XOR [-1] ARE EXECUTED.  THE FLAGS ARE THEN CHECKED.  IF ANY OF THE FLAGS ARE SET,
;THIS TEST FAILS AND XOR IS CONSIDERED TO HAVE ERRONEOUSLY SET THE FLAGS

C5600:	JFCL	17,.+1		;CLEAR ALL FLAGS
	SETO			;CLEAR AC,0
	XOR	[0]		;*XOR SHOULD NOT SET ANY ARITHMETIC FLAG
	XOR	[-1]		;*XOR SHOULD NOT SET ANY ARITHMETIC FLAG
	JFCL	17,.+2		;FAIL IF ANY FLAG WAS SET
	SKIPA			;SKIP HALT IF TEST PASSED
	STOP

;**********
;THIS TEST VERIFIES THAT THE AOBJX INSTRUCTION GROUP DOES DO NOT AFFECT
;THE ARITHMETIC FLAGS.  FIRST THE FLAGS ARE CLEARED AND AC0 IS CLEARED; THEN, AOBJN
;AND AOBJP ARE EXECUTED.  THE FLAGS ARE THEN CHECKED.  IF ANY OF THE FLAGS ARE SET,
;THIS TEST FAILS AND AOBJN OR AOBJP IS CONSIDERED TO HAVE ERRONEOUSLY SET THE FLAGS

C5700:	SETO			;CLEAR ALL FLAGS
	JFCL	17,.+1		;CLEAR AC,0
	AOBJN	.+1		;*AOBJN SHOULD NOT SET ANY ARITHMETIC ARITHMETIC
	AOBJP	.+1		;*AOBJP SHOULD NOT SET ANY ARITHMETIC FLAG
	JFCL	17,.+2		;FAIL IF ANY FLAG WAS SET
	SKIPA			;SKIP HALT IF TST PASSED
	STOP

;**********
;THIS TEST VERIFIES THAT SKIP DOES NOT AFFECT THE FLAGS.
;FIRST, THE ARITHMETIC FLAGS ARE CLEARED; THEN, SKIP IS EXECUTED.
;IF SKIP SETS AROV, CRYO, CRY1 OR FOV, THIS TEST FAILS.

C5701:	JFCL	17,.+1		;CLEAR ALL FLAGS
	SKIP	0,[-1]		;*SKIP SHOULD NOT SET ANY FLAGS
	JFCL	17,.+2		;FAIL IF ANY FLAG IS SET
	SKIPA			;PASS IF NO FLAG IS SET
	STOP

;**********

;THIS TEST VERIFIES THAT JUMP DOES NOT AFFECT THE FLAGS.
;FIRST, THE ARITHMETIC FLAGS ARE CLEARED; THEN, JUMP IS EXECUTED.
;IF JUMP SETS AROV, CRYO, CRY1 OR FOV, THIS TEST FAILS.

C5702:	JFCL	17,.+1		;CLEAR ALL FLAGS
	JUMP	0,[-1]		;*JUMP SHOULD NOT SET ANY FLAGS
	JFCL	17,.+2		;FAIL IF ANY FLAG IS SET
	SKIPA			;PASS IF NO FLAG IS SET
	STOP

;**********
SUBTTL	TEST OF JRST INSTRUCTION AND ARITHMETIC FLAGS

;**********

;THIS TEST VERIFIES THAT 'JRST, 0' DOES NOT SET ANY FLAGS.
;FIRST THE ARITHMETIC FLAGS ARE RESET; THEN, 'JRST 0,.+1' IS EXECUTED
;THE AROV,CRY0 AND CRY1 FLAGS ARE THEN CHECKED. IF ANY
;OF THESE FLAGS ARE SET, THIS TEST FAILS

C6000:	JFCL	17,.+1		;RESET ALL FLAGS
	JRST	.+1		;*JRST SHOULD NOT SET ANY FLAGS
	JFCL	16,.+2		;PASS IF NO FLAGS ARE SET
	SKIPA			;SKIP HALT IF JRST PASSES
	STOP

;**********

;THIS TEST VERIFIES THAT 'MOVE 2,2' DOES NOT SET ANY FLAGS.
;FIRST, THE ARITHMETIC FLAGS ARE RESET; THEN, 'MOVE 2,2' IS EXECUTED.
;THE FOV,AROV,CRY0 AND CRY1 FLAGS ARE THEN CHECKED.  IF ANY
;OF THESE FLAGS ARE SET, THIS TEST FAILS

C6100:	JFCL	17,.+1		;RESET ALL FLAGS
	MOVE	2,2		;*MOVE SHOULD NOT SET ANY FLAGS
	JFCL	17,.+2		;PASS IF NO FLAGS ARE SET
	SKIPA			;SKIP HALT IF MOVE PASSED
	STOP

;**********
;THIS TEST VERIFIES THAT JRST 2,.+1(1) WILL SET THE ARITHMETIC FLAG
;SPECIFIED IN AC1.  IN THIS CASE, AC1 SPECIFIES THE CRY0 FLAG.
;FIRST, ALL FLAGS ARE RESET; THEN AC1 IS SET TO SPECIFY CRY0.
;NEXT, JRST 2,.+1(1) IS EXECUTED TO SET CRY0.  CRY0 IS THEN CHECKED.  IF
;CRY0 IS SET, THIS TEST PASSES.  OTHERWISE, JRST 2,.+1 IS FAULTY

C6200:	JFCL	17,.+1		;CLEAR ALL FLAGS
	SFLAG	CRY0		;SET CRY0 FLAG
	JFCL	4,.+2		;PASS IF CRY0 IS SET
	STOP

;**********

;THIS TEST VERIFIES THAT JRST 2,.+(1) WILL SET THE ARITHMETIC FLAG
;SPECIFIED IN AC1.  IN THIS CASE, AC1 CONTAIN 0.  HENCE, JRST 2,.+1(1)
;SHOULD RESET THE ARITHMETIC FLAGS.  FIRST, THE CRY0/1, FLAGS ARE SET BY ADDI;
;THEN THE FLAGS SHOULD BE CLEARED BY JRST 2,.+1.  IF CRY1 WAS CLEARED, THE
;TEST PASSES.  OTHERWISE, JRST 2,.+1 IS FAULTY

C6300:	MOVE	[-1]		;PRELOAD AC0 WITH -1,,-1
	ADDI	1		;SET CRY0/1 FLAGS
	SFLAG	0		;RESET ALL ARITHMETIC FLAGS
	JFCL	2,.+2		;PASS IF CRY1 IS RESET
	SKIPA			;SKIP HALT INSTRUCTION IF TEST PASSED
	STOP

;**********

;THIS TEST VERIFIES THAT JRST 2,.+(1) WILL SET THE ARITHMETIC FLAG
;SPECIFIED IN AC1.  IN THIS CASE, AC1 CONTAIN 0.  HENCE, JRST 2,.+1(1)
;SHOULD RESET THE ARITHMETIC FLAGS.  FIRST, THE CRY0/1, FLAGS ARE SET BY ADD
;THEN THE FLAGS SHOULD BE CLEARED BY JRST 2,.+1.  IF AROV WAS CLEARED, THE
;TEST PASSES.  OTHERWISE, JRST 2,.+1 IS FAULTY

C6400:	MOVSI	400000		;PRELOAD AC0 WITH -1,,-1
	ADD	[-1]		;SET CRY0 AND AROV FLAGS
	SFLAG	0		;RESET ALL ARITHMETIC FLAGS
	JFCL	10,.+2		;PASS IF AROV IS RESET
	SKIPA			;SKIP HALT INSTRUCTION IF TEST PASSED
	STOP

;**********

;THIS TEST VERIFIES THAT JRST 2,.+1(1) WILL SET THE ARITHMETIC FLAG
;SPECIFIED IN AC1.  IN THIS CASE, AC1 SPECIFIES THE AROV FLAG.
;FIRST, ALL FLAGS ARE RESET; THEN AC1 SET TO SPECIFY AROV.
;NEXT, JRST 2,.+1(1) IS EXECUTED TO SET AROV.  AROV IS THEN CHECKED.  IF
;AROV IS SET, THIS TEST PASSES.  OTHERWISE, JRST 2,.+1 IS FAULTY

C6500:	SFLAG	AROV		;SET AROV FLAG
	JFCL	10,.+2		;PASS IF AROV WAS SET
	STOP

;**********
;THIS TEST VERIFIES THAT JRST 2,.+1(1) WILL SET THE ARITHMETIC FLAG
;SPECIFIED IN AC1.  IN THIS CASE, AC1 SPECIFIES THE CRY1 FLAG.
;FIRST, ALL FLAGS ARE RESET; THEN AC1 SET TO SPECIFY CRY1.
;NEXT, JRST 2,.+1(1) IS EXECUTED TO SET CRY1.  CRY1 IS THEN CHECKED.  IF
;CRY1 IS SET, THIS TEST PASSES.  OTHERWISE, JRST 2,.+1 IS FAULTY

C6600:	SFLAG	CRY1		;SET CRY1 FLAG
	JFCL	2,.+2		;PASS IF CRY1 WAS SET
	STOP

;**********

;THIS TEST VERIFIES THAT JRST 2,.+1(1) WILL SET THE ARITHMETIC FLAG
;SPECIFIED IN AC1.  IN THIS CASE, AC1 SPECIFIES THE FOV FLAG.
;FIRST, ALL FLAGS ARE RESET; THEN AC1 SET TO SPECIFY FOV.
;NEXT, JRST 2,.+1(1) IS EXECUTED TO SET FOV.  FOV IS THEN CHECKED.  IF
;FOV IS SET, THIS TEST PASSES.  OTHERWISE, JRST 2,.+1 IS FAULTY

C6700:	SFLAG	FOV		;SET FOV FLAG
	JFCL	1,.+2		;PASS IF FOV WAS SET
	STOP

;**********
;THIS TEST VERIFIES THAT JFCL 0, SHOULD NEVER JUMP.
;FIRST, FOV IS SET VIA JRST2, ;THEN JFCL 0,
;IS EXECUTED.  IF JFCL 0, DOES NOT SKIP, THIS TEST PASSES

C7000:	SFLAG	FOV		;SET FOV FLAG
	JFCL	,.+2		;*JFCL SHOULD NOT JUMP
	SKIPA			;PASS IF JFCL DID NOT JUMP
	STOP

;**********

;THIS TEST VERIFIES THAT JRST 2,.+1(1) WILL SET THE ARITHMETIC FLAG
;SPECIFIED IN AC1.  IN THIS CASE, AC1 CONTAINS 0.  HENCE, JRST 2,.+1(1)
;SHOULD RESET THE ARITHMETIC FLAGS.  FIRST, THE CRY0, FLAG IS SET BY JRST 2,.+1(1)
;WITH C(AC1)=CRY0.  THEN, THE FLAGS SHOULD BE CLEARED BY JRST 2,.+1 WITH C(AC1)=0.
;IF CRY0 WAS CLEARED, THE TEST PASSES.  OTHERWISE, JRST 2,.+1 IS FAULTY

C7100:	SFLAG	CRY0		;SET CRY0 FLAGS
	SETZ	1,		;SETUP MASK TO CLEAR ARITHMETIC FLAGS
	JRST	2,.+1(1)	;*RESET ARITHMETIC FLAGS
	JFCL	4,.+2		;PASS IF CRY0 FLAG WAS RESET
	SKIPA			;SKIP HALT INSTRUCTION IF TEST PSSED
	STOP

;**********
;THIS TEST VERIFIES THAT JRST 2,.+1(1) WILL SET THE ARITHMETIC FLAG
;SPECIFIED IN AC1.  IN THIS CASE, AC1 CONTAINS 0.  HENCE, JRST 2,.+1(1)
;SHOULD RESET THE ARITHMETIC FLAGS.  FIRST, THE FOV, FLAG IS SET BY JRST 2,.+1(1)
;WITH C(AC1)=FOV.  THEN, THE FLAGS SHOULD BE CLEARED BY JRST 2,.+1 WITH C(AC1)=0.
;IF FOV WAS CLEARED, THE TEST PASSES.  OTHERWISE, JRST 2,.+1 IS FAULTY

C7200:	SFLAG	FOV		;SET FOV FLAG
	SETZ	1,		;SETUP MASK TO CLEAR ARITHMETIC FLAGS,
	JRST	2,.+1(1)	;*RESET ARITHMETIC FLAGS
	JFCL	1,.+2		;PASS IF FOV FLAG WAS RESET
	SKIPA			;SKIP HALT INSTRUCTION IF TEST PSSED
	STOP

;**********

;THIS TEST VERIFIES THAT JRST 2,.+1(1) WILL SET THE ARITHMETIC FLAG
;SPECIFIED IN AC1.  IN THIS CASE, AC1 CONTAINS 0.  HENCE, JRST 2,.+1(1)
;SHOULD RESET THE ARITHMETIC FLAGS.  FIRST, THE ARITHMETIC FLAGS ARE RESET BY
;JFCL 17,.+1.  THEN, THE FLAGS SHOULD BE CLEARED BY JRST 2,.+1.
;IF ALL THE ARITHMETIC FLAGS WERE CLEARED,
;THE TEST PASSES.  OTHERWISE, JRST 2,.+1 IS FAULTY

C7300:	JFCL	17,.+1		;CLEAR FLAGS
	SETZ	1,		;SETUP MASK TO CLEAR ARITMETIC FLAGS
	JRST	2,.+1(1)	;*RESET ARITHMETIC FLAGS
	JFCL	17,.+2		;PASS IF ALL FLAGS ARE RESET
	SKIPA			;SKIP HALT INSTRUCTION IF TEST PASSED
	STOP

;**********
SUBTTL	TEST OF JSP INSTRUCTION

;**********

;THIS TEST VERIFIES THAT JSP ALWAYS STORES THE FLAGS AND PC IN THE AC.
;IN THIS CASE, THE FLAGS ARE RESET; THEN, JSP IS EXECUTED.  THE AC IS THEN
;CHECKED FOR ITS CONTENTS NON-ZERO.  IF C(AC)=0, IT INDICATES
;THAT NEITHER THE FLAGS NOR THE PC WAS SAVED.  HENCE, THIS TEST FAILS.

C7400:	SETZB	1		;CLEAR AC AND SETUP MASK TO RESET FLAGS
	JRST	2,.+1(1)	;RESET FLAGS
	JSP	.+1		;*JSP SHOULD STORE FLAGS AND PC IN THE AC
	SKIPN			;PASS IF C(AC) IS NON-ZERO
	STOP			;IT DID NOT STORE ANY FLAGS OR PC

;**********

;THIS TEST VERIFIES THAT JSP ALWAYS STORES THE PC IN THE RIGHT HALF OF THE AC.
;IN THIS CASE, THE AC IS CLEARED, THEN, JSP IS EXECUTED.  THE RIGHT HALF OF
;THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO.  IF C(AC RIGHT HALF)
;IS NON-ZERO, IT INDICATED THAT THE PC WAS SAVED; AND THIS TEST PASSES.

C7500:	SETZ			;CLEAN AC
	JSP	.+1		;*JSP SHOULD STORE THE PC IN THE AC
	TRNN	-1		;PASS IF C(AC) IN NON-ZERO
	STOP

;**********
;THIS TEST VERIFIES THAT JSP ALWAYS STORES THE FLAGS IN THE LEFT HALF OF THE AC.
;FIST, THE AC IS CLEARED; THEN, SOME FLAGS ARE SET AND JSP IS EXECUTED.
;THE LEFT HALF OF THE AC IS CHECKED FOR ITS CONTENTS NON-ZERO TO DETERMINE
;WHETHER THE FLAGS WERE SAVED.  IF C(AC-LEFT) IS NON-ZERO, THIS TEST PASSES

C7600:	SETZM	0		;CLEAR AC
	MOVSI	1,740000	;SET UP MASK TO SET FLAGS
	JRST	2,.+1(1)	;SET SOME ARITHMETIC FLAGS
	JSP	.+1		;*JSP SHOULD STORE FLAGS IN THE AC
	TLNN	-1		;PASS IF C(AC) IS NON-ZERO
	STOP

;**********

;THIS TEST VERIFIES THAT JSP ALWAYS STORES THE FLAGS IN THE LEFT HALF OF THE AC.
;FIRST, THE AC IS CLEARED; THEN, THE AROV FLAG IS SET AND JSP IS EXECUTED.
;THEN, THE AROV FLAG BIT OF
;THE LEFT HALF OF THE AC IS CHECKED FOR ITS CONTENTS NON-ZERO TO DETERMINE
;WHETHER THE AROV FLAG WAS SAVED.  IF THE AROV FLAG BIT OF THE AC IS SET, THIS TEST PASSES

C7700:	SETZM	0		;CLEAR THE AC
	SFLAG	AROV		;SET AROV FLAG
	JSP	.+1		;*JSP SHOULD SAVE THE FLAGS IN THE AC-LEFT
	TLNN	AROV		;PASS IF AROV WAS SAVED
	STOP

;**********
;THIS TEST VERIFIES THAT JSP ALWAYS STORES THE FLAGS IN THE LEFT HALF OF THE AC.
;FIRST, THE AC IS CLEARED; THEN, THE CRY0 FLAG IS SET AND JSP IS EXECUTED.
;THEN, THE CRY0 FLAG BIT OF
;THE LEFT HALF OF THE AC IS CHECKED FOR ITS CONTENTS NON-ZERO TO DETERMINE
;WHETHER THE CRY0 FLAG WAS SAVED.  IF THE CRY0 FLAG BIT OF THE AC IS SET, THIS TEST PASSES

C10000:	SETZM	0		;CLEAR THE AC
	SFLAG	CRY0		;SET CRY0 FLAG
	JSP	.+1		;*JSP SHOULD SAVE THE FLAGS IN THE AC-LEFT
	TLNN	CRY0		;PASS IF CRY0 WAS SAVED
	STOP

;**********

;THIS TEST VERIFIES THAT JSP ALWAYS STORES THE FLAGS IN THE LEFT HALF OF THE AC.
;FIRST, THE AC IS CLEARED; THEN, THE CRY1 FLAG IS SET AND JSP IS EXECUTED.
;THEN, THE CRY1 FLAG BIT OF
;THE LEFT HALF OF THE AC IS CHECKED FOR ITS CONTENTS NON-ZERO TO DETERMINE
;WHETHER THE FLAG WAS SAVED.  IF THE CRY1 FLAG BIT OF THE AC IS SET, THIS TEST PASSES

C10100:	SETZ			;CLEAR AC
	SFLAG	CRY1		;SET CRY1 FLAG
	JSP	.+1		;*JSP SHOULD SAVE THE FLAGS IN THE AC-LEFT
	TLNN	CRY1		;PASS IF AROV WAS SAVED
	STOP

;**********
;THIS TEST VERIFIES THAT JSP ALWAYS STORES THE FLAGS IN THE LEFT HALF OF THE AC.
;FRIST, THE AC IS CLEARED; THEN, THE FOV FLAG IS SET AND JSP IS EXECUTED.
;THEN, THE FOV FLAG BIT OF THE LEFT HALF OF THE AC IS CHECKED FOR
;ITS CONTENTS NON-ZERO TO DETERMINE WHETHER THE FOV FLAG WAS SAVED.
;IF THE FOV FLAG BIT OF THE AC IS SET, THIS TEST PASSES

C10200:	SETZ			;CLEAR THE AC
	SFLAG	FOV		;SET FOV FLAG
	JSP	.+1		;*JSP SHOULD SAVE THE FLAGS IN THE AC-LEFT
	TLNN	FOV		;PASS IF FOV WAS SAVED
	STOP

;**********

;THIS TEST VERIFIES THAT JSP WILL STORE ONLY FLAGS THAT EXIST.
;I.E. RESET FLAGS WILL NOT BE SET IN THE AC.  ONLY FLAGS THAT ARE
;CLEARABLE BY JRSTF WILL BE CHECKED HERE.  FIRST ALL CLEARABLE
;FLAGS ARE RESET BY JRSTF;  THEN JSP IS EXECUTED.  THE AC IS THEN CHECKED.
;IF ANY CLEARABLE FLAGS ARE SET IN THE AC, THIS TEST FAILS.

C10300:	SFLAG	0		;CLEAR ALL CLEARABLE FLAGS
	JSP	.+1		;*JSP SHOULD NOT STORE CLEARABLE FALGS
	TLNE	761777		;FAIL IF ANY CLEARABLE FLAG IS SET
	STOP

;**********
;THIS TEST VERIFIES THAT JSP ALWAYS JUMPS.
;IN THIS TEST, JSP .+2 IS EXECUTED.  IF JSP JUMPS, THE TEST PASSES;
;OTHERWISE, THIS TEST HALTS

C10400:	JSP	.+2		;*JSP SHOULD ALWAYS JUMP
	STOP

;**********
SUBTTL	TEST JRST INSTRUCTION

;**********

;THIS TEST VERIFIES THAT JRST ALWAYS JUMPS.
;IN THIS TEST, JRST .+2 IS EXECUTED.  IF JRST JUMPS, THE TEST PASSES;
;OTHERWISE, THIS TEST HALTS

C10500:	JRST	.+2		;*JRST 0, SHOULD ALWAYS JUMP
	STOP

;**********
SUBTTL	TEST OF AOBJX INSTRUCTIONS

;**********

;THIS TEST VERIFIES THAT AOBJN ALWAYS ADDS 1 TO BOTH HALVES OF THE AC.
;FIRST, THE AC IS CLEARED; THEN, AOBJN IS EXECUTED AND THE AC IS CHECKED
;FOR 1,,1.  IF C(AC)=1,,1, THIS TEST PASSES.

C11200:	SETZ			;CLEAR THE AC
	AOBJN	.+1		;*AOBJN SHOULD ADD 1 TO BOTH HALVES OF THE AC
	CAME	[XWD 1,1]	;PASS IF C(AC)=1,,1
	STOP

;**********

;THIS TEST VERIFIES THAT AOBJP ALWAYS ADDS 1 TO BOTH HALVES OF THE AC.
;FIRST, THE AC IS CLEARED; THEN AOBJP IS EXECUTED AND THE AC IS CHECKED
;FOR 1,,1.  IF C(AC)=1,,1, THIS TEST PASSES.

C11300:	MOVE	[XWD 377777,377777]	;PRELOAD AC WITH 377777,,377777
	AOBJP	.+1			;*AOBJP SHOULD ADD, TO BOTH HALVES OF THE AC
	CAME	[XWD 400000,400000]	;PASS IF C(AC)=400000,400000
	STOP

;**********
;THIS TEST VERIFIES THAT AOBJN WILL NOT JUMP WHEN C(AC) IS POSITIVE
;FIRST, THE AC IS CLEARED; AND AOBJN IS EXECUTED.  AOBJN SHOULD NOT JUMP
;BECAUSE C(AC) IS POSITIVE.  IF AOBJN JUMPS, THIS TEST FAILS

C11400:	SETZ			;CLEAR THE AC
	AOBJN	.+2		;*AOBJN SHOULD NOT JUMP WHEN C(AC) IS POSITIVE
	SKIPA			;PASS IF AOBJN DOES NOT JUMP
	STOP

;**********

;THIS TEST VERIFIES THAT AOBJP WILL JUMP WHEN C(AC) IS POSITIVE
;FIRST, THE AC IS CLEARED; AND AOBJP IS EXECUTED.  AOBJP SHOULD JUMP
;BECAUSE C(AC) IS POSITIVE.  IF AOBJP DOES NOT JUMP, THIS TEST FAILS

C11500:	SETZ			;CLEAR THE AC
	AOBJP 	.+2		;*AOBJP SHOULD JUMP BECAUSE C(AC) IS POSITIVE
	STOP

;**********
;THIS TEST VERIFIES THAT AOBJN WILL JUMP WHEN C(AC) IS NEGATIVE
;FIRST, THE AC IS PRELOADED WITH 400000,,0; AND AOBJN IS EXECUTED.  AOBJN SHOULD JUMP
;BECAUSE C(AC) IS NEGATIVE.  IF AOBJN DOES NOT JUMP, THIS TEST FAILS

C11600:	MOVE	[XWD 400000,400000]	;PRELOAD AC WITH 400000,,400000
	AOBJN	.+2		;*AOBJN SHOULD JUMP BECAUSE C(AC) IS NEGATIVE
	STOP

;**********

;THIS TEST VERIFIES THAT AOBJP WILL NOT JUMP WHEN C(AC) IS NEGATIVE.  FIRST,
;THE AC IS PRELOADED WITH 400000,,0; AND AOBJP IS EXECUTED.  AOBJP SHOULD NOT JUMP
;BECAUSE C(AC) IS NEGATIVE.  IF AOBJP JUMPS, THIS TEST FAILS

C11700:	MOVE	[XWD 400000,400000]	;PRELOAD AC WITH 400000,,400000
	AOBJP	.+2		;*AOBJP SHOULD NOT JUMP BECAUSE C(AC) IS NEGATIVE
	SKIPA			;PASS IF AOBJP DOES NOT JUMP
	STOP

;**********
;THIS TEST VERIFIES THAT THERE IS A CARRY FROM BIT 18 TO BIT 17 OF THE AC ON AOBJN.
;THE AC IS PRELOADED WITH -1,,-1; THEN AOBJN IS EXECUTED. AOBJN SHOULD ADD ONE
;TO BOTH HALVES OF THE AC, GENERATING A CARRY FROM BIT 18 TO BIT 17. IF A
;CARRY WAS GENERATED, THIS TEST PASSES

C12000:	SETO			;PRELOAD AC WITH -1,, -1
	AOBJN	.+1		;*AOBJN SHOULD GENERATE A CARRY FROM BIT 18 TO 17
	CAME	[1,,0]		;PASS IF C(AC)=1,,0 (CARRY WAS GENERATED)
	STOP

;**********
SUBTTL	TEST SETTING OF ARITHMETIC FLAGS VIA MOVNX AND MOVMX

;THIS TEST VERIFIES THAT MOVNI SETS CRY0 AND CRY1 FLAGS ONLY WHEN THE DATA IS 0.
;FIRST, THE ARITHMETIC FLAGS ARE RESET; THEN, MOVNI IS EXECUTED WITH DATA OF ZEROS.
;THE ARITHMETIC FLAGS ARE CHECKED.
; CRY0/1 ARE SET AND AROV AND FOV RESET, THIS TEST PASSES.

C12100:	JFCL	17,.+1		;CLEAR FLAGS
	MOVNI	0		;* MOVNI 0 SHOULD SET CRY0/1
	JCRY0	.+2		;PASS IF CRY0 IS SET
	STOP
	JCRY1	.+2		;PASS IF CRY1 IS SET
	STOP
	JOV	.+2		;PASS IF AROV RESET
	SKIPA
	STOP
	JFOV	.+2		;PASS IF FOV RESET
	SKIPA
	STOP

;**********

;THIS TEST VERIFIES THAT MOVN WILL NOT SET ARITHMETIC FLAGS WHEN THE DATA IS -1,,-1.
;FIRST, THE FLAGS ARE RESET; THEN, MOVN [-1,,-1] IS EXECUTED.
;THE ARITHMETIC FLAGS ARE CHECKED.
;IF ANY ARITHMETIC FLAG IS SET, THIS TEST FAILS.

C12200:	JFCL	17,.+1		;CLEAR FLAGS
	MOVN	[-1]		;*MOVN [-1,,-1] SHOULD SET ARITHMETIC FLAGS
	JFCL	17,.+2		;FAIL IF AN ARITHMETIC FLAG IS SET
	SKIPA			;SKIP HALT INSTRUCTION IF MOVN PASSED.
	STOP

;**********
;THIS TEST VERIFIES THAT MOVN WILL SET THE AROV AND
;CRY1 FLAGS ONLY WHEN THE DATA IS 400000,,0
;FIRST, THE FLAGS ARE RESET; THEN, MOVN [400000,,0] IS EXECUTED.
;THE ARITHMETIC FLAGS ARE CHECKED.
;IF AROV AND CRY1 ARE SET AND CRY0 AND FOV ARE RESET, THIS TEST PASSES.

C12300:	JFCL	17,.+1		;CLEAR ARITHMETIC FLAGS
	MOVN	[XWD 400000,0]	;*MOVN [400000,,0] SHOULD SET AROV AND CRY1 ONLY
	JOV	.+2		;PASS IF AROV IS SET
	STOP
	JCRY1	.+2		;PASS IF CRY0 IS SET
	STOP
	JCRY0	.+2		;PASS IF CRY0 IS RESET
	SKIPA
	STOP
	JFOV	.+2		;PASS IF FOV IS RESET
	SKIPA
	STOP

;**********

;THIS TEST VERIFIES THAT MOVM WILL SET THE AROV AND
;CRY1 FLAGS ONLY WHEN THE DATA IS 400000,,0
;FIRST, THE FLAGS ARE RESET; THEN, MOVM [400000,,0] IS EXECUTED.
;THE ARITHMETIC FLAGS ARE CHECKED.
;IF AROV AND CRY1 ARE SET AND CRY0 AND FOV ARE RESET, THIS TEST PASSES.

C12301:	JFCL	17,.+1		;CLEAR ARITHMETIC FLAGS
	MOVM	[XWD 400000,0]	;*MOVM [400000,,0] SHOULD SET AROV AND CRY1 ONLY
	JOV	.+2		;PASS IF AROV IS SET
	STOP
	JCRY1	.+2		;PASS IF CRY0 IS SET
	STOP
	JCRY0	.+2		;PASS IF CRY0 IS RESET
	SKIPA
	STOP
	JFOV	.+2		;PASS IF FOV IS RESET
	SKIPA
	STOP

;**********
SUBTTL	TEST OF AOS AND SOS INSTRUCTIONS

;**********

;THIS TEST VERIFIES THAT AOS ADDS 1 TO MEMORY AND DOES NOT SKIP.
;FIRST, E IS CLEARED; THEN, AOS IS EXECUTED. NEXT E IS CHECKED FOR 1.
;IF C(E) IS NOT 1 OR AOS SKIPPED, THIS TEST FAILS

C12600:	SETZ			;CLEAR E
	AOS			;*AOS SHOULD ADD 1 TO C(E) AND NOT SKIP
	CAIE	1		;PASS IF C(E)=0,,1 ANDAOS DID NOT SKIP
	STOP

;**********

;THIS TEST VERIFIES THAT AOS ADDS 1 TO MEMORY AND DOES NOT SKIP.
;FIRST, E IS PRELOADED WITH -1,,-1; THEN, AOS IS EXECUTED. NEXT E IS CHECKED FOR 0.
;IF C(E) IS NOT 0 OR AOS SKIPPED, THIS TEST FAILS

C12700:	SETO			;PRELOAD E WITH -1,,-1
	AOS			;*AOS SHOULD ADD 1 TO C(E) AND NOT SKIP
	CAIE			;PASS IF C(E)=0,,0 AND AOS DID NOT SKIP
	STOP

;**********
;THIS TEST VERIFIES THAT SOS SUBTRACTS 1 FROM MEMORY AND DOES NOT SKIP.
;FIRST, E IS CLEARED; THEN, SOS IS EXECUTED. NEXT E IS CHECKED FOR -1,,-1.
;IF C(E) IS NOT -1,,-1 OR SOS SKIPPED, THIS TEST FAILS

C13100:	SETZ			;CLEAR E
	SOS			;*SOS SHOULD SUBTRACT 1 FROM C(E) AND NOT SKIP
	CAME	[-1]		;PASS IF C(E)=-1,,-1 AND SOS DID NOT SKIP
	STOP

;**********

;THIS TEST VERIFIES THAT SOS SUBTRACTS 1 FROM MEMORY AND DOES NOT SKIP.
;FIRST, E IS PRELOADED WITH A; THEN, SOS IS EXECUTED. NEXT E IS CHECKED FOR 0.
;IF C(E) IS NOT 0 OR SOS SKIPPED, THIS TEST FAILS

C13200:	MOVEI	1		;PRELOAD E WITH 1
	SOS			;*SOS SHOULD SUBTRACT 1 FROM C(E) AND DID NOT SKIP
	CAIE	0		;PASS IF C(E)=0 AND SOS DID NOT SKIP
	STOP

;**********
;THIS TEST VERIFIES THAT SOS SETS CRY0/1 FLAGS IF C(E) IS A NON-ZERO NUMBER OTHER
;THAN 400000,,0.  IN THIS CASE, C(E)=1.  FIRST THE FLAGS ARE RESET; THEN
;SOS IS EXECUTED.  THE  FLAGS ARE CHECKED.  IF CRY0 AND CRY1 ARE SET
;AND AROV AND FOV ARE RESET, THIS TEST PASSES.

C13300:	JFCL	17,.+1		;RESET ARITHMETIC FLAGS
	MOVEI	1		;PRELOAD E WITH 1
	SOS			;*SOS SHOULD SET CRY0/1
	JCRY0	.+2		;PASS IF CRY0 IS SET
	STOP
	JCRY1	.+2		;PASS IF CRY1 IS SET
	STOP
	JOV	.+2		;PASS IF AROV IS RESET
	SKIPA
	STOP
	JFOV	.+2		;PASS IF FOV IS RESET
	SKIPA
	STOP

;**********

;THIS TEST VERIFIES THAT AOS SETS CRY0 AND CRY1 FLAG IF C(E) IS -1,,-1
;FIRST THE FLAGS ARE RESET; THEN
;AOS IS EXECUTED.  THE FLAGS ARE CHECKED.
;IF CRY0 AND CRY1 ARE SET AND AROV AND FOV ARE RESET, THIS TEST PASSES.

C13400:	JFCL	17,.+1		;RESET ARITHMETIC FLAGS
	SETO			;PRELOAD E WITH 1
	AOS			;*AOS SHOULD SET CRY0 AND CRY1
	JCRY0	.+2		;PASS IF CRY0 IS SET
	STOP
	JCRY1	.+2		;PASS IF CRY1 IS SET
	STOP
	JOV	.+2		;PASS IF AROV IS RESET
	SKIPA
	STOP
	JFOV	.+2		;PASS IF FOV IS RESET
	SKIPA
	STOP

;**********
SUBTTL	TEST OF INTERACTION OF JFCL, JRST, AND JSP WITH ARITHMETIC FLAGS

;**********

;THIS TEST VERIFIES THAT JFCL 1, WILL ALWAYS CLEAR FOV FLAG.
;FIRST, FOV IS SET VIA JRST 2, ;THEN JFCL 1,.+1 IS EXECUTED TO CLEAR FOV.
;IF FOV WAS CLEARED, THIS TEST PASSES.

C13600:	SFLAG	FOV		;SET FOV FLAG
	JFCL	1,.+1		;*JFCL SHOULD RESET FOV
	JFCL	1,.+2		;PASS IF FOV IS RESET
	SKIPA			;SKIP HALT IF JFCL 1,.+1 PASSED
	STOP

;**********

;THIS TEST VERIFIES THAT JRST 2, CAN SET FXU AND JSP CAN SAVE FXU IN THE AC.
;FIRST, FXU IS SET VIA JRST 2, ;THEN, JSP IS EXECUTED. THE AC IS CHECKED
;FOR FXU.  IF FXU IS SET, THIS TEST PASSES; OTHERWISE, EITHER JRST 2, OR JSP FAILED.

C13700:	SFLAG	FXU		;*SET FXU FLAG
	JSP	.+1		;*STORE FXU FLAG IN AC
	TLNN	FXU		;PASS IF FXU IS SET IN THE AC
	STOP

;**********
;THIS TEST VERIFIES THAT JRST 2, CAN RESET FXU AND JSP CAN SAVE FXU IN THE AC.
;FIRST, FXU IS SET; THEN, FXU IS RESET VIA JRST 2,.  NEXT, JSP IS EXECUTED; AND
;THE AC IS CHECKED FOR FXU RESET.  IF FXU IS RESET IN THE AC, THIS TEST PASSES;
;OTHERWISE, JRST 2, FAILED TO CLEAR FXU OR JSP STORED FXU INCORECTLY.

C14000:	SFLAG	FXU		;SET FXU FLAG
	SFLAG			;*RESET FXU FLAG
	JSP	.+1		;*STORE FXU FLAG IN THE AC
	TLNE	FXU		;PASS IF FXU IS RESET IN THE AC
	STOP

;**********

;THIS TEST VERIFIES THAT JRST 2, CAN SET DCK AND JSP CAN SAVE DCK IN THE AC.
;FIRST, DCK IS SET VIA JRST 2, ;THEN JSP IS EXECUTED.  THE AC IS CHECKED
;FOR DCK.  IF DCK IS SET, THIS TEST PASSES, OTHERWISE JRST 2, OR JSP FAILED.

C14100:	SFLAG	DCK		;*SET DCK FLAG
	JSP	.+1		;*STORE FXU FLAG IN AC
	TLNN	DCK		;PASS IF FXU IS SET IN THE AC
	STOP

;**********
;THIS TEST VERIFIES THAT JRST 2, CAN RESET DCK AND JSP CAN SAVE DCK IN THE AC.
;FIRST, FXU IS SET; THEN, DCK IS RESET VIA JRST 2,.  NEXT, JSP IS EXPECTED; AND
;THE AC IS CHECKED FOR DCK RESET.  IF DCK IS RESET IN THE AC, THIS TEST PASSES;
;OTHERWISE, JRST 2, FAILED TO CLEAR DCK OR JSP STORED DCK INCORRECTLY.

C14200:	SFLAG	DCK		;SET DCK FLAG
	SFLAG			;*RESET DCK FLAG
	JSP	.+1		;*STORE DCK FLAG IN THE AC
	TLNE	DCK		;PASS IF DCK IS RESET IN THE AC
	STOP

;**********
SUBTTL	TEST OF JUMPX INSTRUCTIONS

;**********

;THIS TEST VERIFIES THAT JUMPL IS DATA DEPENDENT.  IT WILL JUMP IF AND ONLY IF
;C(AC) IS NEGATIVE.  IN THIS TEST, THE AC CONTAINS -1,,-1.  HENCE,
;JUMPL SHOULD JUMP.  IF JUMPL JUMPS, THIS TEST PASSES.

C14500:	SETO			;PRELOAD AC WITH -1,,-1
	JUMPL	.+2		;*JUMPL SHOULD JUMP BECAUSE C(AC) IS NEGATIVE
	STOP

;**********

;THIS TEST VERIFIES THAT JUMPL IS DATA DEPENDENT.  IT WILL JUMP IF AND ONLY IF
;C(AC) IS NEGATIVE.  IN THIS TEST, THE AC CONTAINS 0.  HENCE,
;JUMPL SHOULD NOT JUMP.  IF JUMPL DOES NOT JUMP, THIS TEST PASSES.

C14600:	SETZ			;PRELOAD AC WITH 0
	JUMPL	.+2		;*JUMPL SHOULD NOT JUMP
	SKIPA			;PASS IF JUMPL DOES NOT JUMP
	STOP

;**********

;THIS TEST VERIFIES THAT JUMPE IS DATA DEPENDENT.  IT WILL JUMP IF AND ONLY IF
;C(AC)=0.  IN THIS TEST, THE AC CONTAINS 0.  HENCE,
;JUMPE SHOULD JUMP.  IF JUMPE JUMPS, THIS TEST PASSES.

C14700:	SETZ			;PRELOAD AC WITH 0
	JUMPE	.+2		;*JUMPE SHOULD JUMP
	STOP

;**********
;THIS TEST VERIFIES THAT JUMPN IS DATA DEPENDENT.  IT WILL JUMP IF AND ONLY IF
;C(AC) IS NON-ZERO.  IN THIS TEST, THE AC CONTAINS 1.  HENCE,
;JUMPN SHOULD JUMP.  IF JUMPN JUMPS, THIS TEST PASSES.

C15000:	MOVEI	1		;PRELOAD AC WITH 1
	JUMPN	.+2		;*JUMPN SHOULD JUMP
	STOP

;**********

;THIS TEST VERIFIES THAT JUMPE IS DATA DEPENDENT.  IT WILL JUMP IF AND ONLY IF
;C(AC)=0.  IN THIS TEST, THE AC CONTAINS 2.  HENCE,
;JUMPL SHOULD NOT JUMP.  IF JUMPE DOES NOT JUMP, THIS TEST PASSES.

C15100:	MOVEI	2		;PRELOAD AC WITH 2
	JUMPE	.+2		;*JUMPE SHOULD NOT JUMP
	SKIPA			;PASS IF JUMPE DID NOT JUMP
	STOP

;**********

;THIS TEST VERIFIES THAT JUMPN IS DATA DEPENDENT.  IT WILL JUMP IF AND ONLY IF
;C(AC) IS NON-ZERO.  IN THIS TEST, THE AC CONTAINS 0.  HENCE,
;JUMPN SHOULD NOT JUMP.  IF JUMPN DOES NOT JUMP, THIS TEST PASSES.

C15200:	SETZ			;PRELOAD AC WITH 0
	JUMPN	.+2		;*JUMPN SHOULD NOT JUMP
	SKIPA			;PASS IF JUMPN DID NOT JUMP
	STOP

;**********
;THIS TEST VERIFIES THAT JUMPG IS DATA DEPENDENT.  IT WILL JUMP IF AND ONLY IF
;C(AC) IS GREATER THAN 0.  IN THIS TEST, THE AC CONTAINS 1.  HENCE,
;JUMPG SHOULD JUMP.  IF JUMPG JUMPS, THIS TEST PASSES.

C15300:	MOVEI	1		;PRELOAD  AC WITH 1
	JUMPG	.+2		;*JUMPG SHOULD JUMP
	STOP

;**********

;THIS TEST VERIFIES THAT JUMPG IS DATA DEPENDENT.  IT WILL JUMP IF AND ONLY IF
;C(AC) IS GREATER THAN 0.  IN THIS TEST, THE AC CONTAINS -1,,0.  HENCE,
;JUMPG SHOULD NOT JUMP.  IF JUMPG DOES NOT JUMP, THIS TEST PASSES.

C15400:	MOVSI	-1		;PRELOAD AC WITH -1,,0
	JUMPG	.+2		;*JUMPG SHOULD NOT JUMP
	SKIPA			;PASS IF JUMPG DID NOT JUMP
	STOP

;**********
SUBTTL	TEST OF AOJ AND SOJ INSTRUCTIONS

;**********

;THIS TEST VERIFIES THAT AOJ ADDS 1 TO THE AC AND DOES NOT JUMP.
;FIRST, THE AC IS PRELOADED WITH 0; THEN, AOJ IS EXECUTED.  NEXT, THE
;AC IS CHECKED FOR 1.  IF C(AC) IS NOT 1 OR AOJ SKIPPED, THIS TEST FAILS.

C15500:	SETZ			;PRELOAD AC WITH 0
	AOJ	.+2		;*AOJ SHOULD ADD 1 TO THE AC AND NOT JUMP
	CAIE	1		;PASS IF C(AC)=1 AND AOJ DID NOT JUMP
	STOP

;**********

;THIS TEST VERIFIES THAT AOJ ADDS 1 TO THE AC AND DOES NOT JUMP.
;FIRST, THE AC IS PRELOADED WITH -1,,-1; THEN, AOJ IS EXECUTED.  NEXT, THE
;AC IS CHECKED FOR 0.  IF C(AC) IS NOT 0 OR AOJ SKIPPED, THIS TEST FAILS.

C15600:	SETO			;PRELOAD AC WITH 0
	AOJ	.+2		;*AOJ SHOULD ADD 1 TO THE AC AND NOT JUMP
	CAIE	0		;PASS IF C(AC)=1 AND AOJ DID NOT JUMP
	STOP

;**********

;THIS TEST VERIFIES THAT SOJ SUBTRACTS 1 FROM THE AC AND DOES NOT JUMP.
;FIRST, THE AC IS PRELOADED WITH 0; THEN, SOJ IS EXECUTED.  NEXT, THE
;AC IS CHECKED FOR -1,,-1.  IF C(AC) IS NOT -1,,-1 OR SOJ SKIPPED, THIS TEST FAILS.

C15700:	SETZ			;PRELOAD AC WITH 0
	SOJ	.+2		;*SOJ SHOULD SUBTRACT 1 FROM THE AC AND NOT JUMP
	CAME	[-1]		;PASS IF C(AC)=-1,,-1 AND SOJ DID NOT JUMP
	STOP

;**********
;THIS TEST VERIFIES THAT SOJ SUBTRACTS 1 FROM THE AC AND DOES NOT JUMP.
;FIRST, THE AC IS PRELOADED WITH -1,,-1; THEN, SOJ IS EXECUTED.  NEXT, THE
;AC IS CHECKED FOR -1,,-2.  IF C(AC) IS NOT -1,,-2 OR SOJ SKIPPED, THIS TEST FAILS.

C16000:	SETO			;PRELOAD AC WITH -1,,-1
	SOJ	.+2		;*SOJ SHOULD SUBTRACT 1 FROM THE AC AND NOT JUMP
	CAME	[-2]		;PASS IF C(AC)=-1,,-2 AND SOJ DID NOT JUMP
	STOP

;**********

;THIS TEST VERIFIES THAT SOJ SUBTRACTS 1 FROM THE AC AND DOES NOT JUMP.
;FIRST, THE AC IS PRELOADED WITH 0,,1; THEN, SOJ IS EXECUTED.  NEXT, THE
;AC IS CHECKED FOR 0.  IF C(AC) IS NOT 0 OR SOJ SKIPPED, THIS TEST FAILS.

C16100:	MOVEI	1		;PRELOAD AC WITH 1
	SOJ	.+2		;*SOJ SHOULD SUBTRACT 1 FROM THE AC AND NOT JUMP
	CAIE	0		;PASS IF C(AC)=0 AND SOJ DID NOT JUMP
	STOP

;**********
;THIS TEST VERIFIES THAT SOJ AC, FOLLOWED BY AOJ AC, HAS NO NET EFFECT ON C(AC).
;IN THIS CASE, THE AC IS PRELOADED WITH 0; THEN, SOJ AC, FOLLOWED BY AOJ.
;AC, IS REPEATED 7 TIMES.  THE AC IS THEN CHECKED FOR ITS ORIGINAL CONTENTS, 0.
;IF C(AC)=0, THIS TEST PASSES; OTHERWISE AOJ OR SOJ FAILED.

C16200:	AC=17
	SETZ	AC,		;PRELOAD AC WITH 0
	REPEAT	^D10,<
	SOJ	AC,.		;*SOJ SHOULD SUBTRACT 1 FROM THE AC
	AOJ	AC,.		;*AOJ SHOULD ADD 1 TO THE AC>
	SKIPE	AC		;PASS IF C(AC) IS UNCHANGED. I.E. C(AC)=0
	STOP

;**********
;THIS TEST VERIFIES THAT SOJ SETS CRY0/1 FLAGS IF C(E) IS A NON-ZERO NUMBER OTHER
;THAN 400000,,0.  IN THIS CASE, C(E)=1.  FIRST THE FLAGS ARE RESET; THEN
;SOJ IS EXECUTED.  THE  FLAGS ARE CHECKED.  IF CRY0 AND CRY1 ARE SET
;AND AROV AND FOV ARE RESET, THIS TEST PASSES.

C16201:	JFCL	17,.+1		;RESET ARITHMETIC FLAGS
	MOVEI	1		;PRELOAD E WITH 1
	SOJ			;*SOJ SHOULD SET CRY0/1
	JCRY0	.+2		;PASS IF CRY0 IS SET
	STOP
	JCRY1	.+2		;PASS IF CRY1 IS SET
	STOP
	JOV	.+2		;PASS IF AROV IS RESET
	SKIPA
	STOP
	JFOV	.+2		;PASS IF FOV IS RESET
	SKIPA
	STOP

;**********

;THIS TEST VERIFIES THAT AOJ SETS CRY0 AND CRY1 FLAG IF C(E) IS -1,,-1
;FIRST THE FLAGS ARE RESET; THEN
;AOJ IS EXECUTED.  THE FLAGS ARE CHECKED.
;IF CRY0 AND CRY1 ARE SET AND AROV AND FOV ARE RESET, THIS TEST PASSES.

C16202:	JFCL	17,.+1		;RESET ARITHMETIC FLAGS
	SETO			;PRELOAD E WITH 1
	AOJ			;*AOJ SHOULD SET CRY0 AND CRY1
	JCRY0	.+2		;PASS IF CRY0 IS SET
	STOP
	JCRY1	.+2		;PASS IF CRY1 IS SET
	STOP
	JOV	.+2		;PASS IF AROV IS RESET
	SKIPA
	STOP
	JFOV	.+2		;PASS IF FOV IS RESET
	SKIPA
	STOP

;**********
SUBTTL	TEST OF MEMORY, BOTH AND SELF MODE INSTRUCTIONS

;**********

;THIS TEST VERIFIES THAT ADDM DOES NOT MODIFY C(AC)
;BOTH AC AND E ARE PRELOADED WITH -1,,-1.  THEN ADDM IS EXECUTED.
;THIS TEST PASSES IF C(AC) ARE UNCHANGED

C16400:	SETOB	1		;PRELOAD AC, E WITH -1,,-1
	ADDM	1		;*ADDM SHOULD NOT AFFECT C(AC)
	CAME	[-1]		;PASS IF C(AC) IS UNMODIFIED BY ADDM
	STOP

;**********

;THIS TEST VERIFIES THAT HRREM DOES NOT MODIFY C(AC)
;THE AC IS PRELOADED WITH 0,,-1.  THEN HRRM IS EXECUTED.
;THIS TEST PASSES IF C(AC) ARE UNCHANGED

C16500:	MOVEI	-1		;PRELOAD AC WITH 0,,-1
	HRREM	1		;*HRRM SHOULD NOT AFFECT C(AC)
	CAIE	-1		;PASS IF C(AC) IS UNMODIFIED BY HRRM
	STOP

;**********
;THIS TEST VERIFIES THAT MOVSM DOES NOT MODIFY C(AC)
;THE AC IS PRELOADED WITH 0,,-1.  THEN MOVSM IS EXECUTED.
;THIS TEST PASSES IF C(AC) ARE UNCHANGED

C16600:	MOVEI	-1		;PRELOAD AC WITH 0,,-1
	MOVSM	1		;*MOVSM SHOULD NOT AFFECT C(AC)
	CAIE	-1		;PASS IF C(AC) IS UNMODIFIED BY MOVSM
	STOP

;**********

;THIS TEST VERIFIES THAT XORM DOES NOT MODIFY C(AC)
;BOTH AC AND E ARE PRELOADED WITH -1,,-1.  THEN XORM IS EXECUTED.
;THIS TEST PASSES IF C(AC) ARE UNCHANGED

C16700:	SETOB	1		;PRELOAD AC, E WITH -1,,-1
	XORM	1		;*XORM SHOULD NOT AFFECT C(AC)
	CAME	[-1]		;PASS IF C(AC) IS UNMODIFIED BY XORM
	STOP

;**********
;THIS TEST VERIFIES THAT ADDB ADDS C(AC) TO C(E) AND PLACES THE
;RESULT IN BOTH AC AND E.  IN THIS TEST, BOTH AC AND E ARE PRELOADED
;WITH -1,,-1, THEN, ADDB IS EXECUTED.  C(AC) IS THEN COMPARED TO C(E);
;AND C(AC) IS THEN COMPARED TO -2.  IF BOTH OF THESE COMPARISONS SUCCEED, THIS
;TEST PASSES; OTHERWISE, ADDB FAILED

C17000:	SETOB	1		;PRELOAD AC, E WITH -1,,-1
	ADDB	1		;*ADDB SHOULD ADD C(AC) TO C(E) AND PLACE RESULT
				;INTO BOTH AC AND E
	CAME	1		;PASS IF C(AC)=C(E)
	STOP
	CAME	[-2]		;PASS IF C(AC)=-2
	STOP

;**********

;THIS TEST VERIFIES THAT ADDM ADDS C(AC) TO C(E) AND PLACES THE RESULT IN E
;IN THIS CASE, AC, E ARE BOTH PRELOADED WITH -1; THEN, ADDM IS EXECUTED.
;E IS THEN CHECKED FOR -2.  IF C(E)=-2, THIS TEST PASSES; OTHERWISE, ADDM FAILED

C17100:	SETOB	1		;PRELOAD AC, E WITH -1,,-1
	ADDM	1		;*ADDM SHOULD ADD C(AC) TO C(E)
	CAME	1,[-2]		;PASS IF C(E)=-2
	STOP

;**********
;THIS TEST VERIFIES THAT HLLOS PLACES ONES ON THE RIGHT HALF OF E
;BUT DOES NOT AFFECT THE LEFT HALF OF E.  IN THIS CASE,
;E IS PRELOADED WITH 0; THE, HLLOS IS EXECUTED.  THE RESULT
;IN E SHOULD BE 0,,-1.  IF C(E)=0,,-1, THIS TEST PASSES

C17200:	SETZM	1		;PRELOAD E WITH 0
	HLLOS	1		;*HLLOS SHOULD PLACE 0,,-1 INTO E
	CAIE	1,-1		;PASS IF C(E)=0,,-1
	STOP

;**********

;THIS TEST VERIFIES THAT MOVSS SWAPS BOTHS HALVES OF E AND
;PLACES THE RESULT IN E.  IN THIS CASE, E IS PRELOADED WITH
;-1,,0; THEN, MOVSS IS EXECUTED.  THE RESULT IN E SHOULD BE 0,,-1.
;IF C(E)=0,,-1, THIS TEST PASSES

C17300:	MOVSI	1,-1		;PRELOAD E WITH -1,,0
	MOVSS	1		;*MOVSS SHOULD PLACE 0,,-1 INTO E
	CAIE	1,-1		;PASS IF C(E)=0,,-1
	STOP

;**********
;THIS TEST VERIFIES THAT AOS ADDS ONE TO MEMORY BUT DOES NOT SKIP
;FIRST, E IS PRELOADED WITH -1,-1; THEN, AOS IS EXECUTED.  NEXT, E IS CHECKED FOR 0.
;IF C(E) IS NOT 0 OR AOS SKIPPED, THIS TEST FAILS

C17400:	SETOB	1		;PRELOAD E WITH -1,,-1
	AOS	1		;*AOS SHOULD ADD TO C(E) AND NOT SKIP
	CAIE	1,0		;PASS IF C(E)=0,,0 AND AOS DID NOT SKIP
	STOP

;**********

;THIS TEST VERIFIES THAT HRLM PLACES C(AC-RIGHT) INTO E-LEFT AND DOES
;NOT MODIFY E-RIGHT.  IN THIS CASE, AC IS PRELOADED WITH 0 AND E IS PRELOADED
;WITH -1,,-1.  THEN, HRLM IS EXECUTED.  E IS THEN CHECKED FOR 0,,-1.  IF
;C(E)=0,,-1, THIS TEST PASSES

C17500:	SETZ			;PRELOAD AC WITH 0
	SETO	1,		;PRELOAD E WITH -1,,-1
	HRLM	1		;*HRLM SHOULD PLACE 0,,-1 INTO E
	CAIE	1,-1		;PASS IF C(E)=0,,-1
	STOP

;**********
;THIS TEST VERIFIES THAT HRRS DOES NOT MODIFY E
;E IS PRELOADED WITH 0 AND AC IS PRELOADED WITH -1,,-1.
;HRRS IS EXECUTED; THEN E IS CHECKED.  IF C(E) DOES
;NOT CHANGE, THIS TEST PASSES

C17600:	SETO			;PRELOAD AC WITH -1,,-1
	SETZ	1,		;PRELOAD E WITH 0,,0
	HRRS	1		;*HRRS SHOULD PLACE 0,,0 INTO E
	SKIPE	1
	STOP

;**********

;THIS TEST VERIFIES THAT HRRZM PLACES C(AC-RIGHT) INTO E-RIGHT AND PLACES
;ZEROS INTO E-LEFT.  IN THIS CASE, AC=E=AC1 AND C(AC)=C(E)=-1,,0.  HRRZM
;IS EXECUTED AND AC1 IS CHECKED FOR 0.  IF AC1=0, THIS TEST PASSES.

C17700:	SETO			;PRELOAD AC0 WITH -1,,-1
	MOVSI	1,-1		;PRELOAD AC1 WITH -1,,0
	HRRZM	1,1		;*HRRZM SHOULD PLACE 0 INTO AC1
	SKIPE	1		;PASS IF C(AC1)=0
	STOP

;**********
;THIS TEST VERIFIES THAT JFCL 17,.+1 NEVER JUMPS AND DOES NOT MODIFY C(AC0).
;FIRST, AC0 IS PRELOADED; THEN, JFCL IS EXECUTED.  IF AC0 IS MODIFIED
;OR JFCL SKIPS, THIS TEST FAILS

C20000:	SETZ			;CLEAR AC0
	JFCL	17,.+1		;*JFCL SHOULD NOT JUMP OR MODIFY C(AC0).
	SKIPE			;PASS IF C(AC0)=0 AND JFCL DID NOT JUMP
	STOP

;**********

;THIS TEST VERIFIES THAT XORM PERFORMS THE LOGICAL EXCLUSIVE OR FUNCTION
;BETWEEN C(AC) AND C(E) AND PLACES THE RESULT INTO E
;IN THIS CASE, AC AND E ARE PRELOADED WITH -1,,-1; THEN, XORM IS
;EXECUTED.  IF THE RESULT IN E IS 0, THE TEST PASSES

C20100:	SETOB	1		;PRELOAD AC,E WITH -1,,-1
	XORM	1		;*XORM SHOULD PLACE 0 INTO E
	CAIE	1,0		;PASS IF C(E)=0
	STOP

;**********
;THIS TEST VERIFIES THAT SETZB PLACES ZEROS INTO BOTH AC AND E.
;AFTER SETZB IS EXECUTED, BOTH AC AND E ARE CHECKED
;FOR 0.  IF EITHER AC OR E CONTAINS ANY ONES, THIS TEST FAILS

C20200:	SETZB	1		;*SETZB SHOULD PLACE ZEROES IN BOTH AC AND E
	CAMN	[0]		;FAIL IF C(AC) IS NON-ZERO
	CAME	1		;FAIL IF C(E) IS NON-ZERO
	STOP

;**********

;THIS TEST VERIFIES THAT SETAB PLACES C(AC) INTO BOTH AC AND E.
;FIRST, AC IS PRELOADED WITH -1,,-1 AND E IS PRELOADED WITH 0;
;THEN, SETAB IS EXECUTED.  BOTH AC AND E ARE CHECKED FOR -1,,-1
;IF EITHER AC OR E CONTAIN ANY ZEROS, THIS TEST FAILS.

C20300:	SETZ	1,		;PRELOAD E WITH 0
	SETO			;PRELOAD AC WITH -1,,-1
	SETAB	1		;*SETAB SHOULD PLACE -1,,-1 INTO BOTH AC AND E
	CAMN	[-1]		;FAIL IF C(AC) IS NOT -1,-1
	CAME	1		;FAIL IF C(E) IS NOT -1,,-1
	STOP

;**********
SUBTTL	XCT INSTRUCTION - BASIC TESTS

;**********

;THIS TEST VERIFIES THAT XCT WILL EXECUTE THE INSTRUCTION SPECIFIED BY C(E)
;IN THIS CASE, C(E) SPECIFIES A MOVEI INSTRUCTION
;AFTER EXECUTING MOVEI, CONTROL SHOULD RETURN TO
;THE NEXT SEQUENTIAL INSTRUCTION FOLLOWING XCT.
;THIS TEST PASSES IF CONTROL RETURNS TO THE NEXT SEQUENTIAL INSTRUCTION FOLLOWING XCT

C20400:	SETZB	1		;CLEAR AC0 AND AC1
	XCT	[MOVEI 1,.+2]	;*XCT SHOULD RETURN CONTROL TO NEXT INSTRUCTION
	SKIPA
	STOP

;**********

;THIS TEST VERIFIES THAT XCT WILL EXECUTE THE INSTRUCTION SPECIFIED BY C(E)
;IN THIS CASE, C(E) SPECIFIES A MOVEI INSTRUCTION.
;AFTER EXECUTING MOVEI, THE AC SPECIFIED BY MOVEI IS CHECKED FOR
;0,,1 (THE EXPECTED RESULT).  IF C(AC)=0,,1, THIS TEST PASSES

C20500:	SETZB	1		;CLEAR AC
	XCT	[MOVEI 1,1]	;*XCT OF MOVEI SHOULD PLACE 1 IN THE AC
	CAIE	1,1		;PASS IF C(AC)=1
	STOP

;**********
;THIS TEST VERIFIES THAT A NEST OF XCT INSTRUCTIONS WILL EXECUTE
;THE INSTRUCTION SPECIFIED BY THE MOST NESTED XCT AND RETURN CONTROL TO
;THE NEXT SEQUENTIAL INSTRUCTION FOLLOWING THE FIRST XCT.
;IN THIS CASE, THE EXECUTED INSTRUCTION IS MOVEI.  AFTER EXECUTING THE MOVEI,
;C(AC) IS CHECKED FOR 0,,-1 (THE EXPECTED RESULT).  IF C(AC)=0,,-1, THIS TEST PASSES

C20600:	SETZB	1		;CLEAR AC
	XCT	[XCT[XCT[XCT[XCT[MOVEI 1,-1]]]]] ;*NESTED XCT OF MOVEI
				;SHOULD PLACE 0,,-1 INTO AC
	CAIE	1,-1		;PASS IF C(AC)=0,,-1
	STOP

;**********

;THIS TEST VERIFIES THAT XCT WILL NOT MODIFY AN AC WHICH IS NOT SPECIFIED BY THE
;EXECUTED INSTRUCTION.  IN THIS CASE, AC0 IS CLEARED AND THEN CHECKED FOR ZERO AFTER
;THE XCT INSTRUCTION IS EXECUTED.  AC0 SHOULD NOT BE MODIFIED.

C20700:	SETZB	1		;CLEAR AC0,AC1
	XCT	[MOVE 1,[-1]]	;*XCT SHOULD NOT MODIFY AC0
	SKIPE			;PASS IF AC0 WAS NOT MODIFIED
	STOP

;**********
;THIS TEST VERIFIES THAT XCT OF SKIPA SHOULD RETURN CONTROL TO THE
;SECOND SEQUENTIAL INSTRUCTION FOLLOWING XCT

C21000:	XCT	[SKIPA]		;XCT OF SKIPA SHOULD RETURN CONTROL TO .+2
	STOP

;**********
SUBTTL	INDIRECT ADDRESSING - BASIC TESTS

;**********

;THIS TEST VERIFIES THAT INDIRECT ADDRESSING WORKS WHEN BOTH E AND @E
;ARE WITHIN THE AC RANGE.
;THE INSTRUCTION SPECIFYING INDIRECT ADDRESSING IS A MOVE.
;AFTER MOVE IS EXECUTED, C(AC) IS CHECKED FOR 0,
;THE INITIAL CONTENTS OF THE INDIRECT ADDRESS

C21100:	SETOM	1		;PRELOAD AC WITH -1,,-1
	MOVEI	7,3		;SETUP DIRECT ADDRESS WITH INDIRECT ADDRESS
	SETZM	3		;PRELOAD INDIRECT ADDRESS WITH 0
	MOVE	1,@7		;*FWT FROM INDIRECT ADDRESSS SHOULD
				;PLACE 0 INTO THE AC
	SKIPE	1		;PASS IF C(AC)=0
	STOP

;**********

;THIS TEST VERIFIES THAT INDIRECT ADDRESSING WORKS WHEN BOTH E AND @E
;ARE WITHIN THE AC RANGE.
;THE INSTRUCTION SPECIFYING INDIRECT ADDRESSING IS A MOVE.
;AFTER MOVE IS EXECUTED, C(AC) IS CHECKED FOR -1,,-1,
;THE INITIAL CONTENTS OF THE INDIRECT ADDRESS

C21200:	SETZM	1		;PRELOAD AC WITH -1,,-1
	MOVEI	7,3		;SETUP DIRECT ADDRESS WITH INDIRECT ADDRESS
	SETOM	3		;PRELOAD INDIRECT ADDRESS WITH -1,,-1
	MOVE	1,@7		;*FWT FROM INDIRECT ADDRESS SHOULD
				;PLACE -1,,-1 INTO THE AC
	CAME	1,[-1,,-1]	;PASS IF C(AC)=-1,,-1
	STOP

;**********
;THIS TEST VERIFIES THAT INDIRECT ADDRESSING WORKS WHEN BOTH E AND @E
;ARE WITHIN THE AC RANGE.
;THE INSTRUCTION SPECIFYING INDIRECT ADDRESSING IS A MOVE.
;AFTER MOVE IS EXECUTED, C(AC) IS CHECKED FOR 707070,,707070,
;THE INITIAL CONTENTS OF THE INDIRECT ADDRESS

C21300:	SETZM	1		;PRELOAD AC WITH 0
	MOVEI	7,3		;SETUP DIRECT ADDRESS WITH INDIRECT ADDRESS
	MOVE	3,[707070,,707070] ;PRELOAD INDIRECT ADDRESS WITH 707070,,707070
	MOVE	1,@7		;*FWT FROM INDIRECT ADDRESS SHOULD
				;PLACE 707070,,707070 INTO THE AC
	CAME	1,[707070,,707070]	;PASS IF C(AC)=707070,,707070
	STOP

;**********

;THIS TEST VERIFIES THAT INDIRECT ADDRESSING WORKS WHEN E IS WITHIN THE AC RANGE
;AND @E IS BEYOND THE AC RANGE.
;THE INSTRUCTION SPECIFYING INDIRECT ADDRESSING IS A MOVE.
;AFTER MOVE IS EXECUTED, C(AC) IS CHECKED FOR 707070,,707070,
;THE INITIAL CONTENTS OF THE INDIRECT ADDRESS

C21400:	JRST	.+2
	XWD	707070,707070	;INDIRECT ADDRESS AND ITS DATA
	SETZM	1		;PRELOAD AC WITH 0
	MOVEI	7,C21400+1	;SETUP DIRECT ADDRESS WITH INDIRECT ADDRESS
	MOVE	1,@7		;*FWT FROM INDIRECT ADDRESS SHOULD
				;PLACE 707070,,707070 INTO AC
	CAME	1,C21400+1	;PASS IF C(AC)=707070,,707070
	STOP

;**********
;THIS TEST VERIFIES THAT INDIRECT ADDRESSING WORKS WHEN BOTH E AND @E
;ARE BEYOND THE AC RANGE.
;THE INSTRUCTION SPECIFYING INDIRECT ADDRESSING IS A MOVE.
;AFTER MOVE IS EXECUTED, C(AC) IS CHECKED FOR 202020,,202020,
;THE INITIAL CONTENTS OF THE INDIRECT ADDRESS

C21500:	JRST	.+3
		.+1		;DIRECT ADDRESS AND ITS DATA
	XWD	202020,202020	;INDIRECT ADDRESS AND ITS DATA
	SETZM	1		;PRELOAD AC WITH 0
	MOVE	1,@C21500+1	;*FWT FROM INDIRECT ADDRESS SHOULD
				;PLACE 202020,,202020 INTO AC
	CAME	1,C21500+2	;PASS IF C(AC)=202020,,202020
	STOP

;**********

;THIS TEST VERIFIES THAT INDIRECT ADDRESSING WORKS WHEN BOTH E AND @E
;ARE BEYOND THE AC RANGE.
;THE INSTRUCTION SPECIFYING INDIRECT ADDRESSING IS A CAME.

C21600:	JRST	.+3
		.+1		;DIRECT ADDRESS AND ITS DATA
	XWD	272727,272727	;INDIRECT ADDRESS AND ITS DATA
	MOVE	1,C21600+2	;PRELOAD AC
	CAME	1,@C21600+1	;*CAME OF DATA FROM INDIRECT ADDRESS - NON-AC RANGE
	STOP

;**********
;THIS TEST VERIFIES THAT INDIRECT ADDRESSING WORKS WHEN E IS WITHIN THE AC RANGE
;AND @E IS BEYOND THE AC RANGE.
;THE INSTRUCTION SPECIFYING INDIRECT ADDRESSING IS A CAME.

C21700:	JRST	.+2
	XWD	252525,252525	;INDIRECT ADDRESS AND ITS DATA
	MOVEI	7,C21700+1	;SETUP DIRECT ADDRESS WITH INDIRECT ADDRESS
	MOVE	1,C21700+1	;SETUP AC
	CAME	1,@7		;*CAME IF DATA FROM INDIRECT ADDRESS - AC RANGE
	STOP

;**********
SUBTTL	TEST INDIRECT ADDRESSING WITH INDEXING

;SETUP INDEX REGISTERS

	MOVEI	1,-4
	MOVEI	3,2
	MOVEI	4,10
	MOVEI	5,1
	MOVEI	6,5
	MOVEI	7,7
	MOVEI	10,4
	MOVEI	11,-6
	MOVEI	12,5
	MOVEI	13,2

	JRST	C22000		;RESUME TEST

;INDIRECT ADDRESSING/INDEXING TEST TABLE

;;;;;;;;;;;          ;;;;;;;;;;          ;;;;;;;;;;

;DO NOT MODIFY THIS TABLE OR TESTS C21700 THRU C22600 INDEPENDENTLY !

;;;;;;;;;;          ;;;;;;;;;;          ;;;;;;;;;;

E217:		E217A(3)
E220:		@E220A
E220B:	220220,,220220
E217A:		@E221A		;E221-4
E221B:	221221,,221221
E222A:	217217,,217217		;E217A+2
E220A:		E220B
E221:		E221
E221A:		E221B
E222:		E221
E223A:	223223,,223223
E224A:		E224A(4)	;E223-6
	222222,,222222		;E222A+7
E225:		E225
		E222A(7)	;E222+5
		@E225A		;E225+2
E225B:	225225,,225225
E223:		E223
E225A:		E225B
	224224,,224224		;E224A+10
E226B:	226226,,226226
		E223A		;E223+4
E226A:		@E226A(5)	;E223+5
		E226B		;E226A+1
;THIS TEST VERIFIES THAT INDIRECT ADDRESSING IN COMBINATION WITH INDEXING FUNCTIONS CORRECTLY.
;IN THIS CASE, MOVE 2,@E217 IS TESTED WHERE C(E217)=E217A(3) AND C(3)=0,,2.
;HENCE, THE RESULT IN THE AC SHOULD BE C(E217A+2)=217217,,217217

C22000:	SETOM	2		;INITIALIZE AC
	MOVE	2,@E217		;TEST INDIRECT ADDRESSING WITH INDEXING
	CAME	2,E217A+2	;PASS IF C(AC)=217217,,217217
	STOP

;**********

;THIS TEST VERIFIES THAT INDIRECT ADDRESSING IN COMBINATION WITH INDEXING FUNCTIONS CORRECTLY.
;IN THIS CASE, MOVE 2,@E220 IS TESTED WHERE C(E220)=@E220A AND C(E220A)=E220B.
;HENCE, THE RESULT IN THE AC SHOULD BE C(E220B)=220220,,220220

C22100:	SETZM	2		;INITIALIZE AC
	MOVE	2,@E220		;TEST INDIRECT ADDRESSING WITH INDEXING
	CAME	2,E220B		;PASS IF C(AC)=220220,,220220
	STOP

;**********
;THIS TEST VERIFIES THAT INDIRECT ADDRESSING IN COMBINATION WITH INDEXING FUNCTIONS CORRECTLY.
;IN THIS CASE,E221(1) 2,@E217 IS TESTED WHERE C(1)=-4 AND E221-4=E217A
;HENCE, THE RESULT IN THE AC SHOULD BE C(E217A)=@E221A=20,,E221A

C22200:	SETOM	2		;INITIALIZE AC
	MOVE	2,E221(1)	;TEST INDIRECT ADDRESSING WITH INDEXING
	CAME	2,E217A		;PASS IF C(AC)=@E221A=20,,E221A
	STOP

;**********

;THIS TEST VERIFIES THAT INDIRECT ADDRESSING IN COMBINATION WITH INDEXING FUNCTIONS CORRECTLY.
;IN THIS CASE, MOVE 2,E222(6) IS TESTED WHERE C(6)=5
;HENCE, THE RESULT IN THE AC SHOULD BE C(E222+5)=E222A(7)=7,,E222A

C22300:	SETZM	2		;INITIALIZE AC
	MOVE	2,E222(6)	;TEST INDIRECT ADDRESSING WITH INDEXING
	CAME	2,E222+5	;PASS IF C(AC)=E222A(7)=7,,E222A
	STOP

;**********
;THIS TEST VERIFIES THAT INDIRECT ADDRESSING IN COMBINATION WITH INDEXING FUNCTIONS CORRECTLY.
;IN THIS CASE, MOVE 2,@E223(10) IS TESTED WHERE C(10)=4 AND C(E223+4)=E223A
;HENCE, THE RESULT IN THE AC SHOULD BE C(E223A)=223223,,223223

C22400:	SETOM	2		;INITIALIZE AC
	MOVE	2,@E223(10)	;TEST INDIRECT ADDRESSING WITH INDEXING
	CAME	2,E223A		;PASS IF C(AC)=223223,,223223
	STOP

;**********

;THIS TEST VERIFIES THAT INDIRECT ADDRESSING IN COMBINATION WITH INDEXING FUNCTIONS CORRECTLY.
;IN THIS CASE, MOVE 2,@E223(11) IS TESTED WHERE C(11)=-6, C(E223-6)=E224A(4) AND C(4)=10
;HENCE, THE RESULT IN THE AC SHOULD BE C(E224A+10)=224224,,224224

C22500:	SETZM	2		;INITIALIZE AC
	MOVE	2,@E223(11)	;TEST INDIRECT ADDRESSING WITH INDEXING
	CAME	2,E224A+10	;PASS IF C(AC)=224224,,224224
	STOP

;**********
;THIS TEST VERIFIES THAT INDIRECT ADDRESSING IN COMBINATION WITH INDEXING FUNCTIONS CORRECTLY.
;IN THIS CASE, MOVE 2,@E225(13) IS TESTED WHERE C(13)=2, C(E225+2)=@E225A
;AND C(E225A)=E225B
;HENCE, THE RESULT IN THE AC SHOULD BE C(E225B)=225225,,225225

C22600:	SETOM	2		;INITIALIZE AC
	MOVE	2,@E225(13)	;TEST INDIRECT ADDRESSING WITH INDEXING
	CAME	2,E225B		;PASS IF C(AC)=225225,,225225
	STOP

;**********

;THIS TEST VERIFIES THAT INDIRECT ADDRESSING IN COMBINATION WITH INDEXING FUNCTIONS CORRECTLY.
;IN THIS CASE, MOVE 2,@E223(12) IS TESTED WHERE C(12)=5, C(E223+5)=@E226A(5),
;C(5)=1 AND C(E226A+1)=E226B
;HENCE, THE RESULT IN THE AC SHOULD BE C(E226B)=226226,,226226

C22700:	SETZM	2		;INITIALIZE AC
	MOVE	2,@E223(12)	;TEST INDIRECT ADDRESSING WITH INDEXING
	CAME	2,E226B		;PASS IF C(AC)=226226,,226226
	STOP

;**********

	;JRST	BEGEND
