;MACROS

; STOP - USED FOR SCOPE LOOP, IF INSTRUCTION FAILS, CHANGE (JUMPA .+1)
;	 TO A (JUMPA X) TO CYCLE ON FAILING INSTRUCTION

DEFINE	STOP	(A)<
	HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
	JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
				;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
				;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
				;AND CHANGE HALT INSTRUCTION TO JUMPA .+1>

SUBTTL	DIAGNOSTIC SECTION

START:	;SETZM	USER#		;CLEAR USER CONTROL WORD
	;JSP	0,.+1		;GET FLAGS
	;TLNE	USERF		;IN USER MODE?
	;SETOM	USER		;YES, SET USER CONTROL WORD
	;SKIPN	MONFLG		;SPECIAL USER MODE?
	;SETZM	USER		;YES, CLEAR USER CONTROL WORD
	;SKIPN	USER
	;JRST	STARTA
	;SKIPL	MONCTL
	;TTCALL	3,PGMNAM		;MENTION OUR NAME
	JRST	STARTA

PGMNAM:	ASCIZ/
PDP-10 KA10 BASIC INSTRUCTION DIAGNOSTIC (1) [DAKAA]
/

;BASIC INSTRUCTION TEST (3)
;THE TEST IS DESIGNED FOR INITIAL DEBUGGING OF
;PROCESSOR HARDWARE AND TO DETECT (SOLID) FAILURES
;IN THE FIELD.


STARTA:	JRST	.+1
SUBTTL	TEST OF JUMP, JUMPA AND SKIPX INSTRUCTIONS

;NOTE: AN "*" IN THE COMMENT FIELD OF AN INSTRUCTION INDICATES THAT IT IS THE TESTED
;INSTRUCTION.
;**********

;THIS TEST VERIFIES THAT SKIPA ALWAYS SKIPS THE NEXT INSTRUCTION

A00=.
A12500:	SKIPA			;*SKIPA SHOULD ALWAYS SKIP THE NEXT INSTRUCTION
	HALT			;IF PROGRAM HALTS, SKIPA DID NOT SKIP

;IF PROGRAM HANGS UP ON SKIPA INSTRUCTION, CHECK AB PC EN [ABC], AB PC F/F [ABC],
;AB PC B [ABC OR AB], AB PC (FETCH) EN [ABC], IR SKIPS [IR3], IR SKIPX [IR1],
;IR 3XX [IR1], IR BITS 00 - 08 [IR1], F CYC ACT EN C [FI], FT6 F/F [F2],
;PC CLOCK EN [PCC],  ET2 J F/F [E], PC CLK (ET2) EN [PCC], ADZ COND P [ADZ] AND
;ADZ COND R [ADZ], PC CLOCK A [PCC], PC CLOCK B [PCC]

;IF PROGRAM HALTED ON HALT INSTRUCTION, CHECK ST1 COND [ST2]

;**********

;THIS TEST VERIFIES THAT JUMP NEVER JUMPS

A15000:	JUMP	.+1		;*JUMP SHOULD NEVER JUMP
	SKIPA			;SKIP HALT INSTRUCTION IF JUMP IS SUCCESSFUL
	HALT			;HALT IF JUMP FAILS

;IF PROGRAM HANGS UP ON JUMP .+1 INSTRUCTION, THE JUMP INSTRUCTION
;MAY HAVE FAILED.  CHECK ST1 COND [ST2], ST INST FET ST1 EN [ST2], ET2 D F/F [E],
;IR JUMPS [IR1], IR JUMPX [IR1]

;**********
;THIS TEST VERIFIES THAT JUMP NEVER JUMPS

A15100:	JUMP	.+2		;*JUMP SHOULD NEVER JUMP
	SKIPA			;SKIP HALT INSTRUCTION IF JUMP IS SUCCESSFUL
	HALT			;HALT IF JUMP FAILS

;AB PC EN [ABC]

;**********

;THIS TEST VERIFIES THAT JUMPA .+1 ALWAYS JUMPS TO THE NEXT INSTRUCTION

A12700:	JUMPA	.+1		;*JUMPA .+1 SHOULD NEVER JUMP
	SKIPA			;SKIP HALT INSTRUCTION IF JUMPA IS SUCCESSFUL
	HALT			;HALT IF JUMPA .+1 FAILED

;**********

;THIS TEST VERIFIES THAT JUMPA JUMPS TO THE LOCATION SPECIFIED BY E WHEN E=.+2

A12600:	JUMPA	.+2		;*JUMPA .+2 SHOULD ALWAYS SKIP THE NEXT INSTRUCTION
	HALT			;PROGRAM HALTS HERE IF JUMPA .+2 FAILS

;ST1 COND [ST2]

;**********
;THIS TEST VERIFIES THAT SKIPA IS DATA INDEPENDENT.  HENCE, IT ALWAYS SKIPS THE NEXT
;INSTRUCTION.
;THE MOVE [0] INSTRUCTION IS USED TO TEST THE DATA INDEPENDENCE OF SKIPA.

A100:	MOVE	[0]		;PRESET LOCATION 0 TO ALL ZEROS
	SKIPA			;*SKIPA SHOULD ALWAYS SKIP THE NEXT INSTRUCTION
	STOP

;**********
;THIS TEST INSURES THAT SKIPA IS DATA INDEPENDENT.  HENCE, IT ALWAYS SKIPS THE NEXT
;INSTRUCTION.
;THE MOVE [-1] INSTRUCTION IS USED TO TEST THE DATA INDEPENDENCE OF SKIPA.

A200:	MOVE	[-1]		;PRESET LOCATION 0 TO ALL ONES
	SKIPA			;*SKIPA SKOULD ALWAYS SKIP THE NEXT INSTRUCTION
	STOP

;COND P [ADZ]

;**********
;THIS TEST VERIFIES THAT SKIPGE SKIPS THE NEXT INSTRUCTION WHEN C(E)
;IS ALL ZEROS.  THE MOVE INSTRUCTION IS USED TO LOAD E WITH ALL ZEROS.

A300:	MOVE	[0]		;PRESET E TO ALL ZEROS
	SKIPGE			;*SKIPGE SHOULD SKIP THE NEXT INSTRUCTION
	STOP

;COND R [ADZ], AD00 S-A-1, AD AR + EN [ADAP], AD LT AR + EN [ADAP],
;AD RT AR + EN [ADAP], AD AR + EN C [ADAP], F CYC ACT EN A [F1]

;**********

;THIS TEST VERIFIES THAT SKIP IS DATA INDEPENDENT.  HENCE, SKIP NEVER SKIPS.  IT ALWAYS
;CONTINUES ON TO THE NEXT INSTRUCTION.

A400:	MOVE	[-1]		;PRESET E TO ALL ONES
	SKIP			;*SKIP SHOULD NEVER SKIP THE NEXT INSTRUCTION
	SKIPA			;SKIP HALT INSTRUCTION IF TEST PASSES
	STOP

;PC CHANGE [PCC], PC CHANGE A [PCC], SEE MEMORY CONTROL DWGS [MC1-4]

;**********
;THIS TEST VERIFIES THAT SKIPGE WILL NOT SKIP THE NEXT INSTRUCTION WHEN C(E) IS
;NEGATIVE.  THE MOVE INSTRUCTION LOADS E WITH -1, A NEGATIVE NUMBER.

A500:	MOVE	[-1]		;PRESET E WITH ALL ONES, A NEGATIVE NUMBER
	SKIPGE			;*SKIPGE SHOULD NOT SKIP THE NEXT INSTRUCTION
	SKIPA			;SKIP HALT INSTRUCTION IF TEST PASSES
	STOP

;IF MOVE INSTRUCTION FAILED, CHECK MOVX-: FCE [F1], -IR XXXI [IR1], -IR XXXM [IR1],
;IR HWTFWT [IR3], IR FWT [IR2], IR2XX [IR1]

;IF SKIPGE FAILED, CHECK SKIPX: FCE [F1]

;**********

;THIS TEST VERIFIES THAT SKIPN WILL NOT SKIP THE NEXT INSTRUCTION WHEN
;C(E) IS ZERO.  THE MOVE INSTRUCTION  LOADS E WITH ALL ZEROS.

A600:	MOVE	[0]		;PRESET E WITH ALL ZEROS
	SKIPN			;*SKIPN SHOULD NOT SKIP THE NEXT INSTRUCTION
	SKIPA			;SKIP HALT INSTRUCTION IF TEST PASSES
	STOP

;**********

;THIS TEST VERIFIES THAT SKIPN IS DATA DEPENDENT.  HENCE, IT SHOULD SKIP
;THE NEXT INSTRUCTION WHEN C(E) IS NON-ZERO.  THE MOVE INSTRUCTION LOADS
;E WITH -1, A NON-ZERO NUMBER.

A700:	MOVE	[-1]		;PRESET E WITH ALL ONES, A NON-ZERO NUMBER
	SKIPN			;*SKIPN SHOULD SKIP THE NEXT INSTRUCTION
	STOP

;**********
;THIS TEST VERIFIES THAT SKIPE IS DATA DEPENDENT.  HENCE, IT SHOULD NOT
;SKIP THE NEXT INSTRUCTION WHEN C(E) IS NON-ZERO.  THE MOVE INSTRUCTION LOADS E
;WITH -1, A NON-ZERO NUMBER.

A1000:	MOVE	[-1]		;PRESET E WITH ALL ONES, A NON-ZERO NUMBER
	SKIPE			;*SKIPE SHOULD NOT SKIP THE NEXT INSTRUCTION
	SKIPA			;SKIP HALT INSTRUCTION IF TEST PASSES
	STOP

;**********

;THIS TEST VERIFIES THAT SKIPE IS DATA DEPENDENT.  HENCE, IT SHOULD SKIP
;THE NEXT INSTRUCTION WHEN C(E) IS ZERO.  THE MOVE INSTRUCTION LOADS ALL
;ZEROS INTO E.

A1100:	MOVE	[0]		;PRESET E TO ALL ZEROS
	SKIPE			;*SKIPE SHOULD SKIP THE NEXT INSTRUCTION
	STOP

;**********

;THIS TEST VERIFIES THAT SKIP IS DATA INDEPENDENT.  HENCE, IT NEVER SKIPS.  IT ALWAYS
;CONTINUES ON TO THE NEXT INSTRUCTION.

A1200:	MOVE	[0]		;PRESET E TO ALL ZEROS
	SKIP			;*SKIP SHOULD NEVER SKIP THE NEXT INSTRUCTION
	SKIPA			;SKIP HALT INSTRUCTION IF TEST PASSES
	STOP

;**********
;THIS TEST VERIFIES THAT SKIPL IS DATA DEPENDENT.  HENCE, IT WILL NOT SKIP THE NEXT
;INSTRUCTION WHEN C(E) IS NOT NEGATIVE.  THE MOVE INSTRUCTION IS USED TO LOAD
;E WITH ALL ZEROS, A NON-NEGATIVE NUMBER.

A1300:	MOVE	[0]		;PRESET E T0 ZERO, A NON-NEGATIVE NUMBER
	SKIPL			;*SKIPL SHOULD NOT SKIP THE NEXT INSTRUCTION
	SKIPA			;SKIP HALT INSTRUCTION IF TEST PASSES
	STOP

;**********
;THIS TEST VERIFIES THAT SKIPL IS DATA DEPENDENT.  HENCE, IT WILL SKIP THE NEXT
;INSTRUCTION WHEN C(E) IS NEGATIVE.  THE MOVE INSTRUCTION IS USED TO LOAD E WITH -1,
;A NEGATIVE NUMBER.

A1400:	MOVE	[-1]		;PRESET E TO -1, A NEGATIVE NUMBER
	SKIPL			;*SKIPL SHOULD SKIP THE NEXT INSTRUCTION
	STOP

;**********

;THIS TEST VERIFIES THAT SKIPG IS DATA DEPENDENT.  HENCE, IT WILL SKIP THE NEXT
;INSTRUCTION WHEN C(E) IS GREATER THAN ZERO.  THE MOVE INSTRUCTION IS USED TO LOAD
;E WITH A NON-ZERO POSITIVE NUMBER.

A1500:	MOVE	[XWD 377777,-1]	;PRESET E TO 377777777777, A NON-ZERO POSITIVE NUMBER
	SKIPG			;*SKIPG SHOULD SKIP THE NEXT INSTRUCTION
	STOP

;**********

;THIS TEST VERIFIES THAT SKIPG IS DATA DEPENDENT.  HENCE, IT WILL NOT SKIP THE NEXT
;INSTRUCTION WHEN C(E) IS NOT GREATER THAN ZERO.  THE MOVE INSTRUCTION IS USED TO
;LOAD E WITH -1, A NUMBER NOT GREATER THAN ZERO.

A1600:	MOVE	[-1]		;PRESET E TO -1, A NEGATIVE NUMBER
	SKIPG			;*SKIPG SHOULD NOT SKIP THE NEXT INSTRUCTION
	SKIPA			;SKIP HALT INSTRUCTION IF TEST PASSES
	STOP

;**********
;THIS TEST VERIFIES THAT SKIPL IS DATA  DEPENDENT.  HENCE, IT WILL NOT SKIP THE NEXT
;INSTRUCTION WHEN C(E) IS NON-NEGATIVE.  THE MOVE INSTRUCTION IS USED TO LOAD E WITH
;377777777777, A NON-NEGATIVE NUMBER.

A1700:	MOVE	[XWD 377777,-1]	;PRESET E TO 377777777777, A NON-NEGATIVE NUMBER
	SKIPL			;*SKIPL SHOULD NOT SKIP THE NEXT INSTRUCTION
	SKIPA			;SKIP HALT INSTRUCTION IF TEST PASSES
	STOP

;**********

;THIS TEST VERIFIES THAT SKIPLE IS DATA DEPENDENT.  HENCE, IT WILL SKIP THE NEXT
;INSTRUCTION WHEN C(E) IS ZERO.  THE MOVE INSTRUCTION LOADS E WITH ALL ZEROS.

A2000:	MOVE	[0]		;PRESET E TO ALL ZEROS
	SKIPLE			;*SKIPLE SHOULD SKIP THE NEXT INSTRUCTION
	STOP

;**********

;THIS TEST VERIFIES THAT SKIPLE IS DATA DEPENDENT.  HENCE, IT WILL SKIP THE NEXT
;INSTRUCTION WHEN E CONTAINS A NEGATIVE NUMBER.  THE MOVE INSTRUCTION IS USED TO LOAD
;E WITH 400000000000, A NEGATIVE NUMBER.

A2100:	MOVE	[XWD 400000,0]	;PRESET E TO 400000000000, A NEGATIVE NUMBER.
	SKIPLE			;*SKIPLE SHOULD SKIP THE NEXT INSTRUCTION
	STOP

;**********
;THIS TEST VERIFIES THAT SKIPLE IS DATA DEPENDENT.  HENCE, IT WILL NOT SKIP THE NEXT
;INSTRUCTION WHEN E CONTAINS A POSITIVE NUMBER.  THE MOVE INSTRUCTION LOADS
;E WITH 377777777777, A POSITIVE NUMBER.

A2200:	MOVE	[XWD 377777,-1]	;PRESET E TO 377777777777, A POSITIVE NUMBER
	SKIPLE			;*SKIPLE SHOULD NOT SKIP THE NEXT INSTRUCTION
	SKIPA			;SKIP HALT INSTRUCTION IF TEST PASSES
	STOP

;*********
;THIS TEST VERIFIES THAT SKIPN IS DATA DEPENDENT.  HENCE, IT WILL SKIP THE NEXT
;INSTRUCTION ;WHEN E CONTAINS A NON-ZERO NUMBER.  THE MOVE INSTRUCTION IS USED TO
;LOAD 777000000000, A NON-ZERO NUMBER INTO E.

A2300:	MOVE	[XWD 777000,0]	;PRESET E WITH 777000000000, A NON-ZERO NUMBER
	SKIPN			;*SKIPN SHOULD SKIP THE NEXT INSTRUCTION
	STOP

;**********

;THIS TEST VERIFIES THAT SKIPN IS DATA DEPENDENT.  HENCE, IT WILL SKIP THE NEXT
;INSTRUCTION WHEN E CONTAINS A NON-ZERO NUMBER.  THE MOVE INSTRUCTION IS USED TO
;LOAD A NON-ZERO NUMBER, 377000000 INTO E.

A2400:	MOVE	[XWD 377,0]	;PRESET E TO 377000000, A NON ZERO NUMBER
	SKIPN			;*SKIPN SHOULD SKIP THE NEXT INSTRUCTION
	STOP

;**********

;THIS TEST VERIFIES THAT SKIPN IS DATA DEPENDENT.  HENCE, IT WILL SKIP THE NEXT
;INSTRUCTION WHEN E CONTAINS A NON-ZERO NUMBER.  THE MOVE INSTRUCTION IS USED TO
;LOAD E WITH A NON-ZERO NUMBER, 177000.

A2500:	MOVE	[177000]	;PRESET E WITH 177000, A NON ZERO NUMBER
	SKIPN			;*SKIPN SHOULD SKIP THE NEXT INSTRUCTION
	STOP

;**********
;THIS TEST VERIFIES THAT SKIPN IS DATA DEPENDENT.  HENCE, IT WILL SKIP THE NEXT
;INSTRUCTION WHEN E CONTAINS A NON-ZERO NUMBER.  THE MOVE INSTRUCTION IS USED TO
;LOAD 777, A NON-ZERO NUMBER INTO E.

A2600:	MOVE	[777]		;PRESET E WITH 777, A NON-ZERO NUMBER
	SKIPN			;*SKIPN SHOULD SKIP THE NEXT INSTRUCTION
	STOP

;**********

;THIS TEST VERIFIES THAT SKIPN IS DATA DEPENDENT.  HENCE, IT WILL SKIP THE NEXT
;INSTRUCTION WHEN E CONTAINS A NON-ZERO NUMBER.  THE MOVE INSTRUCTION IS USED TO
;LOAD E WITH 600000, A NON-ZERO NUMBER.

A2700:	MOVE	[600000]	;PRESET E WITK 600000, A NON-ZERO NUMBER
	SKIPN			;*SKIPN SHOULD SKIP THE NEXT INSTRUCTION
	STOP

;**********

;THIS TEST VERIFIES THAT SKIPN IS DATA DEPENDENT.  HENCE, IT WILL SKIP THE NEXT
;INSTRUCTION WHEN E CONTAINS A NON-ZERO NUMBER.  THE MOVE INSTRUCTION IS USED TO
;LOAD E WITH 400000000, A NON-ZERO NUMBER.

A3000:	MOVE	[XWD 400,000]	;PRESET E WITH 400000000, A NON-ZERO NUMBER
	SKIPN			;*SKIPN SHOULD SKIP THE NEXT INSTRUCTION
	STOP

;**********
SN=3100
	ZZ=0

A3100:	REPEAT	^D36,
<;THIS TEST VERIFIES THAT SKIPN IS SENSITIVE TO A ONE IN EVERY BIT POSITION.  THIS TEST
;IS REPEATED 36 TIMES.  EACH TIME A WORD OF ALL ZEROS EXCEPT FOR A ONE IN ONE
;BIT POSITION IS MOVED INTO E.  THEN SKIPN IS EXECUTED.  THIS TEST ALSO
;CHECKS ADDER GATING.  IF THIS TEST FAILS, CHECK C(E).
;IF C(E)=0, MOVE FAILED; OTHERWISE SKIPN FAILED.

SN=SN+1
	ZZ=ZZ+ZZ
	IFE	ZZ,<ZZ=1>
	MOVE	[ZZ]		;MOVE THE CURRENT VALUE OF ZZ INTO E. ZZ IS NON-ZERO
	SKIPN			;*SKIPN SHOULD SKIP THE NEXT INSTRUCTION
	STOP

;**********
>
SUBTTL	TEST OF MOVE, SKIP AND COMPARE INSTRUCTIONS

;THIS TEST VERIFIES THAT MOVEI LOADS E INTO THE AC.  SKIPG IS USED TO CHECK THAT
;THE AC WAS INDEED MODIFIED BY MOVEI.

A3200:	MOVEI	[-1]		;*MOVEI SHOULD LOAD A POSITIVE NUMBER INTO AC0
	SKIPG			;SKIP HALT INSTRUCTION IF MOVEI LOADED AC CORRECTLY
	STOP

;IF PROGRAM HANGS UP ON MOVEI INSTRUCTION, CHECK AD FM +EN [ADFP], AD FM + EN A [ADFP],
;AD FM + F/F [ADFP], F CYC ACT EN C [F1]

;**********

;THIS TEST VERIFIES THAT SKIPL IS SENSITIVE TO THE DATA IN E AND NOT SENSITIVE TO
;THE DATA IN THE AC.  HENCE, SKIPL WILL SKIP THE NEXT INSTRUCTION ONLY IF
;C(E) IS LESS THAN ZERO.  E IS SET TO -1, A NEGATIVE NUMBER; AND
;THE AC IS SET TO 0 IN THIS TEST.  THEREFORE SKIPL SHOULD SKIP.

A3300:	MOVE	[0]		;SET THE AC TO ALL ZEROS
	SKIPL	[-1]		;*SKIPL SHOULD SKIP BECAUSE C(E) IS NEGATIVE
	STOP

;**********

;THIS TEST VERIFIES THAT SKIPL IS SENSITIVE TO THE SIGN BIT IN E.  SKIPL SHOULD
;SKIP THE NEXT INSTRUCTION WHEN AND ONLY WHEN THE SIGN BIT IS SET.  IN THIS
;TEST, C(AC) IS PRESET TO ALL ZEROS, THEN SKIPL IS EXECUTED WITH C(E)=400000,,0.
;A FAILURE UCCURS IF SKIPL DOES NOT SKIP.

A13100:	MOVE	[0]		;SET THE AC TO ALL ZEROS
	SKIPL	[400000,,0]	;*SKIPL SHOULD SKIP BECAUSE C(E) IS NEGATIVE
	STOP

;**********
;THIS TEST VERIFIES THAT THE CAM INSTRUCTION DOES NOT MODIFY C(AC).  THE AC IS
;INITIALLY LOADED WITH ALL ZEROS; THEN CAM IS EXECUTED WITH C(E) NON-ZERO.
;THE AC IS THEN CHECKED FOR ALL ZEROS.  THIS TEST FAILS IF THE AC WAS MODIFIED BY CAM.

A3400:	MOVE	[0]		;PRESET THE AC TO ALL ZEROS
	CAM	[1234]		;*CAM SHOULD NOT MODIFY THE AC
	MOVE			;MOVE C(0) INTO 0 (THIS INSTRUCTION SERVES AS A NO-OP.
				;IT IS A PROGRAM FILLER IN CASE CAM SKIPS.)
	SKIPE			;SKIP HALT INSTRUCTION IF AC WAS NOT MODIFIED BY CAM
	STOP

;IF TEST HANGS ON CAM INSTRUCTION, AB PC EN [ABC], AB PC (FETCH) EN [ABC],
;IR CAXX [IR3]

;IF TEST LOOPS ON CAM INSTRUCTION, MC INSTR FETCH EN [MC1], MC INST FET ET2 EN [MC1],
;ET2 J F/F [E], IR CAXX [IR3]

;IF TEST HALTS AT HALT INSTRUCTION, SAC INH [ST2], IR CAXX [IR3], IR CAMX [IR1]

;**********

;THIS TEST VERIFIES THAT THE CAI INSTRUCTION DOES NOT MODIFY C(AC).  THE AC IS
;INITIALLY LOADED WITH ALL ZEROS; THEN CAI IS EXECUTED WITH E NON-ZERO.  THE AC IS
;THEN CHECKED FOR ALL ZEROS.  THIS TEST FAILS IF THE AC WAS MODIFIED BY CAM.

A3500:	MOVE	[0]		;PRESET THE AC TO ALL ZEROS
	CAI	[1234]		;*CAI SHOULD NOT MODIFY THE AC
	MOVE			;MOVE C(0) INTO 0 (THIS INSTRUCTION IS A PROGRAM FILLER
				;IN CASE CAI MODIFIES THE AC.  IT SERVES AS A NO-OP)
	SKIPE			;SKIP HALT INSTRUCTION IF CAI DID NOT MODIFY THE AC
	STOP

;**********
;THIS TEST VERIFIES THAT CAI DOES NOT MODIFY C(AC0) WHEN AN AC OTHER THAN AC0 IS
;SPECIFIED BY THE CAI INSTRUCTION.
;THIS IS THE FIRST TEST THAT USES AN AC OTHER THAN AC0.
;FIRST, AC0 IS LOADED WITH ALL ZEROS; THEN, THE CAI INSTRUCTION IS EXECUTED WITH
;A NON-ZERO E.  AC 0 IS THEN TESTED F0R ALL ZEROS.

A3600:	MOVE	[0]		;LOAD AC0 WITH ALL ZEROS
	CAI	17,[1234]	;*CAI SHOULD NOT MODIFY AC0
	MOVE			;MOVE C(0) INTO 0 (THIS INSTRUCTION IS A FILLER IN CASE
				;CAI SKIPS THE NEXT INSTRUCTION.  IT ACTS AS A NO-OP)
	SKIPE			;SKIP HALT INSTRUCTION IF C(AC0) WAS NOT MODIFIED
	STOP

;**********

;THIS TEST VERIFIES THAT CAM DOES NOT MODIFY C(AC0) WHEN AN AC OTHER THAN AC0 IS
;SPECIFIED BY THE CAM INSTRUCTION.
;FIRST, AC0 IS LOADED WITH ALL ZEROS; THEN, THE CAM INSTRUCTION IS EXECUTED WITH
;A NON-ZERO E.  AC 0 IS THEN TESTED F0R ALL ZEROS.

A3700:	MOVE	[0]		;PRESET C(AC0) TO ALL ZEROS
	CAM	17,[1234]	;*CAM SHOULD NOT MODIFY AC0
	MOVE			;MOVE C(0) INTO 0 (THIS INSTRUCTION IS A FILLER IN CASE
				;CAM SKIPS THE NEXT INSTRUCTION.  IT SERVES AS A NO-OP)
	SKIPE			;SKIP HALT INSTRUCTION IF AC0 WAS NOT MODIFIED BY CAM
	STOP

;**********
;THIS TEST VERIFIES THAT MOVE WILL PLACE C(E) INTO THE AC.  AC, E AND C(E) ARE NON-ZERO
;IN THIS TEST.  THIS TEST PASSES IF  FINAL C(AC) OF THE MOVE INSTRUCTION IS NON-ZERO.

A4500:	MOVE	1,[0]		;LOAD THE AC WITH ALL ZEROS
	MOVE	1,[-1]		;*MOVE SHOULD PLACE ALL ONES IN THE AC
	SKIPN	1		;SKIP HALT INSTRUCTION IF MOVE MODIFIED THE AC
	STOP

;**********

;THIS TEST VERIFIES THAT THE MOVE INSTRUCTION WILL PLACE C(E) INTO THE AC.
;AC, E ARE NON-ZERO AND C(E)=0.
;THIS TEST FAILS IF THE FINAL C(AC) IS NOT EQUAL TO ZERO, THE ORIGINAL C(E)

A4600:	MOVE	1,[0]		;*PLACE ALL ZEROS INTO THE AC
	SKIPE	1		;SKIP HALT INSTRUCTION IF MOVE PLACED ALL ZEROS INTO AC
	STOP

;IF JUMP .+1 OF PREVIOUS TEST FAILED, CHECK JUMPS: AD FM + EN [ADFP], IR JUMPS [IR1],
;IR JUMPX [IR1], AR AD EN [ARMA], AR AD EN A [ARMA], AR LT AD EN A [ARMA],
;AR LT ADD EN B [ARMA], AR RT AD EN A [ARMA],
;AR RT AD EN B [ARMA], AR A CLK INPUT [ARMA],
;ET2 C F/F [E], AR AD ET2 EN [ARMA], AR AD BR (ET2) B [ARMA]

;**********
;THIS TEST VERIFIES THAT SOS DOES NOT MODIFY C(AC) WHEN THE AC IS AC0.
;FIRST, AC0 IS LOADED WITH ALL ZEROS AND E IS LOADED WITH A POSITIVE NUMBER;
;THEN, SOS IS EXECUTED.  SOS SHOULD SUBTRACT ONE FROM C((E)
;AND EXECUTE THE NEXT INSTRUCTION.  IT SHOULD NOT MODIFY AC0.
;THE TEST PASSES IF AC0 WAS NOT MODIFIED.

A4000:	MOVE	[0]		;PRESET AC0 TO ALL ZEROS
	MOVE	7,[1234]	;PRESET E WITH A POSITIVE NUMBER
	SOS	7		;*SOS SHOULD NOT MODIFY C(AC0)
	MOVE			;MOVE C(0) INTO 0 (THIS INSTRUCTION IS A FILLER IN CASE
				;SOS SKIPS THE NEXT INSTRUCTION.  IT SERVES AS A NO-OP)
	SKIPE			;SKIP THE HALT INSTRUCTION IF C(AC0) WAS NOT MODIFIED
	STOP

;**********
SN=4100
	AC=0

A4100:	REPEAT	4,
<;THIS TEST VERIFIES THAT THE SKIP INSTRUCTION WILL PLACE THE CONTENTS OF E INTO THE AC
;WHEN THE AC IS NOT AC0. THIS TEST IS PERFORMED FOR AC1, AC2, AC4 AND AC10.
;FIRST, THE AC IS LOADED WITH ALL ZEROS;  THEN, THE SKIP INSTRUCTION IS EXECUTED
;WITH AC1, AC2, AC4 OR AC10.  C(E) IS EQUAL TO -1.  THE SKIP INSTRUCTION SHOULD CAUSE
;THE AC TO CONTAIN -1.  THE AC IS THEN CHECKED FOR
;NON-ZERO CONTENTS.  THE TEST FAILS IF C(AC)=0.
;THIS TEST ALSO VERIFIES THAT 'SKIP AC,[-1]' DOES NOT CLOBBER AC0.

SN=SN+1
	AC=AC+AC
	IFE	AC,<AC=1>
	MOVE	0,[0]		;PRESET AC0 TO ALL ZEROS
	MOVE	AC,[0]		;PRESET THE AC TO ALL ZEROS
	SKIP	AC,[-1]		;*SKIP SHOULD PLACE -1 INTO THE AC
	SKIPN	AC		;SKIP THE HALT INSTRUCTION IF THE AC IS NON-ZERO
	STOP
	SKIPE	0		;VERIFY THAT AC0 DID NOT GET CLOBBERED BY SKIP
	STOP

;**********
>
SUBTTL	TEST OF SKIP, FULL WORD TRANSFER AND HALF WORD TRANSFER INSTRUCTIONS

;THIS TEST VERIFIES THAT THE SKIP INSTRUCTION WILL NOT MODIFY THE CONTENTS OF AC0.
;FIRST, AC0 IS LOADED WITH ALL ZEROS;  THEN,
;THE SKIP INSTRUCTION IS EXECUTED WITH C(E)=-1 AND AC0.  AC0 IS THEN TESTED FOR ALL
;ZEROS.  THE TEST FAILS IF AC0 WAS MODIFIED BY THE SKIP INSTRUCTION.

A4200:	MOVE	[0]		;PRESET AC0 TO ALL ZEROS
	SKIP	[-1]		;*SKIP SHOULD NOT MODIFY AC0
	SKIPE			;SKIP HALT INSTRUCTION IF AC0 WAS NOT MODIFIED BY SKIP
	STOP

;AC=0: SAC INH, IR BIT 9, 10, 11 OR 12 S-A-1

;**********

;THIS TEST VERIFIES THAT MOVSS DOES NOT MODIFY C(AC0) WHEN AC0 IS SPECIFIED AS THE AC.
;FIRST, E IS LOADED WITH ALL ONES AND THE AC (AC0)
;IS LOADED WITH ALL ZEROS; THEN, MOVSS IS EXECUTED.  MOVSS SHOULD NOT MODIFY AC0.
;AC0 IS THEN CHECKED TO INSURE THAT IT WAS NOT MODIFIED BY MOVSS.

A4300:	MOVE	7,[-1]		;LOAD E OF THE MOVSS INSTRUCTION WITH ALL ONES
	MOVE	[0]		;PRESET AC0 TO ALL ZEROS
	MOVSS	7		;*MOVSS SHOULD NOT MODIFY AC0
	SKIPE			;SKIP HALT INSTRUCTION IF AC0 WAS INTACT
	STOP

;MOVX & AC=0: SAC INH [ST2], IR XXXS [IR1]

;**********
;THIS TEST VERIFIES THAT HRRS DOES NOT MODIFY C(AC0) WHEN AC0 IS THE SPECIFIED AC.
;FIRST, E IS LOADED WITH ALL ONES AND AC0 IS LOADED WITH ALL ZEROS;
;THEN, HRRS IS EXECUTED WITH AC=AC0.  AC0 IS THEN CHECKED FOR ALL ZEROS.
;IF AC0 WAS MODIFIED BY THE HRRS INSTRUCTION, THE TEST FAIL.

A4400:	MOVE	7,[-1]		;PRESET E OF THE HRRS INSTRUCTION TO ALL ONES
	MOVE	[0]		;PRESET AC0 TO ALL ZEROS
	HRRS	7		;*HRRS SHOULD NOT MODIFY THE AC WHEN THE AC IS AC0
	SKIPE			;SKIP THE HALT INSTRUCTION IF AC0 WAS INTACT
	STOP

;(HXXXS&AC=0): SAC INH [ST2], IR HWTFWT [IR3], IR XXXS [IR1], IR HWT [IR1],
;IR BITS S-A-1

;**********
;THIS TEST VERIFIES THAT THE JUMP INSTRUCTION DOES NOT MODIFY C(AC).
;THE AC IS FIRST LOADED WITH ALL ZEROS;
;THEN JUMP .+1 IS EXECUTED.  THE AC IS THEN CHECKED TO INSURE THAT IT WAS NOT MODIFIED
;BY JUMP.  THE TEST FAILS IF THE AC WAS MODIFIED

A4700:	MOVE	[0]		; PRESET THE AC TO ALL ZEROS
	JUMP	.+1		;*JUMP SHOULD NOT MODIFY THE AC
	SKIPE			;SKIP HALT INSTRUCTION IF AC WAS INTACT
	STOP

;**********

;THIS TEST VERIFIES THAT MOVS WILL NOT PICK UP ANY ONES WHEN SWAPPING A WORD
;OF ALL ZEROS.  FIRST, E IS LOADED WITH A WORD OF ALL ZEROS;
;THEN, MOVS IS EXECUTED.  THE AC IS THEN CHECKED TO INSURE THAT THE RESULT DOES NOT
;CONTAIN ANY ONES.

A5000:	MOVE	[0]		;PRESET E WITH ALL ZEROS
	MOVS			;*MOVS SHOULD RESULT WITH AN AC 0F ALL ZEROS
	SKIPE			;SKIP HALT INSTRUCTION IF C(AC)=0
	STOP

;**********

;THIS TEST VERIFIES THAT A MOVS EXECUTED ON AN E CONTAINING A NON-ZERO NUMBER
;RESULTS IN A NON-ZERO NUMBER IN THE AC.  FIRST A NON-ZERO WORD
;IS LOADED INTO E; THEN, MOVS IS EXECUTED.  THE AC IS CHECKED FOR A NON-ZERO RESULT.
;IF C(AC)=0, THE TEST FAILS.

A5100:	MOVE	[XWD 0,-1]	;LOAD E WITH A NON-ZERO VALUE
	MOVS			;*MOVS SHOULD RESULT IN C(AC) NON-ZERO
	SKIPN			;SKIP HALT INSTRUCTION IF C(AC) OF MOVS IS NON-ZERO
	STOP

;**********
;THIS TEST VERIFIES THAT A MOVS EXECUTED ON AN E CONTAINING A NON-ZERO NUMBER
;RESULTS IN A NON-ZERO NUMBER IN THE AC.  FIRST A NON-ZERO WORD
;IS LOADED INTO E; THEN, MOVS IS EXECUTED.  THE AC IS CHECKED FOR A NON-ZERO
;RESULT.  IF C(AC)=0, THE TEST FAILS.

A5200:	MOVE	[XWD -1,0]	;LOAD E OF MOVS WITH A NON-ZERO NUMBER
	MOVS			;*MOVS SHOULD RESULT WITH C(AC) NON-ZERO
	SKIPN			;SKIP HALT INSTRUCTION IF C(AC) OF MOVS IS NON-ZERO
	STOP

;**********

;THIS TEST VERIFIES THAT THE MOVS INSTRUCTION SWAPS BITS 0 AND 188 OF E
;AND STORES THEM IN THE AC UNLESS AR BIT 0 IS S-A-0.  FIRST, A WORD
;WITH BIT 0 SET TO A ONE AND BIT 18 CLEARED IS LOADED INTO E.  THEN, MOVS
;IS EXECUTED.  THE AC IS THEN CHECKED FOR A 0 IN BIT 0, WHICH IS THE
;CORRECT RESULT.

A5300:	MOVE	[XWD -1,0]	;LOAD E OF MOVS WITH 777777000000
	MOVS			;*MOVS SHOULD RESULT WITH AC BIT 0 EQUAL TO 0
	SKIPG			;SKIP HALT INSTRUCTION IF BIT 0 OF AC IS 0
	STOP

;MOVSX: AR SWAP [ARMB], AR LT AR RT A [ARMB], AR LT AR RT B [ARMB],
;AR RT AR LT A [ARMB], AR RT AR LT B [ARMB], ET2 A F/F [E], IR MOVSX [IR1],
;IR MOV(E,S)X [IR1]

;**********

;THIS TEST VERIFIES THAT THE MOVS INSTRUCTION SWAPS BITS 0 AND 18 OF E AND
;STORES THEM IN THE AC UNLESS AR BIT 0 IS S-A-1.  FIRST, A WORD WITH BIT 0
;SET TO A ONE AND BIT 18 CLEARED IS LOADED INTO E.  THEN, MOVS IS EXECUTED.
;THE AC IS CHECKED FOR A ZERO IN BIT ZERO, WHICH IS THE CORRECT RESULT.

A5400:	MOVE	[XWD 0,-1]	;LOAD E OF MOVS WITH 777777
	MOVS			;*MOVS SHOULD RESULT WITH BIT 0 OF THE AC SET
	SKIPL			;PASS IF AC BIT 0 IS SET
	STOP

;**********
SN=5500
	ZZ=0

A5500:	REPEAT	^D18,
<;THIS TEST VERIFIES THAT AR LT INPUT IS FUNCTIONING.  A WORD OF ALL ZER0S,
;EXCEPT FOR ONE ONE IN THE RIGHT HALF IS SWAPPED.
;THE AC IS CHECKED FOR ITS CONTENTS NON-ZERO.  THE TEST PASSES
;IF C(AC) IS NON-ZERO. THIS TEST IS REPEATED 18 TIMES SO THAT EACH BIT
;OF THE LEFT HALF OF THE AC IS TESTED WITH A 1.
SN=SN+1
	ZZ=ZZ+ZZ
	IFE	ZZ,<ZZ=1>
	MOVE	[0]		;CLEAR AC
	MOVS	[ZZ]		;*MOVS SHOULD RESULT WITH A NON-ZERO WORD IN THE AC
	SKIPN			;SKIP HALT INSTRUCTION IF SET BIT IS NOT LOST IN SWAP.
	STOP

;**********
>
SN=5600

A5600:	REPEAT	^D18,
<;THIS TEST VERIFIES THAT AR RT INPUT IS FUNCTIONING.  A WORD OF ALL
;ZEROS, EXCEPT FOR ONE ONE IN THE LEFT HALF IS SWAPPED.  THE AC IS
;CHECKED FOR ITS CONTENTS NON-ZERO.  THE TEST PASSES IF C(AC) IS
;NON-ZERO.  THIS TEST IS REPEATED 18 TIMES SO THAT EACH BIT OF THE RIGHT
;HALF OF THE AC IS TESTED WITH A 1.

SN=SN+1
	ZZ=ZZ+ZZ
	MOVE	[0]		;CLEAR AC
	MOVS	[ZZ]		;*MOVS SHOULD RESULT WITH A NON-ZERO WORD IN THE AC
	SKIPN			;SKIP HALT INSTRUCTION IF SET BIT IS NOT LOST IN SWAP.
	STOP

;**********
>
SUBTTL	TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)

;THIS TEST VERIFIES THAT SETM LOADS AC FROM E.  THE AC IS FIRST SET
;TO ZERO; THEN, SETM IS EXECUTED WITH ALL ONES IN E.  BIT 0 OF THE AC
;IS THEN CHECKED FOR A 1.

A5700:	MOVE	[0]		;PRELOAD AC WITH ALL ZEROS
	SETM	[-1]		;*SETM SHOULD LOAD AC WITH ALL ONES
	SKIPL			;PASS TEST IF AC BIT 0 IS A ONE
	STOP
;FCE [F1], IR BOOLE [IR1], IRXX(0,5,12,17) [IR2]

;**********

;THIS TEST VERIFIES THAT SETM LOADS AC FROM E.  THE AC IS FIRST SET TO
;ALL ONES; THEN, SETM IS EXECUTED WITH ALL ZEROS IN E.  THE AC IS CHECKED
;FOR ALL ZEROS

A6000:	MOVE	[-1]		;PRESET AC TO ALL ONES
	SETM	[0]		;*SETM SHOULD LOAD AC WITH ALL ONES
	SKIPE			;PASSES TEST IF C(AC) = 0
	STOP

;AD AR + EN [ADAP], AD AR + EN C[ADAP],
;F CYC ACT EN A[F1], IR BOOLE AD A +F[IR2],
;IR BOOLE [IR1], IRXX(1-3,6,11,15,16) [IR2]

;**********

;THIS TEST VERIFIES THAT SETZ LOADS TH AC WITH ALL ZEROS.  FIRST, A WORD
;OF ALL ZEROS IS LOADED INTO THE AC VIA A MOVE INSTC. THEN, SETZ IS
;EXECUTED.  THE AC IS CHECKED FOR ALL ZEROS.
;IF ANY BITS IN THE AC ARE SET, THE TEST FAILS.

A6100:	MOVE	[0]		;RESET AC TO ALL ZEROS
	SETZ			;*SETZ SHOULD CLEAR THE AC
	SKIPE			;PASS TEST IF C(AC) = 0
	STOP

;AD MASK GEN EN [ADC1], AD MASK GEN F/F'S [ADC1]
;AD MASK EN B; F CYC ACT EN B[F1]; IRXX00 [IR1];
;IR BOOLE [IR1]

;**********
;THIS TEST VERIFIES THAT SETZ LOADS THE AC WITH ALL ZEROS.  FIRST,
;THE AC IS SET TO ALL ONES; THEN, SETZ IS EXECUTED.  THE AC IS THEN
;CHECKED FOR ALL ZEROS.  IF ANY BITS IN THE AC ARE SET, THE TEST FAILS.

A6200:	MOVE	[-1]		;PRESET AC TO ALL ONES
	SETZ	.		;*SETZ SHOULD CLEAR THE AC
	SKIPE			;PASS TEST IF C(AC) = 0
	STOP

;AR AD EN [ARMA], AR AD ET2 EN [ARMA], IR BOOLE [IR]

;**********

;THIS TEST VERIFIES THAT THE AND INSTRUCTION OPERATING ON AN AC
;CONTAINING ALL ZEROS AND AN E CONTAINING ALL ZEROS RESULTS IN AN AC
;OF ALL ZEROS.  THE AC AND E ARE THE SAME IN THIS TEST.
;AC, E ARE LOADED WITH ZEROS; THEN, AND IS EXECUTED.  THE AC IS THEN
;CHECKED FOR ALL ZEROS.  IF ANY BITS IN THE AC ARE SET BY THE AND INSTRUCTION,
;THE TEST FAILS.


A6300:	MOVE	[0]		;PRESET AC, E TO ALL ZEROS
	AND			;*AND SHOULD RESULT IN C(AC) = 0
	SKIPE			;PASS TEST IF C(AC) = 0
	STOP

;**********
SN=6400
	ZZ=0

A6400:	REPEAT	^D36,
<;THIS TEST VERIFIES THAT IF ONE OF THE OPERANDS OF THE AND INSTRUCTION
;IS ZERO, THE RESULT WILL BE ZERO.  THIS TEST IS REPEATED 36 TIMES WITH
;ALL ZEROS IN THE AC EXCEPT FOR ONE ONE IN BIT X
;WHERE X TAKES ON INTEGER VALUES 0 THRU 35.  E CONTAINS ALL ZEROS.
;THE RESULT SHOULD BE ALL ZEROS IN THE AC.  IF C(AC) IS NON-ZERO,
;'AND' FAILED.  C(0) IS ALSO CHECKED FOR ALL ZEROS.  IF C(0) IS
;NON-ZERO, AC0 WAS CLOBBERED BY 'AND'.

SN=SN+1
	ZZ=ZZ+ZZ
	IFE	ZZ,<ZZ=1>
	SETZ			;PRESET E TO ALL ZEROS
	MOVE	1,[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN BIT X
				;WHERE X VARIES FROM 0 THRU 35
	AND	1,0		;*AND SHOULD RESULT IN C(AC) = 0
	SKIPE	1		;FAIL IF C(AC) NON-ZERO
	STOP
	SKIPE	0		;FAIL IF C(0) IS NON-ZERO
	STOP
;**********
>
SN=6500
	ZZ=0

A6500:	REPEAT	^D36,
<;THIS TEST VERIFIES THAT THE RESULT OF A WORD ANDED WITH ITSELF
;SHOULD BE THAT SAME WORD.  A WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE
;IN ONLY ONE BIT IS ANDED WITH ITSELF.  THE AC IS THEN CHECKED FOR ITS
;CONTENTS NONZERO.  IF C(AC)=0, THE 'AND' INSTRUCTION FAILED.  THIS TEST IS REPEATED
;36 TIMES TO CHECK EACH BIT INDIVIDUALLY.
SN=SN+1
	ZZ=ZZ+ZZ
	IFE	ZZ,<ZZ=1>
	MOVE	[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN ONE BIT
	AND			;*AND OF WORD CONTAINING A ONE IN ONE BIT
				;POSITION WITH ITSELF SHOULD RESULT WITH
				;C(AC) NONZERO
	SKIPN			;PASS TEST IF C(AC) NONZERO
	STOP

;**********
>
;THIS TEST VERIFIES THAT THE RESULT OF THE AND INSTRUCTION WHERE
;C(AC)=0 AND C(E)=0 AND E OUTSIDE OF THE AC RANGE IS ALL ZEROS IN THE AC.
;FIRST, THE AC IS CLEARED; THEN, THE C(AC) IS ANDED WITH C(E) WHEN
;E GREATER THAN 20 AND C(E)=0. THE RESULT SHOULD BE C(AC)=0.
;IF C(AC) IS NON-ZERO, 'AND' FAILED WITH THE MEMORY OPERAND.

A6600:	MOVE	[0]		;PRESET AC TO ALL ZEROS
	AND	[0]		;*AND OF TWO WORDS OF ALL ZEROS
				;SHOULD RESULT IN C(AC)=0
	SKIPE			;PASS TEST IF C(AC)=0
	STOP

;**********

;THIS TEST VERIFIES THAT THE RESULT OF THE AND INSTRUCTION WHERE C(AC)=0
;AND C(E) IS ALL ONES IS AN AC CONTAINING ALL ZEROS.  FIRST, THE AC IS
;CLEARED; THEN THE C(AC) IS ANDED WITH AN E CONTAINING ALL ONES, WHERE
;E IS BEYOND THE AC RANGE.  THE RESULT SHOULD BE C(AC)=0.
;IF C(AC) IS NON-ZERO, 'AND' FAILED WITH THE MEMORY OPERAND.

A6700:	MOVE	[0]		;PRESET AC TO ALL ZEROS
	AND	[-1]		;*AND OF TWO WORDS WHERE C(AC)=0 SHOULD RESULT IN C(AC)=0
	SKIPE			;PASS TEST IF C(AC)=0
	STOP

;AD FM+EN [ADFP],AD FM+EN A [ADFP],
;F CYC ACT EN C [F1],IR BOOLE AD FM+F [IR2],
;IR BOOLE [IR1],IRXX(1,4,5,11,13,16) [IR2]

;**********
;THIS TEST VERIFIES THAT THE RESULT OF THE AND INSTRUCTION WHERE C(E)=0
;AND C(AC) IS ALL ONES IS AN AC CONTAINING ALL ZEROS. FIRST, THE
;AC IS SET TO ALL ONES; THEN, THE AC IS ANDED WITH AN E CONTAINING ALL
;ZEROS, WHERE E IS BEYOND THE AC RANGE.  THE RESULT SHOULD BE C(AC)=0.
;IF C(AC) IS NON-ZERO, 'AND' FAILED WITH THE MEMORY OPERAND.

A7000:	MOVE	[-1]		;PRESET AC TO ALL ONES
	AND	[0]		;*AND OF TWO WORDS WHERE C(E)=0 SHOULD RESULT IN C(AC)=0
	SKIPE			;PASS TEST IF C(AC)=0
	STOP

;**********

;THIS TEST VERIFIES THAT THE RESULT OF THE AND INSTRUCTION WHERE C(E) IS
;ALL ONES AND C(AC) IS ALL ONES IS AN AC CONTAINING ALL ONES.  FIRST, THE
;AC IS SET TO ALL ONES; THEN, C(AC) IS ANDED WITH AN E CONTAINING ALL
;ONES.  THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
;IF C(AC) IS ZERO, 'AND' FAILED WITH THE MEMORY OPERAND.

A7100:	MOVE	[-1]		;PRELOAD AC WITH ALL ONES
	AND	[-1]		;*AND OF TWO WORDS OF ALL ONES SHOULD
				;RESULT IN C(AC)=ALL ONES
	SKIPN			;PASS TEST IF C(AC) IS NON ZERO
	STOP

;**********

;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
;C(AC)=0 AND C(E) IS NON-ZERO IS AN AC WHERE CONTENTS IS NON-ZERO.
;FIRST, THE AC IS CLEARED, THEN, XOR IS EXECUTED WHERE C(E) IS NON-ZERO.
;THE AC IS THEN CHECKED FOR NON-ZERO CONTENTS.
A7200:	MOVE	[0]		;CLEAR AC
	XOR	[707070707070]	;*XOR WITH C(AC)=0 AND C(E)=7070707070 SHOULD
				;RESTULT IN C(AC)=707070707070
	SKIPN			;PASS TEST IF C(AC) NON-ZERO
	STOP

;**********
SN=7300
	ZZ=0

A7300:	REPEAT	^D36,
<;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
;C(AC)=0 AND C(E) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO. THIS
;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS CLEARED AND XOR IS EXECUTED
;WITH ALL BITS OF E CLEAR EXCEPT FOR ONE FLOATING BIT WHICH IS SET TO A ONE.
;THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
SN=SN+1
	ZZ=ZZ+ZZ
	IFE	ZZ,<ZZ=1>
	MOVE	[0]		;CLEAR AC
	XOR	[ZZ]		;*XOR WITH C(AC)=0 AND ONE BIT OF C(E) SET SHOULD
				;RESULT IN C(AC) NONZERO
	SKIPN			;PASS TEST IF C(AC) NON-ZERO
	STOP

;**********
>
SN=7400
	ZZ=0

A7400:	REPEAT	^D36,
<;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
;C(E)=0 AND C(AC) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO.  THIS
;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS INITIALIZED SO THAT ONE
;AND ONLY ONE FLOATING BIT IS SET TO ONE AND XOR IS EXECUTED WITH E
;CONTAINING ALL ZEROS.  THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
SN=SN+1
	ZZ=ZZ+ZZ
	IFE	ZZ,<ZZ=1>
	MOVE	[ZZ]		;PRELOAD AC WITH ONE FLOATING BIT SET
	XOR	[0]		;*XOR WITH C(E)=0 AND ONE BIT OF C(AC) SET SHOULD
				;RESULT IN C(AC) NON-ZERO
	SKIPN			;PASS TEST IF C(AC) NON-ZERO
	STOP

;AD FM- EN [ADFM], AD FM- F/F'S[ADFM],F CYC ACT EN D[R1],
;IR BOOLE AD FM- F [IR2],IR BOOLE[IR1],IR XX (2,6,7,10,12,15)[IR2],
;AD EQV[ADCR],AD EQV F/F[ADC2],FCYC ACT EN A[F1],
;IR BOOLE (6,11)[IR2],IR BOOLE[IR1],IRXX(6,11)[IR2]

;**********
>
SN=7500
	ZZ=0

A7500:	REPEAT ^D36,
<;THIS TEST VERIFIES THAT THE RESULT OF AN XOR INSTRUCTION
;WHERE C(AC) = C(E) IS AN AC CONTAINING ALL ZEROS.  FIRST,
;THE AC IS INITIALIZED WITH A WORD CONTAINING ALL ZEROS EXCEPT
;FOR ONE FLOATING ONE; THEN, XOR IS EXECUTED WITH E CONTAINING THE SAME
;NUMBER.  THE RESULT SHOULD BE AN AC CONTAINING ALL ZEROS.  THIS TEST
;IS REPEATED 36 TIMES.  IF ANY BIT IN THE RESULT IS NON-ZERO, IT MAY
;INDICATE AN ILLEGAL CARRY GENERATION.
SN=SN+1
	ZZ=ZZ+ZZ
	IFE	ZZ,<ZZ=1>
	MOVE	[ZZ]		;INITIALIZE AC WITH ONE FLOATING BIT SET
	XOR	[ZZ]		;*XOR WITH C(AC)=C(E) SHOULD RESULT IN C(AC)=0
	SKIPE			;PASS TEST IF C(AC)=0
	STOP

;**********
>
;THIS TEST VERIFIES THAT THE RESULT OF AN XOR INSTRUCTION WHERE
;C(AC)=C(E)=0 IS AN AC CONTAINING ALL ZEROS; FIRST THE AC IS CLEARED; THEN
;XOR IS EXECUTED WITH C(E)=0.  THE RESULT IN THE AC IS CHECKED FOR ALL ZEROS

A7600:	MOVE	[0]		;INITIALIZE AC TO ALL ZEROS
	XOR	[0]		;*XOR WITH C(AC)=C(E)=0 SHOULD RESULT INC(AC)=0
	SKIPE			;PASS TEST IF C(AC)=0
	STOP

;**********

;THIS TEST VERIFIES THAT THE RESULT OF AN EQV INSTRUCTION WHERE
;C(AC)=0 AND C(E) ALL ONES IS AN AC CONTAINING ALL ZEROS SINCE
;THE EQUIVALENCE FUNCTION SHOULD SET ONLY LIKE BITS.  FIRST, THE AC
;SHOULD BE CLEARED; THEN, EQV IS EXECUTED WITH E CONTAINING ALL ONES.
;THE AC IS THEN CHECKED FOR ALL ZEROS

A7700:	MOVE	[0]		;CLEAR THE AC
	EQV	[-1]		;*EQV WITH C(AC)=0 AND C(E) ALL ONES SHOULD
				;RESULT IN C(AC)=0
	SKIPE			;PASS TEST IF C(AC)=0
	STOP

;**********
SN=10000
	ZZ=0

A10000:	REPEAT	^D18,
<;THIS TEST VERIFIES THAT THE RESULT OF AN EQV INSTRUCTION WHERE
;C(AC)=0 AND C(E) IS ALL ONES EXCEPT FOR A ZERO IN ONLY ONE BIT IS AN
;AC WHOSE CONTENTS IS NON-ZERO (A ONE RESULTS IN THE BIT WHERE
;E CONTAINS A ZERO).  THIS TEST IS REPEATED 36 TIMES SO THAT EACH BIT
;OF THE RESULT IS A ONE ONCE AND ONLY ONCE.  FIRST, THE AC IS
;CLEARED; THEN,EQV IS EXECUTED WITH ONE BIT OF E EQUAL TO ZERO.  THE
;RESULT IN THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO
SN=SN+1
	ZZ=ZZ+ZZ+1
	IFE	<ZZ-1>,<ZZ=-2>
	MOVE	[0]		;PRESET AC TO ALL ZEROS
	EQV	[XWD -1,ZZ]	;*EQV WITH C(AC)=0 AND ONE BIT OF C(E)=0 SHOULD
				;RESULT IN C(AC) NON-ZERO
	SKIPN			;PASS TEST IF C(AC) NON-ZERO
	STOP

;**********
>
SN=10100
	ZZ=0

A10100:	REPEAT	^D18,
<;THIS TEST VERIFIES THAT THE RESULT OF AN EQV INSTRUCTION WHERE
;C(AC)=0 AND C(E) IS ALL ONES EXCEPT FOR A ZERO IN ONLY ONE BIT IS AN
;AC WHOSE CONTENTS IS NON-ZERO (A ONE RESULTS IN THE BIT WHERE
;E CONTAINS A ZERO).  THIS TEST IS REPEATED 36 TIMES SO THAT EACH BIT
;OF THE RESULT IS A ONE ONCE AND ONLY ONCE.  FIRST, THE AC IS
;CLEARED; THEN,EQV IS EXECUTED WITH ONE BIT OF E EQUAL TO ZERO.  THE
;RESULT IN THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO
SN=SN+1
	ZZ=ZZ+ZZ+1
	IFE	<ZZ-1>,<ZZ=-2>
	MOVE	[0]		;PRESET AC TO ALL ZEROS
	EQV	[XWD ZZ,-1]	;*EQV WITH C(AC)=0 AND ONE BIT OF C(E)=0 SHOULD
				;RESULT IN C(AC) NON-ZERO
	SKIPN			;PASS TEST IF C(AC) NON-ZERO
	STOP

;**********
>
;THIS TEST VERIFIES THAT THE RESULT OF AN AC CONTAINING ALL ZEROS
;EQUIVALENCED WITH AN E CONTAINING ALL ZEROS IS AN AC CONTAINING ALL
;ONES; AND FUTHERMORE, IF THIS AC CONTAINING ALL ONES IS EQUIVALANCED
;WITH AN E CONTAINING ALL ZEROS, THE FINAL RESULT IN THE AC
;SHOULD BE ALL ZEROS.  FIRST, THE AC IS INITIALIZED TO ALL ZEROS, THEN,
;THIS AC IS EQUIVALENCED TWICE WITH AN E CONTAINING ALL ZEROS.  THE AC IS
;THEN CHECKED FOR ALL ZEROS

A10200:	MOVE	[0]		;CLEAR THE AC
	EQV	[0]		;*EQV SHOULD RESULT IN C(AC)=ALL ONES
	EQV	[0]		;*EQV SHOULD RESULT IN C(AC)=0
	SKIPE			;PASS TEST IF C(AC)=0
	STOP

;**********

;THIS TEST VERIFIES THAT THE RESULT OF AN AC CONTAINING ALL ONES
;EQUIVALENCED WITH AN E CONTAINING ALL ONES IS AN AC CONTAINING ALL ONES;
;AND FUTHERMORE, IF THIS AC CONTAINING ALL ONES ISEQUIVALENCED WITH AN E
;CONTAINING ALL ZEROS, THE FINAL RESULT IN THE AC SHOULD BE ALL ZEROS.
;FIRST, THE AC IS INITIALIZED TO ALL ONES; THEN, THIS AC IS
;EQUIVALENCED WITH AN E OF ALL ONES.  NEXT, THIS SAME AC IS EQUIVALENCED
;WITH AN E OF ALL ZEROS.  THE AC IS THEN CHECKED FOR ALL ZEROS.

A10300:	MOVE	[-1]		;SET C(AC) TO ALL ONES
	EQV	[-1]		;*EQV SHOULD RESULT IN C(AC) OF ALL ONES
	EQV	[0]		;*EQV SHOULD RESULT IN C(AC)=0
	SKIPE			;PASS TEST IF C(AC)=0
	STOP

;**********
SN=13000
	ZZ=0

A13000:	REPEAT	^D36,
<;THIS TEST CHECKS THE 'AND' INSTRUCTION AND THE ADDER ON A ONE-BIT-AT-A-TIME BASIS.
;THE AC IS LOADED WITH ALL ZEROS EXCEPT FOR ONE BIT EQUAL TO ONE; THE AC IS THEN
;ANDED WITH C(E) WHERE C(E)=C(AC).  THE NET RESULT SHOULD BE NO CHANGE TO C(AC).
;NEXT, THE AC IS EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
;BE ALL ONES IN THE AC.  THE AC IS THEN EQUIVALENCED WITH A WORD OF ALL ZEROS,
;WHICH SHOULD RESULT IN C(AC)=0.  THE AC IS CHECKED FOR ALL ZEROS.
;IF C(AC) IS NON-ZERO, THE TEST FAILS.  THIS TEST IS REPEATED 36 TIMES TO
;RIPPLE A ONE THROUGH EVERY BIT OF THE AC.
SN=SN+1
	ZZ=ZZ+ZZ
	IFE	ZZ,<ZZ=1>
	MOVE	[ZZ]		;SETUP AC WITH A ONE IN ONLY ONE BIT
	AND	[ZZ]		;*AND FLOATING ONE WITH ITSELF SHOULD NOT CHANGE C(AC)
	EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
	EQV	[0]		;RESULTS IN C(AC)=0
	SKIPE			;PASS TEST IF C(AC)=0
	STOP

;**********
>
ENDXX:
	;JRST	BEGEND		;LOOP PROGRAM
