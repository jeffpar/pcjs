SUBTTL	DIAGNOSTIC PARAMETERS

;ACCUMULATOR ASSIGNMENTS

;CONTROL WORDS

AROV=400000		;ARITHMETIC OVERFLOW
CRY0=200000		;CARRY 0
CRY1=100000		;CARRY 1
FOV=40000		;FLOATING OVERFLOW
BIS=20000		;BYTE INTERRUPT
USERF=10000		;USER MODE FLAG
EXIOT=4000		;USER PRIV I/O FLAG
FXU=100			;FLOATING UNDERFLOW
DCK=40			;DIVIDE CHECK

;MACROS

; STOP - USED FOR SCOPE LOOP, IF INSTRUCTION FAILS, CHANGE (JUMPA .+1)
;	 TO A (JUMPA X) TO CYCLE ON FAILING INSTRUCTION

DEFINE	STOP	(A)<
	HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
	JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1)
				;TO JUMPA X(X IS THE ADDRESS OF THE FIRST
				;INSTRUCTION IN THE SUBTEST) TO LOOP ON ERROR
				;AND CHANGE HALT INSTRUCTION TO JUMPA .+1>

; SFLAG - USED TO CLEAR ALL FLAGS THEN TO SET REQUESTED FLAG

DEFINE	SFLAG	(A)<
	MOVSI	1,A
	JFCL	17,.+1		;RESET ALL FLAGS
	JRST	2,.+1(1)	;SET A FLAG>

SUBTTL	DIAGNOSTIC SECTION

START:	;SETZM	USER#		;CLEAR USER CONTROL WORD
	;JSP	0,.+1		;GET FLAGS
	;TLNE	USERF		;IN USER MODE?
	;SETOM	USER		;YES, SET USER CONTROL WORD
	;SKIPN	MONFLG		;SPECIAL USER MODE?
	;SETZM	USER		;YES, CLEAR USER CONTROL WORD
	;SKIPN	USER
	;JRST	STARTA
	;SKIPL	MONCTL
	;TTCALL	3,PGMNAM	;MENTION OUR NAME
	JRST	STARTA

PGMNAM:	ASCIZ/
PDP-10 KI10 BASIC INSTRUCTION DIAGNOSTIC (7) [DAKAG]
/

STARTA:	JRST	.+1
SUBTTL	TEST OF PUSH INSTRUCTION

;**********

;THIS TEST VERIFIES THAT PUSH DECODES CORRECTLY.
;IF PUSH DECODES AS PUSHJ, THIS TEST FAILS.

C27200:	SETZ	2,		;CLEAR AC
	PUSH	2,.+2		;*PUSH SHOULD NOT JUMP
	SKIPA			;PASS IF PUSH DID NOT JUMP
	STOP

;**********

;THIS TEST VERIFIES THAT PUSH DOES NOT MODIFY C(E).
;CLEAR E AND AC; THEN, EXECUTE PUSH.
;CHECK E FOR ORIGINAL CONTENTS ,0.
;PASS IF C(E)=0.

C27300:	SETZB	2		;CLEAR AC,E
	PUSH	2,		;*PUSH SHOULD NOT ALTER C(E)
	SKIPE			;PASS IF C(E)=0,,0
	STOP

;**********
;THIS TEST VERIFIES THAT PUSH ADDS 1,,1 TO THE AC.
;FIRST THE AC IS CLEARED; THEN PUSH IS EXECUTED.
;THE AC IS CHECKED FOR 1,,1.  IF C(AC)=1,,1, THIS TEST PASSES.

C27400:	SETZ	2,		;CLEAR AC
	PUSH	2,.+1		;*PUSH SHOULD ADD 1,,1 TO C(AC)
	CAME	2,[XWD 1,1]	;PASS IF C(AC)=1,,1
	STOP

;**********

;THIS TEST VERIFIES THAT PUSH ADDS 1,,1 TO THE AC BEFORE MODIFYING C(C(AC-RIGHT)).
;FIRST, THE AC AND AC0 ARE ZEROED; THEN PUSH IS EXECUTED.
;C(C(AC-RIGHT)) [BEFORE AC UPDATING] (AC0) IS CHECKED FOR THE INITIAL VALUE, 0.
;IF C(AC0)=0, THIS TEST PASSES

C27500:	SETZB	2		;CLEAR AC AND AC0
	PUSH	2,[16541320]	;*PUSH SHOULD NOT MODIFY C(AC0)
	SKIPE			;PASS IF C(AC0)=0
	STOP

;**********
;THIS TEST VERIFIES THAT PUSH ADDS 1,,1 TO THE AC BEFORE MODIFYING C(C(AC-RIGHT)).
;FIRST, THE AC AND AC0 ARE ZEROED; THEN PUSH IS EXECUTED.
;C(C(AC-RIGHT)) [BEFORE AC UPDATING] (AC0) IS CHECKED FOR
;IF C(AC0)IS NOT EQUAL TO E, THIS TEST PASSES

C27600:	SETZB	1,2		;CLEAR AC AND AC0
	PUSH	2,.+1		;*PUSH SHOULD NOT MODIFY C(AC0)
	CAIN	.		;FAIL IF C(AC0)=E
	STOP

;**********

;THIS TEST VERIFIES THAT PUSH ADDS 1,,1 TO THE AC; THEN, MOVES C(E) INTO
;THE LOCATION SPECIFIED BY C(AC-RIGHT).  IN THIS CASE, AC AND THE LOCATION SPECIFIED
;BY UPDATING C(AC-RIGHT) ARE CLEARED; THEN, PUSH IS EXECUTED WITH C(E)=-1,,-1.
;THE LOCATION SPECIFIED BY C(AC-RIGHT) IS THEN CHECKED FOR -1,,-1, THE
;ORIGINAL C(E).  IF C(C(AC-RIGHT))=-1,,-1, THIS TEST PASSES.

C27700:	SETZB	1,2		;CLEAR AC, C(AC-RIGHT)
	PUSH	2,[-1]		;*PUSH SHOULD PLACE -1,,-1 INTO AC1
	CAME	1,[-1]		;PASS IF C(1)=-1,,-1
	STOP

;**********
;THIS TEST VERIFIES THAT PUSH ADDS 1,,1 TO THE AC; THEN, MOVES C(E) INTO
;THE LOCATION SPECIFIED BY C(AC-RIGHT).  IN THIS CASE, AC
;IS CLEARED; THEN, PUSH IS EXECUTED WITH C(E)=0.
;THE LOCATION SPECIFIED BY C(AC-RIGHT) IS THEN CHECKED FOR 0, THE
;ORIGINAL C(E).  IF C(C(AC-RIGHT))=0, THIS TEST PASSES.

C30000:	SETZM	2		;CLEAR AC
	PUSH	2,[0]		;*PUSH SHOULD PLACE 0 INTO AC1
	SKIPE	1		;PASS IF C(1)=0
	STOP

;**********

;THIS TEST VERIFIES THAT PUSH ADDS 1,,1 TO THE AC; THEN, MOVES C(E) INTO
;THE LOCATION SPECIFIED BY C(AC-RIGHT).  IN THIS CASE,
;AC IS PRELOADED WITH 0,,-1, AND THE LOCATION SPECIFIED
;BY UPDATING C(AC-RIGHT) IS CLEARED; THEN, PUSH IS EXECUTED WITH C(E)=-1,,-1.
;THE LOCATION SPECIFIED BY C(AC-RIGHT) IS THEN CHECKED FOR -1,,-1, THE
;ORIGINAL C(E).  IF C(C(AC-RIGHT))=-1,,-1, THIS TEST PASSES.

C30100:	MOVEI	2,-1		;PRELOAD AC WITH 0,,-1
	SETZ			;CLEAR AC, C(AC-RIGHT)
	PUSH	2,[-1]		;*PUSH SHOULD PLACE -1,,-1 INTO AC0
	CAME	[-1]		;PASS IF C(0)=-1,,-1
	STOP

;**********
;THIS TEST VERIFIES THAT THERE IS A CARRY FROM AC BIT 18 TO BIT 17 OF THE AC ON PUSH.
;THE AC IS PRELOADED WITH 0,,-1; THEN PUSH IS EXECUTED. PUSH SHOULD ADD ONE TO BOTH
;HALVES OF THE AC, GENERATING A CARRY FROM BIT 18 TO BIT 17. IF A CARRY WAS GENERATED,
;THIS TEST PASSES.

C30101:	MOVEI	2,-1		;PRELOAD AC WITH 0,,-1
	PUSH	2,0		;*PUSH SHOULD GENERATE A CARRY FROM BIT 18 TO BIT 17
	CAME	2,[2,,0]	;PASS IF C(AC)=2,,0 (CARRY WAS GENERATED)
	STOP

;*************
SUBTTL	TEST OF PUSHJ INSTRUCTION

;**********

;THIS TEST VERIFIES THAT PUSHJ TRANSFERS CONTROL TO THE LOCATION ADDRESSED BY E.
;IF PUSHJ DOES NOT JUMP, THIS TEST FAILS

C30200:	SFLAG	CRY0		;SETS CRY0 FLAG
	SETZ			;CLEAR AC
	PUSHJ	.+2		;*PUSHJ SHOULD JUMP TO LOCATION E
	STOP

;**********

;THIS TEST VERIFIES THAT PUSHJ DOES NOT MODIFY C(PC) WHERE PC IS ONE GREATER
;THAN THE LOCATION OF THE PUSHJ INSTRUCTION.
;IF PUSHJ MODIFIES C(PC), THIS TEST FAILS

C30300:	SFLAG	CRY0		;SET CRY0
	SETZB	1,.+2		;CLEAR C(AC-RIGHT) AND C(PC)
	PUSHJ	.+3		;*PUSHJ SHOULD NOT MODIFY C(PC)
	0			;THIS LOCATION SHOULD NOT BE MODIFIED BY PUSHJ
	CAM			;PUSHJ SHOULD JUMP OVER THIS LOCATION
	SKIPE	.-2		;PASS IF PUSHJ DID NOT MODIFY C(PC)
	STOP

;**********
;THIS TEST VERIFIES THAT PUSHJ DOES NOT STORE IN E
;IF PUSHJ STORED IN E, THIS TEST FAILS

C30400:	SFLAG	CRY0		;SET CRY0
	SETZB	1		;CLEAR AC AND C(AC-RIGHT
	PUSHJ	.+1		;*PUSHJ SHOULD NOT STORE IN E
	MOVE	2,.		;SAVE C(E)
	CAME	2,.-1		;FAIL IF PUSHJ STORED IN E
	STOP

;**********

;THIS TEST VERIFIES THAT PUSHJ DOES NOT STORE IN LOC 0
;PUSHJ SHOULD STORE PC IN C(AC-RIGHT) - LOCATION 2.
;IF PUSHJ STORES IN LOCATION 0, THIS TEST FAILS

C30500:	MOVEI	2,1		;PRELOAD AC WITH 0,,1
	SETZ	0		;CLEAR 0
	PUSHJ	2,.+1		;*PUSHJ SHOULD NOT STORE IN LOCATION 0
	SKIPE			;FAIL IF PUSHJ STORED IN LOCATION 0
	STOP

;**********
;THIS TEST VERIFIES THAT PUSHJ STORES THE PC IN THE LOCATION SPECIFIED
;BY C(AC-RIGHT) AFTER INCREMENTING AC.
;IN THIS TEST, AC AND C(AC-RIGHT) ARE CLEARED; THEN, PUSHJ IS EXECUTED.
;C(C(AC-RIGHT))IS THEN COMPARED TO ZERO.  IF C(C(AC-RIGHT)) IS NON-ZERO,
;A PC WAS STORED AND THIS TEST PASSES.

C30600:	SETZB	1		;CLEAR AC, C(AC-RIGHT)
	PUSHJ	.+2		;*PUSHJ SHOULD STORE PC IN RIGHT HALF OF C(AC-RIGHT)
	HALT	.		;PUSHJ SHOULD JUMP OVER THIS INSTRUCTION
	ANDI	1,-1		;SAVE C(C(AC-RIGHT))
	CAIN	1,.-1		;FAIL IF PC WAS NOT STORED IN C(AC-RIGHT)
	STOP

;**********

;THIS TEST VERIFIES THAT PUSHJ ADDS 1,,1 TO THE AC
;THE AC IS CLEARED AND PUSHJ IS EXECUTED
;AC IS CHECKED FOR 1,,1 IF C(AC)=1,,1, THIS TEST PASSES

C31000:	SETZ			;CLEAR AC
	PUSHJ	.+1		;*PUSHJ SHOULD PLACE 1,,1 INTO THE AC
	CAME	[1,,1]		;PASS IF C(AC)=1,,1
	STOP

;**********
;THIS TEST VERIFIES THAT PUSHJ STORES THE FLAGS IN LEFT HALF OF C(AC-RIGHT)
;FIRST, CRY0 IS SET AND AC AND C(AC-RIGHT) ARE CLEARED; THEN, PUSHJ IS EXECUTED.
;C(C(AC-RIGHT)) IS THEN CHECKED FOR CRY0.  IF CRY0 IS SET, THIS TEST PASSES.

C31100:	SFLAG	CRY0		;SET CRY0
	SETZB	1		;CLEAR AC AND C(AC-RIGHT)
	PUSHJ	.+1		;*PUSHJ SHOULD STORE FLAGS IN LEFT HALF OF C(AC-RIGHT)
	TLNN	1,CRY0		;PASS IF CRY0 STORED CORRECTLY
	STOP

;**********

;THIS TEST VERIFIES THAT PUSHJ ADDS 1,,1 TO THE AC
;THE AC IS PRELOADED WITH 0,,1 AND PUSHJ IS EXECUTED
;AC IS CHECKED FOR 1,,2 IF C(AC)=1,,2, THIS TEST PASSES

C31400:	MOVEI	1,1		;PRELOAD AC WITH 0,,1
	PUSHJ	1,.+2		;*PUSHJ SHOULD PLACE 1,,2 INTO THE AC
	HALT			;PUSHJ SHOULD JUMP OVER THIS INSTRUCTION
	CAME	1,[XWD 1,2]	;PASS IF AC WAS INCREMENTED CORRECTLY
	STOP

;**********
;THIS TEST VERIFIES THAT PUSHJ STORES THE PC IN RIGHT HALF OF C(AC-RIGHT)
;THIS TEST PASSES IF THE PC WAS STORED CORRECTLY.

C31500:	MOVEI	1,1		;PLACE 0,,1 INTO AC
	PUSHJ	1,.+2		;*PUSHJ SHOULD STORE .+1 INTO RIGHT HALF OF C(AC-RIGHT)
	HALT			;PUSHJ SHOULD JUMP OVER THIS PC
	ANDI	2,-1		;SAVE RIGHT HALF OF C(AC-RIGHT)
	CAIE	2,.-2		;PASS IF PC STORED CORRECTLY
	STOP

;**********

;THIS TEST VERIFIES THAT PUSHJ ALWAYS RESETS BIS.
;FIRST BIS IS SET; THEN PUSHJ IS EXECUTED.  THE FLAGS ARE
;THEN SAVED AND CHECKED.  IF BIS WAS RESET VIA PUSHJ, THIS TEST PASSES.

C31501:	SFLAG	BIS		;SET BIS
	SETZ			;CLEAR AC
	PUSHJ	.+1		;*PUSHJ SHOULD RESET BIS
	JSP	.+1		;SAVE FLAGS
	TLNE	BIS		;PASS IF BIS FLAG IS RESET
	STOP

;**********
;THIS TEST VERIFIES THAT THERE IS A CARRY FROM BIT18 TO BIT17 OF THE AC ON PUSHJ.
;THE AC IS PRELOADED WITH 0,,-1; THEN PUSHJ IS EXECUTED. PUSHJ SHOULD ADD ONE TO
;BOTH HALVES OF THE AC, GENERATING A CARRY FROM BIT18 TO BIT17. IF A
;CARRY WAS GENERATED, THE TEST PASSES.

C31502:	MOVEI	2,-1		;PRELOAD AC WITH 0,,-1
	PUSHJ	2,.+1		;*PUSHJ SHOULD GENERATE A CARRY FROM BIT18 TO BIT17
	CAME	2,[2,,0]	;PASS IF C(AC)=2,,0 (CARRY WAS GENERATED)
	STOP

;****************
SUBTTL	TEST OF POP INSTRUCTION

;**********

;THIS TEST VERIFIES THAT POP SUBTRACTS 1,,1 FROM THE AC
;THE AC IS PRELOADED WITH 1,,1; THEN, POP IS EXECUTED.
;THE AC IS CHECKED FOR 0.  IF C(AC)=0, THIS TEST PASSES.

C31600:	MOVE	[XWD 1,1]	;PRELOAD AC WITH 1,,1
	POP	1		;*POP SHOULD SUBTRACT 1,,1 FROM THE AC
	SKIPE			;PASS IF AC WAS DECREMENTED CORRECTLY
	STOP

;**********

;THIS TEST VERIFIES THAT POP SUBTRACTS 1,,1 FROM THE AC
;THE AC IS PRELOADED WITH 2,,2; THEN, POP IS EXECUTED.
;THE AC IS CHECKED FOR 1,,1.  IF C(AC)=1,,1, THIS TEST PASSES.

C31700:	MOVE	[XWD 2,2]	;PRELOAD AC WITH E,,E WHERE E=2
	MOVEI	2,5		;PRELOAD 2 WITH 0,,5
	POP	2		;*POP SHOULD SUBTRACT 1,,1 FROM THE AC
	CAME	[1,,1]		;PASS IF AC WAS DECREMENTED CORRECTLY
	STOP

;**********
;THIS TEST VERIFIES THAT POP STORES C(C(AC-RIGHT)) INTO E
;IN THIS CASE, AC=0 AND AC IS PRELOADED WITH 2,,2; E=2 AND IS PRELOADED WITH 0.
;POP IS THEN EXECUTED.  POP SHOULD PLACE 0 INTO E.  IF C(E)=0, THIS TEST PASSES.

C32300:	MOVE	[XWD 2,2]	;PRELOAD AC WITH 2,,2
	SETZM	2		;CLEAR E AND C(AC-RIGHT)
	POP	2		;*POP SHOULD PLACE 0 INTO E
	SKIPE	2		;PASS IF C(E)=0
	STOP

;**********

;THIS TEST VERIFIES THAT POP DOES NOT MODIFY C(C(AC-RIGHT)-1).
;THIS TEST FAILS IF C(C(AC-RIGHT)-1) IS MODIFIED BY POP.

C32400:	MOVE	[XWD 2,2]	;PRELOAD AC WITH 2,,2
	MOVEI	2,17		;PRELOAD 2 WITH 0,,17
	SETZM	1		;CLEAR C(C(AC-RIGHT)-1)
	POP	2		;*POP SHOULD NOT MODIFY C(C(AC-RIGHT)-1)
	SKIPE	1		;PASS IF C(C(AC-RIGHT)-1) WAS UNALTERED
	STOP

;**********
;THIS TEST VERIFIES THAT POP STORES C(C(AC-RIGHT)) INTO E.
;IN THIS CASE, AC IS PRELOADED WITH 2,,2 AND AC2 [C(AC-RIGHT)] IS PRELOADED WITH 0,,3.
;E IS CLEARED AND POP IS EXECUTED.  E IS THEN CHECKED FOR 0,,3 [C(C(AC-RIGHT))] .
;IF C(E)=0,,3, THIS TEST PASSES.

C32500:	MOVE	[XWD 2,2]	;PRELOAD AC WITH 2,,2
	MOVEI	2,3		;PRELOAD C(AC-RIGHT) WITH 0,,3
	SETZM	3		;CLEAR E
	POP	3		;*POP SHOULD PLACE 0,,3 INTO E
	CAIE	3,3		;PASS IF C(E)=0,,3
	STOP

;**********

;THIS TEST VERIFIES THAT POP STORES C(C(AC-RIGHT)) INTO E.  IN THIS CASE,
;AC IS PRELOADED WITH 2,,2 AND AC2 [C(AC-RIGHT)] IS PRELOADED WITH 0,,17.
;E IS CLEARED AND POP IS EXECUTED.  E IS THEN CHECKED FOR 0,,17 [C(C(AC-RIGHT))] .
;IF C(E)=0,,17, THIS TEST PASSES.

C32600:	SETZM	2		;CLEAR E
	MOVE	[XWD 2,2]	;PRELOAD AC WITH 2,,2
	MOVEI	2,17		;PRELOAD C(AC-RIGHT) WITH 0,,17
	POP	2		;*POP SHOULD PLACE 0,,17 INTO E
	CAIE	2,17		;PASS IF C(E)=0,,17
	STOP

;**********
;THIS TEST VERIFIES THAT POP STORES C(C(AC-RIGHT)) INTO E.  IN THIS CASE,
;AC IS PRELOADED WITH 2,,2 AND AC2 [C(AC-RIGHT)] IS PRELOADED WITH -1,,-1.
;E IS CLEARED AND POP IS EXECUTED.  E IS THEN CHECKED FOR -1,,-1 [C(C(AC-RIGHT))] .
;IF C(E)=0,,3, THIS TEST PASSES.

C33100:	MOVE	[XWD 2,2]	;PRELOAD AC WITH 2,,2
	SETOM	2		;PRELOAD C(AC-RIGHT) WITH -1,,-1
	SETZM	3		;CLEAR E
	POP	3		;*POP SHOULD PLACE -1,,-1 INTO E
	CAME	3,[-1]		;PASS IF C(E)=-1,,-1
	STOP

;**********

;THIS TEST VERIFIES THAT POP PLACES C(C(AC-RIGHT)) INTO E AND ADDS 1,,1 TO AC.
;IN THIS CASE, THE AC IS PRELOADED WITH 1,,17; E=1 AND E IS PRELOADED WITH 0;
;C(AC-RIGHT) IS PRELOADED WITH -1,,-1; AND POP IS EXECUTED.  POP SHOULD PLACE -1,,-1
;INTO E AND 0,,16 INTO AC.  IF AC AND E ARE UPDATED CORRECTLY, THIS TEST PASSES.

C33300:	MOVE	[XWD 1,17]	;PRELOAD AC WITH 1,,17
	SETZM	1		;PRELOAD E WITH 0
	SETOM	17		;PRELOAD C(AC-RIGHT) WITH 1,,1
	POP	1		;*POP SHOULD PLACE -1,,-1 INTO E AND 0,,16 INTO AC
	CAME	1,[-1]		;PASS IF C(E)=-1,,-1
	STOP
C33310:	CAIE	16		;PASS IF C(AC)=0,,16
	STOP

;**********
;THIS TEST VERIFIES THAT POP PLACES C(C(AC-RIGHT)) INTO E AND ADDS 1,,1 TO AC
;IN THIS CASE, THE AC IS PRELOADED WITH -1,,0; E=17
;C(AC-RIGHT) IS PRELOADED WITH 0; AND POP IS EXECUTED.  POP SHOULD PLACE 0
;INTO E.  IF AC IS UPDATED CORRECTLY, THIS TEST PASSES.

C33400:	MOVSI	1,-1		;PRELOAD AC WITH -1,,0
	SETZ			;CLEAR C(AC-RIGHT)
	POP	1,17		;*POP SHOULD PLACE 0 INTO E
	SKIPE	17		;PASS IF C(E)=0
	STOP

;**********

;THIS TEST VERIFIES THAT THERE IS A CARRY FROM BIT18 TO BIT17 OF THE AC ON POP.
;THE AC IS PRELOADED WITH 2,,0; THEN POP IS EXECUTED. POP SHOULD SUBTRACT ONE FROM
;BOTH HALVES OF THE AC, GENERATING A CARRY FROM BIT18 TO BIT17.
;IF A CARRY WAS GENERATED, THIS TEST PASSES.

C33401:	HRLZI	2,2		;PRELOAD AC WITH 2,,0
	POP	2,0		;*POP SHOULD GENERATE A CARRY FROM BIT18 TO BIT17
	CAIE	2,-1		;PASS IF C(AC) = 0,,-1	(CARRY WAS GENERATED)
	STOP

;************
SUBTTL	TEST OF POPJ INSTRUCTION

;**********

;THIS TEST VERIFIES THAT POPJ JUMPS TO THE LOCATION ADDRESSED BY RIGHT HALF OF
;C(C(AC-RIGHT)) BEFORE POPJ DECREMENTED THE AC.
;THIS TEST PASSES IF POPJ JUMPS CORRECTLY.

C33500:	MOVE	[XWD 1,1]	;PRELOAD AC WITH 1,,1
	MOVEI	1,.+3		;PRELOAD C(AC-RIGHT) WITH .+3
	POPJ	.+2		;*POPJ SHOULD JUMP TO LOCATION
				;ADDRESSED BY C(C(AC-RIGHT))
	STOP

;**********

;THIS TEST VERIFIES THAT POPJ SUBTRACTS 1,,1 FROM THE AC
;THIS AC IS PRELOADED WITH 1,,1; THEN,POPJ IS EXECUTED.
;THE AC IS CHECKED FOR 0.  IF C(AC)=0, THIS TEST PASSES.

C33600:	MOVE	[XWD 1,1]	;PRELOAD AC WITH 1,,1
	MOVEI	1,.+2		;PRELOAD C(AC-NIGHT)WITH .+2
	POPJ	.+1		;*POPJ SHOULD SUBTRACT 1,,1 FROM AC
	CAME	[0]		;PASS IF C(AC)=0
	STOP

;**********
;THIS TEST VERIFIES THAT POPJ JUMPS TO THE LOCATION ADDRESSED BY RIGHT HALF OF
;C(C(AC-RIGHT)) BEFORE POPJ DECREMENTED THE AC.
;THIS TEST PASSES IF POPJ JUMPS CORRECTLY.

C33700:	MOVE	[XWD 1,1]	;PRELOAD AC WITH 1,,1
	MOVEI	1,.+2		;PRELOAD C(AC-RIGHT) WITH C33700+3
	POPJ	.+2		;*POPJ SHOULD JUMP TO C33700+3
	SKIPA			;PASS IF POPJ JUMPED CORRECTLY
	STOP

;**********

;THIS TEST VERIFIES THAT THERE IS A CARRY FROM BIT18 TO BIT17 OF THE AC ON POPJ.
;THE AC IS PRELOADED WITH 2,,0; THEN POPJ IS EXECUTED POPJ SHOULD SUBTRACT ONE FROM
;BOTH HALVES OF THE AC, GENERATING A CARRY FROM BIT18 TO BIT17.
;IF A CARRY WAS GENERATED, THIS TEST PASSES.

C33701:	HRLZI	2,2		;PRELOAD AC WITH 2,,0
	MOVEI	0,.+2		;PRELOAD RH(AC) WITH C33701: +3
	POPJ	2,0		;*POPJ SHOULD GENERATE A CARRY FROM BIT18 TO BIT17
	CAIE	2,-1		;PASS IF C(AC)=0,,-1 (CARRY WAS GENERATED)
	STOP

;*************
SUBTTL	XCT INSTRUCTION - ADDITIONAL TESTS

;**********

;THIS TEST VERIFIES THAT IF AN XCT EXECUTES A SKIP INSTRUCTION, THE SKIP IS RELATIVE
;TO THE LOCATION OF THE XCT.

C34000:	SETOB	1
	XCT	[CAME 0,1]	;*CAME SHOULD SKIP TO C34000+3
	STOP

;**********

;THIS TEST VERIFIES THAT IF AN XCT EXECUTES A SKIP INSTRUCTION, THE SKIP IS RELATIVE
;TO THE LOCATION OF THE XCT.

C34100:	SETOB	1
	XCT	[XCT[XCT[CAME 0,1]]]	;*CAME SHOULD SKIP TO C34100+3
	STOP

;**********
;THIS TEST VERIFIES THAT IF AN XCT EXECUTES A JUMP, PROGRAM FLOW IS ALTERED AS
;SPECIFIED BY THE JUMP.

C34200:	XCT	[JRST .+4]	;*JRST SHOULD JUMP TO C34200+4
	HALT			;JRST SHOULD JUMP OVER THIS LOCATION
	HALT			;JRST SHOULD JUMP OVER THIS LOCATION
	STOP

;**********

;THIS TEST VERIFIES THAT IF AN XCT EXECUTES A JUMP, PROGRAM FLOW IS ALTERED AS
;SPECIFIED BY THE JUMP AND THAT WHEN THE PC IS SAVED IT CONTAINS AN
;ADDRESS ONE GREATER THAN THE LOCATION OF FIRST XCT OF THE CHAIN.

C34300:	SETZM	3		;CLEAR AC OF JSP
	XCT	[XCT[XCT[JSP 3,.+3]]] ;*JSP SHOULD JUMP TO C34300+4 AND
	HALT			;THE SAVED PC SHOULD BE C 34300+2
	HALT			;PASS IF JSP JUMPED CORRECTLY
	TRZ	3,.-2		;AND SAVED PC=C34300+2
	TRNE	3,-1
	STOP

;**********
;THIS TEST VERIFIES THAT IF AN XCT EXECUTES A SKIP INSTRUCTION, THE SKIP IS RELATIVE
;TO THE LOCATION OF THE XCT.
;IN THIS CASE, NO SKIP SHOULD OCCUR  ;HENCE, THE INSTRUCTION
;FOLLOWING XCT SHOULD BE EXECUTED AFTER 'CAME' IS EXECUTED.

C34400:	SETZB	0		;SET-UP AC,E SO THAT
	SETOM	1		;CAME WILL NOT SKIP
	XCT	[CAME 0,1]	;*CAME SHOULD CAUSE EXECUTION
				;OF INSTRUCTION FOLLOWING XCT
	JRST	.+2		;PASS IF THIS INSTRUCTION IS EXECUTED
	STOP

;**********

;THIS TEST VERIFIES INDEXING FOR XCT OF AN ADD INSTRUCTION
;C(4)=10, AND C(6)=3, SO THE RESULT IN 6 (THE AC) SHOULD BE 16
;C(11)=13

C34500:	MOVEI	4,10		;PRELOAD INDEX REG WITH 10
	MOVEI	11,13		;PRELOAD EFFECTIVE ADDRESS WITH 13
	MOVEI	6,3		;PRELOAD AC WITH 3
	XCT	[ADD 6,1(4)]	;*ADD SHOULD PLACE 16 IN AC
	CAIE	6,16		;PASS IF C(AC)=16
	STOP

;**********
;THIS TEST VERIFIES THAT IF AN XCT EXECUTES A SKIP INSTRUCTION, THE SKIP IS RELATIVE
;TO THE LOCATION OF THE XCT
;IN THIS CASE, NO SKIP SHOULD OCCUR  ;HENCE, THE INSTRUCTION
;FOLLOWING XCT SHOULD BE EXECUTED AFTER CAME IS EXECUTED.

C34600:	SETZM	2		;SETUP E SO THAT SKIPL WILL NOT SKIP
	XCT	[SKIPL 1,2]	;*SKIPL SHOULD CAUSE INSTRUCTION
				;OF FOLLOWING INSTRUCTION
	JRST	.+2		;PASS IF THIS INSTRUCTION IS EXECUTED.
	STOP
C34610:	SKIPE	1		;*SKIPE SHOULD SKIP BECAUSE XCT OF SKIPL
				;PLACED 0 INTO AC1
	STOP

;**********

;THIS TEST VERIFIES THAT IF AN XCT EXECUTES A SKIP INSTRUCTION, THE SKIP IS RELATIVE
;TO THE LOCATION OF THE XCT.

C34700:	SETOM	6		;SETUP E SO THAT SKIPL WILL SKIP
	XCT	[SKIPL 3,6]	;*SKIPL SHOULD SKIP TO C34700+3
	STOP
C34710:	SKIPL	3		;*SKIPE SHOULD SKIP BECAUSE XCT OF SKIPL
				;PLACED 0 INTO AC1
	STOP

;**********
;THIS TEST VERIFIES THAT IF AN XCT EXECUTES A JUMP, PROGRAM FLOW IS ALTERED AS
;SPECIFIED BY THE JUMP.
;THIS TEST ALSO VERIFIES CORRECT UPDATING OF THE AC FOR AOBJN

C35000:	MOVE	3,[-2,,5]	;SETUP AC SO THAT AOBJN WILL JUMP
	XCT	[AOBJN 3,.+3]	;*JUMP SHOULD BE TO C35000+4
	HALT			;JUMP OVER THIS INSTRUCTION
	HALT			;JUMP OVER THIS INSTRUCTION
	CAME	3,[-1,,6]	;PASS IF C(AC)=-1,,6 AND AOBJN JUMPED
	STOP

;**********

;THIS TEST VERIFIES THAT IF AN XCT EXECUTES A JUMP, PROGRAM FLOW IS ALTERED AS
;SPECIFIED BY THE JUMP.
;THIS TEST ALSO VERIFIES CORRECT UPDATING OF THE AC FOR AOBJN

C35100:	MOVE	3,[-1,,6]	;SETUP AC SO THAT AOBJN WILL NOT JUMP
	XCT	[AOBJN 3,.+2]	;*AOBJN SHOULD NOT JUMP
	CAME	3,[0,,7]	;PASS IF AOBJN DID NOT JUMP AND C(AC)=0,,7
	STOP

;**********
SUBTTL	TEST XCT INSTRUCTION WITH INDIRECT ADDRESSING AND INDEXING

;**********

;THIS TEST VERIFIES THAT XCT WILL EXECUTE AN INSTRUCTION
;FROM AN INDIRECTLY ADDRESSED LOCATION

C35200:	SETZB	2
	JRST	.+3
		.+1
	SETOM	2		;THIS INSTRUCTION SHOULD BE EXECUTED
	XCT	@.-2
	CAME	2,[-1,,-1]	;PASS IF 'SETOM 2' WAS EXECUTED
	STOP

;**********

;THIS TEST VERIFIES THAT XCT WILL EXECUTE AN INSTRUCTION
;FROM AN INDEXED LOCATION

C35300:	MOVEI	4,.+1
	JRST	.+2
	CAIE	4,.-1		;THIS INSTRUCTION SHOULD BE EXECUTED
	XCT	1(4)
	STOP			;PASS IF 'CAIE 4,,-1' WAS EXECUTED

;**********
;THIS TEST VERIFIES THAT XCT WILL EXECUTE AN INSTRUCTION
;FROM AN INDIRECTLY ADDRESSED AND INDEXED LOCATION

C35400:	SETZM	5
	MOVEI	3,.+3
	JRST	.+2
	MOVEI	5,.+3
	XCT	@-1(3)
	JRST	.+2
	SETOM	5		;THIS INSTRUCTION SHOULD BE EXECUTED
	CAME	5,[-1,,-1]	;PASS IF 'SETOM 5' WAS EXECUTED
	STOP

;**********

;THIS TEST VERIFIES THAT XCT WILL EXECUTE AN INDIRECTLY ADDRESSED
;AND INDEXED INSTRUCTION

C35500:	SETZM	3
	MOVEI	10,3
	JRST	.+5
	HALT
	HALT
	MOVE	3,@.-2(10)	;THIS INSTRUCTION SHOULD BE EXECUTED
	HALT	[0,,707070]
	XCT	.-2
	CAIE	3,707070	;PASS IF 'MOVE 3,@.-2(10)' WAS EXECUTED
	STOP

;**********
SUBTTL	TEST OF SHIFT/ROTATE INSTRUCTIONS USED IN THE ERROR HANDLER

;**********

;THIS TEST VERIFIES THAT A ROT INSTRUCTION FUNCTIONS CORRECTLY.
;IN THIS CASE, 0,,0 SHOULD BE ROTATED RIGHT 3 BIT POSITIONS
;SO THAT FINAL C(AC)=0,,0.
;C(AC+1) SHOULD NOT BE AFFECTED.

C35600:	MOVE	0,[0,,0]	;PRELOAD AC WITH 0,,0
	MOVE	1,[172737,,405060] ;PRELOAD AC+1 WITH 172737,,405060
	ROT	0,-3		;*ROT SHOULD ROTATE 0,,0 RIGHT 3 BIT POSITIONS
	CAME	0,[0,,0]	;PASS IF C(AC)=0,,0
	STOP
	CAME	1,[172737,,405060] ;PASS IF C(AC+1) NOT AFFECTED
	STOP

;**********

;THIS TEST VERIFIES THAT A ROT INSTRUCTION FUNCTIONS CORRECTLY.
;IN THIS CASE, -1,,-1 SHOULD BE ROTATED RIGHT 3 BIT POSITIONS
;SO THAT FINAL C(AC)=-1,,-1.
;C(AC+1) SHOULD NOT BE AFFECTED.

C35700:	MOVE	0,[-1,,-1]	;PRELOAD AC WITH 0,,0
	MOVE	1,[172737,,405060] ;PRELOAD AC+1 WITH 172737,,405060
	ROT	0,-3		;*ROT SHOULD ROTATE -1,,-1 RIGHT 3 BIT POSITIONS
	CAME	0,[-1,,-1]	;PASS IF C(AC)=-1,,-1
	STOP
	CAME	1,[172737,,405060] ;PASS IF C(AC+1) NOT AFFECTED
	STOP

;**********
;THIS TEST VERIFIES THAT A ROT INSTRUCTION FUNCTIONS CORRECTLY.
;IN THIS CASE, 252525,,252525 SHOULD BE ROTATED RIGHT 3 BIT POSITIONS
;SO THAT FINAL C(AC)=525252,,525252.
;C(AC+1) SHOULD NOT BE AFFECTED.

C36000:	MOVE	0,[252525,,252525] ;PRELOAD AC WITH 252525,,252525
	MOVE	1,[172737,,405060] ;PRELOAD AC+1 WITH 172737,,405060
	ROT	0,-3		;*ROT SHOULD ROTATE 252525,,252525
				;RIGHT 3 BIT POSITIONS
	CAME	0,[525252,,525252] ;PASS IF C(AC)=525252,,525252
	STOP
	CAME	1,[172737,,405060] ;PASS IF C(AC+1) NOT AFFECTED
	STOP

;**********

;THIS TEST VERIFIES THAT A ROT INSTRUCTION FUNCTIONS CORRECTLY.
;IN THIS CASE, 525252,,525252 SHOULD BE ROTATED RIGHT 3 BIT POSITIONS
;SO THAT FINAL C(AC)=252525,,252525.
;C(AC+1) SHOULD NOT BE AFFECTED.

C36100:	MOVE	0,[525252,,525252] ;PRELOAD AC WITH 525252,,525252
	MOVE	1,[172737,,405060] ;PRELOAD AC+1 WITH 172737,,405060
	ROT	0,-3		;*ROT SHOULD ROTATE 525252,,525252
				;RIGHT 3 BIT POSITIONS
	CAME	0,[252525,,252525] ;PASS IF C(AC)=252525,,252525
	STOP
	CAME	1,[172737,,405060] ;PASS IF C(AC+1) NOT AFFECTED
	STOP

;**********
;THIS TEST VERIFIES THAT A ROT INSTRUCTION FUNCTIONS CORRECTLY.
;IN THIS CASE, 230703,,603700 SHOULD BE ROTATED RIGHT 3 BIT POSITIONS
;SO THAT FINAL C(AC)=023070,,360370.
;C(AC+1) SHOULD NOT BE AFFECTED.

C36200:	MOVE	0,[230703,,603700] ;PRELOAD AC WITH 230703,,603700
	MOVE	1,[172737,,405060] ;PRELOAD AC+1 WITH 172737,,405060
	ROT	0,-3		;*ROT SHOULD ROTATE 230703,,603700
				;RIGHT 3 BIT POSITIONS
	CAME	0,[023070,,360370] ;PASS IF C(AC)=023070,,360370
	STOP
	CAME	1,[172737,,405060] ;PASS IF C(AC+1) NOT AFFECTED
	STOP

;**********

;THIS TEST VERIFIES THAT A ROT INSTRUCTION FUNCTIONS CORRECTLY.
;IN THIS CASE, 007603,,607062 SHOULD BE ROTATED RIGHT 3 BIT POSITIONS
;SO THAT FINAL C(AC)=200760,,360706.
;C(AC+1) SHOULD NOT BE AFFECTED.

C36300:	MOVE	0,[007603,,607062] ;PRELOAD AC WITH 007603,,607062
	MOVE	1,[172737,,405060] ;PRELOAD AC+1 WITH 172737,,405060
	ROT	0,-3		;*ROT SHOULD ROTATE 007603,,607062
				;RIGHT 3 BIT POSITIONS
	CAME	0,[200760,,360706] ;PASS IF C(AC)=200760,,360706
	STOP
	CAME	1,[172737,,405060] ;PASS IF C(AC+1) NOT AFFECTED
	STOP

;**********
;THIS TEST VERIFIES THAT A ROT INSTRUCTION FUNCTIONS CORRECTLY.
;IN THIS CASE, 0,,0 SHOULD BE ROTATED LEFT 15 BIT POSITIONS
;SO THAT FINAL C(AC)=0,,0.
;C(AC+1) SHOULD NOT BE AFFECTED.

C36400:	MOVE	2,[0,,0]	;PRELOAD AC WITH 0,,0
	MOVE	3,[172737,,405060] ;PRELOAD AC+1 WITH 172737,,405060
	ROT	2,15		;*ROT SHOULD ROTATE 0,,0 LEFT 15 BIT POSITIONS
	CAME	2,[0,,0]	;PASS IF C(AC)=0,,0
	STOP
	CAME	3,[172737,,405060] ;PASS IF C(AC+1) NOT AFFECTED
	STOP

;**********

;THIS TEST VERIFIES THAT A ROT INSTRUCTION FUNCTIONS CORRECTLY.
;IN THIS CASE, -1,,-1 SHOULD BE ROTATED LEFT 15 BIT POSITIONS
;SO THAT FINAL C(AC)=-1,,-1.
;C(AC+1) SHOULD NOT BE AFFECTED.

C36500:	MOVE	2,[-1,,-1]	;PRELOAD AC WITH -1,,-1
	MOVE	3,[172737,,405060] ;PRELOAD AC+1 WITH 172737,,405060
	ROT	2,15		;*ROT SHOULD ROTATE -1,,-1 LEFT 15 BIT POSITIONS
	CAME	2,[-1,,-1]	;PASS IF C(AC)=-1,,-1
	STOP
	CAME	3,[172737,,405060] ;PASS IF C(AC+1) NOT AFFECTED
	STOP

;**********
;THIS TEST VERIFIES THAT A ROT INSTRUCTION FUNCTIONS CORRECTLY.
;IN THIS CASE, 252525,,252525 SHOULD BE ROTATED LEFT 15 BIT POSITIONS
;SO THAT FINAL C(AC)=525252,,525252.
;C(AC+1) SHOULD NOT BE AFFECTED.

C36600:	MOVE	2,[252525,,252525] ;PRELOAD AC WITH 252525,,252525
	MOVE	3,[172737,,405060] ;PRELOAD AC+1 WITH 172737,,405060
	ROT	2,15		;*ROT SHOULD ROTATE 252525,,252525
				;LEFT 15 BIT POSITIONS
	CAME	2,[525252,,525252] ;PASS IF C(AC)=525252,,525252
	STOP
	CAME	3,[172737,,405060] ;PASS IF C(AC+1) NOT AFFECTED
	STOP

;**********

;THIS TEST VERIFIES THAT A ROT INSTRUCTION FUNCTIONS CORRECTLY.
;IN THIS CASE, 525252,,525252 SHOULD BE ROTATED LEFT 15 BIT POSITIONS
;SO THAT FINAL C(AC)=252525,,252525.
;C(AC+1) SHOULD NOT BE AFFECTED.

C36700:	MOVE	2,[525252,,525252] ;PRELOAD AC WITH 525252,,525252
	MOVE	3,[172737,,405060] ;PRELOAD AC+1 WITH 172737,,405060
	ROT	2,15		;*ROT SHOULD ROTATE 525252,,525252
				;LEFT 15 BIT POSITIONS
	CAME	2,[252525,,252525] ;PASS IF C(AC)=252525,,252525
	STOP
	CAME	3,[172737,,405060] ;PASS IF C(AC+1) NOT AFFECTED
	STOP

;**********
;THIS TEST VERIFIES THAT A ROT INSTRUCTION FUNCTIONS CORRECTLY.
;IN THIS CASE, 230703,,603700 SHOULD BE ROTATED LEFT 15 BIT POSITIONS
;SO THAT FINAL C(AC)074076,,004616.
;C(AC+1) SHOULD NOT BE AFFECTED.

C37000:	MOVE	2,[230703,,603700] ;PRELOAD AC WITH 230703,,603700
	MOVE	3,[172737,,405060] ;PRELOAD AC+1 WITH 172737,,405060
	ROT	2,15		;*ROT SHOULD ROTATE 230703,,603700
				;LEFT 15 BIT POSITIONS
	CAME	2,[074076,,004616] ;PASS IF C(AC)074076,,004616
	STOP
	CAME	3,[172737,,405060] ;PASS IF C(AC+1) NOT AFFECTED
	STOP

;**********

;THIS TEST VERIFIES THAT A ROT INSTRUCTION FUNCTIONS CORRECTLY.
;IN THIS CASE, 007603,,607062 SHOULD BE ROTATED LEFT 15 BIT POSITIONS
;SO THAT FINAL C(AC)074161,,440174.
;C(AC+1) SHOULD NOT BE AFFECTED.

C37100:	MOVE	2,[007603,,607062] ;PRELOAD AC WITH 007603,,607062
	MOVE	3,[172737,,405060] ;PRELOAD AC+1 WITH 172737,,405060
	ROT	2,15		;*ROT SHOULD ROTATE 007603,,607062
				;LEFT 15 BIT POSITIONS
	CAME	2,[074161,,440174] ;PASS IF C(AC)074161,,440174
	STOP
	CAME	3,[172737,,405060] ;PASS IF C(AC+1) NOT AFFECTED
	STOP

;**********
;THIS TEST VERIFIES THAT A ROTC INSTRUCTION FUNCTIONS CORRECTLY.
;IN THIS CASE, 0,,0 0,,0 SHOULD BE ROTATED LEFT 3 BIT POSITIONS
;SO THAT FINAL C(AC)=0,,0 AND FINAL C(AC+1)=0,,0

C37200:	MOVE	0,[0,,0]	;PRELOAD AC WITH 0,,0
	MOVE	1,[0,,0]	;PRELOAD AC+1 WITH 0,,0
	ROTC	0,3		;*ROTC SHOULD ROTATE 0,,0 0,,0 LEFT 3 BIT POSITIONS
	CAME	0,[0,,0]	;PASS IF C(AC)=0,,0
	STOP
	CAME	1,[0,,0]	;PASS IF C(AC+1)=0,,0
	STOP

;**********

;THIS TEST VERIFIES THAT A ROTC INSTRUCTION FUNCTIONS CORRECTLY.
;IN THIS CASE, -1,,-1 -1,,-1 SHOULD BE ROTATED LEFT 3 BIT POSITIONS
;SO THAT FINAL C(AC)=-1,,-1 AND FINAL C(AC+1)=-1,,-1

C37300:	MOVE	0,[-1,,-1]	;PRELOAD AC WITH -1,,-1
	MOVE	1,[-1,,-1]	;PRELOAD AC+1 WITH -1,,-1
	ROTC	0,3		;*ROTC SHOULD ROTATE -1,,-1
				;-1,,-1 LEFT 3 BIT POSITIONS
	CAME	0,[-1,,-1]	;PASS IF C(AC)=-1,,-1
	STOP
	CAME	0,[-1,,-1]	;PASS IF C(AC+1)=-1,,-1
	STOP

;**********
;THIS TEST VERIFIES THAT A ROTC INSTRUCTION FUNCTIONS CORRECTLY.
;IN THIS CASE, 252525,,252525 252525,,252525 SHOULD BE ROTATED LEFT 3 BIT POSITIONS
;SO THAT FINAL C(AC)=525252,,525252 AND FINAL C(AC+1)=525252,,525252

C37400:	MOVE	0,[252525,,252525]	;PRELOAD AC WITH 252525,,252525
	MOVE	1,[252525,,252525]	;PRELOAD AC+1 WITH 252525,,252525
	ROTC	0,3			;*ROTC SHOULD ROTATE 252525,,252525
					;252525,,252525 LEFT 3 BIT POSITIONS
	CAME	0,[525252,,525252]	;PASS IF C(AC)=525252,,525252
	STOP
	CAME	1,[525252,,525252]	;PASS IF C(AC+1)=525252,,525252
	STOP

;**********

;THIS TEST VERIFIES THAT A ROTC INSTRUCTION FUNCTIONS CORRECTLY.
;IN THIS CASE, 525252,,525252 525252,,525252 SHOULD BE ROTATED LEFT 3 BIT POSITIONS
;SO THAT FINAL C(AC)=252525,,252525 AND FINAL C(AC+1)=252525,,252525

C37500:	MOVE	0,[525252,,525252]	;PRELOAD AC WITH 525252,,525252
	MOVE	1,[525252,,525252]	;PRELOAD AC+1 WITH 525252,,525252
	ROTC	0,3			;*ROTC SHOULD ROTATE 525252,,525252
					;525252,,525252 LEFT 3 BIT POSITIONS
	CAME	0,[252525,,252525]	;PASS IF C(AC)=252525,,252525
	STOP
	CAME	1,[252525,,252525]	;PASS IF C(AC+1)=252525,,252525
	STOP

;**********
;THIS TEST VERIFIES THAT A ROTC INSTRUCTION FUNCTIONS CORRECTLY.
;IN THIS CASE, 230703,,603700 770037,,600377 SHOULD BE ROTATED LEFT 3 BIT POSITIONS
;SO THAT FINAL C(AC)=307036,,37007 AND FINAL C(AC+1)=700376,,003772

C37600:	MOVE	0,[230703,,603700]	;PRELOAD AC WITH 230703,,603700
	MOVE	1,[770037,,600377]	;PRELOAD AC+1 WITH 770037,,600377
	ROTC	0,3			;*ROTC SHOULD ROTATE 230703,,603700
					;770037,,600377 LEFT 3 BIT POSITIONS
	CAME	0,[307036,,037007]	;PASS IF C(AC)=307036,,37007
	STOP
	CAME	1,[700376,,003772]	;PASS IF C(AC+1)=700376,,003772
	STOP

;**********

;THIS TEST VERIFIES THAT A ROTC INSTRUCTION FUNCTIONS CORRECTLY.
;IN THIS CASE, 776003,,760077 007603,,607062 SHOULD BE ROTATED LEFT 3 BIT POSITIONS
;SO THAT FINAL C(AC)=760037,,600770 AND FINAL C(AC+1)=076036,,070627

C37700:	MOVE	0,[776003,,760077]	;PRELOAD AC WITH 776003,,760077
	MOVE	1,[007603,,607062]	;PRELOAD AC+1 WITH 007603,,607062
	ROTC	0,3			;*ROTC SHOULD ROTATE 776003,,760077
					;007603,,607062 LEFT 3 BIT POSITIONS
	CAME	0,[760037,,600770]	;PASS IF C(AC)=076036,,070627
	STOP
	CAME	1,[076036,,070627]	;PASS IF C(AC+1)=760037,,600770
	STOP

;**********
;THIS TEST VERIFIES THAT A ROTC INSTRUCTION FUNCTIONS CORRECTLY.
;IN THIS CASE, 0,,0 0,,0 SHOULD BE ROTATED LEFT 7 BIT POSITIONS
;SO THAT FINAL C(AC)=0,,0 AND FINAL C(AC+1)=0,,0

C40000:	MOVE	0,[0,,0]	;PRELOAD AC WITH 0,,0
	MOVE	1,[0,,0]	;PRELOAD AC+1 WITH 0,,0
	ROTC	0,7		;*ROTC SHOULD ROTATE 0,,0 0,,0 LEFT 7 BIT POSITIONS
	CAME	0,[0,,0]	;PASS IF C(AC)=0,,0
	STOP
	CAME	1,[0,,0]	;PASS IF C(AC+1)=0,,0
	STOP

;**********

;THIS TEST VERIFIES THAT A ROTC INSTRUCTION FUNCTIONS CORRECTLY.
;IN THIS CASE, -1,,-1 -1,,-1  SHOULD BE ROTATED LEFT 7 BIT POSITIONS
;SO THAT FINAL C(AC)=-1,,-1 AND FINAL C(AC+1)=-1,,-1

C40100:	MOVE	0,[-1,,-1]	;PRELOAD AC WITH -1,,-1
	MOVE	1,[-1,,-1]	;PRELOAD AC+1 WITH -1,,-1
	ROTC	0,7		;*ROTC SHOULD ROTATE -1,,-1
				;-1,,-1 LEFT 7 BIT POSITIONS
	CAME	0,[-1,,-1]	;PASS IF C(AC)=-1,,-1
	STOP
	CAME	1,[-1,,-1]	;PASS IF C(AC+1)=-1,,-1
	STOP

;**********
;THIS TEST VERIFIES THAT A ROTC INSTRUCTION FUNCTIONS CORRECTLY.
;IN THIS CASE, 252525,,252525 252525,,252525 SHOULD BE ROTATED LEFT 7 BIT POSITIONS
;SO THAT FINAL C(AC)=525252,,525252 AND FINAL C(AC+1)=525252,,525252

C40200:	MOVE	0,[252525,,252525]	;PRELOAD AC WITH 252525,,252525
	MOVE	1,[252525,,252525]	;PRELOAD AC+1 WITH 252525,,252525
	ROTC	0,7			;*ROTC SHOULD ROTATE 252525,,252525
					;252525,,252525 LEFT 7 BIT POSITIONS
	CAME	0,[525252,,525252]	;PASS IF C(AC)=525252,,525252
	STOP
	CAME	1,[525252,,525252]	;PASS IF C(AC+1)=525252,,525252
	STOP

;**********

;THIS TEST VERIFIES THAT A ROTC INSTRUCTION FUNCTIONS CORRECTLY.
;IN THIS CASE, 525252,,525252 525252,,525252 SHOULD BE ROTATED LEFT 7 BIT POSITIONS
;SO THAT FINAL C(AC)=252525,,252525 AND FINAL C(AC+1)=252525,,252525

C40300:	MOVE	0,[525252,,525252]	;PRELOAD AC WITH 525252,,525252
	MOVE	1,[525252,,525252]	;PRELOAD AC+1 WITH 525252,,525252
	ROTC	0,7			;*ROTC SHOULD ROTATE 525252,,525252
					;525252,,525252 LEFT 7 BIT POSITIONS
	CAME	0,[252525,,252525]	;PASS IF C(AC)=252525,,252525
	STOP
	CAME	1,[252525,,252525]	;PASS IF C(AC+1)=252525,,252525
	STOP

;**********
;THIS TEST VERIFIES THAT A ROTC INSTRUCTION FUNCTIONS CORRECTLY.
;IN THIS CASE, 230703,,603700 770037,,600377 SHOULD BE ROTATED LEFT 7 BIT POSITIONS
;SO THAT FINAL C(AC)=160740,,760176 AND FINAL C(AC+1)=007740,,077646

C40400:	MOVE	0,[230703,,603700]	;PRELOAD AC WITH 230703,,603700
	MOVE	1,[770037,,600377]	;PRELOAD AC+1 WITH 770037,,600377
	ROTC	0,7			;*ROTC SHOULD ROTATE 230703,,603700
					;770037,,600377 LEFT 7 BIT POSITIONS
	CAME	0,[160740,,760176]	;PASS IF C(AC)=160740,,760176
	STOP
	CAME	1,[007740,,077646]	;PASS IF C(AC+1)=007740,,077646
	STOP

;**********

;THIS TEST VERIFIES THAT A ROTC INSTRUCTION FUNCTIONS CORRECTLY.
;IN THIS CASE, 776003,,760077 007603,,607063 SHOULD BE ROTATED LEFT 7 BIT POSITIONS
;SO THAT FINAL C(AC)=400774,,017610 AND FINAL C(AC+1)=740741,,614577

C40500:	MOVE	0,[776003,,760077]	;PRELOAD AC WITH 776003,,760077
	MOVE	1,[007603,,607062]	;PRELOAD AC+1 WITH 007603,,607062
	ROTC	0,7			;*ROTC SHOULD ROTATE 776003,,760077
					;007603,,607062 LEFT 7 BIT POSITIONS
	CAME	0,[400774,,017601]	;PASS IF C(AC)=400774,,017601
	STOP
	CAME	1,[740741,,614577]	;PASS IF C(AC+1)=740741,,614577
	STOP

;**********
;THIS TEST VERIFIES THAT THE LSH INSTRUCTION FUNCTIONS CORRECTLY
;IN THIS CASE, 0,,0 SHOULD BE LOGICALLY SHIFTED RIGHT 33 OCTAL BIT POSITIONS
;SO THAT FINAL C(AC)=0,,0.
;C(AC+1) SHOULD NOT BE AFFECTED

C40600:	MOVE	0,[0,,0]	;PRELOAD AC WITH 0,,0
	MOVE	1,[172737,,405060] ;PRELOAD AC+1 WITH 172737,,405060
	LSH	0,-33		;*LSH SHOULD LOGICALLY SHIFT 0,,0
				;RIGHT 33 OCTAL BIT POSITIONS
	CAME	0,[0,,0]	;PASS IF C(AC)=0,,0
	STOP
	CAME	1,[172737,,405060] ;PASS IF C(AC+1) NOT AFFECTED
	STOP

;**********

;THIS TEST VERIFIES THAT THE LSH INSTRUCTION FUNCTIONS CORRECTLY
;IN -1,,-1 SHOULD BE LOGICALLY SHIFTED RIGHT 33 OCTAL BIT POSITIONS
;SO THAT FINAL C(AC)=0,,777.
;C(AC+1) SHOULD NOT BE AFFECTED

C40700:	MOVE	0,[-1,,-1]	;PRELOAD AC WITH -1,,-1
	MOVE	1,[172737,,405060] ;PRELOAD AC+1 WITH 172737,,405060
	LSH	0,-33		;*LSH SHOULD LOGICALLY SHIFT -1,,-1
				;RIGHT 33 OCTAL BIT POSITIONS
	CAME	0,[0,777]	;PASS IF C(AC)=0,,777
	STOP
	CAME	1,[172737,,405060] ;PASS IF C(AC+1) NOT AFFECTED
	STOP

;**********
;THIS TEST VERIFIES THAT THE LSH INSTRUCTION FUNCTIONS CORRECTLY
;IN 252525,,252525 SHOULD BE LOGICALLY SHIFTED RIGHT 33 OCTAL BIT POSITIONS
;SO THAT FINAL C(AC)=0,,252.
;C(AC+1) SHOULD NOT BE AFFECTED

C41000:	MOVE	0,[252525,,252525]	;PRELOAD AC WITH 252525,,252525
	MOVE	1,[172737,,405060] 	;PRELOAD AC+1 WITH 172737,,405060
	LSH	0,-33			;*LSH SHOULD LOGICALLY SHIFT 252525,,252525
					;RIGHT 33 OCTAL BIT POSITIONS
	CAME	0,[0,,252]		;PASS IF C(AC)=0,,252
	STOP
	CAME	1,[172737,,405060]	;PASS IF C(AC+1) NOT AFFECTED
	STOP

;**********

;THIS TEST VERIFIES THAT THE LSH INSTRUCTION FUNCTIONS CORRECTLY
;IN THIS CASE, 525252,,525252 SHOULD BE LOGICALLY SHIFTED RIGHT 33 OCTAL BIT POSITIONS
;SO THAT FINAL C(AC)=0,,525.
;C(AC+1) SHOULD NOT BE AFFECTED

C41100:	MOVE	0,[525252,,525252]	;PRELOAD AC WITH 525252,,525252
	MOVE	1,[172737,,405060]	;PRELOAD AC+1 WITH 172737,,405060
	LSH	0,-33			;*LSH SHOULD LOGICALLY SHIFT 525252,,525252
					;RIGHT 33 OCTAL BIT POSITIONS
	CAME	0,[0,,525]		;PASS IF C(AC)=0,,525
	STOP
	CAME	1,[172737,,405060]	;PASS IF C(AC+1) NOT AFFECTED
	STOP

;**********
;THIS TEST VERIFIES THAT THE LSH INSTRUCTION FUNCTIONS CORRECTLY
;IN THIS CASE, 230703,,603700 SHOULD BE LOGICALLY SHIFTED RIGHT 33 OCTAL BIT POSITIONS
;SO THAT FINAL C(AC)=0,,230.
;C(AC+1) SHOULD NOT BE AFFECTED

C41200:	MOVE	0,[230703,,603700]	;PRELOAD AC WITH 230703,,603700
	MOVE	1,[172737,,405060]	;PRELOAD AC+1 WITH 172737,,405060
	LSH	0,-33			;*LSH SHOULD LOGICALLY SHIFT 230703,,603700
					;RIGHT 33 OCTAL BIT POSITIONS
	CAME	0,[0,,230]		;PASS IF C(AC)=230703,,603700
	STOP
	CAME	1,[172737,,405060]	;PASS IF C(AC+1) NOT AFFECTED
	STOP

;**********

;THIS TEST VERIFIES THAT THE LSH INSTRUCTION FUNCTIONS CORRECTLY
;IN THIS CASE, 007603,,607062 SHOULD BE LOGICALLY SHIFTED RIGHT 33 OCTAL BIT POSITIONS
;SO THAT FINAL C(AC)=0,,7.
;C(AC+1) SHOULD NOT BE AFFECTED

C41300:	MOVE	0,[007603,,607062]	;PRELOAD AC WITH 007603,,607062
	MOVE	1,[172737,,405060]	;PRELOAD AC+1 WITH 172737,,405060
	LSH	0,-33			;*LSH SHOULD LOGICALLY SHIFT 007603,,6070062
					;RIGHT 33 OCTAL BIT POSITIONS
	CAME	0,[0,,7]		;PASS IF C(AC)=0,,7
	STOP
	CAME	1,[172737,,405060]	;PASS IF C(AC+1) NOT AFFECTED
	STOP

;**********
;THIS TEST VERIFIES THAT THE LSH INSTRUCTION FUNCTIONS CORRECTLY
;IN THIS CASE, 0,,0 SHOULD BE LOGICALLY SHIFTED RIGHT 27 OCTAL BIT POSITIONS
;SO THAT FINAL C(AC)=0,,0.
;C(AC+1) SHOULD NOT BE AFFECTED

C41400:	MOVE	1,[0,,0]	;PRELOAD AC WITH 0,,0
	MOVE	2,[172737,,405060]	;PRELOAD C(AC+1) WITH 172737,,405060
	LSH	1,-27		;*LSH SHOULD LOGICALLY SHIFT 0,,0
				;RIGHT 27 OCTAL BIT POSITIONS
	CAME	1,[0,,0]	;PASS IF C(AC)=0,,0
	STOP
	CAME	2,[172737,,405060]	;PASS IF C(AC+1) NOT AFFECTED
	STOP

;**********

;THIS TEST VERIFIES THAT THE LSH INSTRUCTION FUNCTIONS CORRECTLY
;IN THIS CASE, -1,,-1 SHOULD BE LOGICALLY SHIFTED RIGHT 27 OCTAL BIT POSITIONS
;SO THAT FINAL C(AC)=0,,17777.
;C(AC+1) SHOULD NOT BE AFFECTED

C41500:	MOVE	1,[-1,,-1]	;PRELOAD AC WITH -1,,-1
	MOVE	2,[172737,,405060]	;PRELOAD C(AC+1) WITH 172737,,405060
	LSH	1,-27		;*LSH SHOULD LOGICALLY SHIFT -1,,-1
				;RIGHT 27 OCTAL BIT POSITIONS
	CAME	1,[0,,17777]	;PASS IF C(AC)=0,17777
	STOP
	CAME	2,[172737,,405060]	;PASS IF C(AC+1) NOT AFFECTED
	STOP

;**********
;THIS TEST VERIFIES THAT THE LSH INSTRUCTION FUNCTIONS CORRECTLY
;IN THIS CASE, 252525,,252525 SHOULD BE LOGICALLY SHIFTED RIGHT 27 OCTAL BIT POSITIONS
;SO THAT FINAL C(AC)=0,,5252.
;C(AC+1) SHOULD NOT BE AFFECTED

C41600:	MOVE	1,[252525,,252525]	;PRELOAD AC WITH 252525,,252525
	MOVE	2,[172737,,405060]	;PRELOAD C(AC+1) WITH 172737,,405060
	LSH	1,-27			;*LSH SHOULD LOGICALLY SHIFT 252525,,252525
					;RIGHT 27 OCTAL BIT POSITIONS
	CAME	1,[0,,5252]		;PASS IF C(AC)=0,,5252
	STOP
	CAME	2,[172737,,405060]	;PASS IF C(AC+1) NOT AFFECTED
	STOP

;**********

;THIS TEST VERIFIES THAT THE LSH INSTRUCTION FUNCTIONS CORRECTLY
;IN THIS CASE, 525252,,525252 SHOULD BE LOGICALLY SHIFTED RIGHT 27 OCTAL BIT POSITIONS
;SO THAT FINAL C(AC)=0,,12525.
;C(AC+1) SHOULD NOT BE AFFECTED

C41700:	MOVE	1,[525252,,525252]	;PRELOAD AC WITH 525252,,525252
	MOVE	2,[172737,,405060]	;PRELOAD C(AC+1) WITH 172737,,405060
	LSH	1,-27			;*LSH SHOULD LOGICALLY SHIFT 525252,,525252
					;RIGHT 27 OCTAL BIT POSITIONS
	CAME	1,[0,,12525]		;PASS IF C(AC)=0,,12525
	STOP
	CAME	2,[172737,,405060]	;PASS IF C(AC+1) NOT AFFECTED
	STOP

;**********
;THIS TEST VERIFIES THAT THE LSH INSTRUCTION FUNCTIONS CORRECTLY
;IN THIS CASE, 230703,602700 SHOULD BE LOGICALLY SHIFTED RIGHT 27 OCTAL BIT POSITIONS
;SO THAT FINAL C(AC)=0,,4616.
;C(AC+1) SHOULD NOT BE AFFECTED

C42000:	MOVE	1,[230703,,603700]	;PRELOAD AC WITH 230703,603700
	MOVE	2,[172737,,405060]	;PRELOAD C(AC+1) WITH 172737,,405060
	LSH	1,-27			;*LSH SHOULD LOGICALLY SHIFT 230703,,603700
					;RIGHT 27 OCTAL BIT POSITIONS
	CAME	1,[0,,4616]		;PASS IF C(AC)=0,,4616
	STOP
	CAME	2,[172737,,405060]	;PASS IF C(AC+1) NOT AFFECTED
	STOP

;**********

;THIS TEST VERIFIES THAT THE LSH INSTRUCTION FUNCTIONS CORRECTLY
;IN THIS CASE, 007603,,607062 SHOULD BE LOGICALLY SHIFTED RIGHT 27 OCTAL BIT POSITIONS
;SO THAT FINAL C(AC)=0,,174.
;C(AC+1) SHOULD NOT BE AFFECTED

C42100:	MOVE	1,[007603,,607062]	;PRELOAD AC WITH 007603,,607062
	MOVE	2,[172737,,405060]	;PRELOAD C(AC+1) WITH 172737,,405060
	LSH	1,-27			;*LSH SHOULD LOGICALLY SHIFT 007603,,607062
					;RIGHT 27 OCTAL BIT POSITIONS
	CAME	1,[0,,174]		;PASS IF C(AC)=0,,174
	STOP
	CAME	2,[172737,,405060]	;PASS IF C(AC+1) NOT AFFECTED
	STOP

;**********
;THIS TEST VERIFIES THAT THE LSH INSTRUCTION FUNCTIONS CORRECTLY
;IN THIS CASE, 0,,0 SHOULD BE LOGICALLY SHIFTED RIGHT 33 OCTAL BIT POSITIONS
;SO THAT FINAL C(AC)=0,,0.
;C(AC+1) SHOULD NOT BE AFFECTED

C42200:	MOVE	1,[0,0]		;PRELOAD AC WITH 0,,0
	MOVE	2,[172737,,405060]	;PRELOAD C(AC+1) WITH 172737,,405060
	LSH	1,-33		;*LSH SHOULD LOGICALLY SHIFT 0,,0
				;RIGHT 33 OCTAL BIT POSITIONS
	CAME	1,[0,,0]	;PASS IF C(AC)=0,,0
	STOP
	CAME	2,[172737,,405060]	;PASS IF C(AC+1) NOT AFFECTED
	STOP

;**********

;THIS TEST VERIFIES THAT THE LSH INSTRUCTION FUNCTIONS CORRECTLY
;IN THIS CASE, -1,,-1 SHOULD BE LOGICALLY SHIFTED RIGHT 33 OCTAL BIT POSITIONS
;SO THAT FINAL C(AC)=0,,777.
;C(AC+1) SHOULD NOT BE AFFECTED

C42300:	MOVE	1,[-1,,-1]	;PRELOAD AC WITH -1,,-1
	MOVE	2,[172737,,405060]	;PRELOAD C(AC+1) WITH 172737,,405060
	LSH	1,-33		;*LSH SHOULD LOGICALLY SHIFT -1,,-1
				;RIGHT 33 OCTAL BIT POSITIONS
	CAME	1,[0,,777]	;PASS IF C(AC)=0,,777
	STOP
	CAME	2,[172737,,405060]	;PASS IF C(AC+1) NOT AFFECTED
	STOP

;**********
;THIS TEST VERIFIES THAT THE LSH INSTRUCTION FUNCTIONS CORRECTLY
;IN THIS CASE, 252525,,252525 SHOULD BE LOGICALLY SHIFTED RIGHT 33 OCTAL BIT POSITIONS
;SO THAT FINAL C(AC)=0,,252.
;C(AC+1) SHOULD NOT BE AFFECTED

C42400:	MOVE	1,[252525,,252525]	;PRELOAD AC WITH 252525,,252525
	MOVE	2,[172737,,405060]	;PRELOAD C(AC+1) WITH 172737,,405060
	LSH	1,-33			;*LSH SHOULD LOGICALLY SHIFT 252525,,252525
					;RIGHT 33 OCTAL BIT POSITIONS
	CAME	1,[0,,252]		;PASS IF C(AC)=0,,252
	STOP
	CAME	2,[172737,,405060]	;PASS IF C(AC+1) NOT AFFECTED
	STOP

;**********

;THIS TEST VERIFIES THAT THE LSH INSTRUCTION FUNCTIONS CORRECTLY
;IN THIS CASE, 525252,,525252 SHOULD BE LOGICALLY SHIFTED RIGHT 33 OCTAL BIT POSITIONS
;SO THAT FINAL C(AC)=0,,525.
;C(AC+1) SHOULD NOT BE AFFECTED

C42500:	MOVE	1,[525252,,525252]	;PRELOAD AC WITH 525252,,525252
	MOVE	2,[172737,,405060]	;PRELOAD C(AC+1) WITH 172737,,405060
	LSH	1,-33			;*LSH SHOULD LOGICALLY SHIFT 525252,,525252
					;RIGHT 33 OCTAL BIT POSITIONS
	CAME	1,[0,,525]		;PASS IF C(AC)=0,525
	STOP
	CAME	2,[172737,,405060]	;PASS IF C(AC+1) NOT AFFECTED
	STOP

;**********
;THIS TEST VERIFIES THAT THE LSH INSTRUCTION FUNCTIONS CORRECTLY
;IN THIS CASE, 230703,,603700 SHOULD BE LOGICALLY SHIFTED RIGHT 33 OCTAL BIT POSITIONS
;SO THAT FINAL C(AC)=0,,230.
;C(AC+1) SHOULD NOT BE AFFECTED

C42600:	MOVE	1,[230703,,603700]	;PRELOAD AC WITH 230703,,603700
	MOVE	2,[172737,,405060]	;PRELOAD C(AC+1) WITH 172737,,405060
	LSH	1,-33			;*LSH SHOULD LOGICALLY SHIFT 230703,,603700
					;RIGHT 33 OCTAL BIT POSITIONS
	CAME	1,[0,,230]		;PASS IF C(AC)=0,,230
	STOP
	CAME	2,[172737,,405060]	;PASS IF C(AC+1) NOT AFFECTED
	STOP

;**********

;THIS TEST VERIFIES THAT THE LSH INSTRUCTION FUNCTIONS CORRECTLY
;IN THIS CASE, 007603,,607062 SHOULD BE LOGICALLY SHIFTED RIGHT 33 OCTAL BIT POSITIONS
;SO THAT FINAL C(AC)=0,,7.
;C(AC+1) SHOULD NOT BE AFFECTED

C42700:	MOVE	1,[007603,,607062]	;PRELOAD AC WITH 007603,,607062
	MOVE	2,[172737,,405060]	;PRELOAD C(AC+1) WITH 172737,,405060
	LSH	1,-33			;*LSH SHOULD LOGICALLY SHIFT 007603,,607062
					;RIGHT 33 OCTAL BIT POSITIONS
	CAME	1,[0,,7]		;PASS IF C(AC)=0,,7
	STOP
	CAME	2,[172737,,405060]	;PASS IF C(AC+1) NOT AFFECTED
	STOP

	;JRST	BEGEND		;REPEAT TEST
