---
layout: post
title: Introducing the Intel 8080 CPU
date: 2016-04-30 14:00:00
permalink: /blog/2016/04/30/
---

Or rather, introducing [PCx80]({{ site.github.pages }}/machines/pcx80/), a new 8080-based machine emulator
recently added to the PCjs Project.

Our first [8080 Test Machine](/machines/pcx80/exerciser/) loads a copy of the
[8080 Exerciser](https://web.archive.org/web/20151006085348/http://www.idb.me.uk/sunhillow/8080.html)
(specifically, [8080EX1](/machines/pcx80/ram/exerciser/8080EX1.MAC)) and intercepts the exerciser's CP/M console
calls so that you can see its progress in the PCjs Debugger window.  It's a "headless" test machine
(no keyboard or display), so that's all you get.

The good news: PCx80 passes all the 8080 Exerciser tests.  And it doesn't do it by using all sorts of weird
"flags tables" that most other 8080 emulators seem to fall back on.

Like all the other CPU emulations in the PCjs Project, PCx80 never "calculates" the flags unless/until they are
actually required, which considerably speeds up arithmetic operations.

Of particular note are the 8080's subtract, compare, and decrement operations, which actually perform addition,
not subtraction, by using two's complement arithmetic in "stages": the first stage (inverting the source operand)
occurs *before* the addition, and the second stage (incrementing the inverted operand) occurs *after* the addition.
And it appears to be the result of the *first* stage, not the second, that determines the state of the Auxiliary
Carry flag (AF).

The behavior of the Auxiliary Carry flag (AF) and the associated DAA instruction are probably the most significant
(and least understood) *arithmetic* differences between the 8080 and all later x86-based CPUs.  Well, there's also
the fact that the 8080 doesn't provide an Overflow flag (OF).  Internally however, PCx80 retains the ability to
calculate overflow (since PCx80 was a fork of PCjs), which should be useful when we add Z80 support to PCx80.

On a related note, [Ken Shirriff](http://www.righto.com/) has some fascinating blog posts on the 8085 that also
provide clues as to how the 8080 likely operates:

  - [Inside the ALU of the 8085 microprocessor (January 2013)](http://www.righto.com/2013/01/inside-alu-of-8085-microprocessor.html)
  - [Silicon reverse engineering: The 8085's undocumented flags (February 2013)](http://www.righto.com/2013/02/looking-at-silicon-to-understanding.html)
  - [The 8085's register file reverse engineered (March 2013)](http://www.righto.com/2013/03/register-file-8085.html)
  - [Reverse-engineering the 8085's ALU and its hidden registers (July 2013)](http://www.righto.com/2013/07/reverse-engineering-8085s-alu-and-its.html)
  - [Reverse-engineering the flag circuits in the 8085 processor (July 2013)](http://www.righto.com/2013/07/reverse-engineering-flag-circuits-in.html)
  - [Reverse-engineering the 8085's decimal adjust circuitry (August 2013)](http://www.righto.com/2013/08/reverse-engineering-8085s-decimal.html)

The idea is to make [PCx80]({{ site.github.pages }}/machines/pcx80/) sufficiently configurable so that it will work with a variety of
8080-based systems, including those with memory-mapped video displays (like
[Space Invaders](/machines/arcade/invaders/)), as well as simpler terminal-based systems, like the CP/M-based
systems of old.

In fact, as soon as [Space Invaders](/machines/arcade/invaders/) is working, my next planned adaptation
is a DEC VT100 terminal emulator (itself an 8080-based machine) which can then be "wired up" to other PCjs machine
simulations.  This will not be yet-another VT100-compatible emulation -- which, like 8080 emulators, has been done to
death -- but rather a simulation of the original VT100 hardware, building on [Adam Mayer's](https://github.com/phooky)
work [reverse-engineering the VT100](https://github.com/phooky/VT100-Hax).
