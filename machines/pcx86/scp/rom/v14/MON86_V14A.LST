				;8086 Monitor Assembly Listing 

0000 				;Seattle Computer Products 8086 Monitor version 1.4  2/18/80 
0000 				;  by Tim Paterson 
0000 				; This software is not copyrighted. 
0000 
0000 
0000 				;To select a disk boot, set one of the following equates 
0000 				;to 1, the rest to 0. 
0000 
0000 				CROMEMCO4FDC:	EQU 0 		;1 for 4FDC, 0 for others 
0000 				NORTHSTARSD: 	EQU 1 		;North Star single density? 
0000 				TARBELL: 	EQU 0 		;Tarbell (single or double)? 
0000 				OTHER: 		EQU 0 		;User-defined disk 
0000 
0000 				PUTBASE:EQU	100H 
0000 				LOAD: 	EQU	200H 
0000 					ORG	7F0H 
07FO 					PUT 	PUTBASE+7F0H 
07FO EA 00 00 80 FF 			JMP 	0,0FF80H 	;Power-on jump to monitor 
07F5 
07F5 				;Baud Rate Table. The 9513 divides 2MHz by these values. 
07F5 				;They are for 9600, 1200, 300, 150, 110 baud 
07F5 
07F5 OD 00 68 00 AO 01 		BAUD: 	DW 	13,104,416,832,1144 
07FF 
07FF 					ORG 	100H 		;RAM area base address 
0100 
0100 				;System Equates 
0100 
0100				BASE: 	EQU 	0F0H 		;CPU Support base pOrt address 
0100 				STAT: 	EQU 	BASE+7 		;UART status port 
0100 				DATA: 	EQU 	BASE+6 		;UART data port 
0100 				DAV: 	EQU 	2 		;UART data available bit 
0100 				TBMT: 	EQU 	1 		;UART transmitter ready bit 
0100 				BUFLEN:	EQU 	80 		;Maximum length of line input buffer 
0100				BPMAX: 	EQU 	10 		;Maximum number of breakpoints 
0100 				BPLEN: 	EQU 	BPMAX+BPMAX 	;Length of breakpoint table 
0100 				REGTABLEN:EQU 	14 		;Number of registers 
0100 				SEGDIF: EQU 	800H 		;-0FF800H (ROM address) 
0100				PROMPT: EQU 	">" 
0100 				CAN: 	EQU 	"@" 
0100 
0100 				;RAM area. 
0100 				BRKCNT: DS 	2 		;Number of breakpoints 
0102 				TCOUNT: DS 	2 		;Number of steps to trace 010~ BPTAB: DS BPLEN ;Breakpoint table 
0118				LINEBUF:DS 	BUFLEN+1 	;Line input buffer 
0169 					ALIGN 
016A 					DS 	50 		;Working stack area 
019C 				STACK: 
019C 
019C 				;Register save area 
019C 
019C 				AXSAVE: DS	2 
019E 				BXSAVE: DS 	2 
01AO 				CXSAVE: DS 	2 
01A2 				DXSAVE: DS 	2 
01A~ 				SPSAVE: DS 	2 
01A6 				BPSAVE: DS 	2 
01A8 				SISAVE: DS 	2 
01AA 				DISAVE: DS 	2 
01AC 				DSSAVE: DS 	2 
01AE 				ESSAVE: DS 	2 
01BO			 	RSTACK: 			;Stack set here so registers can be saved by pushing 
01BO			 	SSSAVE: DS 	2 
01B2 				CSSAVE: DS 	2 
01B~ 				IPSAVE: DS 	2 
				FSAVE:	DS	2

				;Start of Monitor code 
					ORG 	0 
					PUT 	PUTBASE 

				;One-time initialization 
					UP 
					XOR 	AX,AX 
					MOV 	SS,AX 
					MOV 	DS,AX 
					MOV 	ES,AX 
					MOV 	DI,AXSAVE 
					MOV 	CX,14 
					REP 
					STOW			;Set register images to zero 
					OR 	B,[FSAVE+1],2	;Enable interrupts 
					MOV 	CL,4 
					MOV 	AL,40H 
					MOV 	DI,DSSAVE 
					REP 
					STOW 			;Set segment reg. images to 40H 
					MOV B	[SPSAVE+1],0CH 	;Set user stack to 400H+OCOOH 
					MOV 	SP,STACK 3
				;Prepare 9513 
					MOV 	AL,17H 
					OUT 	BASE+5 		;Select Master Mode register 	
					MOV 	AL,0F3H 
					OUT 	BASE+4 		;Low byte of Master Mode 
					MOV 	AX,584H 	;Output 84H to BASE+4 
					OUTW 	BASE+4 		;and 05H to BASE+5 
				;Master Mode now set to 84F3H: 
				;	Scaler set to BCD division 
				;	Enable data pointer increment 
				;	8-bit data bus 
				;	FOUT:100Hz, dividing F5 by 4 (F5:4MHz/10000) 
				;	Both alarm comparators disabled 
				; 	Time-of-day enabled 
				;Counter 5 selected 

				;Initialize loop. Ports BASE through BASE+7 are initialized 
				;from table. Each table entry has number of bytes followed by 
				;data. 
						
					MOV 	SI,INITTABLE 	;Initialization table 
					MOV 	DX,BASE 	;DX has (variable) port no. 
						
				INITPORT:
					SEG 	CS 
					LODB 			;Get byte count 
					MOV 	CL,AL 
					JCXZ 	NEXTPORT 	;No init. for some ports 
				INITBYTE: 
					SEG 	CS
					LODB 			;Get init. data 
					OUT 	DX 		;Send to port 
					LOOP 	INITBYTE 	;As many bytes as required NEXTPORT: 
					INC 	DX 		;Prepare for next port 
					CMP 	DL,BASE+8 	;Check against limit 
					JNZ 	INITPORT 
				;Initialization complete except for determining baud rate. 
				;Both 8259As are ready to accept interrupts, the 9513 is 
				;providing 19.2k baud X 16 to the 8251A which is set for 
				;16X clock and one stop bit. 
					CALL 	CHECKB		;Check for correct baud rate 
				;CHECKB does not return if baud rate is correct 
004E 004E 			;Intial baud rate (19.2k) was wrong, so run auto-baud routine 
004E 004E 			INITBAUD: 
004E BE F5 07 				MOV 	SI,BAUD 
0051 				;First set up 9513 for slower baud rates (<=9600). 
0051 				;Counter 5 mode register has already been selected. 
0051 88 23 E8 				MOV 	AX,0E823H 	;Output 23H to BASE+4 
0054 E7 F4 				OUTW 	BASE+4 		;and 0EBH to BASE+5 
0056 				;23H to BASE+4 sets lower half of Counter 5 mode register. 
0056 				;Reload from Load, count down repetively in binary, 
0056 				;toggle output. 
0056 				;0E8H to BASE+5 disables data pointer sequencing 
0056 0056 BO 00 			MOV 	AL,0DH 
0058 E6 F5 				OUT 	BASE+5 		;Select Counter 5 load reg. 
005A 				INITB: 
005A 2E 				SEG 	CS 
0056 AD 				LODW 			;Get divisor 
005C E6 F4 				OUT	BASE+4 		;Output low byte 
005E 8A C4 				MOV 	AL,AH 
0060 E6 F4 				OUT 	BASE+4 		;Output high byte 
0062 E8 02 00 				CALL 	CHECKB 		;Check if baud rate correct 
0065 EB F3 				JP 	INITB 		;Try next rate if not 
0067 				CHECKB: 
0067 E8 98 00 				CALL	IN 		;First byte could be messed up 
006A E8 95 00				CALL 	IN 		;Get carriage return 
0060 3C 00 				CMP 	AL,13 		;Correct? 
006F 74 01 				JZ 	MONITOR 	;Don't return if correct 
0071 C3 				RET 			;Didn't get it yet 
0072 
0072 				;Initialization complete, including baud rate. 
0072 
0072 				MONITOR: 
0072 				;Do auto boot if sense switch 0 is on. 
0072 BF 18 01 				HOV 	DI,LINEBUF 
0075 C6 05 00 				MOV 	B,[DI],13 	;No breakpoints after boot 
0078 E4 FF 				IN 	BASE+0FH 	;Sense switch port 
007A A8 01 				TEST 	AL, 1 
007C 74 03 				JZ 	DOHON 
007E E9 F5 06 				JMP 	BOOT 
0081 				DOMON: 
0081 BE 51 07 				MOV 	SI,HEADER 
0084 E8 86 00 				CALL 	PRINTMES 
0087 				COMMAND: 
0087 				;Re-establish initial conditions 
0087 FC 				UP 
0088 33 co 				XOR 	AX,AX 
008A 8E 08 				MOV 	DS,AX 
008C 8E CO 				MOV 	ES,AX 
008E BC 9C 01 				MOV 	SP,STACK 
0091 C7 06 64 00 88 06 			MOV 	[64H],INT 	;Set UART interrupt vector 
0097 8C OE 66 00			MOV 	[66H],CS 
0096 BO 3E 				MOV 	AL,PROMPT 
0090 E8 C8 00 				CALL 	OUT 
OOAO E8 1E 00 				CALL 	INBUF 		;Get command line 
OOA3 				;From now and throughout command line processing, DI points 
OOA3 				;to next character in command line to be processed. 
OOA3 E8 7F 00 				CALL 	SCANB 		;Scan off leading blanks
 OOA6 74 OF 				JZ 	COMMAND 	;Null command? 
OOA8 8A 05 				MOV 	AL,[DI] 	;AL:first non-blank character 
OOAA 				;Prepare command letter for table lookup 
OOAA 2C 42 				SUB 	AL,"B" 		;Low end range check 
OOAC 72 10 				JC 	ERR1 
OOAE 3C 13 				CMP 	AL,"T"+1-"B" 	;Upper end range check 
OOBO 73 OC 				JNC 	ERR1
 0082 47 				INC 	DI 
0083 DO EO 				SHL 	AL 		;Times two 
0085 98 				CBW 			;Now a 16-bit quantity 
0086 93 				XCHG 	BX,AX 		;In BX we can address with it 
0087 2E 				SEG	CS
0088 FF 97 7D 01 			CALL 	[BX+COMTAB] 	;Execute command 
0112 					JP  	COMMAND  	;Get next command  
				ERR1: 	JMP  	ERROR  

				;Get input line  

				INBUF:  
					MOV  	DI,UNEBUF  	;Next empty buffer location  
					XOR  	CX,CX  		;Character count  
				GETCH:  
					CALL  	IN  		;Get input character  
					CHP  	AL,20H  	;Check for control characters  
					JC  	CONTROL  
					CMP	AL,7FH 
					JZ	BACKSP  	;RUBOUT is a backspace  
					CALL  	OUT  		;Echo character  
					CMP  	AL,CAN  	;Cancel line?  
					JZ  	KILL  
					STOB  			;Put in input buffer  
					INC 	CX
					CMP	CX,BUFLEN  	;Bump character count ;Buffer full?  
					JBE  	GETCH  		;Drop in to backspace if full  
				BACKSP:  
					JCXZ  	GETCH  		;Can't backspace over nothing  
					DEC  	DI  		;Drop pointer  
					DEC  	CX  		;and character count  
					CALL  	BACKUP  	;Send physical backspace  
					JP  	GETCH  		;Get next char.  
				CONTROL:  
					CMP  	AL,8  		;Check for backspace  
					JZ  	BACKSP  
					CHP  	AL,13  		;Check for carriage return  
					JNZ  	GETCH  		;Ignore all other control char.  
					STOB  			;Put the car. ret. in buffer  
					MOV  	DI,LINEBUF  	;Set up DI for command processing  
				
				;Output CR/LF  sequence  

				CRLF:  
					MOV  	AL,13  
					CALL  	OUT  
					HOV  	AL,10  
					JP  	OUT  

				;Cancel input  line  

				KILL:  
					CALL  	CRLF  
					JP  	COMMAND  

				;Character in put routine  

				IN:  
					DI  			;Poll, don't interrupt  
					INB  	STAT  
					TEST  	AL,DAV  
					JZ  	IN  		;Loop until ready  
					INB  	DATA  
					AND  	AL,7FH  	;Only 7 bits  
					EI  			;Interrupts OK now  
					RET 			

				;Physical backspace -blank, backspace, blank 

				BACKUP: 
					MOV SI,BACMES 		
					
				;Print ASCII message. Last char has bit 7 set 

0112 				PRINTMES: 
0112 2E 				SEG 	CS 
0113 AC 				LODB 			;Get char to print 
0114 E8 51 00 				CALL 	OUT 
0117 DO EO 				SHL 	AL 		;High bit set? 
0119 73 F7 				JNC 	PRINTMES 
0 11B C3 				RET 
011C 
011C 				;Scan for parameters of a command 
011C 
011C 				SCANP: 
011C E8 06 00 				CALL 	SCANB 		;Get first non-blank 
011F 82 3D 2C 				CMP 	B,[DI],"," 	;One comma between params OK 
0122 75 OA 				JNE 	EOLCHK 		;If not comma, we found param 
0124 47 				INC 	DI 		;Skip over comma 
0125 0125 			;Scan command line for next non-blank character 
0125 
0125 				SCANB: 
0125 BO 20 				MOV 	AL," " 
0127 51 				PUSH 	CX 		;Don't disturb CX 
0128 B1 FF 				MOV 	CL,-1 		;but scan as many as necessary 
012A F3 				REPE 
0128 AE 				SCAB 
012C 4F 				DEC 	DI 		;Back up to first non-blank 
012D 59 				POP 	CX 
012E 				EOLCHK: 
012E 82 3D OD 				CMP 	B,[DI],13 
0131 C3 				RET 

0132 0132 			;Print the 5-digit hex address of SI and DS 0132 

0132 				OUTSI: 
0132 8C DA 				MOV 	DX,DS 		;Put DS where we can work with it 
0134 B4 00 				MOV 	AH,0 		;Will become high bits of DS 
0136 E8 78 00 				CALL 	SHIFT4 		;Shift DS four bits 
0139 03 D6 A				ADD 	DX,SI 		;Compute absolute address 
013B EB 09 				JP 	OUTADD 		;Finish below 013D 
013D 				
				;Print 5-digit hex address of DI and ES 
				;Same as OUTSI above
				
013D 				OUTDI: 
013D 8C C2 				MOV 	DX,ES 
013F B4 00 				MOV 	AH,O0
0141 E8 6D 00 				CALL 	SHIFT4 
0144 03 D7 				ADD 	DX,DI ;
				;Finish OUTSI here too 
0146 				OUTADD: 
0146 82 D4 00 				ADC 	AH,0 		;Add in carry to high bits 
0149 E8 12 00 				CALL 	HIDIG 		;Output hex value in AH 
014C 014C 			
				;Print out 16-bit value in DX in hex 
				
014C 014C 			OUT16: 
014C 8A C6 				MOV 	AL,DH 		;High-order byte first 
014E E8 02 00 				CALL 	HEX 
					MOV 	AL,DL 		;Then low-order byte 
					
0153 0153 			;Output byte in AL as two hex digits 

0153 0153 			HEX: 
0153 8A EO 				MOV 	AH,AL 		;Save for second digit 
0155 				;Shift high digit into low 4 bits 
0155 51				 	PUSH 	CX 
0156 B1 04 				MOV 	CL,4 
0158 D2 E8 				SHR 	AL,CL 
					POP 	CX
					
015B 0158 E8 02 00 			CALL 	DIGIT 		;Output first digit 

015E 				HIDIG: 
015E 8A C4 				MOV 	AL,AH 		;Now do digit saved in AH 

0160 				DIGIT: 

0160 24 OF 				AND 	AL,0FH 		;Mask to 4 bits 
0162 				;Trick 6-byte hex conversion works on 8086 too. 
0162 04 90 				ADD 	AL,90H 
0164 27 				DAA 
0165 111 40 				ADC 
0167 27 				DAA 
0168 
0168 				;Console output of character in AL 
0168 
0168 				OUT: 
0168 50 				PUSH 	AX 		;Character to output on stack 
0169 				OUT1: 
0169 Ell F7 				INB 	STAT 
0168 211 01 				AND 	AL,TBMT 
016D 711 FA 				JZ 	OUT1 		;Wait until ready 
016F 58 				POP 	AX 
0170 E6 F6 				OUTS 	DATA 
0172 C3 				RET 
0173 
0173 				;Output one space 
0173 

0173 				BLANK: 
0173 BO 20 				MOV 	AL," " 
0175 EB F1 				JP 	OUT 
0177 
0177 				;Output the number of blanks in ex 
0177 
0177 				TAB: 
0177 E8 F9 FF 				CALL 	BLANK 
017A E2 FB 				LOOP 	TAB 
017C C3 				RET 
017D 
017D 				;Command Table. Command letter indexes into table to get 
017D 				;address of command. PERR prints error for no such command. 
017D 
017D 				COMTAB: 
017D 76 07 				DW 	BOOT 		;B 
017F 68 03 				DW 	PERR 		;C 
0181 OD 02 				DW 	DUMP 		;D 
0183 88 03 				DW 	ENTER 		;E 
0185 97 02 				DW 	FILL 		;F 
0187 6A 06 				DW 	GO 		;G 
0189 68 03 				DW 	PERR 		;H 
0188 IIC 06 				DW 	INPUT 		;I 
018D 68 03 				DW 	PERR 		;J 
018F 68 03 				DW 	PERR 		;K 
0191 68 03 				DW 	PERR 		;L 
0193 6A 02 				DW 	MOVE 		;M 
0195 68 03 				DW 	PERR 		;N 
0197 59 06				DW 	OUTPUT 		;O 
0199 68 03 				DW 	PERR 		;P 
0198 68 03 				DW 	PERR 		;Q 
019D 2F 011 				DW 	REG 		;R 
019F BA 02 				DW 	SEARCH 		;S 
01A1 6A 05 				DW 	TRACE 		;T 
01A3 
01A3 				;Given 20-bit address in AH:DX, breaks it down to a segment 
01A3 				;number in AX and a displacement in DX. Displacement is 
01A3 				;always zero except for least significant 4 bits. 
01A3 01A3 			GETSEG: 
01A3 8A C2 				MOV 	AL,DL 
01A5 211 OF 				AND 	AL,0FH 		;AL has least significant 4 bits 
01A7 E8 07 00 				CALL 	SHIFT4 		;4-bit left shift of AH:DX
 01AA 8A DO 				MOV 	DL,AL 		;Restore lowest 4 bits 
 OlAC 8A C6 				MOV 	AL,DH 		;Low byte of segment number 
 01AE 32 F6 				XOR 	DH,DH 		;Zero high byte of displacement 
					RET 

				;Shift AH:DX left 4 bits 

				SHIFT4: 
					SHL 	DX 
					RCL 	AH 		;1 
					SHL 	DX 
					RCL 	AH 		;2 
					SHL 	DX 
					RCL 	AH 		;3 
					SHL 	DX 
					RCL 	AH 		;4 
				RET2: 	RET 

				;RANGE - Looks for parameters defining an address range. 
				;The first parameter is a hex number of 5 or less digits 
				;which specifies the starting address. The second parameter 
				;may specify the ending address, or it may be preceded by 
				;"L" and specify a length (4 digits max), or it may be 
				;omitted and a length of 128 bytes is assumed. Returns with 
				;segment no. in AX and displacement (0-F) in DX. 

				RANGE: 
					MOV 	CX,5 		;5 digits max 
					CALL 	GETHEX 		;Get hex number 
					PUSH 	AX 		;Save high 4 bits 
					PUSH 	DX 		;Save low 16 bits 
					CALL 	SCANP 		;Get to next parameter 
					CMP 	B,[DI],"L" 	;Length indicator? 
					JE 	GETLEN 
					MOV 	DX,128 		;Default length 
					CALL 	HEXIN 		;Second parameter present? 
					JC 	RNGRET 		;If not, use default 
					MOV 	CX,5 		;5 hex digits 
					CALL 	GETHEX 		;Get ending address 
					MOV 	CX,DX 		;Low 16 bits of ending addr. 
					POP 	DX 		;Low 16 bits of starting addr. 
					POP 	BX 		;BH:hi 4 bits of start addr. 
					SUB 	CX,DX 		;Compute range 
					SBB 	AH,BH 		;Finish 20-bit subtract 
					JNZ 	RNGERR 		;Range must be less than 64K 
					XCHG 	AX,BX 		;AH=starting, BH=ending hi 4 bits 
					INC 	CX 		;Range must include ending location 
					JP 	RNGCHK 		;Finish range testing and return 
				GETLEN: 
					INC	DI 		;Skip over "L" to length 
					MOV 	CX,4 		;Length may have 4 digits 
					CALL 	GETHEX 		;Get the range 
				RNGRET: 
					MOV 	CX,DX 		;Length 
					POP 	DX 		;Low 16 bits of starting addr. 
					POP 	AX 		;AH=hi 4 bits of starting addr. 
					
				;RNGCHK verifies that the range lies entirely within one segment. 
				;CX=0 means count=10000H. Range is within one segment only if 
				;adding the low 4 bits of the starting address to the count is 
				:<=10000H, because segments can start only on 16-byte boundaries. 
				
				RNGCHK: 
					MOV 	BX,DX 		;Low 16 bits of start addr. 
					AND 	BX,0FH 		;Low 4 bits of starting addr. 
					JCXZ 	MAXRNG 		;If count=10000H then BX must be 0 
					ADD 	BX,CX 		;Must be <=10000H 
					JNC 	GETSEG 		;OK if strictly < 
				MAXRNG: 
				;If here because of JCXZ MAXRNG, we are testing if low 4 bits 
				;(in BX) are zero. If we dropped straight in, we are testing 
				;for BX+CX:10000H (=0). Either way, zero flag set means 
				;withing range. 
					JZ 	GETSEG 
				RNGERR: 
					MOV 	AX,4700H+"R" 	;RG ERROR 
					JMP 	ERR 

				;Dump an area of memory in both hex and ASCII 
				DUMP: 
					CALL 	RANGE 		;Get range to dump 
					PUSH 	AX 		;Save segment 
					CALL 	GETEOL 		;Check for errors 
					POP 	DS 		;Set segment 
					MOV 	SI,DX 		;SI has displacement in segment 
				ROW: 
					CALL 	OUTSI 		;Print address at start of line 
					PUSH 	SI 		;Save address for ASCII dump 
				BYTE: 
					CALL 	BLANK 		;Space between bytes 
				BYTE1: 
					LODB 			;Get byte to dump 
					CALL 	HEX 		;and display it 
					POP 	DX		;DX has start addr. for ASCII dump
					DEC 	CX 		;Drop loop count 
					JZ 	ASCII 		;If through do ASCII dump 
					MOV 	AX,SI 
					TEST 	AL,0FH 		;On 16-byte boundary? 
					JZ 	ENDROW 
					PUSH 	DX 		;Didn't need ASCII addr. yet 
					TEST 	AL,7 		;On 8-byte boundary? 
					JNZ 	BYTE 
					MOV 	AL,"-" 		;Mark every 8 bytes 
					CALL 	OUT 
					JP 	BYTE1 
				ENDROW: 
					CALL 	ASCII 		;Show it in ASCII 
					JP 	ROW 		;Loop until count is zero ASCII 
					PUSH 	CX 		;Save byte count 
					MOV 	AX,SI 		;Current dump address 
					MOV 	SI,DX 		;ASCII dump address 
					SUB 	AX,DX 		;AX=length of ASCII dump 
				;Compute tab length. ASCII dump always appears on right side 
				;screen regardless of how many bytes were dumped. Figure 3 
				;characters for each byte dumped and subtract from 51, which 
				;allows a minimum of 3 blanks after the last byte dumped. 
					MOV 	BX,AX 
					SHL 	AX 		;Length times 2 
					ADD 	AX,BX 		;Length times 3 
					MOV 	CX,51 
					SUB 	CX,AX 		;Amount to tab in CX 
					CALL 	TAB 
					MOV 	CX,BX 		;ASCII dump length back in CX 
				ASCDMP: 
					LODB 			;Get ASCII byte to dump 
					AND 	AL,7FH 		;ASCII uses 7 bits 
					CHP 	AL,7FH 		;Don't try to print RUBOUT 
					JZ 	NOPRT 
					CMP 	AL," " 		;Check for control characters 
					JNC 	PRIN 
				NOPRT: 
					MOV 	AL,"." 		;If unprintable character 
				PRIN: 
					CALL 	OUT 		;Print ASCII character 
					LOOP 	ASCDMP 		;CX times 
					POP 	CX		;Restore overall dump length 
					JMP 	CRLF 		;Print CR/LF and return 
				;Block move one area of memory to another. Overlapping moves 
				;are performed correctly, i.e., so that a source byte is not 
				;overwritten until after it has been moved. 
				MOVE: 
					CALL 	RANGE 		;Get range of source area 
					PUSH 	CX 		;Save length 
					PUSH 	AX 		;Save segment 
					MOV 	SI,DX 		;Set source displacement 
					MOV 	CX,5 		;Allow 5 digits 
					CALL 	GETHEX 		;in destination address 
					CALL 	GETEOL 		;Check for errors 
					CALL 	GETSEG 		;Convert dest. to seg/disp 
					MOV 	DI,DX 		;Set dest. displacement 
					POP 	BX 		; Source segment 
					MCV 	DS,BX 
					MOV 	ES,AX 		;Destination segment 
					POP 	CX 		;Length 
					CMP 	DI,SI 		;Check direction of move 
					SBB 	AX,BX 		;Extend the CMP to 32 bits 
					JB 	COPYLIST 		;Move forward into lower mem. 
				;Otherwise, move backward. Figure end of source and destination 
				;areas and flip direction flag. 
					DEC 	CX 
					ADD 	SI,CX 		;End of source area 
					ADD 	DI,CX 		;End of destination area 
					DOWN 			;Reverse direction 
					INC 	CX 
				COPYLIST: 
					MOVB 	;Do at least 1 - Range is 1-10000H not 0-FFFFH 
					DEC 	CX 
					REP 
					MOVB 			;Block move 
					RET 
					
				;Fill an area of memory with a list values. If the list 
				;is bigger than the area, don't use the whole list. If the 
				;list is smaller, repeat it as many times as necessary. 

				FILL: 
					CALL 	RANGE 		;Get range to fill 
					PUSH 	CX 		;Save length 
					PUSH 	AX 		;Save segment number 
					PUSH 	DX 		;Save displacement 
					CALL 	LIST 		;Get list of values to fill with 
					POP 	DI 		;Displacement in segment 
					POP 	ES 		;Segment 
					POP 	CX 		;Length 
					CMP 	BX,CX 		;BX is length of fill list 
					MOV 	SI,LINEBUF 	;List is in line buffer 
					JCXZ 	BIGRNG 
					JAE 	COPYLIST 	;If list is big, copy part of it 
				BIGRNG: 
					SUB 	CX,BX 		;How much bigger is area than list? 
					XCHG 	CX,BX 		;CX:length of list 
					PUSH 	DI 		;Save starting addr. of area 
					REP 	MOVB 		;Move list into area 
					POP 	SI 
				;The list has been copied into the beginning of the 
				;specified area of memory. SI is the first address 
				;of that area, DI is the end of the copy of the list 
				;plus one, which is where the list will begin to repeat. 
				;All we need to do now is copy [SI] to [DI] until the 
				;end of the memory area is reached. This will cause the 
				;list to repeat as many times as necessary. 
					MOV 	CX,BX 		;Length of area minus list 
					PUSH 	ES 		;Different index register 
					POP 	DS 		;requires different segment reg. 
					JP 	COPYLIST 	;Do the block move 
				;Search a specified area of memory for given list of bytes. 
				;Print address of first byte of each match. 
02BA 				SEARCH: 
02BA E8 05 FF 				CALL 	RANGE 		;Get area to be searched 
02BD 51 				PUSH 	CX 		;Save count 
02BE 50 				PUSH 	AX 		;Save segment number 
02BF 52 				PUSH 	DX 		;Save displacement 
02CO E8 91 00 				CALL	LIST 		;Get search list 
02C3 !IS 				DEC 	BX 		;No, of bytes in list-1 
02C4 5F 				POP 	DI 		;Displacement within segment 
02C5 07 				POP 	ES 		;Segment 
02C6 59 				POP 	CX 		;Length to be searched 
02C7 2B CB 				SUB 	CX,BX 		;minus length of list 
02C9 				SCAN: 
02C9 BE 18 01 				MOV 	SI,LINEBUF 	;List kept in line buffer 
02CC AC 				LODB 			;Bring first byte into AL 
02CD 				DOSCAN:
					SCAB 			;Search for first byte 
02CE EO FD 				LOOPNE 	DOSCAN 		;Do at least once by using LOOP 
0200 75 4A 				JNZ 	RET 		;Exit if not found 
0202 53 				PUSH 	BX 		;Length of list minus 1 
0203 87 CB 				XCHG 	BX,CX 
0205 57 				PUSH 	DI 		;Will resume search here 
0206 F3 				REPE 
0207 A6 				CMPB 			;Compare rest of string 
0208 88 CB 				MOV 	CX,BX 		;Area length back in CX 
02DA 5F 				POP	DI 		;Next search location 
0208 5B 				POP 	BX 		;Restore list length 
02DC 75 08 				JNZ 	TEST 		;Continue search if no match 
02DE 4F 				DEC 	DI 		;Match address 
02DF E8 58 FE 				CALL 	OUTDI 		;Print it 
02E2 47 				INC 	DI 		;Restore search address 
-tl2E3 E8 OE FE 			CALL 	CRLF 
02E6 				TEST: 
02E6 E3 34 				JCXZ 	RET 
02E8 EB OF 				JP 	SCAN 		;Look for next occurrence 
02EA 
02EA 				;Get the next parameter, which must be a hex number. 
02EA 				;CX is maximum number of digits the number may have. 
02EA 
02EA 				GETHEX: 
02EA E8 2F FE 				CALL 	SCANP 		;Scan to next parameter 
02ED 				GETHEXl: 
02ED 33 02 				XOR 	DX,DX 		;Initialize the number 
02EF 8A E6 				MOV 	AH,DH 
02F1 E8 14 00 				CALL 	HEXIN 		;Get a hex digit 
02F4 72 73 				JC 	ERROR 		;Must be one valid digit. 
02F6 8A DO 				MOV 	DL,AL 		;First 4 bits in position 
02F8 				GETLP: 
02F8 47 				INC 	DI 		;Next char in buffer 
02F9 49 				DEC 	CX 		;Digit count 
02FA E8 OB 00 				CALL 	HEXIN 		;Get another hex digit? 
02FD 72 10 				JC 	RET 		;All done if no more digits 
02FF E3 68 				JCXZ 	ERROR 		;Too many digits? 
0301 E8 AD FE 				CALL 	SHIFT4 		;Multiply by 16 
0304 OA DO 				OR 	DL,AL 		;and combine new digit 
0306 EB FO 				JP 	GETLP 		;Get more digits 
0308 
0308 				;Check if next character in the input buffer is a hex digit 
0308 				;and convert it to binary if it is. Carry set if not. 
0308 
0308 				HEXIN: 
0308 8A 05 				MOV 	AL,[DI] 
030A 
030A 				;Check if AL has a hex digit and convert it to binary if it 
030A 				;is. Carry set if not. 
030A 
030A 				HEXCHK: 
030A 2C 30 				SUB 	AL,"0" 		;Kill ASCII numeric bias 
030C 72 OE 				JC 	RET 
030E 3C OA 				CMP 	AL,10 
0310 F5 				CMC 
0311 73 09 				JNC 	RET 		;OK if 0-9 
0313 2C 07 				SUB 	AL,7 		;Kill A-F bias 
0315 3C OA 				CMP 	AL,10 
0317 72 03 				JC 	RET 
0319 3C 10 				CMP 	AL,16 
0318 F5 				CMC 
031C C3 			RET: 	RET 
0310 
0310 				;Process one parameter when a list of bytes is 
0310 				;required. Carry set if parameter bad. Called by LIST 
0310 
0310 				LISTITEM: 
0310 E8 FC FO 				CALL 	SCANP 		;Scan to parameter 
0320 E8 E5 FF 				CALL 	HEXIN 		; Is it in hex? 
0323 72 OB 				JC 	STRINGCHK 	;If not, could be a string 
0325 89 02 00 				MOV 	CX,2 		;Only 2 hex digits for bytes 
0328 E8 BF FF 				CALL 	GETHEX 		;Get the byte value 
0328 88 17 				MOV 	[BX],DL 	;Add to list 
0320 43 				INC 	BX 
032E F8 			GRET: 	CLC 			;Parameter was OK 
032F C3 				RET 
0330 				STRINGCHK: 
0330 8A 05 				MOV	AL,[DI] 	;Get first character of param 
0332 3C 27 				CMP 	AL,"'" 		;String? 
0334 74 06 				JZ 	STRING 
0336 3C 22 				CMP 	AL,'"'	 	;Either quote is all right 
0338 74 02 				JZ 	STRING 
033A F9 				STC 			;Not string, not hex -bad 
0338 C3 				RET 
033C 				STRING: 
033C 8A EO 				MOV 	AH,AL 		;Save for closing quote 
033E 47 				INC 	DI 
033F 				STRNGLP: 
033F 8A 05 				MOV 	AL,[DI] 	;Next char of string 
0341 47 				INC 	DI 
0342 3C 00 				CMP 	AL,13 		;Check for end of line 
0344 74 23 				JZ 	ERROR 		;Must find a close quote 
0346 3A C4 				CMP 	AL,AH 		;Check for close quote 
0348 75 05 				JNZ 	STOSTRG 	;Add new character to list 
034A 3A 25 				CMP 	AH, [DI]	;Two quotes in a row? 
034C 75 EO 				JNZ 	GRET 		;If not, we're done 
034E 47 				INC 	DI 		;Yes -skip second one 
034F 				STOSTRG: 
034F 88 07 				MOV 	[BX],AL 	;Put new char in list 
0351 43 				INC 	BX 
0352 EB EB 				JP 	STRNGLP 	;Get more characters 
0354 
0354 				;Get a byte list for ENTER, FILL or SEARCH. Accepts any number 
0354 				;of 2-digit hex values or character strings in either single 
0354 				;(') or double (") quotes. 
0354 
0354 				LIST: 
0354 BB 18 01				MOV 	BX,LINEBUF 	;Put byte list in the line buffer 
0357 				LISTLP: 
0357 E8 C3 FF				CALL 	LISTITEM 	;Process a parameter 
035A 73 FB 				JNC 	LISTLP 		;If OK, try for more 
035C 81 EB 18 01 			SUB 	BX,LINEBUF 	;BX now has no. of bytes in list 
0360 74 07 				JZ	ERROR 		;List must not be empty
0362 
0362 				;Make sure there is nothing more on the line except for 
0362 				;blanks and carriage return. If there is, it is an 
0362 				;unrecognized parameter and an error. 
0362 
0362 				GETEOL: 
0362 E8 CO FO 				CALL 	SCANB 		;Skip blanks 
0365 75 02 				JNZ 	ERROR 		;Better be a RETURN 
0367 C3 				RET 
0368 
0368 				;Command error. DI has been incremented beyond the
				;command letter so it must decremented for the 
				;error pointer to work. 
				
				PERR: 
					DEC 	DI 
					
				;Syntax error. DI points to character in the input buffer 
				;which caused error, By subtracting from start of buffer, 
				;we will know how far tq tab over to appear directly below 
				;it on the terminal. Then print "^ Error". 
				
				ERROR: 
					SUB 	DI,LINEBUF-1 	;How many char processed so far? 
					MOV 	CX,DI 		;Parameter for TAB in CX 
					CALL 	TAB 		;Directly below bad char 
					MOV 	SI,SYNERR 	;Error message 

				;Print error message and abort to command level 

				PRINT: 
					CALL 	PRINTMES
					JMP 	COMMAND 

				;Short form of ENTER command. A list of values from the 
				;command line are put into memory without using normal 
				;ENTER mode. 
				
				GETLIST: 
					CALL 	LIST 		;Get the bytes to enter 
					POP 	DI 		;Displacement within segment 
					POP 	ES 		;Segment to enter into 
					MOV 	SI,LINEBUF 	;List of bytes is in line buffer 
					MOV 	CX,BX 		;Count of bytes 
					REP 	
					MOVB 			;Enter that byte list 
					RET 

				;Enter values into memory at a specified address. If the 
				;line contains nothing but the address we go into "enter 
				;mode", where the address and its current value are printed 
				;and the user may change it if desired. To change, type in 
				;new value in hex. Backspace works to correct errors. If 
				;an illegal hex digit or too many digits are typed, the 
				;bell is sounded but it is otherwise ignored. To go to the 
				;next byte (with or without change), hit space bar. To 
				;back up to a previous address, type "-". On 
				;every 8-byte boundary a new line is started and the address 
				;is printed, To terminate command, type carriage return. 
				;   Alternatively, the list of bytes to be entered may be 
				;included on the original command line immediately following 
				;the address. This is in regular LIST format so any number 
				;of hex values or strings in quotes may be entered. 

				ENTER: 
					MOV 	CX,5 		;5 digits in address 
					CALL 	GETHEX 		;Get ENTER address 
					CALL 	GETSEG 		;Convert to seg/disp format 
				;Adjust segment and displacement so we are in the middle 
				;of the segment instead of the very bottom, This allows 
				;backing up a long way. 
					SUB 	AH,8 		;Adjust segment 32K down 
					ADD 	DH,80H		; and displacement 32K up 
					PUSH 	AX 		;save for later 
					PUSH 	DX 
					CALL 	SCANB 		;Any more parameters? 
					JNZ 	GETLIST 	;If not end-of-line get list 
					POP 	DI 		;Displacement of ENTER
					POP 	ES 		;Segment 
				GETROW: 
					CALL 	OUTDI 		;Print address of entry 
03A3 E8 CD FO 				CALL 	BLANK 		;Leave a space 
03A6 				GETBYTE: 
03A6 26 				SEG 	ES 
03A7 8A 05 				MOV 	AL,[DI] 	;Get current value 
03A9 E8 A7 FD 				CALL 	HEX 		;And display it 
03AC BO 2E 				MOV 	AL,"." 
03AE E8 B7 FO				CALL 	OUT 		;Prompt for new value 
03B1 B9 02 00 				MOV 	CX,2 		;Max of 2 digits in new value 
03B4 BA 00 00 				MOV 	DX,0 		;Intial new value 
03B7 				GETDIG: 
03B7 E8 48 FO 				CALL 	IN 		;Get digit from user 
03BA 8A EO				MOV 	AH,AL 		;Save 
03BC E8 4B FF 				CALL	HEXCHK 		;Hex digit? 
03BF 86 EO 				XCHG 	AH,AL 		;Need original for echo 
03C1 72 OC 				JC 	NOHEX 		;If not, try special command 
03C3 E8 A2 FD 				CALL 	OUT 		;Echo to console 
03C6 8A F2 				MOV 	DH,DL 		;Rotate new value 
03C8 8A 04 				MOV 	DL,AH 		;And include new digit 
03CA E2 EB 				LOOP 	GETDIG 		;At most 2 digits 
03CC 				;We have two digits, so all we will accept now is a command, 
03CC				WAIT: 
03CC E8 33 FO 				CALL 	IN 		;Get command character 
03CF 				NOHEX: 
03CF 3C 08 				CMP 	AL,8 		;Backspace 
0301 74 19 				JZ 	BS 
0303 3C 7F 				CMP 	AL,7FH 		;RUBOUT 
0305 74 15 				JZ 	BS 
0307 3C 2D 				CMP 	AL,"-" 		;Back up to previous address 
0309 74 40 				JZ 	PREV 
03DB 3C OD 				CMP 	AL,13 		;All done with command? 
03DD 74 2F 				JZ 	EOL 
03DF 3C 20 				CMP 	AL," "		;Go to next address 
03E1 74 31 				JZ 	NEXT 
03E3 				;If we got here, character was invalid. Sound bell, 
03E3 BO 07 				MOV 	AL,7 
03E5 E8 80 FD 				CALL 	OUT 
03E8 E3 E2 				JCXZ 	WAIT 		;CX:O means no more digits 
03EA EB CB 				JP	GETDIG 		;Don't have 2 digits yet
				BS:
03EC 82 F9 02 				CMP 	CL,2 		;CX:2 means nothing typed yet 
03EF 714 C6 				JZ 	GETDIG 		;Can't back up over nothing 
03F1 FE C1 				INC 	CL 		;Accept one more character 
03F3 8A 06 				MOV 	DL,DH 		;Rotate out last digit 
03F5 8A F5 				MOV 	DH,CH 		;Zero this digit 
03F7 E8 15 FO 				CALL	BACKUP 		;Physical backspace 
03FA EB BB 				JP 	GETDIG 		;Get more digits 

03FC 03FC 			;If new value has been entered, convert it to binary and 
03FC 				;put into memory, Always bump pointer to next location 

03FC 03FC 			STORE: 
03FC 82 F9 02 				CMP 	CL,2 		;CX:2 means nothing typed yet 
03FF 74 OB 				JZ 	NOSTO 		;So no new value to store 
0401 				;Rotate OH left 4 bits to combine with DL and make a byte value 
0401 51 				PUSH 	CX
					MOV 	CL,4 
0404 02 E6 				SHL 	DH,CL 
0406 59 				POP 	CX 
0407 OA 06 				OR 	DL,DH 		;Hex is now converted to binary 
0409 26 				SEG	ES 
040A 88 15 				MOV 	[DI],DL 	;Store new value 
040C 				NOSTO: 
040C 47 				INC 	DI 		;Prepare for next location 
0400 C3 				RET
040E 				EOL: 
0140E E8 EB FF 				CALL 	STORE 		;Enter the new value 
0411 E9 EO FC 				JMP 	CRLF 		;CR/LF and terminate
414 				NEXT: 
0414 E8 E5 FF 				CALL 	STORE 		;Enter new value 
0417 41 				INC 	CX 		;Leave a space plus two for
0418 41 				INC 	CX 		; each digit not entered 
0419 E8 5B FD 				CALL 	TAB 
041C 88 C7 				MOV 	AX,DI 		;Next memory address 
041E 24 07 				AND 	AL,7 		;Check for 8-byte boundary
0420 75 84 				JNZ 	GETBYTE 	;Take 8 per line 
0422 				NEWROW: 
0422 E8 CF FC 				CALL 	CRLF 		;Terminate line 
0425 E9 78 FF 				JMP 	GETROW 		;Print address on new line 
0428 				PREV: 
0428 E8 D1 FF 				CALL 	STORE 		;Enter the new value 
0428 				;DI has been bumped to next byte. Drop it 2 to go to previous addr 
0428 4F 				DEC 	DI 
042C 4F 				DEC	DI 
042D E8 F3 				JP 	NEWROW 		;Terminate line after backing up
042F 
042F				;Perform register dump if no parameters or set register if a 
042F 				;register designation is a parameter. 
042F 
042F 				REG: 
042F E8 EA FC				CALL 	SCANP 
0432 74 62 				JZ 	DISPREG 
0434 8A 15 				MOV 	DL,[DI] 
0436 47 				INC 	DI 
0437 8A 35 				MOV 	DH,[DI] 
0439 82 FE OD 				CMP 	DH,13 
043C 74 76 				JZ 	FLAG 
043E 47 				INC 	DI 
043F E8 20 FF 				CALL 	GETEOL 
0442 82 FE 20 				CMP 	DH," " 
0445 74 6D 				JZ 	FLAG 
044.7 8F D7 06 				MOV 	DI,REGTAB 
044A 92 				XCHG 	AX,DX 
0448 OE 				PUSH 	CS 
044C 07 				POP 	ES 
044D B9 OE 00 				MOV 	CX,REGTABLEN 
0450 F2 				REPNZ 
0451 AF 				SCAW 
0452 75 3C 				JNZ 	BADREG 
0454 OB C9 				OR 	CX,CX 
0456 75 06 J				NZ 	NOTPC 
0458 4F 				DEC 	DI 
0459 4F 				DEC	DI 
045A 2E 				SEG 	CS 
0458 88 45 FE 				MOV 	AX,[DI-2] 
045E 				NOTPC: 
045E E8 07 FD 				CALL 	OUT 
0461 8A C4 				MOV 	AL,AH 
0463 E8 02 FD 				CALL 	OUT 
0466 E8 OA FD 				CALL 	BLANK 
0469 1E 				PUSH 	DS 
046A 07 				POP 	ES 
0468 80 9D C3 FA 			LEA 	BX,[DI+REGDIF-2] 
046F 88 17 				MOV 	DX,[BX] 
0471 E8 D8 FC 				CALL 	OUT16 
0474 E8 7D FC 				CALL 	CRLF 
0477 80 3A 				MOV 	AL,":" 
0479 E8 EC FC 				CALL 	OUT 
047C E8 42 FC 				CALL 	INBUF 
047F E8 A3 FC 				CALL 	SCANB 
0482 74 OB 				JZ 	RET3 
0484 B9 04 00 				MOV 	CX,4 
0487 E8 63 FE 				CALL 	GETHEX1 
048A E8 05 FE 				CALL 	GETEOL 
048D 89 17 				MOV 	[BX],DX 
048F C3 			RET3: 	RET 
				BADREG: 
0490 88 42 52 				MOV 	AX,5200H+"B" 	;BR ERROR 
0493 E9 96 00 				JMP 	ERR 
				DISPREG: 
0496 BE D7 06 				MOV 	SI,REGTAB 
0499 BB 9C 01 				MOV 	BX,AXSAVE 
049C B9 08 00 				MOV 	CX,8 
049F E8 65 00 				CALL 	DISPREGLINE 
04A2 E8 4F FC 				CALL 	CRLF 
04A5 B9 05 00				MOV 	CX,5 
04A8 E8 5C 00 				CALL 	DISPREGLINE 
OIIAB E8 C5 FC 				CALL 	BLANK 
OIIAE E8 93 00 				CALL 	DISPFLAGS 
0481 E9 40 FC 				JMP 	CRLF 
0484 				FLAG: 
484 82 FA 46 				CMP 	DL,"F" 
0487 75 D7 				JNZ 	BADREG 
0489 E8 88 00 				CALL 	DISPFLAGS 
OIIBC BO 2D 				MOV 	AL, "-" 
OIIBE E8 A7 FC 				CALL	OUT 
04C1 E8 FD FB 				CALL 	INBUF 
Ol!Cli E8 5E FC 			CALL 	SCANB 
04C7 33 DB 				XOR 	BX,BX 
04C9 8B 16 B6 01 			MOV 	DX,[FSAVE] 
OIICD 				GETFLG: 
OIICD 8B F7 				MOV 	SI,DI 
OIICF AD 				LODW
IIDO 3C OD 				CMP 	AL,13 
04D2 74 66 				JZ 	SAVCHG 
04D4 82 FC OD 				CMP 	AH,13 
04D7 74 66 				JZ 	FLGERR 
04D9 BF F3 06 				MOV 	DI,FLAGTAB 
IIDC B9 20 00 				MOV 	CX,32 
OIIDF OE 				PUSH	CS 
04EO 07 				POP 	ES 
04E 1 F2 				REPNE 
04E2 AF 				SCAW 
04E3 75 5A 				JNZ 	FLGERR 
04E5 8A E9 				MOV 	CH,CL 
04E7 80 E1 OF 				AND 	CL,0FH 
O&EA 88 01 00 				MOV 	AX,1 
OilED D3 CO 				ROL 	AX,CL 
04EF 85 C3 				TEST 	AX,BX 
04F1 75 33 				JNZ 	REPFLG 
04F3 OB DB 				OR 	BX,AX 
04F5 OB DO 				OR 	DX,AX 
04F7 F6 C5 10 				TEST 	CH,16 
04FA 75 02 				JNZ 	NEXFLG 
OIIFC 33 DO 				XOR 	DX,AX 
OilFE 				NEXFLG: 
04FE 8B FE				MOV 	DI,SI 
0500 1E 				PUSH 	DS 
0501 07 				POP	ES 
0502 E8 17 FC 				CALL	SCANP 
0505 EB C6 				JP 	GETFLG 
0507 				DISPREGLINE: 
0507 2E 				SEG 	CS 
0508 AD 				LODW 
0509 E8 5C 				CALL	OUT 
50C 8A Cli 				MOV 	AL,AH 
050E E8 57 FC 				CALL 	OUT 
0511 BO 3D 				MOV 	AL,"=" 
0513 E8 52 FC 				CALL 	OUT 
516 BB 17 				MOV 	DX,[BX] 
0518 43 				INC 	BX 
0519 43 				INC 	BX 
051A E8 2F FC 				CALL 	OUT16 
051D EB 53 FC 				CALL 	BLANK 
0520 EB 50 FC 				CALL 	BLANK 
0523 E2 E2 				LOOP 	DISPREGLINE 
0525 C3 				RET 
0526 				REPFLG: 
0526 BB 44 46 				MOV 	AX,4600H+"D" 	;DF ERROR 
0529 				FERR: 
0529 E8 OE 00 				CALL 	SAVCHG 
052C 				ERR:  
052C  E8  39 FC  			CALL  	OUT  
052F  8A  C4  				MOV  	AL,AH  
0531  E8  34 FC  			CALL  	OUT  
0534 BE  6B  07  			MOV  	SI,ERRMES  
0537 E9  3B  FE  			JMP  	PRINT  
053A  				SAVCHG:  
053A 89 053E C3  16 B6  01 	 	MOV 	[FSAVE],DX  
					RET
053F  				FLGERR:  
053F B8 0542 EB  42 E5  46  		MOV	AX,4600H+"B" 
					JP	FERR  		;BF  ERROR  
0544  				DISPFLAGS:  
0544 BE  F3  06  			MOV  	SI,FLAGTAB  
0547 B9  10 00  			MOV  	CX,16  
054A  8B  16 B6 01  			MOV  	DX,[FSAVE]  
054E  				DFLAGS:  
054E  2E  				SEG  	CS  
054F AD  				LODW  
0550 D1  E2  				SHL  	DX  
0552 72  04  				JC  	FLAGSET  
0554  2E  				SEG	CS  
					MOV	AX,[SI+30]
0555 0558  8B  44  1E  		FLAGSET:
0558 OB  CO  				OR  	AX,AX  
055A 74  OB  				JZ  	NEXTFLG  
055C  E8 09 FC 				CALL  	OUT  
055F  8A  C4  				MOV  	AL,AH  
0561  E8 04 FC 				CALL  	OUT  
0564 E8  OC  FC  			CALL  	BLANK  
0567  				NEXTFLG:  
0567 E2  E5  				LOOP  	DFLAGS  
0569 C3  				RET  
056A  
056A 056A 056A 056A  
				;Trace 1 instruction or the number of instruction specified
				;by the parameter using 8086 trace mode. Registers are all 
				;set according to values in save area  

056A  				TRACE:  
056A E8  AF  FB  			CALL  	SCANP  
056D  E8  98 FD  			CALL  	HEXIN  
0570 BA  01  00  			MOV  	DX,1  
0573 72  06  				JC  	STOCNT  
0575 B9  04  00 			MOV  	CX,4  
0578 E8  6F  FD  			CALL  	GETHEX  
057B  				STOCNT:  
057B 89  16 02 01  			MOV  	[TCOUNT],DX  
057F  EB  EO  FD  			CALL  	GETEOL  
05B2  				STEP:  
05B2 C7  06 00 01  00 00  		MOV  	[BRKCNT],0  
05BB  BO  OE  B7  01  01  		OR  	B,[FSAVE+1],1  
05BD  				EXIT:  	
					MOV 	[12],BREAKFIX
					MOV	[14],CS
					MOV	[4],REENTER
059D  8C  OE  06  00  			MOV	[6],CS  
05A 1 FA  				DI  
05A2 C7 06 64 00  DB 05  		MOV  	[64H],REENTER  
					MOV  	[66H],CS
					MOV	SP,STACK  
05AF 58  				POP  	AX  
0580  5B  				POP  	BX  
05B1  59  				POP  	CX  
0582  5A  				POP  	DX  
05B3 5D  				POP  	BP  
0584  5D  				POP  	BP  
0585 5E  				POP  	SI  
0586 5F  				POP  	DI  
0587 07  				POP  	ES  
058B 07  				POP  	ES  
0589 17 				POP 	SS
058A 88 26 A4 01			MOV 	SP,[SPSAVE] 
058E FF 36 86 01 			PUSH 	[FSAVE] 
05C2 FF 36 82 01 			PUSH 	[CSSAVE]
05C6 FF 36 84 01 			PUSH 	[IPSAVE] 
05CA 8E 1E AC 01 			MOV 	DS,[DSSAVE) 
05CE CF !				RET 
05CF E8 81 		STEP1: 		JP 	STEP 
05D1 05D1 		;Re-entry point from breakpoint. Need to decrement instruction 
05D1 			;pointer so it points to location where breakpoint actually 
05D1 			;occured. 
05D1 
05D1 			BREAKFIX: 
05D1 87 EC 				XCHG 	SP,BP 
05D3 FF 4E 00 				DEC 	[BP] 
05D6 87 EC				XCHG 	SP,BP 
05D8 
05D8 			;Re-entry point from trace mode or interrupt during 
05D8 			;execution. All registers are saved so they can be 
05D8 			;displayed or modified. 
05D8 
05D8 			REENTER: 
05D8 2E 				SEG 	CS 
05D9 89 26 A4 09 			MOV 	[SPSAVE+SEGDIF],SP 
05DD 2E 				SEG 	CS 
05DE 8C 16 80 09			MOV 	[SSSAVE+SEGDIF],SS 
05E2 33 E4 				XOR 	SP,SP 
05E4 8E D4 · 				MOV 	SS,SP 
05E6 8C 80 01 				MOV 	SP,RSTACK 
05E9 06 				PUSH 	ES 
05EA 1E 				PUSH 	DS 
05EB 57 				PUSH 	DI 
05EC 56 				PUSH 	SI 
05ED 55 				PUSH 	BP 
05EE 4C 				DEC 	SP 
05EF 4C 				DEC 	SP 
05FO 52 				PUSH 	DX 
05F 1 51 				PUSH 	CX 
05F2 53 				PUSH 	BX 
05F3 50 				PUSH 	AX 
05F4 16 				PUSH 	SS 
05F5 1F 				POP 	DS 
05F6 8B 26 A4 01 			MOV 	SP,[SPSAVE]
05FA 8E 16 BO 01 			MOV 	SS,[SSSAVE]
05FE 8F 06 B4 01 			POP 	[IPSAVE]
0602 8F 06 82 01 			POP 	[CSSAVE]
0606 58 				POP 	AX 
0607 80 E4 FE 				AND 	AH,0FEH 
060A A3 86 01 				MOV 	[FSAVE],AX 
060D 89 26 A4 01 			MOV 	[SPSAVE],SP 
0611 1E 				PUSH 	DS
0612 17 				POP 	SS 
0613 1E 				PUSH 	DS 
0614 07 				POP 	ES 
0615 8C 9C 01 				MOV 	SP,STACK 
0618 C7 06 64 00 88 06 			MOV 	[64H],INT 
061E 80 20 				MOV 	AL,20H 
0620 E6 F2 				OUT 	BASE+2 
0622 FB 				EI 
0623 FC 				UP 
0624 E8 CD FA 				CALL 	CRLF 
0627 E8 6C FE 				CALL 	DISPREG 
062A FF OE 02 01			DEC 	[TCOUNT] 
062E 75 9F 				JNZ 	STEP1 
0630 				ENDGO: 
0630 BE 04 01 				MOV 	SI,BPTAB 
0633 8B OE 00 01 			MOV 	CX,[BRKCNT]
0637 E3 10 				JCXZ 	COMJMP 
0639 				CLEARBP: 
					MOV 	DX,[SI+BPLEN] 
					LODW
					PUSH 	AX 
					CALL 	GETSEG 
					MOV 	ES,AX 
					MOV 	DI,DX 
					POP 	AX 
					STOB 
					LOOP 	CLEARBP 
				COMJHP: JMP 	COMMAND 

				;Input from the specified port and display result 

				INPUT: 
					MOV 	CX,4 		;Port may have 4 digits 
					CALL 	GETHEX 		;Get port number in DX 
					INB 	DX 		;Variable port input 
					CALL 	HEX 		;And display 
					JMP 	CRLF 

				;Output a value to specified port. 

				OUTPUT: 
					MOV 	CX,4 		;Port may have 4 digits 
					CALL 	GETHEX 		;Get port number 
					PUSH 	DX 		;Save while we get data 
					MOV 	CX,2 		;Byte output only 
					CALL 	GETHEX 		;Get data to output 
					XCHG 	AX.DX 		;Output data in AL 
					POP 	DX 		;Port in DX 
					OUTB 	DX 		;Variable port output 
					RET 

				;Jump to program, setting up registers according to the 
				;save area. Up to 10 breakpoint addresses may be specified. 

				GO: 
					MOV 	BX,LINEBUF 
					XOR 	SI,SI 
				GO1: 
					CALL 	SCANP 
					JZ 	EXEC 
					MOV 	CX,5 
					CALL 	GETHEX 
					MOV 	[BX],DX 
					MOV 	[BX-BPLEN+1],AH 
					INC 	BX 
					INC 	BX 
					INC 	SI 
					CMP 	SI,BPHAX+1 
					JNZ 	GO1 
					MOV 	AX,5000H+"B" 	;BP ERROR 
					JMP 	ERR 
				EXEC: 
					MOV 	[BRKCNT],SI 
					CALL 	GETEOL 
					MOV 	CX,SI
					JCXZ 	NOBP 
					MOV 	SI,BPTAB 
				SETBP: 
					MOV 	DX,[SI+BPLEN] 
					LODW
					CALL 	GETSEG 
					MOV 	DS,AX 
					MOV 	DI,DX 
					MOV 	AL,[DI] 
					MOV 	B,[DI],0CCH 
					PUSH 	ES 
					POP 	DS 
					MOV 	[SI-2],AL 
					LOOP 	SETBP 
				NOBP: 
					MOV 	[TCOUNT],1 
					JMP 	EXIT 

				;Console input interrupt handler. Used to interrupt commands 
				;or programs under execution (if they have interrupts 
				;enabled). Control-S causes a loop which waits for any other 
				;character to be typed. Control-C causes abort to command 
				;mode. All other characters are ignored. 

				INT: 
					PUSH 	AX 		;Don't destroy accumulator 
				;Output End-of-Interrupt commands to slave 8259A. This 
				;wouldn't be necessary if Automatic End of Interrupt mode 
				;worked like it was supposed to! 
					MOV 	AL,20H 
					OUT 	BASE+2 
					IN 	DATA 
					AND 	AL,7FH 
					CMP 	AL,"S"-"@" 
					JNZ 	NOSTOP 
					CALL 	IN
				NOSTOP: 
					CMP	AL,"C"-"@"
					JZ	BREAK
				;Just ignore 
					POP	AX
					IRET 
				BREAK: 
					CALL	CRLF
					JMP	COMMAND
				REGTAB: DB 	"AXBXCXDXSPBPSIDIDSESSSCSIPPC"

				REGDIF: EQU 	AXSAVE-REGTAB

				;Flags are ordered to correspond with the bits of the flag 
				;register, most significant bit first, zero if bit is not 
				;a flag. First 16 entries are for bit set, second 16 for 
				;bit reset. 
				FLAGTAB: 
					DW 	0 
					DW 	0 
					DW 	0 
					DW 	0 
					DB 	"OV" 
					DB 	"DN" 
					DB 	"EI" 
					DW 	0 
					DB 	"NG" 
					DB 	"ZR" 
					DW 	0 
					DB 	"AC" 
					DW 	0 
					DB 	"PE" 
					DW 	0 
					DB 	"CY" 
					DW 	0 
					DW 	0 
					DW 	0 
					DW 	0 
					DB 	"NV" 
					DB 	"UP" 
					DB 	"DI" 
					DW 	0 
					DB 	"PL" 
					DB 	"NZ" 
					DW 	0 
					DB 	"NA" 
					DW 	0 
					DB 	"PO" 
					DW 	0 
					DB 	"NC" 
					
0733  				;Initialization table.  First byte of each entry is no.  
0733  				;of bytes to output to the corresponding port. That  
0733  				;many initialization bytes follow.  
0733  
0733  				INITTABLE:  
0733  				;Port BASE+0 - Master 8259A.  Intialization Command Word (ICW)  
0733  				;One sets level-triggered mode, multiple 8259As, require  
0733  				;ICW4.  
0733  01  				DB  	1  
0734  19  				DB  	19H  
0735  				;Port BASE+1 - Master 8259A. ICW2 sets vector base to 10H  
0735  				;ICW3 sets a slave on interrupt input 1; ICW4  sets buffered  
0735  				;mode, as a master, with Automatic End of Interrupt, 8086  
0735  				;vector; Operation Command Word (OCW) One sets interrupt  
0735  				;mask to enable line 1 (slave 8259A) only.  
0735 04  				DB  	4  
0736  10 02  OF  FD  			DB  	10H,2,0FH,0FDH  
073A  				;Port BASE+2 - Slave 8259A. ICW1 sets level-triggered mode,  
073A  				;multiple 8259As, require ICW4.  
073A 01  				DB  	1  
073B 19  				DB  	19H  
one  				;Port BASE+3 - Slave 8259A. ICW2 sets vector base to 18H  
one  				;ICW3 sets slave address as 1; ICW4 set  buffered mode,  
073C  				;as slave, with Automatic End  of Interrupt (which doesn't  
07:J;  				;work in slaves), 8086 vector; OCW1 sets interrupt mask  
073C 073C 04  			;to enable line 1 (serial receive) only. 
					DB 	4  
073D  18 01  OB  FD  			DB  	18H,1,0BH,OFDH  
0741  				;Port Base+4 - 9513 Data. 9513 has previously been set  
0741  				;up for  Counter 5 mode register with auto increment. Thus  
0741  				;mode is set to OB63H, which is no gating, count source is  
0741  				;F1 (4 MHz), reload from load or hold, count down repetitively  
0741  				;in binary, with output toggle.  Load register is set to  
0741  				;0007H, and Hold register is set to 0006H. Thus we  
0741  				;alternately divide by 7 and 6, which is divided by 2 by  
0741  				;the output toggle, thus providing a square wav  of  
0741  				;4 MHz/13 = 307.7 kHz, which divided by 16 in the 8251A  
0741  				;provides 19,230 baud (0.16% high).  
0741  06  				DB  	6  
0742 63  OB  07 00 06 00  		DB  	63H,0BH,7,0,6,0  
0748  				;Port BASE+5 - 9513 Control. Load and arm  counter 5,  
0748  				;enabling baud rate generation. Then select counter  
0748  				;5 mode register, in case baud rate wasn't right.  
0748 02  				DB  	2  
0749 70 05  				DB  	70H,5  
074B 074B 00  			;Port BASE+6 DB - 8251A Data. No initialization to this port.
					BB	0
074C  				;Port BASE+7 - 8251A Control. Since it is not possible to  
074C  				;know whether the 8251A next  expects a Mode Instruction  or  
074C  				;a Command Instruction, a dummy byte is sent which could  
074C  				;safely be interpreted as either but guarantees it is now  
074C  				;expecting a Command. The command sent is Internal Reset  
074C  				;which causes it to start expecting a mode. The mode sent  
074C  				;is for 2 stop bits, no  parity, 8 data bits, 16X clock.  
07LIC  				;This is followed by the command to error reset, enable  
074C  				;transmitter and receiver, set RTS and DTR to +12V.  
074C 04  				DB  	4  
074D B7 77 CE  37  			DB  	0B7H,77H,0CEH,37H  
0751  OD  OA  OA  53  43  50  	HEADER:	DM	13,10,10,"SCP 8086 Monitor 1.4",13,10  

076A  5E  			SYNERR:	DB	'^'  
0768 20 45  72 72  6F 72  	ERRMES:	DM	" Error",13,10  
0773  08  20  88  		BACMES:	DM	8,32,8  
0776  
0776  				;Disk  boot.  
0776  
0776  				BOOT:  
0776 57  				PUSH  DI  

				;************************************************

0777 				;Boot for Cromemco 4FDC disk controller with either 
0777 				;large or small disks. Loads track 0, sector 1 into LOAD.
0777 					IF CROMEMC04FDC 
0777 BO 01 				MOV 	AL,1 
0779 E6 02 				OUT 	2 		;Reset 4FDC serial I/O
0778 BO 84				MOV 	AL,84H 
077D E6 00 				OUT 	0 		;and set for 300 baud 
077F BO 7F 				MOV 	AL,7FH 
0781 E6 04 				OUT 	4 
0783 82 21 				MOV 	DL,21H 
0785 				RETRY: 
0785 BO DO 				MOV 	AL,0D0H 
0787 E6 30 				OUTB 	30H 
0789 				READY: 
0789 E4 30 				INB 	30H 
078B Do c8 				ROR 	AL 
078D 72 FA 				JC 	READY 
078F 80 F2 10 				XOR 	DL,10H 
0792 8A C2 				MOV 	AL,DL 
0794 E6 34 				OUTB 	34H 
0796 BF 00 02 				MOV 	DI,LOAD 
0799 BO OC 				MOV 	AL,12 
0798 E6 30 				OUTB 	30H 
079D 				HOME: 
079D E4 34 				INB 	34H 
079F DO C8 				ROR 	AL 
07A 1 73 FA 				JNC 	HOME 
07A3 E4 30 				INB 	30H 
07A5 24 98 				AND 	AL,98H 
07A7 75 DC 				JNZ 	RETRY 
07A9 BO 01 				MOV 	AL,1 
07AB E6 32 				OUTB 	32H 
07AD 89 80 00 				MOV 	CX,80H 
0780 8A C2 				MOV 	AL,DL 
0782 oc 80 				OR 	AL,80H 
0784 E6 34 				OUTB 	34H 
0786 BO 8C 				MOV 	AL,8CH 
0788 E6 30 				OUTB 	30H 
078A 				READ: 
07BA E4 34 				INB 	34H 
07BC DO C8 				ROR 	AL 
07BE 72 OB 				JC 	DONE 
07CO E4 33 				INB 	33H 
07C2 AA 				STOB 
07C3 E2 F5 				LOOP 	READ 
07C5 				WSTAT: 
07C5 E4 34 				INB 	34H 
07C7 DO C8 				ROR 	AL 
07C9 73 FA 				JNC	WSTAT 
07CB 				DONE: 
07CB E4 30 				INB 	30H 
07CD 24 9C 				AND 	AL,9CH 
07CF 75 84 				JNZ 	RETRY 
07D1 					ENDIF 

				; Successful read
					MOV 	[CSSAVE],0 
					MOV 	[IPSAVE],LOAD 
					POP 	DI 
					JMP 	GO

				;************************************************

0777 				;Boot for North Star disk, single density.
				; Loads track 0, sector 0 into address LOAD 

					IF  NORTHSTARSD  

				;Disk command  equates  

				SEL:  	EQU  	1  
				STP1:  	EQU  	9  
				STP2:  	EQU  	8  
				NOP:  	EQU  	10H  
				SEC:  	EQU  	14H  
				STPOUT:	EQU  	1CH  
				RD:  	EQU  	40H  
				BST:  	EQU  	20H  
				
					PUSH  	DS  
					MOV  	AX,0FEB8H  
					MOV  	DS,AX  
					MOV  	AL,[SEL]
					MOV  	CX,20  
				MOTOR:
					CALL  	SECTOR  
					LOOP  	MOTOR  
				CHKTRK:  
					TEST  	B,[STPOUT],1  
					JNZ  	ONTRACK  
					MOV  	AL,[STP1]  
					AAM  
					MOV  	AL,[STP2]  
					CALL  	SECTOR  
					CALL  	SECTOR  
					JP  	CHKTRK  
				SECTOR:  
					MOV  	AL,[SEC]  
				SECLP:  
					MOV  	AL,[BST+NOP]
					TEST  	AL,80H  
					JZ  	SECLP  
					RET  
				ONTRACK:  
					MOV  	DI,LOAD  
					MOV  	CX,280  
					MOV  	BX,RD+NOP  
				GETSEC:  
					CALL  	SECTOR  
					AND  	AL,0FH  
					JNZ  	GETSEC  
				GETSYNC:  
					TEST  	B,[NOP],4  
					LOOPZ  	GETSYNC  
					JZ  	ONTRACK  
					MOV  	CX,100H  
					XOR  	DL,DL  
					AAD  
				READ:  
					MOV  	AL,[BX]  
					STOB			;Uses  ES  
07CD  32  DO  				XOR  	DL,AL  
07CF  DO C2  				ROL  	DL  
07D1  D5 OA  				AAD  
07D3  E2 F5  				LOOP  	READ  
07D5  8A 07  				MOV  	AL,[BX]  
07D7  3A  C2  				CMP  	AL,DL  
07D9  75 CF  				JNZ  	ONTRACK  
07DB  1F  				POP  	DS  
07DC  					ENDIF  
			;Successful read
					MOV	[CSSAVE],0
					MOV	[IPSAVE],LOAD
					POP	DI  
					JMP	GO  

				;************************************************

0777 				;Boot for Tarbell disk controllers. Load track 0, 
.0777 				;sector 1 into LOAD. 
0777 
0777 					IF TARBELL 
0777 
0777 				DISK: 	EQU 	78H 
0777 
0777 				RETRY: 
0777 BO DO 				MOV 	AL,0D0H 
0779 E6 78 				OUTB 	DISK 
0778 				READY: 
0778 E4 78 				INB	DISK 
077D DO C8 				ROR 	AL 
077F 72 FA 				JC 	READY 
0781 BF 00 02 				MOV 	DI,LOAD 
0784 BO OE 				MOV 	AL,0EH 		;Home command @ 10ms/track 
0786 E6 78 				OUTB 	DISK 
0788 E4 7C 				INB 	DISK+4 
078A E4 78 				INB 	DISK 
078C 24 98 				AND 	AL,98H 
078E 75 E7 				JNZ 	RETRY 
0790 BO 01 				MOV 	AL,1 
0792 E6 7A 				OUTB 	DISK+2 
0794 89 80 00 				MOV 	CX,80H 
0797 BO 8C				MOV 	AL,8CH 
0799 E6 78 				OUTB 	DISK 
0798 				READ: 
0798 E4 7C 				INB 	DISK+4 
079D DO CO 				ROL 	AL 
079F 73 OB 				JNC 	DONE 
07A1 E4 7B 				INB 	DISK+3 
07A3 AA 				STOB 
07A4 E2 F5				LOOP 	READ 
07A6 				WSTAT: 
07A6 E4 7C 				INB 	DISK+4 
07A8 DO CO 				ROL 	AL 
07AA 72 FA 				JC 	WSTAT 
07AC 				DONE: 
07AC E4 78 				INB 	DISK 
07AE 24 9C 				AND 	AL,9CH 
0780 75 C5 				JNZ 	RETRY 
0782 					ENDIF 

			;Successful read
					MOV	[CSSAVE],0
					MOV	[IPSAVE],LOAD
					POP	DI  
					JMP	GO  

				;************************************************

0777 					IF	OTHER 

			;User may insert customized disk boot here. All 
			;registers are available, stack pointer is valid 
			;and interrupts are enabled. Stack should be at 
			;same level on fall-through to code below. Last 
			;address available is 07DF hex. 

					ORG 	7E0H 		;Simulate boot of maximum length 

					ENDIF 
			;Successful read 
					MOV 	[CSSAVE],0
					MOV 	[IPSAVE],LOAD 
					POP	DI 
					JMP 	GO 

.END
