/**
 * @copyright https://www.pcjs.org/machines/modules/v2/defines.js (C) 2012-2024 Jeff Parsons
 */

/**
 * @define {string}
 */
const APPVERSION = "2.23";              // this @define is overridden with the version in machines.json

/**
 * COMPILED is false by default; overridden with true in the Closure Compiler release.
 *
 * @define {boolean}
 */
const COMPILED = false;                 // this @define is overridden by the Closure Compiler

/**
 * @define {string}
 */
const COPYRIGHT = "Copyright Â© 2012-2024 Jeff Parsons <Jeff@pcjs.org>";

/**
 * @define {string}
 */
const CSSCLASS = "pcjs";

/**
 * DEBUG is true by default, enabling assertions and other runtime checks; overridden with false
 * in the Closure Compiler release, which generally results in the removal of any DEBUG code.  Our
 * gulpfile, however, takes the extra precaution of physically removing all "assert" method calls
 * from the concatenated file that is generated for the Closure Compiler.
 *
 * @define {boolean}
 */
const DEBUG = true;

/**
 * WARNING: DEBUGGER needs to accurately reflect whether or not the Debugger component is (or will be) loaded.
 * In the compiled case, we rely on the Closure Compiler to override DEBUGGER as appropriate.  When it's *false*,
 * nearly all of debugger.js will be conditionally removed by the compiler, reducing it to little more than a
 * "type skeleton", which also solves some type-related warnings we would otherwise have if we tried to remove
 * debugger.js from the compilation process altogether.
 *
 * However, when we're in "development mode" and running uncompiled code in debugger-less configurations,
 * I would like to skip loading debugger.js altogether.  When doing that, we must ALSO arrange for an additional file
 * (nodebugger.js) to be loaded immediately after this file, which *explicitly* overrides DEBUGGER with *false*.
 *
 * @define {boolean}
 */
var DEBUGGER = true;

/**
 * @define {string}
 */
const LICENSE = "License: MIT <https://www.pcjs.org/LICENSE.txt>";

/**
 * MAXDEBUG can be set to true to enable MAXDEBUG-only code (ie, hyper-aggressive DEBUG checks that should only be
 * enabled in special cases); it always overridden with false in the Closure Compiler release.
 *
 * @define {boolean}
 */
const MAXDEBUG = false;

/**
 * PRIVATE can be set to true to enable PRIVATE-only code (ie, code that should never be enabled in a public release);
 * it always overridden with false in the Closure Compiler release.
 *
 * @define {boolean}
 */
const PRIVATE = false;

/*
 * RS-232 DB-25 Pin Definitions, mapped to bits 1-25 in a 32-bit status value.
 *
 * SerialPorts in PCjs machines are considered DTE (Data Terminal Equipment), which means they should be "virtually"
 * connected to each other via a null-modem cable, which assumes the following cross-wiring:
 *
 *     G       1  <->  1        G       (Ground)
 *     TD      2  <->  3        RD      (Received Data)
 *     RD      3  <->  2        TD      (Transmitted Data)
 *     RTS     4  <->  5        CTS     (Clear To Send)
 *     CTS     5  <->  4        RTS     (Request To Send)
 *     DSR   6+8  <->  20       DTR     (Data Terminal Ready)
 *     SG      7  <->  7        SG      (Signal Ground)
 *     DTR    20  <->  6+8      DSR     (Data Set Ready + Carrier Detect)
 *     RI     22  <->  22       RI      (Ring Indicator)
 *
 * TODO: Move these definitions to a more appropriate shared file at some point.
 */
const RS232 = {
    RTS: {
        PIN:  4,
        MASK: 0x00000010
    },
    CTS: {
        PIN:  5,
        MASK: 0x00000020
    },
    DSR: {
        PIN:  6,
        MASK: 0x00000040
    },
    CD: {
        PIN:  8,
        MASK: 0x00000100
    },
    DTR: {
        PIN:  20,
        MASK: 0x00100000
    },
    RI: {
        PIN:  22,
        MASK: 0x00400000
    }
};

/**
 * SITEURL is the URL of the web server; it is replaced by the Closure Compiler (eg, "https://www.pcjs.org")
 *
 * @define {string}
 */
const SITEURL = "http://localhost:8088";

/**
 * LOCALDISKS is intended to reflect the webserver's operating mode.  Normally, we assume that all web
 * resources should be accessed remotely, but if the webserver is running in "developer" mode, then the
 * webserver should indicate that fact by setting the global variable 'LOCALDISKS' to true on any pages
 * with embedded machines.
 *
 * @define {boolean}
 */
var LOCALDISKS = false;

/*
 * Platform-agnostic way to isolate global variables (both mine and the system's).
 */
let globals = {
    browser: (typeof window != "undefined"),
    node: (typeof window != "undefined")? {} : global,
    process: (typeof process != "undefined")? process : {},
    window: (typeof window != "undefined")? window : global,
    document: (typeof document != "undefined")? document : {},
    pcjs: { 'machines': {}, 'components': [], 'commands': {}, 'files': null }
};

if (globals.window['PCjs']) {
    globals.pcjs = globals.window['PCjs'];
} else {
    globals.window['PCjs'] = globals.pcjs;
}

globals.window['LOCALDISKS'] = LOCALDISKS;


/**
 * @copyright https://www.pcjs.org/machines/modules/v2/message.js (C) 2012-2024 Jeff Parsons
 */

/*
 * Standard machine message flags.
 *
 * NOTE: Because this machine defines more than 32 message categories, some of these message flags
 * exceed 32 bits, so when concatenating, be sure to use "+", not "|".
 */
const MESSAGE = {
    NONE:       0x000000000000,
    ADDR:       0x000000000001,
    LOG:        0x001000000000,
    STATUS:     0x002000000000,
    NOTICE:     0x004000000000,
    WARNING:    0x008000000000,
    ERROR:      0x010000000000,
    ALERTS:     0x01c000000000,
    DEBUG:      0x020000000000,
    PROGRESS:   0x040000000000,
    SCRIPT:     0x080000000000,
    TYPES:      0x0ff000000000,
    HALT:       0x400000000000,
    BUFFER:     0x800000000000,
    ALL:        0x000ffffffffe
};

/*
 * Message categories supported by the messageEnabled() function and other assorted message
 * functions. Each category has a corresponding bit value that can be combined (ie, OR'ed) as
 * needed.  The Debugger's message command ("m") is used to turn message categories on and off,
 * like so:
 *
 *      m port on
 *      m port off
 *      ...
 *
 * NOTE: The order of these categories can be rearranged, alphabetized, etc, as desired; just be
 * aware that changing the bit values could break saved Debugger states (not a huge concern, just
 * something to be aware of).
 */
MESSAGE.NAMES = {
    "log":      MESSAGE.LOG,
    "warn":     MESSAGE.WARNING,
    /*
     * Now we turn to message actions rather than message types; for example, setting "halt"
     * on or off doesn't enable "halt" messages, but rather halts the CPU on any message above.
     *
     * Similarly, "m buffer on" turns on message buffering, deferring the display of all messages
     * until "m buffer off" is issued.
     */
    "halt":     MESSAGE.HALT,
    "buffer":   MESSAGE.BUFFER
};


/**
 * @copyright https://www.pcjs.org/machines/modules/v2/format.js (C) 2012-2024 Jeff Parsons
 */

/** @typedef {Function} */
let Formatter;

/**
 * @class Format
 * @property {Object.<string,(Formatter|null)>}>} formatters
 */
class Format {

    static NamesOfDays = [
        "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"
    ];
    static NamesOfMonths = [
        "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"
    ];
    static HexLowerCase = "0123456789abcdef?";
    static HexUpperCase = "0123456789ABCDEF?";

    /**
     * constructor()
     *
     * @this {Format}
     */
    constructor()
    {
        /**
         * We populate the sprintf() formatters table with null functions for all the predefined (built-in) types,
         * so that type validation has only one look-up to perform.
         *
         * For reference purposes, the standard ANSI C set of format types is "dioxXucsfeEgGpn%", not all of which
         * are supported.  Some built-in types have been added, including Date types (see the upper-case types),
         * a boolean type ('b'), and a JSON type ('j'); external format types include the Debugger Address type ('a'),
         * and a default number type ('n') that selects the appropriate base type ('d', 'o', or 'x'), um, based on
         * current Debugger preferences.
         */
        this.formatters = {};
        let predefinedTypes = "ACDFGHMNSTWYBbdfjcsoXx%";
        for (let i = 0; i < predefinedTypes.length; i++) {
            this.formatters[predefinedTypes[i]] = null;
        }
    }

    /**
     * addFormatType(type, func)
     *
     * Whenever the specified type character is encountered in a sprintf() call, the specified
     * function will be called with all the associated formatting parameters; the function must
     * return a stringified copy of the arg.
     *
     * @this {Format}
     * @param {string} type (the sprintf standard requires this be a single character)
     * @param {Formatter} func
     * @returns {boolean} (true if successful, false if type character has already been defined)
     */
    addFormatType(type, func)
    {
        // assert(!this.formatters[type]);
        if (!this.formatters[type]) {
            this.formatters[type] = func;
            return true;
        }
        return false;
    }

    /**
     * isDate(date)
     *
     * @param {Date} date
     * @returns {boolean}
     */
    static isDate(date)
    {
        return !isNaN(date.getTime());
    }

    /**
     * parseDate(date)
     * parseDate(date, time)
     * parseDate(year, month, day, hour, minute, second)
     * parseDate(timestamp, fLocal)
     *
     * Produces a UTC date when ONLY a date (no time) is provided; otherwise, it combines the date and
     * and time, producing a date that is either local or UTC, depending on the presence (or lack) of time
     * zone information.  Finally, if numeric inputs are provided, then Date.UTC() is called to generate
     * a UTC time (since there is no provision for a time zone in that case either).
     *
     * In general, you should use this instead of new Date(), because the Date constructor implicitly calls
     * Date.parse(s), which behaves inconsistently.  For example, ISO date-only strings (e.g. "1970-01-01")
     * generate a UTC time, but non-ISO date-only strings (eg, "10/1/1945" or "October 1, 1945") generate a
     * local time.
     *
     * @param {...} args
     * @returns {Date} (UTC unless a time string with a timezone is explicitly provided)
     */
    static parseDate(...args)
    {
        let date;
        if (args[0] === undefined) {
            date = new Date(Date.now());
        }
        else if (typeof args[0] === "string") {
            let s = args[0];
            if (s.indexOf(':') < 0) {
                s += ' ' + (args[1] || "00:00:00 UTC");
            } else if (s.match(/^[0-9][0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9] [0-9][0-9]:[0-9][0-9]:[0-9][0-9]$/)) {
                /**
                 * I don't care to support all the possible time zone specifiers just to determine whether or not
                 * a time zone was provided, so for now, I simply look for common date+time patterns I use, such as
                 * the "timestamp" pattern above.  TODO: Make this general-purpose someday.
                 *
                 * Also, when a timestamp is provided, then a second (optional) fLocal parameter can be specified;
                 * requesting a (local) non-UTC date can be helpful, for example, when the date is going to be used
                 * as a local file modification time.
                 */
                if (!args[1]) s += " UTC";
            }
            date = new Date(s);
        }
        else if (args[1] === undefined) {
            date = new Date(args[0]);
        } else {
            // assert(args[1] < 12 && args[2] <= 31 && args[3] < 24 && args[4] < 60 && args[5] < 60);
            date = new Date(Date.UTC(...args));
        }
        return date;
    }

    /**
     * sprintf(format, ...args)
     *
     * This C-like version of sprintf() supports only a subset of the standard C formatting specifiers, plus a few
     * non-standard ones (eg, to display booleans, dates, times, etc).
     *
     * This version also supports custom format specifiers; see addFormatType() for details.
     *
     * TODO: The %c and %s specifiers support a negative width for left-justified output, but the numeric specifiers
     * (eg, %d and %x) do not; they support only positive widths and right-justified output.  That's one of the more
     * glaring omissions at the moment.
     *
     * @this {Format}
     * @param {string} format
     * @param {...} [args]
     * @returns {string}
     */
    sprintf(format, ...args)
    {
        /**
         * This isn't just a nice optimization; it's also important if the caller is simply trying
         * to printf() a string that may also contain '%' and doesn't want or expect any formatting.
         */
        if (!args || !args.length) {
            return format;
        }

        let buffer = "";
        let aParts = format.split(/%([-+ 0#]*)([0-9]*|\*)(\.[0-9]+|)([bwhlL]?)([A-Za-z%])/);

        let iArg = 0, iPart;
        for (iPart = 0; iPart < aParts.length - 6; iPart += 6) {

            buffer += aParts[iPart];
            let arg, type = aParts[iPart+5];

            /**
             * Check for unrecognized types immediately, so we don't inadvertently pop any arguments.
             */
            if (this.formatters[type] === undefined) {
                buffer += '%' + aParts[iPart+1] + aParts[iPart+2] + aParts[iPart+3] + aParts[iPart+4] + type;
                continue;
            }

            if (iArg < args.length) {
                arg = args[iArg];
                if (type != '%') iArg++;
            } else {
                arg = args[args.length-1];
            }
            let signed = false;
            let flags = aParts[iPart+1];
            let hash = flags.indexOf('#') >= 0;
            let zeroPad = flags.indexOf('0') >= 0;
            let width = aParts[iPart+2];
            if (width == '*') {
                width = arg;
                if (iArg < args.length) {
                    arg = args[iArg++];
                } else {
                    arg = args[args.length-1];
                }
            } else {
                width = +width || 0;
            }
            let precision = aParts[iPart+3];
            precision = precision? +precision.substr(1) : -1;
            let length = aParts[iPart+4];       // eg, 'h', 'l' or 'L'; we also allow 'w' (instead of 'h') and 'b' (instead of 'hh')
            let ach = null, s, radix = 0, prefix = "";

            /**
             * The following non-standard sprintf() format types provide handy alternatives to the
             * PHP date() format types that we previously used with the old datelib.formatDate() function:
             *
             *      a:  lowercase ante meridiem and post meridiem (am or pm)                %A (%.1A for a or p)
             *      F:  month ("January", "February", ..., "December")                      %F (%.3F for 3-letter month)
             *      g:  hour in 12-hour format                                              %G (%02G for leading zero)
             *      h:  hour in 24-hour format                                              %H (%02H for leading zero)
             *      i:  minutes (0, 1, ..., 59)                                             %N (%02N for leading zero)
             *      j:  day of the month (1, 2, ..., 31)                                    %D (%02D for leading zero)
             *      l:  day of the week ("Sunday", "Monday", ..., "Saturday")               %W (%.3W for 3-letter day)
             *      n:  month (1, 2, ..., 12)                                               %M (%02M for leading zero)
             *      s:  seconds (0, 1, ..., 59)                                             %S (%02S for leading zero)
             *      Y:  4-digit year (eg, 2014)                                             %Y (%0.2Y for 2-digit year)
             *
             * We also support a few custom format types:
             *
             *      %C:  calendar output (equivalent to: %W, %F %D, %Y)
             *      %T:  timestamp output (equivalent to: %Y-%02M-%02D %02H:%02N:%02S)
             *
             * Use the optional '#' flag with any of the above '%' format types to produce UTC results
             * (eg, '%#G' instead of '%G').
             *
             * The %A, %F, and %W types act as strings (which support the '-' left justification flag, as well as
             * the width and precision options), and the rest act as integers (which support the '0' padding flag
             * and the width option).  Also, while %Y does act as an integer, it also supports truncation using the
             * precision option (normally, integers do not); this enables a variable number of digits for the year.
             *
             * So old code like this:
             *
             *      printf("%s\n", formatDate("l, F j, Y", date));
             *
             * can now be written like this:
             *
             *      printf("%W, %F %D, %Y\n", date, date, date, date);
             *
             * or even more succinctly, as:
             *
             *      printf("%C\n", date);
             *
             * In fact, even the previous example can be written more succinctly as:
             *
             *      printf("%W, %F %D, %Y\n", date);
             *
             * because unlike the C runtime, we reuse the final parameter once the format string has exhausted all parameters.
             */
            let date = /** @type {Date} */ ("ACDFGHMNSTWY".indexOf(type) >= 0 && typeof arg != "object"? Format.parseDate(arg) : arg);

            switch(type) {
            case 'C':
                buffer += (Format.isDate(date)? this.sprintf("%#W, %#F %#D, %#Y".replaceAll('#', hash? '#' : ''), date) : undefined);
                continue;

            case 'D':
                arg = hash? date.getUTCDate() : date.getDate();
                type = 'd';
                break;

            case 'A':
            case 'G':
            case 'H':
                arg = hash? date.getUTCHours() : date.getHours();
                if (type == 'A') {
                    arg = (arg < 12 ? "am" : "pm");
                    type = 's';
                }
                else {
                    if (type == 'G') {
                        arg = (!arg? 12 : (arg > 12 ? arg - 12 : arg));
                    }
                    type = 'd';
                }
                break;

            case 'F':
            case 'M':
                arg = hash? date.getUTCMonth() : date.getMonth();
                if (type == 'F') {
                    arg = Format.NamesOfMonths[arg];
                    type = 's';
                } else {
                    arg++;
                    type = 'd';
                }
                break;

            case 'N':
                arg = hash? date.getUTCMinutes() : date.getMinutes();
                type = 'd';
                break;

            case 'S':
                arg = hash? date.getUTCSeconds() : date.getSeconds();
                type = 'd';
                break;

            case 'T':
                buffer += (Format.isDate(date)? this.sprintf("%#Y-%#02M-%#02D %#02H:%#02N:%#02S".replaceAll('#', hash? '#' : ''), date) : undefined);
                continue;

            case 'W':
                arg = Format.NamesOfDays[hash? date.getUTCDay() : date.getDay()];
                type = 's';
                break;

            case 'Y':
                arg = hash? date.getUTCFullYear() : date.getFullYear();
                if (precision > 0) {
                    arg = arg % (Math.pow(10, precision));
                }
                type = 'd';
                break;
            }

            switch(type) {
            /**
             * "%b" is for boolean-like values.
             */
            case 'b':
                buffer += (arg? "true" : "false");
                break;

            /**
             * "%d" is for signed decimal numbers.
             */
            case 'd':
                /**
                 * I could use "arg |= 0", but there may be some value to supporting integers > 32 bits,
                 * so I use Math.trunc() instead.  Bit-wise operators also mask a lot of evils, by converting
                 * complete nonsense into zero, so while I'm ordinarily a fan, that's not desirable here.
                 *
                 * Other (hidden) advantages of Math.trunc(): it automatically converts strings, it honors
                 * numeric prefixes (the traditional "0x" for hex and the newer "0o" for octal), and it returns
                 * NaN if the ENTIRE string cannot be converted.
                 *
                 * parseInt(), which would seem to be the more logical choice here, doesn't understand "0o",
                 * doesn't return NaN if non-digits are embedded in the string, and doesn't behave consistently
                 * across all browsers when parsing older octal values with a leading "0"; Math.trunc() doesn't
                 * recognize those octal values either, but I'm OK with that, as long as it CONSISTENTLY doesn't
                 * recognize them.
                 *
                 * That last problem is why some recommend you ALWAYS pass a radix to parseInt(), but that
                 * forces you to parse the string first and determine the proper radix; otherwise, you end up
                 * with NEW inconsistencies.  For example, if radix is 10 and the string is "0x10", the result
                 * is zero, since parseInt() happily stops parsing when it reaches the first non-radix 10 digit.
                 */
                arg = Math.trunc(arg);
                /**
                 * Before falling into the decimal floating-point code, we take this opportunity to convert
                 * the precision value, if any, to the minimum number of digits to print.  Which basically means
                 * setting zeroPad to true, width to precision, and then unsetting precision.
                 *
                 * TODO: This isn't quite accurate.  For example, printf("%6.3d", 3) should print "   003", not
                 * "000003".  But once again, this isn't a common enough case to worry about.
                 */
                if (precision >= 0) {
                    zeroPad = true;
                    if (width < precision) width = precision;
                    precision = -1;
                }
                /* falls through */

            /**
             * "%f" is for floating-point numbers.
             */
            case 'f':
                arg = +arg;             // convert to a number, if it isn't already
                s = arg + "";
                if (precision >= 0) {
                    s = arg.toFixed(precision);
                }
                if (s.length < width) {
                    if (zeroPad) {
                        if (arg < 0) {
                            width--;
                            s = s.substr(1);
                        }
                        s = ("0".repeat(width) + s).slice(-width);
                        if (arg < 0) s = '-' + s;
                    } else {
                        s = (" ".repeat(width) + s).slice(-width);
                    }
                }
                buffer += s;
                break;

            /**
             * "%j" is for objects (displayed as JSON, with configurable indentation).
             */
            case 'j':
                /**
                 * 'j' is one of our non-standard extensions to the sprintf() interface; it signals that
                 * the caller is providing an object that should be rendered as JSON.  If a width is included
                 * (eg, "%2j"), it's used as an indentation value; otherwise, no whitespace is added.
                 */
                buffer += JSON.stringify(arg, null, width || undefined);
                break;

            /**
             * "%c" is for characters (which can be either single-character strings or ASCII codes).
             */
            case 'c':
                arg = typeof arg == "string"? arg[0] : String.fromCharCode(arg);
                /* falls through */

            /**
             * "%s" is for strings.
             */
            case 's':
                /**
                 * 's' includes some non-standard benefits, such as coercing non-strings to strings first;
                 * we know undefined and null values don't have a toString() method, but hopefully everything
                 * else does.
                 */
                if (arg != undefined) {
                    if (typeof arg != "string") {
                        arg = arg.toString();
                    }
                    if (precision >= 0) {
                        arg = arg.substr(0, precision);
                    }
                    while (arg.length < width) {
                        if (flags.indexOf('-') >= 0) {
                            arg += ' ';
                        } else {
                            arg = ' ' + arg;
                        }
                    }
                }
                buffer += arg;
                break;

            /**
             * "%B" is for binary integers.
             */
            case 'B':
                radix = 2;
                if (hash) prefix = "0b";
                /* falls through */

            /**
             * "%o" is for octal integers.
             */
            case 'o':
                if (!radix) radix = 8;
                if (!prefix && hash) prefix = "0o";
                /* falls through */

            /**
             * "%X" is for hexadecimal integers (using upper-case letters).
             */
            case 'X':
                ach = Format.HexUpperCase;
                // if (!prefix && hash) prefix = "0X";  // I don't like that %#X uppercases BOTH the prefix and the value
                /* falls through */

            /**
             * "%x" is for hexadecimal integers (using lower-case letters).
             */
            case 'x':
                s = "";
                if (!radix) radix = 16;
                if (!prefix && hash) prefix = "0x";
                if (!ach) ach = Format.HexLowerCase;
                /**
                 * For all the same reasons articulated above (for type 'd'), we pass the arg through Math.trunc(),
                 * and we honor precision, if any, as the minimum number of digits to print.
                 *
                 * NOTE: In spite of what I mentioned above, Math.trunc() fails on some string values, most notably
                 * signed prefixed values (eg, "-0x1234").  So we deal with that below.
                 */
                if (typeof arg == "string") {
                    if (arg[0] == '-') {
                        signed = true;
                        arg = arg.slice(1);
                    }
                }
                arg = Math.trunc(arg);
                if (signed) arg = -arg;
                /**
                 * Since we now use division instead of shifts to reduce the value as we extract digits (in order to support
                 * values > 32 bits), negative numbers will not render properly.  That's easily fixed for 32-bit values with
                 * the unsigned 32-bit right-shift operator (>>>).  For larger values, we add 2^53 to the value, which gives us
                 * the two's complement of the value as a positive number.  And if the value is larger than 2^53, well, you've
                 * exceeded the integer precision of JavaScript's Number type, so you're out of luck.
                 *
                 * Example: Let's say you calculated 1 - 0x123456789, resulting in -0x123456788.  By adding 0x2000000000000 to
                 * it, we get 0x1FFFEDCBA9878, which is the 53-bit representation of -0x123456788 as a positive number.
                 */
                if (arg < 0) {
                    if ((arg|0) == arg) {
                        arg >>>= 0;
                    } else if (Math.abs(arg) <= Math.pow(2, 53)) {
                        arg += Math.pow(2, 53);
                    }
                }
                if (precision >= 0) {
                    zeroPad = true;
                    if (width < precision) width = precision;
                    precision = -1;
                }
                if (zeroPad && !width) {
                    /**
                     * When zero padding is specified without a width (eg, "%0x"), auto-select a width.
                     */
                    if (length == 'b') {
                        width = 2;      // if an 8-bit length was specified (eg, "%0bx"), then default to 2
                    } else if (length == 'h' || length == 'w') {
                        width = 4;      // if a 16-bit length was specified (eg, "%0wx"), then default to 4
                    } else if (length == 'l') {
                        width = 8;      // if a 32-bit length was specified (eg, "%0lx"), then default to 8
                    } else {
                        let v = Math.abs(arg);
                        if (v <= 0xff) {
                            width = 2;
                        } else if (v <= 0xffff) {
                            width = 4;
                        } else if (v <= 0xffffffff) {
                            width = 8;
                        } else {
                            width = 9;
                        }
                    }
                    width += prefix.length;
                }
                width -= prefix.length;
                do {
                    let d = 16;         // digit index corresponding to '?'
                    /*
                     * We default to '?' if isNaN(); since we always call Math.trunc() for integer args, if the original
                     * arg was undefined, or a string containing a non-number, or anything else that couldn't be converted
                     * to a number, the resulting arg should be NaN.
                     */
                    if (!Number.isNaN(arg)) {
                        d = arg & (radix - 1);
                        /*
                         * We divide by the base (8 or 16) and truncate, instead of the more traditional bit-wise shift,
                         * because, like the decimal integer case, this allows us to support values > 32 bits (up to 53 bits).
                         */
                        arg = Math.trunc(arg / radix);
                        // arg >>>= (radix == 16? 4 : 3);
                    }
                    if (zeroPad || !s || d || arg) {
                        s = ach[d] + s;
                    } else {
                        if (prefix) {
                            s = prefix + s;
                            prefix = "";
                        }
                        if (width > 0) s = ' ' + s;
                    }
                } while (--width > 0 || arg);
                buffer += prefix + s;
                break;

            /**
             * "%%" is for the percent symbol.
             */
            case '%':
                buffer += '%';
                break;

            default:
                // assert(this.formatters[type]);
                if (this.formatters[type]) {
                    buffer += this.formatters[type](type, flags, width, precision, arg);
                    break;
                }
                buffer += "(unimplemented sprintf type: %" + type + ")";
                break;
            }
        }

        buffer += aParts[iPart];
        return buffer;
    }
}

/**
 * @copyright https://www.pcjs.org/machines/modules/v2/databuffer.js (C) 2012-2024 Jeff Parsons
 */

/**
 * @class DataBuffer
 * @property {boolean} node
 * @property {number} length
 */
class DataBuffer {
    /**
     * DataBuffer
     *
     * Our pseudo-Buffer class constructor needs to handle:
     *
     *   1) Array.<number> (array of bytes)
     *   2) ArrayBuffer
     *   3) another DataBuffer
     *   4) string
     *   5) number (to create a buffer with that many bytes)
     *   6) Buffer (for Node-specific callers)
     *
     * The start and end parameters are only used with #3 (ie, when another DataBuffer is passed).
     *
     * NOTE: You will NOT find all the methods of the Buffer class implemented here (only the ones we actually use).
     *
     * @this {DataBuffer}
     * @param {*} [init]
     * @param {number} [start]
     * @param {number} [end]
     */
    constructor(init = 0, start, end)
    {
        this.node = (typeof Buffer != "undefined");
        if (typeof init == "number") {
            init = new ArrayBuffer(init);
        }
        if (this.node) {
            if (Buffer.isBuffer(init)) {
                this.buffer = init;
            }
            else if (init instanceof DataBuffer) {
                this.buffer = init.buffer.slice(start, end);
            }
            else {
                this.buffer = Buffer.from(init);
            }
            this.length = this.buffer.length;
        }
        else {
            if (init instanceof DataBuffer) {
                init = init.ab;
            }
            if (init instanceof ArrayBuffer) {
                this.ab = init.slice(start || 0, end || init.byteLength);
                this.length = this.ab.byteLength;
                this.dv = new DataView(this.ab, 0, this.length);
            }
            else {
                if (typeof init == "string") {
                    let enc = new TextEncoder("utf-8");
                    init = enc.encode(init);
                }
                this.ab = new ArrayBuffer(init.length);
                this.dv = new DataView(this.ab, 0, init.length);
                for (let i = 0; i < init.length; i++) {
                    this.dv.setUint8(i, init[i]);
                }
                this.length = init.length;
            }
            this.buffer = new Uint8Array(this.ab);
        }
    }

    /**
     * compare(dbTarget)
     *
     * @this {DataBuffer}
     * @param {DataBuffer} dbTarget
     * @returns {boolean} (true if the contents of this buffer are equal to the contents of the specified buffer, false otherwise)
     */
    compare(dbTarget)
    {
        if (this.node) {
            return !Buffer.compare(this.buffer, dbTarget.buffer);
        }
        return false;   // TODO
    }

    /**
     * copy(dbTarget, offTarget, offSource, offSourceEnd)
     *
     * @this {DataBuffer}
     * @param {DataBuffer} dbTarget
     * @param {number} [offTarget]
     * @param {number} [offSource]
     * @param {number} [offSourceEnd]
     */
    copy(dbTarget, offTarget = 0, offSource = 0, offSourceEnd = this.length)
    {
        if (this.node) {
            this.buffer.copy(dbTarget.buffer, offTarget, offSource, offSourceEnd);
        } else {
            let cbCopy = offSourceEnd - offSource;
            let cbMax = dbTarget.length - offTarget;
            if (cbCopy > cbMax) cbCopy = cbMax;
            while (cbCopy-- > 0) {
                dbTarget.writeUInt8(this.readUInt8(offSource++), offTarget++);
            }
        }
    }

    /**
     * fill(data, off, end)
     *
     * NOTE: The Node Buffer class doesn't support fill() with a simple Array of bytes (aka octets), which seems a bit odd,
     * since Buffer class methods, such as from(), DO support such arrays.  Since our modules will always be using DataBuffer,
     * I'm going to take the liberty of adding that support.
     *
     * @this {DataBuffer}
     * @param {Array|number} data
     * @param {number} [off]
     * @param {number} [end]
     */
    fill(data, off = 0, end = this.length)
    {
        if (this.node && typeof data == "number") {
            this.buffer.fill(data, off, end);
        } else {
            let i = 0;
            if (end > this.length) end = this.length;
            for (let o = off; o < end; o++) {
                this.writeUInt8(typeof data == "number"? data : data[i++], o);
            }
        }
    }

    /**
     * new(size)
     *
     * @this {DataBuffer}
     * @param {number} size
     */
    new(size)
    {
        if (this.node && Buffer.alloc) {        // TODO: Determine why the Closure Compiler requires checking for 'alloc'
            this.buffer = Buffer.alloc(size);
            this.length = size;
        } else {
            this.ab = new ArrayBuffer(size);
            this.length = this.ab.byteLength;
            this.dv = new DataView(this.ab, 0, this.length);
        }
    }

    /**
     * slice(start, end)
     *
     * @this {DataBuffer}
     * @param {number} [start]
     * @param {number} [end]
     * @returns {DataBuffer}
     */
    slice(start, end)
    {
        return new DataBuffer(this, start || 0, end);
    }

    /**
     * write(s, off, len)
     *
     * @this {DataBuffer}
     * @param {string} s
     * @param {number} off
     * @param {number} len
     */
    write(s, off, len)
    {
        if (this.node) {
            this.buffer.write(s, off, len);
        } else {
            let i = 0;
            while (off < this.length) {
                this.dv.setUint8(off, s.charCodeAt(i++));
                off++;
            }
        }
    }

    /**
     * readUInt8(off)
     *
     * @this {DataBuffer}
     * @param {number} off
     * @returns {number}
     */
    readUInt8(off)
    {
        return this.node? this.buffer.readUInt8(off) : this.dv.getUint8(off);
    }

    /**
     * writeUInt8(b, off)
     *
     * @this {DataBuffer}
     * @param {number} b
     * @param {number} off
     */
    writeUInt8(b, off)
    {
        if (this.node) this.buffer.writeUInt8(b, off); else this.dv.setUint8(off, b);
    }

    /**
     * readUInt16BE(off)
     *
     * @this {DataBuffer}
     * @param {number} off
     * @returns {number}
     */
    readUInt16BE(off)
    {
        return this.node? this.buffer.readUInt16BE(off) : this.dv.getUint16(off);
    }

    /**
     * readUInt16LE(off)
     *
     * @this {DataBuffer}
     * @param {number} off
     * @returns {number}
     */
    readUInt16LE(off)
    {
        return this.node? this.buffer.readUInt16LE(off) : this.dv.getUint16(off, true);
    }

    /**
     * writeUInt16LE(w, off)
     *
     * @this {DataBuffer}
     * @param {number} w
     * @param {number} off
     */
    writeUInt16LE(w, off)
    {
        if (this.node) this.buffer.writeUInt16LE(w, off); else this.dv.setUint16(off, w, true);
    }

    /**
     * readInt16BE(off)
     *
     * @this {DataBuffer}
     * @param {number} off
     * @returns {number}
     */
    readInt16BE(off)
    {
        return this.node? this.buffer.readInt16BE(off) : this.dv.getInt16(off);
    }

    /**
     * readInt16LE(off)
     *
     * @this {DataBuffer}
     * @param {number} off
     * @returns {number}
     */
    readInt16LE(off)
    {
        return this.node? this.buffer.readInt16LE(off) : this.dv.getInt16(off, true);
    }

    /**
     * readUInt32BE(off)
     *
     * @this {DataBuffer}
     * @param {number} off
     * @returns {number}
     */
    readUInt32BE(off)
    {
        return this.node? this.buffer.readUInt32BE(off) : this.dv.getUint32(off);
    }

    /**
     * readUInt32LE(off)
     *
     * @this {DataBuffer}
     * @param {number} off
     * @returns {number}
     */
    readUInt32LE(off)
    {
        return this.node? this.buffer.readUInt32LE(off): this.dv.getUint32(off, true);
    }

    /**
     * readInt32BE(off)
     *
     * @this {DataBuffer}
     * @param {number} off
     * @returns {number}
     */
    readInt32BE(off)
    {
        return this.node? this.buffer.readInt32BE(off) : this.dv.getInt32(off);
    }

    /**
     * readInt32LE(off)
     *
     * @this {DataBuffer}
     * @param {number} off
     * @returns {number}
     */
    readInt32LE(off)
    {
        return this.node? this.buffer.readInt32LE(off) : this.dv.getInt32(off, true);
    }

    /**
     * writeInt32LE(dw, off)
     *
     * @this {DataBuffer}
     * @param {number} dw
     * @param {number} off
     */
    writeInt32LE(dw, off)
    {
        if (this.node) this.buffer.writeInt32LE(dw, off); else this.dv.setInt32(off, dw, true);
    }

    /**
     * toString(format, start, end)
     *
     * @this {DataBuffer}
     * @param {string} [format]
     * @param {number} [start]
     * @param {number} [end]
     * @returns {string}
     */
    toString(format, start = 0, end = this.length)
    {
        let s = "";
        if (this.node) {
            s = this.buffer.toString(format, start, end);
        } else {
            let a = new Uint8Array(this.ab, start, end - start);
            if (format && "TextDecoder" in window) {
                let dec = new TextDecoder(format);
                s = dec.decode(a);
            } else {
                // s = String.fromCharCode(...a) fails for large arrays...
                for (let i = 0; i < a.length; i++) s += String.fromCharCode(a[i]);
            }
        }
        return s;
    }
}

/**
 * @copyright https://www.pcjs.org/machines/modules/v2/diskapi.js (C) 2012-2024 Jeff Parsons
 */

/*
 * Our "DiskIO API" looks like:
 *
 *      http://www.pcjs.org/api/v1/disk?action=open&volume=*10mb.img&mode=demandrw&chs=c:h:s&machine=xxx&user=yyy
 */
const DiskAPI = {
    ENDPOINT:       "/api/v1/disk",
    QUERY: {
        ACTION:     "action",   // value is one of DiskAPI.ACTION.*
        VOLUME:     "volume",   // value is path of a disk image
        MODE:       "mode",     // value is one of DiskAPI.MODE.*
        CHS:        "chs",      // value is cylinders:heads:sectors:bytes
        ADDR:       "addr",     // value is cylinder:head:sector:count
        MACHINE:    "machine",  // value is machine token
        USER:       "user",     // value is user ID
        DATA:       "data"      // value is data to be written
    },
    ACTION: {
        OPEN:       "open",
        READ:       "read",
        WRITE:      "write",
        CLOSE:      "close"
    },
    MODE: {
        LOCAL:      "local",    // this mode implies no API (at best, localStorage backing only)
        PRELOAD:    "preload",  // this mode implies use of the DumpAPI
        DEMANDRW:   "demandrw",
        DEMANDRO:   "demandro"
    },
    FAIL: {
        BADACTION:  "invalid action",
        BADUSER:    "invalid user",
        BADVOL:     "invalid volume",
        OPENVOL:    "unable to open volume",
        CREATEVOL:  "unable to create volume",
        WRITEVOL:   "unable to write volume",
        REVOKED:    "access revoked"
    }
};

/*
 * TODO: Eventually, our tools will need to support looking up disk formats by "model" rather than by raw disk size,
 * because obviously multiple disk geometries can yield the same raw disk size.  For each conflict that arises, I'll
 * probably create a fake (approximate) disk size entry above, and then create a mapping to that approximate size below.
 */
DiskAPI.MODELS = {
    "RL01": 5242880,
    "RL02": 10485760
};

DiskAPI.MBR = {
    PARTITIONS: {
        OFFSET:     0x1BE,
        ENTRY: {
            STATUS:         0x00,   // 1-byte (0x80 if active)
            CHS_FIRST:      0x01,   // 3-byte CHS specifier
            TYPE:           0x04,   // 1-byte TYPE (see below)
            CHS_LAST:       0x05,   // 3-byte CHS specifier
            LBA_FIRST:      0x08,   // 4-byte Logical Block Address
            LBA_TOTAL:      0x0C,   // 4-byte Logical Block Address
        },
        ENTRY_LENGTH:       0x10,
        STATUS: {
            ACTIVE:         0x80
        },
        TYPE: {
            EMPTY:          0x00,
            FAT12_PRIMARY:  0x01,   // DOS 2.0 and up (12-bit FAT)
            FAT16_PRIMARY:  0x04    // DOS 3.0 and up (16-bit FAT)
        }
    },
    SIG_OFFSET:     0x1FE,
    SIGNATURE:      0xAA55          // to be clear, the low byte (at offset 0x1FE) is 0x55 and the high byte (at offset 0x1FF) is 0xAA
};

/*
 * Boot sector offsets (and assorted constants) in DOS-compatible boot sectors (DOS 2.0 and up)
 *
 * WARNING: I've heard apocryphal stories about SIGNATURE being improperly reversed on some systems
 * (ie, 0x55AA instead 0xAA55) -- perhaps by a dyslexic programmer -- so be careful out there.
 */
DiskAPI.BOOT = {
    OPCODE:         0x000,      // 1 byte for a JMP opcode, followed by a 1 or 2-byte offset
    OEM:            0x003,      // 8 bytes
    SIG_OFFSET:     0x1FE,
    SIGNATURE:      0xAA55      // to be clear, the low byte (at offset 0x1FE) is 0x55 and the high byte (at offset 0x1FF) is 0xAA
};

/*
 * BIOS Parameter Block (BPB) offsets in DOS-compatible boot sectors (DOS 2.x and up)
 *
 * NOTE: DOS 2.x OEM documentation says that the words starting at offset 0x018 (TRACKSECS, DRIVEHEADS, and HIDDENSECS)
 * are optional, but even the DOS 2.0 FORMAT utility initializes all three of those words.  There may be some OEM media out
 * there with BPBs that are only valid up to offset 0x018, but I've not run across any media like that.
 *
 * DOS 3.20 added LARGESECS, but unfortunately, it was added as a 2-byte value at offset 0x01E.  DOS 3.31 decided
 * to make both HIDDENSECS and LARGESECS 4-byte values, which meant that LARGESECS had to move from 0x01E to 0x020.
 */
DiskAPI.BPB = {
    SECBYTES:       0x00B,      // 2 bytes: bytes per sector (eg, 0x200 or 512)
    CLUSSECS:       0x00D,      // 1 byte: sectors per cluster (eg, 1)
    RESSECS:        0x00E,      // 2 bytes: reserved sectors; ie, # sectors preceding the first FAT--usually just the boot sector (eg, 1)
    FATS:           0x010,      // 1 byte: FAT copies (eg, 2)
    DIRENTS:        0x011,      // 2 bytes: root directory entries (eg, 0x40 or 64) 0x40 * 0x20 = 0x800 (1 sector is 0x200 bytes, total of 4 sectors)
    DISKSECS:       0x013,      // 2 bytes: number of sectors (eg, 0x140 or 320); if zero, refer to LARGESECS
    MEDIA:          0x015,      // 1 byte: media ID (see DiskAPI.FAT.MEDIA_*); should also match the first byte of the FAT (aka FAT ID)
    FATSECS:        0x016,      // 2 bytes: sectors per FAT (eg, 1)
    TRACKSECS:      0x018,      // 2 bytes: sectors per track (eg, 8)
    DRIVEHEADS:     0x01A,      // 2 bytes: number of heads (eg, 1)
    HIDDENSECS:     0x01C,      // 2 bytes (DOS 2.x) or 4 bytes (DOS 3.31 and up): number of hidden sectors (always 0 for non-partitioned media)
    LARGESECS:      0x020       // 4 bytes (DOS 3.31 and up): number of sectors if DISKSECS is zero
};

/*
 * Common (supported) diskette geometries.
 *
 * Each entry in GEOMETRIES is an array of values in "CHS" order:
 *
 *      [# cylinders, # heads, # sectors/track, # bytes/sector, media ID]
 *
 * If the 4th value is omitted, the sector size is assumed to be 512.  The order of these "geometric" values mirrors
 * the structure of our JSON-encoded disk images, which consist of an array of cylinders, each of which is an array of
 * heads, each of which is an array of sector objects.
 *
 * NOTES
 *
 *      1720320 is used by Microsoft "DMF" diskettes (eg, OEM signature "MSDMF3.2"); see Windows 95.
 *
 *      1884160 is used by IBM "XDF" diskettes (eg, OEM signature "IBM 20.0") which effectively have 23 512-byte
 *      sectors per track, but whose tracks (beyond track 0) are actually formatted with one 8Kb sector, one 2Kb sector,
 *      one 1Kb sector, and one 512-byte sector; see PC DOS 7.0.  Unsure why IBM chose media ID 0xF9.
 */
DiskAPI.GEOMETRIES = {
    163840:  [40,1,8,,0xFE],    // media ID 0xFE: 40 cylinders, 1 head (single-sided),   8 sectors/track, ( 320 total sectors x 512 bytes/sector ==  163840)
    184320:  [40,1,9,,0xFC],    // media ID 0xFC: 40 cylinders, 1 head (single-sided),   9 sectors/track, ( 360 total sectors x 512 bytes/sector ==  184320)
    327680:  [40,2,8,,0xFF],    // media ID 0xFF: 40 cylinders, 2 heads (double-sided),  8 sectors/track, ( 640 total sectors x 512 bytes/sector ==  327680)
    368640:  [40,2,9,,0xFD],    // media ID 0xFD: 40 cylinders, 2 heads (double-sided),  9 sectors/track, ( 720 total sectors x 512 bytes/sector ==  368640)
    737280:  [80,2,9,,0xF9],    // media ID 0xF9: 80 cylinders, 2 heads (double-sided),  9 sectors/track, (1440 total sectors x 512 bytes/sector ==  737280)
    1228800: [80,2,15,,0xF9],   // media ID 0xF9: 80 cylinders, 2 heads (double-sided), 15 sectors/track, (2400 total sectors x 512 bytes/sector == 1228800)
    1474560: [80,2,18,,0xF0],   // media ID 0xF0: 80 cylinders, 2 heads (double-sided), 18 sectors/track, (2880 total sectors x 512 bytes/sector == 1474560)
    1720320: [80,2,21,,0xF0],   // media ID 0xF0: 80 cylinders, 2 heads (double-sided), 21 sectors/track, (3360 total sectors x 512 bytes/sector == 1720320)
    1884160: [80,2,23,,0xF9],   // media ID 0xF9: 80 cylinders, 2 heads (double-sided), 23 sectors/track, (3680 total sectors x 512 bytes/sector == 1884160)
    2949120: [80,2,36,,0xF0],   // media ID 0xF0: 80 cylinders, 2 heads (double-sided), 36 sectors/track, (5760 total sectors x 512 bytes/sector == 2949120)
    /*
     * The following are some common disk sizes and their CHS values, since missing or bogus MBR and/or BPB values
     * might mislead us when attempting to determine the exact disk geometry.
     */
    10653696:[306,4,17],        // PC XT 10Mb hard drive (type 3)
    21411840:[615,4,17],        // PC AT 20Mb hard drive (type 2)
    /*
     * Assorted DEC disk formats.
     */
    256256:  [77, 1,26,128],    // RX01 single-platter diskette: 77 tracks, 1 head, 26 sectors/track, 128 bytes/sector, for a total of 256256 bytes
    2494464: [203,2,12,512],    // RK03 single-platter disk cartridge: 203 tracks, 2 heads, 12 sectors/track, 512 bytes/sector, for a total of 2494464 bytes
    5242880: [256,2,40,256],    // RL01K single-platter disk cartridge: 256 tracks, 2 heads, 40 sectors/track, 256 bytes/sector, for a total of 5242880 bytes
    10485760:[512,2,40,256]     // RL02K single-platter disk cartridge: 512 tracks, 2 heads, 40 sectors/track, 256 bytes/sector, for a total of 10485760 bytes
};

/*
 * Media ID (descriptor) bytes for DOS-compatible FAT-formatted disks (stored in the first byte of the FAT)
 */
DiskAPI.FAT = {
    MEDIA_160KB:    0xFE,       // 5.25-inch, 1-sided,  8-sector, 40-track
    MEDIA_180KB:    0xFC,       // 5.25-inch, 1-sided,  9-sector, 40-track
    MEDIA_320KB:    0xFF,       // 5.25-inch, 2-sided,  8-sector, 40-track
    MEDIA_360KB:    0xFD,       // 5.25-inch, 2-sided,  9-sector, 40-track
    MEDIA_720KB:    0xF9,       //  3.5-inch, 2-sided,  9-sector, 80-track
    MEDIA_1200KB:   0xF9,       //  3.5-inch, 2-sided, 15-sector, 80-track
    MEDIA_FIXED:    0xF8,       // fixed disk (aka hard drive)
    MEDIA_1440KB:   0xF0,       //  3.5-inch, 2-sided, 18-sector, 80-track
    MEDIA_2880KB:   0xF0        //  3.5-inch, 2-sided, 36-sector, 80-track
};

/*
 * Cluster constants for 12-bit FATs (CLUSNUM_FREE, CLUSNUM_RES and CLUSNUM_MIN are the same for all FATs)
 */
DiskAPI.FAT12 = {
    MAX_CLUSTERS:   4084,
    CLUSNUM_FREE:   0,          // this should NEVER appear in cluster chain (except at the start of an empty chain)
    CLUSNUM_RES:    1,          // reserved; this should NEVER appear in cluster chain
    CLUSNUM_MIN:    2,          // smallest valid cluster number
    CLUSNUM_MAX:    0xFF6,      // largest valid cluster number
    CLUSNUM_BAD:    0xFF7,      // bad cluster; this should NEVER appear in cluster chain
    CLUSNUM_EOC:    0xFF8       // end of chain (actually, anything from 0xFF8-0xFFF indicates EOC)
};

/*
 * Cluster constants for 16-bit FATs (CLUSNUM_FREE, CLUSNUM_RES and CLUSNUM_MIN are the same for all FATs)
 */
DiskAPI.FAT16 = {
    MAX_CLUSTERS:   65524,
    CLUSNUM_FREE:   0,          // this should NEVER appear in cluster chain (except at the start of an empty chain)
    CLUSNUM_RES:    1,          // reserved; this should NEVER appear in cluster chain
    CLUSNUM_MIN:    2,          // smallest valid cluster number
    CLUSNUM_MAX:    0xFFF6,     // largest valid cluster number
    CLUSNUM_BAD:    0xFFF7,     // bad cluster; this should NEVER appear in cluster chain
    CLUSNUM_EOC:    0xFFF8      // end of chain (actually, anything from 0xFFF8-0xFFFF indicates EOC)
};

/*
 * Directory Entry offsets (and assorted constants) in FAT disk images
 *
 * NOTE: Versions of DOS prior to 2.0 used INVALID exclusively to mark available directory entries; any entry marked
 * UNUSED was actually considered USED.  In DOS 2.0 and up, UNUSED was added to indicate that all remaining entries were
 * unused, relieving it from having to initialize the rest of the sectors in the directory cluster(s).  And in fact,
 * you will likely encounter garbage in subsequent directory sectors if you read beyond the first UNUSED entry.
 *
 * For more details on MODTIME and MODDATE, see diskdump.js; in particular, buildDateTime() and getDSTAdjustedTime().
 */
DiskAPI.DIRENT = {
    NAME:           0x000,      // 8 bytes
    EXT:            0x008,      // 3 bytes
    ATTR:           0x00B,      // 1 byte
    MODTIME:        0x016,      // 2 bytes: bits 15-11 is hour (0-31), bits 10-5 is minute (0-63), bits 4-0 is second/2 (0-31)
    MODDATE:        0x018,      // 2 bytes: bits 15-9 is year (0 for 1980, 127 for 2107), bits 8-5 is month (1-12), bits 4-0 is day (1-31)
    CLUSTER:        0x01A,      // 2 bytes
    SIZE:           0x01C,      // 4 bytes (typically zero for subdirectories)
    LENGTH:         0x20,       // 32 bytes total
    UNUSED:         0x00,       // indicates this and all subsequent directory entries are unused
    INVALID:        0xE5        // indicates this directory entry is unused
};

/*
 * Possible values for DIRENT.ATTR
 */
DiskAPI.ATTR = {
    READONLY:       0x01,       // PC-DOS 2.0 and up
    HIDDEN:         0x02,
    SYSTEM:         0x04,
    LABEL:          0x08,       // PC-DOS 2.0 and up
    SUBDIR:         0x10,       // PC-DOS 2.0 and up
    ARCHIVE:        0x20        // PC-DOS 2.0 and up
};


/**
 * @copyright https://www.pcjs.org/machines/modules/v2/dumpapi.js (C) 2012-2024 Jeff Parsons
 */

/*
 * Our "DiskDump API", such as it was, used to look like:
 *
 *      http://pcjs.org/bin/convdisk.php?disk=/disks/pc/dos/ibm/2.00/PCDOS200-DISK1.json&format=img
 *
 * To make it (a bit) more "REST-like", the above request now looks like:
 *
 *      https://www.pcjs.org/api/v1/dump?disk=/disks/pc/dos/ibm/2.00/PCDOS200-DISK1.json&format=img
 *
 * Similarly, our "FileDump API" used to look like:
 *
 *      http://pcjs.org/bin/convrom.php?rom=/devices/pc/rom/5150/1981-04-24/PCBIOS-REV1.rom&format=json
 *
 * and that request now looks like:
 *
 *      https://www.pcjs.org/api/v1/dump?file=/devices/pc/rom/5150/1981-04-24/PCBIOS-REV1.rom&format=json
 *
 * I don't think it makes sense to avoid "query" parameters, because blending the path of a disk image with the
 * the rest of the URL would be (a) confusing, and (b) more work to parse.
 */
const DumpAPI = {
    ENDPOINT:       "/api/v1/dump",
    QUERY: {
        DIR:        "dir",      // value is path of a directory (DiskDump only)
        DISK:       "disk",     // value is path of a disk image (DiskDump only)
        FILE:       "file",     // value is path of a ROM image file (FileDump only)
        IMG:        "img",      // alias for DISK
        PATH:       "path",     // value is path of a one or more files (DiskDump only)
        FORMAT:     "format",   // value is one of FORMAT values below
        COMMENTS:   "comments", // value is either "true" or "false"
        DECIMAL:    "decimal",  // value is either "true" to force all numbers to decimal, "false" or undefined otherwise
        MBHD:       "mbhd",     // value is hard drive size in Mb (formerly "mbsize") (DiskDump only) (DEPRECATED)
        SIZE:       "size"      // value is target disk size in Kb (supersedes "mbhd") (DiskDump only)
    },
    FORMAT: {
        JSON:       "json",     // default
        JSON_GZ:    "gz",       // gzip is currently used ONLY for compressed JSON
        DATA:       "data",     // same as "json", but built without JSON.stringify() (DiskDump only)
        HEX:        "hex",      // deprecated
        OCTAL:      "octal",    // displays data as octal words
        BYTES:      "bytes",    // displays data as hex bytes; normally used only when comments are enabled
        WORDS:      "words",    // displays data as hex words; normally used only when comments are enabled
        LONGS:      "longs",    // displays data as dwords
        IMG:        "img",      // returns the raw disk data (ie, using a Buffer object) (DiskDump only)
        ROM:        "rom"       // returns the raw file data (ie, using a Buffer object) (FileDump only)
    }
};

/*
 * Because we use an overloaded API endpoint (ie, one that's shared with the FileDump module), we must
 * also provide a list of commands which, when combined with the endpoint, define a unique request.
 */
DumpAPI.asDiskCommands = [DumpAPI.QUERY.DIR, DumpAPI.QUERY.DISK, DumpAPI.QUERY.PATH];
DumpAPI.asFileCommands = [DumpAPI.QUERY.FILE];


/**
 * @copyright https://www.pcjs.org/machines/modules/v2/reportapi.js (C) 2012-2024 Jeff Parsons
 */

const ReportAPI = {
    ENDPOINT:       "/api/v1/report",
    QUERY: {
        APP:        "app",
        VER:        "ver",
        URL:        "url",
        USER:       "user",
        TYPE:       "type",
        DATA:       "data"
    },
    TYPE: {
        BUG:        "bug"
    },
    RES: {
        OK:         "Thank you"
    }
};


/**
 * @copyright https://www.pcjs.org/machines/modules/v2/userapi.js (C) 2012-2024 Jeff Parsons
 */

/*
 * Examples of User API requests:
 *
 *      web.getHostOrigin() + UserAPI.ENDPOINT + '?' + UserAPI.QUERY.REQ + '=' + UserAPI.REQ.VERIFY + '&' + UserAPI.QUERY.USER + '=' + sUser;
 */
const UserAPI = {
    ENDPOINT:       "/api/v1/user",
    QUERY: {
        REQ:        "req",      // specifies a request
        USER:       "user",     // specifies a user ID
        STATE:      "state",    // specifies a state ID
        DATA:       "data"      // specifies state data
    },
    REQ: {
        CREATE:     "create",   // creates a user ID
        VERIFY:     "verify",   // requests verification of a user ID
        STORE:      "store",    // stores a machine state on the server
        LOAD:       "load"      // loads a machine state from the server
    },
    RES: {
        CODE:       "code",
        DATA:       "data"
    },
    CODE: {
        OK:         "ok",
        FAIL:       "error"
    },
    FAIL: {
        DUPLICATE:  "user already exists",
        VERIFY:     "unable to verify user",
        BADSTATE:   "invalid state parameter",
        NOSTATE:    "no machine state",
        BADLOAD:    "unable to load machine state",
        BADSTORE:   "unable to save machine state"
    }
};


/**
 * @copyright https://www.pcjs.org/machines/modules/v2/keys.js (C) 2012-2024 Jeff Parsons
 */

const Keys = {
    /*
     * Keys and/or key combinations that generate common ASCII codes.
     *
     * NOTE: If you're looking for a general-purpose ASCII code table, see StrLib.ASCII in strlib.js;
     * if something's missing, that's probably the more appropriate table to add it to.
     *
     * TODO: The Closure Compiler doesn't inline all references to these values, at least those with
     * quoted property names, which is why I've 'unquoted' as many of them as possible.  One solution
     * would be to add mnemonics for all of them, not just the non-printable ones (eg, SPACE instead
     * of ' ', AMP instead of '&', etc.)
     */
    ASCII: {
          BREAK:  0, CTRL_A:  1, CTRL_B:  2, CTRL_C:  3, CTRL_D:  4, CTRL_E:  5, CTRL_F:  6, CTRL_G:  7,
         CTRL_H:  8, CTRL_I:  9, CTRL_J: 10, CTRL_K: 11, CTRL_L: 12, CTRL_M: 13, CTRL_N: 14, CTRL_O: 15,
         CTRL_P: 16, CTRL_Q: 17, CTRL_R: 18, CTRL_S: 19, CTRL_T: 20, CTRL_U: 21, CTRL_V: 22, CTRL_W: 23,
         CTRL_X: 24, CTRL_Y: 25, CTRL_Z: 26, ESC:    27,
            ' ': 32,    '!': 33,    '"': 34,    '#': 35,    '$': 36,    '%': 37,    '&': 38,    "'": 39,
            '(': 40,    ')': 41,    '*': 42,    '+': 43,    ',': 44,    '-': 45,    '.': 46,    '/': 47,
            '0': 48,    '1': 49,    '2': 50,    '3': 51,    '4': 52,    '5': 53,    '6': 54,    '7': 55,
            '8': 56,    '9': 57,    ':': 58,    ';': 59,    '<': 60,    '=': 61,    '>': 62,    '?': 63,
            '@': 64,     A:  65,     B:  66,     C:  67,     D:  68,     E:  69,     F:  70,     G:  71,
             H:  72,     I:  73,     J:  74,     K:  75,     L:  76,     M:  77,     N:  78,     O:  79,
             P:  80,     Q:  81,     R:  82,     S:  83,     T:  84,     U:  85,     V:  86,     W:  87,
             X:  88,     Y:  89,     Z:  90,    '[': 91,    '\\':92,    ']': 93,    '^': 94,    '_': 95,
            '`': 96,     a:  97,     b:  98,     c:  99,     d: 100,     e: 101,     f: 102,     g: 103,
             h:  104,    i: 105,     j: 106,     k: 107,     l: 108,     m: 109,     n: 110,     o: 111,
             p:  112,    q: 113,     r: 114,     s: 115,     t: 116,     u: 117,     v: 118,     w: 119,
             x:  120,    y: 121,     z: 122,    '{':123,    '|':124,    '}':125,    '~':126,   DEL: 127
    },
    /*
     * Browser keyCodes we must pay particular attention to.  For the most part, these are non-alphanumeric
     * or function keys, some which may require special treatment (eg, preventDefault() if returning false on
     * the initial keyDown event is insufficient).
     *
     * keyCodes for most common ASCII keys can simply use the appropriate ASCII code above.
     *
     * Most of these represent non-ASCII keys (eg, the LEFT arrow key), yet for some reason, browsers defined
     * them using ASCII codes (eg, the LEFT arrow key uses the ASCII code for '%' or 37).
     */
    KEYCODE: {
        /* 0x08 */ BS:          8,          // BACKSPACE        (ASCII.CTRL_H)
        /* 0x09 */ TAB:         9,          // TAB              (ASCII.CTRL_I)
        /* 0x0A */ LF:          10,         // LINE-FEED        (ASCII.CTRL_J) (Some Windows-based browsers used to generate this via CTRL-ENTER)
        /* 0x0D */ CR:          13,         // CARRIAGE RETURN  (ASCII.CTRL_M)
        /* 0x10 */ SHIFT:       16,
        /* 0x11 */ CTRL:        17,
        /* 0x12 */ ALT:         18,
        /* 0x13 */ PAUSE:       19,         // PAUSE/BREAK
        /* 0x14 */ CAPS_LOCK:   20,
        /* 0x1B */ ESC:         27,
        /* 0x20 */ SPACE:       32,
        /* 0x21 */ PGUP:        33,
        /* 0x22 */ PGDN:        34,
        /* 0x23 */ END:         35,
        /* 0x24 */ HOME:        36,
        /* 0x25 */ LEFT:        37,
        /* 0x26 */ UP:          38,
        /* 0x27 */ RIGHT:       39,
        /* 0x27 */ FF_QUOTE:    39,
        /* 0x28 */ DOWN:        40,
        /* 0x2C */ FF_COMMA:    44,
        /* 0x2C */ PRTSC:       44,
        /* 0x2D */ INS:         45,
        /* 0x2E */ DEL:         46,
        /* 0x2E */ FF_PERIOD:   46,
        /* 0x2F */ FF_SLASH:    47,
        /* 0x30 */ ZERO:        48,
        /* 0x31 */ ONE:         49,
        /* 0x32 */ TWO:         50,
        /* 0x33 */ THREE:       51,
        /* 0x34 */ FOUR:        52,
        /* 0x35 */ FIVE:        53,
        /* 0x36 */ SIX:         54,
        /* 0x37 */ SEVEN:       55,
        /* 0x38 */ EIGHT:       56,
        /* 0x39 */ NINE:        57,
        /* 0x3B */ FF_SEMI:     59,
        /* 0x3D */ FF_EQUALS:   61,
        /* 0x5B */ CMD:         91,         // aka WIN
        /* 0x5B */ FF_LBRACK:   91,
        /* 0x5C */ FF_BSLASH:   92,
        /* 0x5D */ RCMD:        93,         // aka MENU
        /* 0x5D */ FF_RBRACK:   93,
        /* 0x60 */ NUM_0:       96,
        /* 0x60 */ NUM_INS:     96,
        /* 0x60 */ FF_BQUOTE:   96,
        /* 0x61 */ NUM_1:       97,
        /* 0x61 */ NUM_END:     97,
        /* 0x62 */ NUM_2:       98,
        /* 0x62 */ NUM_DOWN:    98,
        /* 0x63 */ NUM_3:       99,
        /* 0x63 */ NUM_PGDN:    99,
        /* 0x64 */ NUM_4:       100,
        /* 0x64 */ NUM_LEFT:    100,
        /* 0x65 */ NUM_5:       101,
        /* 0x65 */ NUM_CENTER:  101,
        /* 0x66 */ NUM_6:       102,
        /* 0x66 */ NUM_RIGHT:   102,
        /* 0x67 */ NUM_7:       103,
        /* 0x67 */ NUM_HOME:    103,
        /* 0x68 */ NUM_8:       104,
        /* 0x68 */ NUM_UP:      104,
        /* 0x69 */ NUM_9:       105,
        /* 0x69 */ NUM_PGUP:    105,
        /* 0x6A */ NUM_MUL:     106,
        /* 0x6B */ NUM_ADD:     107,
        /* 0x6D */ NUM_SUB:     109,
        /* 0x6E */ NUM_DEL:     110,        // aka PERIOD
        /* 0x6F */ NUM_DIV:     111,
        /* 0x70 */ F1:          112,
        /* 0x71 */ F2:          113,
        /* 0x72 */ F3:          114,
        /* 0x73 */ F4:          115,
        /* 0x74 */ F5:          116,
        /* 0x75 */ F6:          117,
        /* 0x76 */ F7:          118,
        /* 0x77 */ F8:          119,
        /* 0x78 */ F9:          120,
        /* 0x79 */ F10:         121,
        /* 0x7A */ F11:         122,
        /* 0x7B */ F12:         123,
        /* 0x90 */ NUM_LOCK:    144,
        /* 0x91 */ SCROLL_LOCK: 145,
        /* 0xAD */ FF_DASH:     173,
        /* 0xBA */ SEMI:        186,        // Firefox:  59 (FF_SEMI)
        /* 0xBB */ EQUALS:      187,        // Firefox:  61 (FF_EQUALS)
        /* 0xBC */ COMMA:       188,
        /* 0xBD */ DASH:        189,        // Firefox: 173 (FF_DASH)
        /* 0xBE */ PERIOD:      190,
        /* 0xBF */ SLASH:       191,
        /* 0xC0 */ BQUOTE:      192,
        /* 0xDB */ LBRACK:      219,
        /* 0xDC */ BSLASH:      220,
        /* 0xDD */ RBRACK:      221,
        /* 0xDE */ QUOTE:       222,
        /* 0xE0 */ FF_CMD:      224,        // Firefox only (used for both CMD and RCMD)
        //
        // The following biases use what I'll call Decimal Coded Binary or DCB (the opposite of BCD),
        // where the thousands digit is used to store the sum of "binary" digits 1 and/or 2 and/or 4.
        //
        // Technically, that makes it DCO (Decimal Coded Octal), but then again, BCD should have really
        // been called HCD (Hexadecimal Coded Decimal), so if "they" can take liberties, so can I.
        //
        // ONDOWN is a bias we add to browser keyCodes that we want to handle on "down" rather than on "press".
        //
        ONDOWN:                 1000,
        //
        // ONRIGHT is a bias we add to browser keyCodes that need to check for a "right" location (default is "left")
        //
        ONRIGHT:                2000,
        //
        // FAKE is a bias we add to signal these are fake keyCodes corresponding to internal keystroke combinations.
        // The actual values are for internal use only and merely need to be unique and used consistently.
        //
        FAKE:                   4000
    },
    /*
     * The set of values that a browser may store in the 'location' property of a keyboard event object
     * which we also support.
     */
    LOCATION: {
        LEFT:                   1,
        RIGHT:                  2,
        NUMPAD:                 3
    }
};

/*
 * Table to map new browser keyboard event "code" property values to their old KEYCODE values.
 */
Keys.CODEKEY = {
    "Comma":            Keys.KEYCODE.COMMA,
    "Period":           Keys.KEYCODE.PERIOD,
    "Semicolon":        Keys.KEYCODE.SEMI,
    "Quote":            Keys.KEYCODE.QUOTE,
    "BracketLeft":      Keys.KEYCODE.LBRACK,
    "BracketRight":     Keys.KEYCODE.RBRACK,
    "Backquote":        Keys.KEYCODE.BQUOTE,
    "Backslash":        Keys.KEYCODE.BSLASH,
    "Minus":            Keys.KEYCODE.DASH,
    "Equal":            Keys.KEYCODE.EQUALS,
    "AltLeft":          Keys.KEYCODE.ALT,
    "AltRight":         Keys.KEYCODE.ALT,
    "CapsLock":         Keys.KEYCODE.CAPS_LOCK,
    "ControlLeft":      Keys.KEYCODE.CTRL,
    "ControlRight":     Keys.KEYCODE.CTRL,
    "OSLeft":           Keys.KEYCODE.CMD,
    "OSRight":          Keys.KEYCODE.RCMD,
    "ShiftLeft":        Keys.KEYCODE.SHIFT,
    "ShiftRight":       Keys.KEYCODE.SHIFT,
    "Enter":            Keys.KEYCODE.CR,
    "Space":            Keys.KEYCODE.SPACE,
    "Tab":              Keys.KEYCODE.TAB,
    "Delete":           Keys.KEYCODE.DEL,
    "End":              Keys.KEYCODE.END,
    "Home":             Keys.KEYCODE.HOME,
    "Insert":           Keys.KEYCODE.INS,
    "PageDown":         Keys.KEYCODE.PGDN,
    "PageUp":           Keys.KEYCODE.PGUP,
    "ArrowDown":        Keys.KEYCODE.DOWN,
    "ArrowLeft":        Keys.KEYCODE.LEFT,
    "ArrowRight":       Keys.KEYCODE.RIGHT,
    "ArrowUp":          Keys.KEYCODE.UP,
    "Escape":           Keys.KEYCODE.ESC,
    "PrintScreen":      Keys.KEYCODE.PRTSC,
    "ScrollLock":       Keys.KEYCODE.SCROLL_LOCK,
    "Pause":            Keys.KEYCODE.PAUSE,
    "F1":               Keys.KEYCODE.F1,
    "F2":               Keys.KEYCODE.F2,
    "F3":               Keys.KEYCODE.F3,
    "F4":               Keys.KEYCODE.F4,
    "F5":               Keys.KEYCODE.F5,
    "F6":               Keys.KEYCODE.F6,
    "F7":               Keys.KEYCODE.F7,
    "F8":               Keys.KEYCODE.F8,
    "F9":               Keys.KEYCODE.F9,
    "F10":              Keys.KEYCODE.F10,
    "F11":              Keys.KEYCODE.F11,
    "F12":              Keys.KEYCODE.F12,
    "NumLock":          Keys.KEYCODE.NUM_LOCK,
    "Numpad0":          Keys.KEYCODE.NUM_0,
    "Numpad1":          Keys.KEYCODE.NUM_1,
    "Numpad2":          Keys.KEYCODE.NUM_2,
    "Numpad3":          Keys.KEYCODE.NUM_3,
    "Numpad4":          Keys.KEYCODE.NUM_4,
    "Numpad5":          Keys.KEYCODE.NUM_5,
    "Numpad6":          Keys.KEYCODE.NUM_6,
    "Numpad7":          Keys.KEYCODE.NUM_7,
    "Numpad8":          Keys.KEYCODE.NUM_8,
    "Numpad9":          Keys.KEYCODE.NUM_9,
    "NumpadAdd":        Keys.KEYCODE.NUM_ADD,
    "NumpadSubtract":   Keys.KEYCODE.NUM_SUB,
    "NumpadMultiply":   Keys.KEYCODE.NUM_MUL,
    "NumpadDivide":     Keys.KEYCODE.NUM_DIV,
    "NumpadDecimal":    Keys.KEYCODE.NUM_DEL,
    "NumpadEnter":      Keys.KEYCODE.NUM_CR
};

/*
 * Check the event object's 'location' property for a non-zero value for the following ONRIGHT keys.
 */
Keys.KEYCODE.NUM_CR = Keys.KEYCODE.CR + Keys.KEYCODE.ONRIGHT;


/*
 * Maps Firefox keyCodes to their more common keyCode counterparts; a number of entries in this table
 * are no longer valid (if indeed they ever were), so they've been commented out.  It's likely that I
 * simply extended this table to resolve additional differences in other browsers (ie, Opera), but without
 * browser-specific checks, it's not safe to perform all the mappings shown below.
 */
Keys.FF_KEYCODES = {};
Keys.FF_KEYCODES[Keys.KEYCODE.FF_SEMI]   = Keys.KEYCODE.SEMI;           //  59 -> 186
Keys.FF_KEYCODES[Keys.KEYCODE.FF_EQUALS] = Keys.KEYCODE.EQUALS;         //  61 -> 187
Keys.FF_KEYCODES[Keys.KEYCODE.FF_DASH]   = Keys.KEYCODE.DASH;           // 173 -> 189
Keys.FF_KEYCODES[Keys.KEYCODE.FF_CMD]    = Keys.KEYCODE.CMD;            // 224 -> 91
// Keys.FF_KEYCODES[Keys.KEYCODE.FF_COMMA]  = Keys.KEYCODE.COMMA;       //  44 -> 188
// Keys.FF_KEYCODES[Keys.KEYCODE.FF_PERIOD] = Keys.KEYCODE.PERIOD;      //  46 -> 190
// Keys.FF_KEYCODES[Keys.KEYCODE.FF_SLASH]  = Keys.KEYCODE.SLASH;       //  47 -> 191
// Keys.FF_KEYCODES[Keys.KEYCODE.FF_BQUOTE] = Keys.KEYCODE.BQUOTE;      //  96 -> 192
// Keys.FF_KEYCODES[Keys.KEYCODE.FF_LBRACK  = Keys.KEYCODE.LBRACK;      //  91 -> 219
// Keys.FF_KEYCODES[Keys.KEYCODE.FF_BSLASH] = Keys.KEYCODE.BSLASH;      //  92 -> 220
// Keys.FF_KEYCODES[Keys.KEYCODE.FF_RBRACK] = Keys.KEYCODE.RBRACK;      //  93 -> 221
// Keys.FF_KEYCODES[Keys.KEYCODE.FF_QUOTE]  = Keys.KEYCODE.QUOTE;       //  39 -> 222

/*
 * Maps non-ASCII keyCodes to their ASCII counterparts
 */
Keys.NONASCII_KEYCODES = {};
Keys.NONASCII_KEYCODES[Keys.KEYCODE.FF_DASH] = Keys.ASCII['-'];         // 173 -> 45
Keys.NONASCII_KEYCODES[Keys.KEYCODE.SEMI]    = Keys.ASCII[';'];         // 186 -> 59
Keys.NONASCII_KEYCODES[Keys.KEYCODE.EQUALS]  = Keys.ASCII['='];         // 187 -> 61
Keys.NONASCII_KEYCODES[Keys.KEYCODE.DASH]    = Keys.ASCII['-'];         // 189 -> 45
Keys.NONASCII_KEYCODES[Keys.KEYCODE.COMMA]   = Keys.ASCII[','];         // 188 -> 44
Keys.NONASCII_KEYCODES[Keys.KEYCODE.PERIOD]  = Keys.ASCII['.'];         // 190 -> 46
Keys.NONASCII_KEYCODES[Keys.KEYCODE.SLASH]   = Keys.ASCII['/'];         // 191 -> 47
Keys.NONASCII_KEYCODES[Keys.KEYCODE.BQUOTE]  = Keys.ASCII['`'];         // 192 -> 96
Keys.NONASCII_KEYCODES[Keys.KEYCODE.LBRACK]  = Keys.ASCII['['];         // 219 -> 91
Keys.NONASCII_KEYCODES[Keys.KEYCODE.BSLASH]  = Keys.ASCII['\\'];        // 220 -> 92
Keys.NONASCII_KEYCODES[Keys.KEYCODE.RBRACK]  = Keys.ASCII[']'];         // 221 -> 93
Keys.NONASCII_KEYCODES[Keys.KEYCODE.QUOTE]   = Keys.ASCII["'"];         // 222 -> 39

/*
 * Maps unshifted keyCodes to their shifted counterparts; to be used when a shift-key is down.
 * Alphabetic characters are handled in code, since they must also take CAPS_LOCK into consideration.
 */
Keys.SHIFTED_KEYCODES = {};
Keys.SHIFTED_KEYCODES[Keys.ASCII['1']]     = Keys.ASCII['!'];
Keys.SHIFTED_KEYCODES[Keys.ASCII['2']]     = Keys.ASCII['@'];
Keys.SHIFTED_KEYCODES[Keys.ASCII['3']]     = Keys.ASCII['#'];
Keys.SHIFTED_KEYCODES[Keys.ASCII['4']]     = Keys.ASCII['$'];
Keys.SHIFTED_KEYCODES[Keys.ASCII['5']]     = Keys.ASCII['%'];
Keys.SHIFTED_KEYCODES[Keys.ASCII['6']]     = Keys.ASCII['^'];
Keys.SHIFTED_KEYCODES[Keys.ASCII['7']]     = Keys.ASCII['&'];
Keys.SHIFTED_KEYCODES[Keys.ASCII['8']]     = Keys.ASCII['*'];
Keys.SHIFTED_KEYCODES[Keys.ASCII['9']]     = Keys.ASCII['('];
Keys.SHIFTED_KEYCODES[Keys.ASCII['0']]     = Keys.ASCII[')'];
Keys.SHIFTED_KEYCODES[Keys.KEYCODE.SEMI]   = Keys.ASCII[':'];
Keys.SHIFTED_KEYCODES[Keys.KEYCODE.EQUALS] = Keys.ASCII['+'];
Keys.SHIFTED_KEYCODES[Keys.KEYCODE.COMMA]  = Keys.ASCII['<'];
Keys.SHIFTED_KEYCODES[Keys.KEYCODE.DASH]   = Keys.ASCII['_'];
Keys.SHIFTED_KEYCODES[Keys.KEYCODE.PERIOD] = Keys.ASCII['>'];
Keys.SHIFTED_KEYCODES[Keys.KEYCODE.SLASH]  = Keys.ASCII['?'];
Keys.SHIFTED_KEYCODES[Keys.KEYCODE.BQUOTE] = Keys.ASCII['~'];
Keys.SHIFTED_KEYCODES[Keys.KEYCODE.LBRACK] = Keys.ASCII['{'];
Keys.SHIFTED_KEYCODES[Keys.KEYCODE.BSLASH] = Keys.ASCII['|'];
Keys.SHIFTED_KEYCODES[Keys.KEYCODE.RBRACK] = Keys.ASCII['}'];
Keys.SHIFTED_KEYCODES[Keys.KEYCODE.QUOTE]  = Keys.ASCII['"'];
Keys.SHIFTED_KEYCODES[Keys.KEYCODE.FF_DASH]   = Keys.ASCII['_'];
Keys.SHIFTED_KEYCODES[Keys.KEYCODE.FF_EQUALS] = Keys.ASCII['+'];
Keys.SHIFTED_KEYCODES[Keys.KEYCODE.FF_SEMI]   = Keys.ASCII[':'];


/**
 * @copyright https://www.pcjs.org/machines/modules/v2/pcfs.js (C) 2012-2024 Jeff Parsons
 */

/** @typedef {{ name: string, size: number, attr: number, date: Date, data: *, files: (Array|null) }} */
let PCFSItem;

/**
 * @class PCFS
 */
class PCFS {

    static root = "/pcfs";

    static ATTR = {                 // copied from /machines/pcx86/modules/v3/diskinfo.js (DiskInfo.ATTR.*)
        READONLY:       0x01,       // PC DOS 2.0 and up
        HIDDEN:         0x02,
        SYSTEM:         0x04,
        VOLUME:         0x08,       // PC DOS 2.0 and up
        LFN:            0x0f,       // combination used by Windows 95 (MS-DOS 7.0) and up, indicating a long filename (LFN) DIRENT
        SUBDIR:         0x10,       // PC DOS 2.0 and up
        ARCHIVE:        0x20,       // PC DOS 2.0 and up
    };

    /**
     * isPCFS(path)
     *
     * @param {string} path
     * @returns {boolean}
     */
    static isPCFS(path)
    {
        return path.indexOf(PCFS.root) == 0;
    }

    /**
     * getRoot(path)
     *
     * @param {string} path
     * @returns {Array|null}
     */
    static getRoot(path)
    {
        return PCFS.isPCFS(path)? globals.pcjs['files'] : null;
    }

    /**
     * getNodes(path)
     *
     * @param {string} path
     * @returns {Array}
     */
    static getNodes(path)
    {
        return path.slice(PCFS.root.length+1).split('/');
    }

    /**
     * getItem(path, fCreate, fDirectory)
     *
     * @param {string} path
     * @param {boolean} [fCreate] (true to create, false to remove)
     * @param {boolean} [fDirectory]
     * @returns {PCFSItem|null}
     */
    static getItem(path, fCreate, fDirectory)
    {
        let item = null;
        let dir = PCFS.getRoot(path);
        if (dir) {
            let nodes = PCFS.getNodes(path);
            let i, j;
            for (i = 0; i < nodes.length; i++) {
                let name = nodes[i], match = false;
                if (!name) {
                    item = dir;
                    break;
                }
                for (j = 0; j < dir.files.length; j++) {
                    let next = dir.files[j];
                    if (next.name.toLowerCase() == name.toLowerCase()) {
                        if (i == nodes.length - 1) {
                            item = next;
                            break;
                        }
                        if (next.files) {
                            dir = next;
                            match = true;
                            break;
                        }
                    }
                }
                if (item) break;
                if (match) continue;
                if (i < nodes.length-1) {
                    if (fCreate) {
                        let sub = {name, size: 0, attr: PCFS.ATTR.SUBDIR, date: new Date(), files: []};
                        dir.files.push(sub);
                        dir = sub;
                        continue;
                    }
                    break;
                }
            }
            if (!item && i == nodes.length) {
                if (fCreate) {
                    let attr = fDirectory? PCFS.ATTR.SUBDIR : PCFS.ATTR.ARCHIVE;
                    item = dir.files[dir.files.length] = {name: nodes[nodes.length-1], size: 0, attr: attr, date: new Date(), files: fDirectory? [] : null};
                } else if (fCreate === false) {
                    dir.files.splice(j, 1);
                }
            }
        }
        return item;
    }

    /**
     * setItem(item, data, date, attr)
     *
     * @param {PCFSItem} item
     * @param {*} [data]
     * @param {Date} [date]
     * @param {number} [attr]
     */
    static setItem(item, data, date, attr)
    {
        if (!item.files && data) {
            item.data = data;
            item.size = data.length;
            if (!date) date = new Date();
        }
        if (date) {
            item.date = date;
        }
        if (attr !== undefined) {
            item.attr = attr;
        }
    }
}

if (!globals.pcjs['files']) {
    globals.pcjs['files'] = { name: "", size: 0, attr: PCFS.ATTR.SUBDIR, date: new Date(), files: [] };
}

/**
 * @copyright https://www.pcjs.org/machines/modules/v2/strlib.js (C) 2012-2024 Jeff Parsons
 */

/**
 * @class StrLib
 * @unrestricted
 */
class StrLib {
    /*
     * Map special characters to their HTML escape sequences.
     */
    static HTMLEscapeMap = {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&apos;',
        '$': '&dollar;'
    };

    /*
     * Map "unprintable" ASCII codes to mnemonics, to more clearly see what's being printed.
     */
    static ASCIICodeMap = {
        0x00:   "NUL",
        0x01:   "SOH",      // (CTRL_A) Start of Heading
        0x02:   "STX",      // (CTRL_B) Start of Text
        0x03:   "ETX",      // (CTRL_C) End of Text
        0x04:   "EOT",      // (CTRL_D) End of Transmission
        0x05:   "ENQ",      // (CTRL_E) Enquiry
        0x06:   "ACK",      // (CTRL_F) Acknowledge
        0x07:   "BEL",      // (CTRL_G) Bell
        0x08:   "BS",       // (CTRL_H) Backspace
        0x09:   "TAB",      // (CTRL_I) Horizontal Tab (aka HT)
        0x0A:   "LF",       // (CTRL_J) Line Feed (New Line)
        0x0B:   "VT",       // (CTRL_K) Vertical Tab
        0x0C:   "FF",       // (CTRL_L) Form Feed (New Page)
        0x0D:   "CR",       // (CTRL_M) Carriage Return
        0x0E:   "SO",       // (CTRL_N) Shift Out
        0x0F:   "SI",       // (CTRL_O) Shift In
        0x10:   "DLE",      // (CTRL_P) Data Link Escape
        0x11:   "XON",      // (CTRL_Q) Device Control 1 (aka DC1)
        0x12:   "DC2",      // (CTRL_R) Device Control 2
        0x13:   "XOFF",     // (CTRL_S) Device Control 3 (aka DC3)
        0x14:   "DC4",      // (CTRL_T) Device Control 4
        0x15:   "NAK",      // (CTRL_U) Negative Acknowledge
        0x16:   "SYN",      // (CTRL_V) Synchronous Idle
        0x17:   "ETB",      // (CTRL_W) End of Transmission Block
        0x18:   "CAN",      // (CTRL_X) Cancel
        0x19:   "EM",       // (CTRL_Y) End of Medium
        0x1A:   "SUB",      // (CTRL_Z) Substitute
        0x1B:   "ESC",      // Escape
        0x1C:   "FS",       // File Separator
        0x1D:   "GS",       // Group Separator
        0x1E:   "RS",       // Record Separator
        0x1F:   "US",       // Unit Separator
        0x7F:   "DEL"
    };

    /*
     * TODO: Future home of a complete ASCII table.
     */
    static ASCII = {
        LF:     0x0A,
        CR:     0x0D
    };

    static TYPES = {
        NULL:       0,
        BYTE:       1,
        WORD:       2,
        DWORD:      3,
        NUMBER:     4,
        STRING:     5,
        BOOLEAN:    6,
        OBJECT:     7,
        ARRAY:      8
    };

    /**
     * isValidInt(s, base)
     *
     * The built-in parseInt() function has the annoying feature of returning a partial value (ie,
     * up to the point where it encounters an invalid character); eg, parseInt("foo", 16) returns 0xf.
     *
     * So it's best to use our own StrLib.parseInt() function, which will in turn use this function to
     * validate the entire string.
     *
     * @param {string} s is the string representation of some number
     * @param {number} [base] is the radix to use (default is 10); only 2, 8, 10 and 16 are supported
     * @returns {boolean} true if valid, false if invalid (or the specified base isn't supported)
     */
    static isValidInt(s, base)
    {
        if (!base || base == 10) return s.match(/^-?[0-9]+$/) !== null;
        if (base == 16) return s.match(/^-?[0-9a-f]+$/i) !== null;
        if (base == 8) return s.match(/^-?[0-7]+$/) !== null;
        if (base == 2) return s.match(/^-?[01]+$/) !== null;
        return false;
    }

    /**
     * parseInt(s, base)
     *
     * This is a wrapper around the built-in parseInt() function.  Our wrapper recognizes certain prefixes
     * ('$' or "0x" for hex, '#' or "0o" for octal) and suffixes ('.' for decimal, 'h' for hex, 'y' for
     * binary), and then calls isValidInt() to ensure we don't convert strings that contain partial values;
     * see isValidInt() for details.
     *
     * The use of multiple prefix/suffix combinations is undefined (although for the record, we process
     * prefixes first).  We do NOT support the "0b" prefix to indicate binary UNLESS one or more commas are
     * also present (because "0b" is also a valid hex sequence), and we do NOT support a single leading zero
     * to indicate octal (because such a number could also be decimal or hex).  Any number of commas are
     * allowed; we remove them all before calling the built-in parseInt().
     *
     * More recently, we've added support for "^D", "^O", and "^B" prefixes to accommodate the base overrides
     * that the PDP-10's MACRO-10 assembly language supports (decimal, octal, and binary, respectively).
     * If this support turns out to adversely affect other debuggers, then it will have to be "conditionalized".
     * Similarly, we've added support for "K", "M", and "G" MACRO-10-style suffixes that add 3, 6, or 9 zeros
     * to the value to be parsed, respectively.
     *
     * @param {string} s is the string representation of some number
     * @param {number} [base] is the radix to use (default is 10); can be overridden by prefixes/suffixes
     * @returns {number|undefined} corresponding value, or undefined if invalid
     */
    static parseInt(s, base)
    {
        let value;

        if (s) {
            if (!base) base = 10;

            let ch, chPrefix, chSuffix;
            let fCommas = (s.indexOf(',') > 0);
            if (fCommas) s = s.replace(/,/g, '');

            ch = chPrefix = s.charAt(0);
            if (chPrefix == '#') {
                base = 8;
                chPrefix = '';
            }
            else if (chPrefix == '$') {
                base = 16;
                chPrefix = '';
            }
            if (ch != chPrefix) {
                s = s.substr(1);
            }
            else {
                ch = chPrefix = s.substr(0, 2);
                if (chPrefix == '0b' && fCommas || chPrefix == '^B') {
                    base = 2;
                    chPrefix = '';
                }
                else if (chPrefix == '0o' || chPrefix == '^O') {
                    base = 8;
                    chPrefix = '';
                }
                else if (chPrefix == '^D') {
                    base = 10;
                    chPrefix = '';
                }
                else if (chPrefix == '0x') {
                    base = 16;
                    chPrefix = '';
                }
                if (ch != chPrefix) s = s.substr(2);
            }
            ch = chSuffix = s.slice(-1);
            if (chSuffix == 'Y' || chSuffix == 'y') {
                base = 2;
                chSuffix = '';
            }
            else if (chSuffix == '.') {
                base = 10;
                chSuffix = '';
            }
            else if (chSuffix == 'H' || chSuffix == 'h') {
                base = 16;
                chSuffix = '';
            }
            else if (chSuffix == 'K') {
                chSuffix = '000';
            }
            else if (chSuffix == 'M') {
                chSuffix = '000000';
            }
            else if (chSuffix == 'G') {
                chSuffix = '000000000';
            }
            if (ch != chSuffix) s = s.slice(0, -1) + chSuffix;
            /*
             * This adds support for the MACRO-10 binary shifting (Bn) suffix, which must be stripped from the
             * number before parsing, and then applied to the value after parsing.  If n is omitted, 35 is assumed,
             * which is a net shift of zero.  If n < 35, then a left shift of (35 - n) is required; if n > 35, then
             * a right shift of -(35 - n) is required.
             */
            let v, shift = 0;
            if (base <= 10) {
                let match = s.match(/(-?[0-9]+)B([0-9]*)/);
                if (match) {
                    s = match[1];
                    shift = 35 - ((match[2] || 35) & 0xff);
                }
            }
            if (StrLib.isValidInt(s, base) && !isNaN(v = parseInt(s, base))) {
                /*
                 * With the need to support larger (eg, 36-bit) integers, truncating to 32 bits is no longer helpful.
                 *
                 *      value = v|0;
                 */
                if (shift) {
                    /*
                     * Since binary shifting is a logical operation, and since shifting by division only works properly
                     * with positive numbers, we must convert a negative value to a positive value, by computing the two's
                     * complement.
                     */
                    if (v < 0) v += Math.pow(2, 36);
                    if (shift > 0) {
                        v *= Math.pow(2, shift);
                    } else {
                        v = Math.trunc(v / Math.pow(2, -shift));
                    }
                }
                value = v;
            }
        }
        return value;
    }

    /**
     * toBase(n, radix, cch, sPrefix, nGrouping)
     *
     * Displays the given number as an unsigned integer using the specified radix and number of digits.
     *
     * @param {number|*} n
     * @param {number} radix (ie, the base)
     * @param {number} cch (the desired number of digits)
     * @param {string} [sPrefix] (default is none)
     * @param {number} [nGrouping]
     * @returns {string}
     */
    static toBase(n, radix, cch, sPrefix = "", nGrouping = 0)
    {
        /*
         * We can't rely entirely on isNaN(), because isNaN(null) returns false, and we can't rely
         * entirely on typeof either, because typeof NaN returns "number".  Sigh.
         *
         * Alternatively, we could mask and shift n regardless of whether it's null/undefined/NaN,
         * since JavaScript coerces such operands to zero, but I think there's "value" in seeing those
         * values displayed differently.
         */
        let s = "";
        if (isNaN(n) || typeof n != "number") {
            n = null;
        } else {
            /*
             * Callers that produced an input by dividing by a power of two rather than shifting (in order
             * to access more than 32 bits) may produce a fractional result, which ordinarily we would simply
             * ignore, but if the integer portion is zero and the sign is negative, we should probably treat
             * this value as a sign-extension.
             */
            if (n < 0 && n > -1) n = -1;
            /*
             * Negative values should be two's complemented according to the number of digits; for example,
             * 12 octal digits implies an upper limit 8^12.
             */
            if (n < 0) {
                n += Math.pow(radix, cch);
            }
            if (n >= Math.pow(radix, cch)) {
                cch = Math.ceil(Math.log(n) / Math.log(radix));
            }
        }
        let g = nGrouping || -1;
        while (cch-- > 0) {
            if (!g) {
                s = ',' + s;
                g = nGrouping;
            }
            if (n == null) {
                s = '?' + s;
            } else {
                let d = n % radix;
                d += (d >= 0 && d <= 9? 0x30 : 0x41 - 10);
                s = String.fromCharCode(d) + s;
                n = Math.trunc(n / radix);
            }
            g--;
        }
        return sPrefix + s;
    }

    /**
     * toBin(n, cch, nGrouping)
     *
     * Converts an integer to binary, with the specified number of digits (up to a maximum of 36).
     *
     * @param {number|*} n (supports integers up to 36 bits now)
     * @param {number} [cch] is the desired number of binary digits (0 or undefined for default of either 8, 18, or 36)
     * @param {number} [nGrouping]
     * @returns {string} the binary representation of n
     */
    static toBin(n, cch, nGrouping)
    {
        if (!cch) {
            // cch = Math.ceil(Math.log(Math.abs(n) + 1) / Math.LN2) || 1;
            let v = Math.abs(n);
            if (v <= 0b11111111) {
                cch = 8;
            } else if (v <= 0b111111111111111111) {
                cch = 18;
            } else {
                cch = 36;
            }
        } else if (cch > 36) cch = 36;
        return StrLib.toBase(n, 2, cch, "", nGrouping);
    }

    /**
     * toBinBytes(n, cb, fPrefix)
     *
     * Converts an integer to binary, with the specified number of bytes (up to the default of 4).
     *
     * @param {number|null|undefined} n (interpreted as a 32-bit value)
     * @param {number} [cb] is the desired number of binary bytes (4 is both the default and the maximum)
     * @param {boolean} [fPrefix]
     * @returns {string} the binary representation of n
     */
    static toBinBytes(n, cb, fPrefix)
    {
        let s = "";
        if (!cb || cb > 4) cb = 4;
        for (let i = 0; i < cb; i++) {
            if (s) s = ',' + s;
            s = StrLib.toBin(n & 0xff, 8) + s;
            n >>= 8;
        }
        return (fPrefix? "0b" : "") + s;
    }

    /**
     * toOct(n, cch, fPrefix)
     *
     * Converts an integer to octal, with the specified number of digits (default of 6; max of 12)
     *
     * You might be tempted to use the built-in n.toString(8) instead, but it doesn't zero-pad and it
     * doesn't properly convert negative values.  Moreover, if n is undefined, n.toString() will throw
     * an exception, whereas this function will return '?' characters.
     *
     * @param {number|*} n (supports integers up to 36 bits now)
     * @param {number} [cch] is the desired number of octal digits (0 or undefined for default of either 6, 8, or 12)
     * @param {boolean} [fPrefix]
     * @returns {string} the octal representation of n
     */
    static toOct(n, cch, fPrefix)
    {
        if (!cch) {
            // cch = Math.ceil(Math.log(Math.abs(n) + 1) / Math.log(8)) || 1;
            let v = Math.abs(n);
            if (v <= 0o777777) {
                cch = 6;
            } else if (v <= 0o77777777) {
                cch = 8;
            } else {
                cch = 12;
            }
        } else if (cch > 12) cch = 12;
        return StrLib.toBase(n, 8, cch, fPrefix? "0o" : "");
    }

    /**
     * toDec(n, cch)
     *
     * Converts an integer to decimal, with the specified number of digits (default of 5; max of 11)
     *
     * You might be tempted to use the built-in n.toString(10) instead, but it doesn't zero-pad and it
     * doesn't properly convert negative values.  Moreover, if n is undefined, n.toString() will throw
     * an exception, whereas this function will return '?' characters.
     *
     * @param {number|*} n (supports integers up to 36 bits now)
     * @param {number} [cch] is the desired number of decimal digits (0 or undefined for default of either 5 or 11)
     * @returns {string} the decimal representation of n
     */
    static toDec(n, cch)
    {
        if (!cch) {
            // cch = Math.ceil(Math.log(Math.abs(n) + 1) / Math.LN10) || 1;
            let v = Math.abs(n);
            if (v <= 99999) {
                cch = 5;
            } else {
                cch = 11;
            }
        } else if (cch > 11) cch = 11;
        return StrLib.toBase(n, 10, cch);
    }

    /**
     * toHex(n, cch, fPrefix)
     *
     * Converts an integer to hex, with the specified number of digits (default of 2/4/8, max of 9).
     *
     * You might be tempted to use the built-in n.toString(16) instead, but it doesn't zero-pad and it
     * doesn't properly convert negative values; for example, if n is -2147483647, then n.toString(16)
     * will return "-7fffffff" instead of "80000001".  Moreover, if n is undefined, n.toString() will
     * throw an exception, whereas this function will return '?' characters.
     *
     * NOTE: The following work-around (adapted from code found on StackOverflow) would be another solution,
     * taking care of negative values, zero-padding, and upper-casing, but not null/undefined/NaN values:
     *
     *      s = (n < 0? n + 0x100000000 : n).toString(16);
     *      s = "00000000".substr(0, 8 - s.length) + s;
     *      s = s.substr(0, cch).toUpperCase();
     *
     * @param {number|*} n (supports integers up to 36 bits now)
     * @param {number} [cch] is the desired number of hex digits (0 or undefined for default of 2/4/8/9)
     * @param {boolean} [fPrefix]
     * @returns {string} the hex representation of n
     */
    static toHex(n, cch, fPrefix)
    {
        if (!cch) {
            // cch = Math.ceil(Math.log(Math.abs(n) + 1) / Math.log(16)) || 1;
            let v = Math.abs(n);
            if (v <= 0xff) {
                cch = 2;
            } else if (v <= 0xffff) {
                cch = 4;
            } else if (v <= 0xffffffff) {
                cch = 8;
            } else {
                cch = 9;
            }
        } else if (cch > 9) cch = 9;
        return StrLib.toBase(n, 16, cch, fPrefix? "0x" : "");
    }

    /**
     * toHexByte(b)
     *
     * Alias for StrLib.toHex(b, 2, true)
     *
     * @param {number|null|undefined} b is a byte value
     * @returns {string} the hex representation of b
     */
    static toHexByte(b)
    {
        return StrLib.toHex(b, 2, true);
    }

    /**
     * toHexWord(w)
     *
     * Alias for StrLib.toHex(w, 4, true)
     *
     * @param {number|null|undefined} w is a word (16-bit) value
     * @returns {string} the hex representation of w
     */
    static toHexWord(w)
    {
        return StrLib.toHex(w, 4, true);
    }

    /**
     * toHexLong(l)
     *
     * Alias for StrLib.toHex(l, 8, true)
     *
     * @param {number|null|undefined} l is a dword (32-bit) value
     * @returns {string} the hex representation of w
     */
    static toHexLong(l)
    {
        return StrLib.toHex(l, 8, true);
    }

    /**
     * getBaseName(sFileName, fStripExt)
     *
     * This is a poor-man's version of Node's path.basename(), which Node-only components should use instead.
     *
     * Note that if fStripExt is true, this strips ANY extension, whereas path.basename() strips the extension only
     * if it matches the second parameter (eg, path.basename("/foo/bar/baz/asdf/quux.html", ".html") returns "quux").
     *
     * @param {string} sFileName
     * @param {boolean} [fStripExt]
     * @returns {string}
     */
    static getBaseName(sFileName, fStripExt)
    {
        let sBaseName = sFileName;

        let i = sFileName.lastIndexOf('/');
        if (i >= 0) sBaseName = sFileName.substr(i + 1);

        /*
         * This next bit is a kludge to clean up names that are part of a URL that includes unsightly query parameters.
         */
        i = sBaseName.indexOf('&');
        if (i > 0) sBaseName = sBaseName.substr(0, i);

        if (fStripExt) {
            i = sBaseName.lastIndexOf(".");
            if (i > 0) {
                sBaseName = sBaseName.substring(0, i);
            }
        }
        return sBaseName;
    }

    /**
     * getExtension(sFileName)
     *
     * This is a poor-man's version of Node's path.extname(), which Node-only components should use instead.
     *
     * Note that we EXCLUDE the period from the returned extension, whereas path.extname() includes it.
     *
     * @param {string} sFileName
     * @returns {string} the filename's extension (in lower-case and EXCLUDING the "."), or an empty string
     */
    static getExtension(sFileName)
    {
        let sExtension = "";
        let i = sFileName.lastIndexOf(".");
        if (i >= 0) {
            sExtension = sFileName.substr(i + 1).toLowerCase();
            if (sExtension == "json5") sExtension = "json";
        }
        return sExtension;
    }

    /**
     * endsWith(s, sSuffix)
     *
     * @param {string} s
     * @param {string} sSuffix
     * @returns {boolean} true if s ends with sSuffix, false if not
     */
    static endsWith(s, sSuffix)
    {
        return s.indexOf(sSuffix, s.length - sSuffix.length) !== -1;
    }

    /**
     * escapeHTML(sHTML)
     *
     * @param {string} sHTML
     * @returns {string} with special characters "escaped" as HTML entities, similar to PHP's htmlspecialchars()
     */
    static escapeHTML(sHTML)
    {
        /*
         * Most recently, '$' was added to the list to help avoid problems when callers use the resulting string
         * as a replacement string for JavaScript's string replace() function, which treats '$' specially.  Technically,
         * that's on the callers of replace(), not us, but this doesn't seem harmful, and it's definitely helpful.
         */
        return sHTML.replace(/[&<>"'$]/g, function(m)
        {
            return StrLib.HTMLEscapeMap[m];
        });
    }

    /**
     * replace(sSearch, sReplace, s)
     *
     * The JavaScript replace() function ALWAYS interprets "$" specially in replacement strings, even when
     * the search string is NOT a RegExp; specifically:
     *
     *      $$  Inserts a "$"
     *      $&  Inserts the matched substring
     *      $`  Inserts the portion of the string that precedes the matched substring
     *      $'  Inserts the portion of the string that follows the matched substring
     *      $n  Where n is a positive integer less than 100, inserts the nth parenthesized sub-match string,
     *          provided the first argument was a RegExp object
     *
     * So, if a replacement string containing dollar signs passes through a series of replace() calls, untold
     * problems could result.  Hence, this function, which simply uses the replacement string as-is.
     *
     * Similar to the JavaScript replace() method (when sSearch is a string), this replaces only ONE occurrence
     * (ie, the FIRST occurrence); it might be nice to add options to replace the LAST occurrence and/or ALL
     * occurrences, but we'll revisit that later.
     *
     * @param {string} sSearch
     * @param {string} sReplace
     * @param {string} s
     * @returns {string}
     */
    static replace(sSearch, sReplace, s)
    {
        let i = s.indexOf(sSearch);
        if (i >= 0) {
            s = s.substr(0, i) + sReplace + s.substr(i + sSearch.length);
        }
        return s;
    }

    /**
     * replaceAll(sSearch, sReplace, s)
     *
     * @param {string} sSearch
     * @param {string} sReplace
     * @param {string} s
     * @returns {string}
     */
    static replaceAll(sSearch, sReplace, s)
    {
        let a = {};
        a[sSearch] = sReplace;
        return StrLib.replaceArray(a, s);
    }

    /**
     * replaceArray(a, s)
     *
     * @param {Object} a
     * @param {string} s
     * @returns {string}
     */
    static replaceArray(a, s)
    {
        let sMatch = "";
        for (let k in a) {
            /*
             * As noted in:
             *
             *      http://www.regexguru.com/2008/04/escape-characters-only-when-necessary/
             *
             * inside character classes, only backslash, caret, hyphen and the closing bracket need to be
             * escaped.  And in fact, if you ensure that the closing bracket is first, the caret is not first,
             * and the hyphen is last, you can avoid escaping those as well.
             */
            k = k.replace(/([\\[\]*{}().+?|$])/g, "\\$1");
            sMatch += (sMatch? '|' : '') + k;
        }
        return s.replace(new RegExp('(' + sMatch + ')', "g"), function(m) {
            return a[m];
        });
    }

    /**
     * pad(s, cch)
     *
     * Use a negative cch to pad on the right (ie, left-align), similar to sprintf("%-Ns", s).
     * This also truncates the string if it's longer than abs(cch), similar to sprintf("%.Ns", s).
     *
     * @param {string} s is a string
     * @param {number} cch is desired length
     * @returns {string} the original string (s) with spaces padding it to the specified length
     */
    static pad(s, cch)
    {
        return StrLib.sprintf('%' + cch + '.' + Math.abs(cch) + 's', s);
    }

    /**
     * parseDate(date)
     * parseDate(date, time)
     * parseDate(year, month, day, hour, minute, second)
     *
     * Produces a UTC date when ONLY a date (no time) is provided; otherwise, it combines the date and
     * and time, producing a date that is either UTC or local, depending on the presence (or lack) of time
     * zone information.  Finally, if numeric inputs are provided, then Date.UTC() is called to generate
     * a UTC time.
     *
     * In general, you should use this instead of new Date(s), because the Date constructor implicitly calls
     * Date.parse(s), which behaves inconsistently.  For example, ISO date-only strings (e.g. "1970-01-01")
     * generate a UTC time, but non-ISO date-only strings (eg, "10/1/1945" or "October 1, 1945") generate a
     * local time.
     *
     * @param {...} args
     * @returns {Date} (UTC unless a time string with a non-GMT timezone is explicitly provided)
     */
    static parseDate(...args)
    {
        let date;
        if (args[0] === undefined) {
            date = new Date(Date.now());
        }
        else if (typeof args[0] === "string") {
            date = new Date(args[0] + ' ' + (args[1] || "00:00:00 GMT"));
        }
        else if (args[1] === undefined) {
            date = new Date(args[0]);
        } else {
            date = new Date(Date.UTC(...args));
        }
        return date;
    }

    /**
     * isValidDate(date)
     *
     * @param {Date} date
     * @returns {boolean}
     */
    static isValidDate(date)
    {
        return !isNaN(date.getTime());
    }

    /**
     * stripLeadingZeros(s, fPad)
     *
     * @param {string} s
     * @param {boolean} [fPad]
     * @returns {string}
     */
    static stripLeadingZeros(s, fPad)
    {
        let cch = s.length;
        s = s.replace(/^0+([0-9A-F]+)$/i, "$1");
        if (fPad) s = StrLib.pad(s, cch);
        return s;
    }

    /**
     * trim(s)
     *
     * @param {string} s
     * @returns {string}
     */
    static trim(s)
    {
        if (String.prototype.trim) {
            return s.trim();
        }
        return s.replace(/^\s+|\s+$/g, "");
    }

    /**
     * toASCIICode(b)
     *
     * @param {number} b
     * @returns {string}
     */
    static toASCIICode(b)
    {
        let s;
        if (b != StrLib.ASCII.CR && b != StrLib.ASCII.LF) {
            s = StrLib.ASCIICodeMap[b];
        }
        if (s) {
            s = '<' + s + '>';
        } else {
            s = String.fromCharCode(b);
        }
        return s;
    }
}

StrLib.format = new Format();
StrLib.sprintf = StrLib.format.sprintf.bind(StrLib.format);

/**
 * @copyright https://www.pcjs.org/machines/modules/v2/usrlib.js (C) 2012-2024 Jeff Parsons
 */

/** @typedef {{ mask: number, shift: number }} */
let BitField;

/** @typedef {Object.<BitField>} */
let BitFields;

/**
 * @class UsrLib
 * @unrestricted
 */
class UsrLib {

    static aMonthDays = [
        31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31
    ];

    /**
     * binarySearch(a, v, fnCompare)
     *
     * @param {Array} a is an array
     * @param {number|string|Array|Object} v
     * @param {function((number|string|Array|Object), (number|string|Array|Object))} [fnCompare]
     * @returns {number} the index of matching entry if non-negative, otherwise the index of the insertion point
     */
    static binarySearch(a, v, fnCompare)
    {
        let left = 0;
        let right = a.length;
        let found = 0;
        if (fnCompare === undefined) {
            fnCompare = function(a, b)
            {
                return a > b ? 1 : a < b ? -1 : 0;
            };
        }
        while (left < right) {
            let middle = (left + right) >> 1;
            let compareResult;
            compareResult = fnCompare(v, a[middle]);
            if (compareResult > 0) {
                left = middle + 1;
            } else {
                right = middle;
                found = !compareResult;
            }
        }
        return found ? left : ~left;
    }

    /**
     * binaryInsert(a, v, fnCompare)
     *
     * If element v already exists in array a, the array is unchanged (we don't allow duplicates); otherwise, the
     * element is inserted into the array at the appropriate index.
     *
     * @param {Array} a is an array
     * @param {number|string|Array|Object} v is the value to insert
     * @param {function((number|string|Array|Object), (number|string|Array|Object))} [fnCompare]
     */
    static binaryInsert(a, v, fnCompare)
    {
        let index = UsrLib.binarySearch(a, v, fnCompare);
        if (index < 0) {
            a.splice(-(index + 1), 0, v);
        }
    }

    /**
     * getTimestamp()
     *
     * @returns {string} timestamp containing the current date and time ("yyyy-mm-dd hh:mm:ss")
     */
    static getTimestamp()
    {
        let date = new Date();
        return StrLib.sprintf("%T", date);
    }

    /**
     * getMonthDays(nMonth, nYear)
     *
     * NOTE: If we're being called on behalf of the PCx86 RTC, its year is always truncated to two digits (mod 100),
     * so we have no idea what century the year 0 might refer to.  When using the normal leap-year formula, 0 fails
     * the mod 100 test but passes the mod 400 test, so as far as the RTC is concerned, every century year is a leap
     * year.  Since we're most likely dealing with the year 2000, that's fine, since 2000 was also a leap year.
     *
     * TODO: There IS a separate RTC CMOS byte that's supposed to be set to CMOS_ADDR.CENTURY_DATE; it's always BCD,
     * so theoretically it will contain values like 0x19 or 0x20 (for the 20th and 21st centuries, respectively), and
     * we could add that as another parameter to this function, to improve the accuracy, but that would go beyond what
     * a real RTC actually does.
     *
     * @param {number} nMonth (1-12)
     * @param {number} nYear (normally a 4-digit year, but it may also be mod 100)
     * @returns {number} the maximum (1-based) day allowed for the specified month and year
     */
    static getMonthDays(nMonth, nYear)
    {
        let nDays = UsrLib.aMonthDays[nMonth - 1];
        if (nDays == 28) {
            if ((nYear % 4) === 0 && ((nYear % 100) || (nYear % 400) === 0)) {
                nDays++;
            }
        }
        return nDays;
    }

    /**
     * adjustDays(date, days)
     *
     * Although the setDate() method compensates for day-of-month values outside the current month:
     *
     *      > let d = new Date('11/4/2012');d
     *      2012-11-04T07:00:00.000Z
     *      > new Date(d.setDate(d.getDate() + 365))
     *      2014-11-04T08:00:00.000Z
     *
     * notice the discrepancy in the time-of-day.  Even if there is some technical reason (eg, a DayLight
     * Savings Time side-effect) why that answer is correct, it doesn't satisfy my goal of adjusting ONLY the
     * day, not the time-of-day.
     *
     * By comparison, the method below (multiplying the number of milliseconds in a day by the number of days)
     * works just fine, without any unexpected side-effects:
     *
     *      > let d = new Date('11/4/2012');d
     *      2012-11-04T07:00:00.000Z
     *      > new Date(d.getTime() + 365 * 86400000)
     *      2013-11-04T07:00:00.000Z
     *
     * @param {Date} date
     * @param {number} days (+/-)
     * @returns {Date}
     */
    static adjustDays(date, days)
    {
        return new Date(date.getTime() + days * 86400000);
    }

    /**
     * subtractDays(date1, date2)
     *
     * @param {Date|string} date1
     * @param {Date|string} date2
     * @returns {number} (date1 - date2, returned as a signed integer number of days)
     */
    static subtractDays(date1, date2)
    {
        if (typeof date1 == "string") date1 = new Date(date1);
        if (typeof date2 == "string") date2 = new Date(date2);
        return Math.round((date1.getTime() - date2.getTime()) / 86400000);
    }

    /**
     * defineBitFields(bfs)
     *
     * Prepares a bit field definition for use with getBitField() and setBitField(); eg:
     *
     *      let bfs = UsrLib.defineBitFields({num:20, count:8, btmod:1, type:3});
     *
     * The above defines a set of bit fields containing four fields: num (bits 0-19), count (bits 20-27), btmod (bit 28), and type (bits 29-31).
     *
     *      UsrLib.setBitField(bfs.num, n, 1);
     *
     * The above set bit field "bfs.num" in numeric variable "n" to the value 1.
     *
     * @param {Object} bfs
     * @returns {BitFields}
     */
    static defineBitFields(bfs)
    {
        let bit = 0;
        for (let f in bfs) {
            let width = bfs[f];
            let mask = ((1 << width) - 1) << bit;
            bfs[f] = {mask: mask, shift: bit};
            bit += width;
        }
        return bfs;
    }

    /**
     * initBitFields(bfs, ...)
     *
     * @param {BitFields} bfs
     * @param {...number} var_args
     * @returns {number} a value containing all supplied bit fields
     */
    static initBitFields(bfs, var_args)
    {
        let v = 0, i = 1;
        for (let f in bfs) {
            if (i >= arguments.length) break;
            v = UsrLib.setBitField(bfs[f], v, arguments[i++]);
        }
        return v;
    }

    /**
     * getBitField(bf, v)
     *
     * @param {BitField} bf
     * @param {number} v is a value containing bit fields
     * @returns {number} the value of the bit field in v defined by bf
     */
    static getBitField(bf, v)
    {
        return (v & bf.mask) >> bf.shift;
    }

    /**
     * setBitField(bf, v, n)
     *
     * @param {BitField} bf
     * @param {number} v is a value containing bit fields
     * @param {number} n is a value to store in v in the bit field defined by bf
     * @returns {number} updated v
     */
    static setBitField(bf, v, n)
    {
        return (v & ~bf.mask) | ((n << bf.shift) & bf.mask);
    }

    /**
     * indexOf(a, t, i)
     *
     * Use this instead of Array.prototype.indexOf() if you can't be sure the browser supports it.
     *
     * @param {Array} a
     * @param {*} t
     * @param {number} [i]
     * @returns {number}
     */
    static indexOf(a, t, i)
    {
        if (Array.prototype.indexOf) {
            return a.indexOf(t, i);
        }
        i = i || 0;
        if (i < 0) i += a.length;
        if (i < 0) i = 0;
        for (let n = a.length; i < n; i++) {
            if (i in a && a[i] === t) return i;
        }
        return -1;
    }
}

/**
 * @copyright https://www.pcjs.org/machines/modules/v2/weblib.js (C) 2012-2024 Jeff Parsons
 */

/*
 * According to http://www.w3schools.com/jsref/jsref_obj_global.asp, these are the *global* properties
 * and functions of JavaScript-in-the-Browser:
 *
 * Property             Description
 * ---
 * Infinity             A numeric value that represents positive/negative infinity
 * NaN                  "Not-a-Number" value
 * undefined            Indicates that a variable has not been assigned a value
 *
 * Function             Description
 * ---
 * decodeURI()          Decodes a URI
 * decodeURIComponent() Decodes a URI component
 * encodeURI()          Encodes a URI
 * encodeURIComponent() Encodes a URI component
 * escape()             Deprecated in version 1.5. Use encodeURI() or encodeURIComponent() instead
 * eval()               Evaluates a string and executes it as if it was script code
 * isFinite()           Determines whether a value is a finite, legal number
 * isNaN()              Determines whether a value is an illegal number
 * Number()             Converts an object's value to a number
 * parseFloat()         Parses a string and returns a floating point number
 * parseInt()           Parses a string and returns an integer
 * String()             Converts an object's value to a string
 * unescape()           Deprecated in version 1.5. Use decodeURI() or decodeURIComponent() instead
 *
 * And according to http://www.w3schools.com/jsref/obj_window.asp, these are the properties and functions
 * of the *window* object.
 *
 * Property             Description
 * ---
 * closed               Returns a Boolean value indicating whether a window has been closed or not
 * defaultStatus        Sets or returns the default text in the statusbar of a window
 * document             Returns the Document object for the window (See Document object)
 * frames               Returns an array of all the frames (including iframes) in the current window
 * history              Returns the History object for the window (See History object)
 * innerHeight          Returns the inner height of a window's content area
 * innerWidth           Returns the inner width of a window's content area
 * length               Returns the number of frames (including iframes) in a window
 * location             Returns the Location object for the window (See Location object)
 * name                 Sets or returns the name of a window
 * navigator            Returns the Navigator object for the window (See Navigator object)
 * opener               Returns a reference to the window that created the window
 * outerHeight          Returns the outer height of a window, including toolbars/scrollbars
 * outerWidth           Returns the outer width of a window, including toolbars/scrollbars
 * pageXOffset          Returns the pixels the current document has been scrolled (horizontally) from the upper left corner of the window
 * pageYOffset          Returns the pixels the current document has been scrolled (vertically) from the upper left corner of the window
 * parent               Returns the parent window of the current window
 * screen               Returns the Screen object for the window (See Screen object)
 * screenLeft           Returns the x coordinate of the window relative to the screen
 * screenTop            Returns the y coordinate of the window relative to the screen
 * screenX              Returns the x coordinate of the window relative to the screen
 * screenY              Returns the y coordinate of the window relative to the screen
 * self                 Returns the current window
 * status               Sets or returns the text in the statusbar of a window
 * top                  Returns the topmost browser window
 *
 * Method               Description
 * ---
 * alert()              Displays an alert box with a message and an OK button
 * atob()               Decodes a base-64 encoded string
 * blur()               Removes focus from the current window
 * btoa()               Encodes a string in base-64
 * clearInterval()      Clears a timer set with setInterval()
 * clearTimeout()       Clears a timer set with setTimeout()
 * close()              Closes the current window
 * confirm()            Displays a dialog box with a message and an OK and a Cancel button
 * createPopup()        Creates a pop-up window
 * focus()              Sets focus to the current window
 * moveBy()             Moves a window relative to its current position
 * moveTo()             Moves a window to the specified position
 * open()               Opens a new browser window
 * print()              Prints the content of the current window
 * prompt()             Displays a dialog box that prompts the visitor for input
 * resizeBy()           Resizes the window by the specified pixels
 * resizeTo()           Resizes the window to the specified width and height
 * scroll()             This method has been replaced by the scrollTo() method.
 * scrollBy()           Scrolls the content by the specified number of pixels
 * scrollTo()           Scrolls the content to the specified coordinates
 * setInterval()        Calls a function or evaluates an expression at specified intervals (in milliseconds)
 * setTimeout()         Calls a function or evaluates an expression after a specified number of milliseconds
 * stop()               Stops the window from loading
 */

/**
 * @class Web
 * @unrestricted
 */
class WebLib {
    /**
     * getResource(sURL, type, fAsync, done, progress)
     *
     * Request the specified resource (sURL), and once the request is complete, notify done().
     *
     * If fAsync is true, a done() callback should ALWAYS be supplied; otherwise, you'll have no
     * idea when the request is complete or what the response was.  done() is passed three parameters:
     *
     *      done(sURL, resource, nErrorCode)
     *
     * If nErrorCode is zero, resource should contain the requested data; otherwise, an error occurred.
     *
     * If type is set to a string, that string can be used to control the response format;
     * by default, the response format is plain text, but you can specify "arraybuffer" to request arbitrary
     * binary data, in which case the returned resource will be a ArrayBuffer rather than a string.
     *
     * @param {string} sURL
     * @param {string|Object|null} [type] (object for POST request, otherwise type of GET request)
     * @param {boolean} [fAsync] is true for an asynchronous request; false otherwise (MUST be set for IE)
     * @param {function(string,string,number)|function(string,ArrayBuffer,number)} [done]
     * @param {function(number)} [progress]
     * @returns {Array|null} Array containing [resource, nErrorCode], or null if no response available (yet)
     */
    static getResource(sURL, type = "text", fAsync = false, done, progress)
    {
        let nErrorCode = 0, resource = null, response = null;

        let resources = globals.window['resources'];
        if (typeof resources == 'object' && (resource = resources[sURL])) {
            if (done) done(sURL, resource, nErrorCode);
            return [resource, nErrorCode];
        }
        else if (fAsync && typeof resources == 'function') {
            resources(sURL, function(resource, nErrorCode) {
                if (done) done(sURL, resource, nErrorCode);
            });
            return response;
        }

        /*
         * While it would be nice to simply import LOCALDISKS from defines.js, that merely defines the *default*
         * value of the global variable 'LOCALDISKS'; since imported values are immutable, we must look at the global
         * variable, since that's the only one that *might* have been changed at runtime.
         */
        if (globals.window['LOCALDISKS'] && WebLib.getHostName().match(/^(.+\.local|localhost|0\.0\.0\.0|pcjs)$/)) {
            sURL = sURL.replace(/^\/(diskettes|gamedisks|miscdisks|harddisks|decdisks|pcsigdisks|pcsig[0-9a-z]*-disks|private)\//, "/disks/$1/").replace(/^\/discs\/([^/]*)\//, "/disks/cdroms/$1/");
        } else {
            sURL = sURL.replace(/^\/(disks\/|)(diskettes|gamedisks|miscdisks|harddisks|decdisks|pcsigdisks|pcsig[0-9a-z]*-disks|private)\//, "https://$2.pcjs.org/").replace(/^\/(disks\/cdroms|discs)\/([^/]*)\//, "https://$2.pcjs.org/");
        }

        Component.printf(MESSAGE.DEBUG, "getResource(%s)\n", sURL);

        /*
         * globals.node.readFileSync exists only when another module has import filelib.js, which means we're
         * running under Node.js, and we can use Node's file system to read local files.  Note that filelib.js only
         * offers readFileSync() at the moment.
         */
        if (globals.node.readFileSync && sURL.indexOf("http") != 0) {
            try {
                let encoding = (type == "arraybuffer"? null : "utf8");
                resource = globals.node.readFileSync(sURL, encoding);
                if (!encoding) {
                    /*
                     * For non-UTF8 data, readFileSync() returns a DataBuffer, which wraps a Node Buffer, which wraps an ArrayBuffer.
                     */
                    resource = resource.buffer;
                    if (resource.buffer) resource = resource.buffer;
                }
            } catch (err) {
                nErrorCode = err['errno'];
            }
            if (resource !== undefined) {
                if (done) done(sURL, resource, nErrorCode);
                return [resource, nErrorCode];
            }
        }

        /*
         * If PCjs is simulating a command-line environment inside a browser, PCFS (the PCjs File System) can be used
         * to simulate a local file system.  So we check for that next.
         */
        if (PCFS.isPCFS(sURL)) {
            let item = PCFS.getItem(sURL);
            if (item) {
                resource = item.data;
                if (done) done(sURL, resource, nErrorCode);
                return [resource, nErrorCode];
            }
        }

        /*
         * Don't encode Windows paths (although frankly, that should never happen and I don't recall under what circumstances
         * it apparently did) or URLs with components (which the caller should have already encoded with encodeURIComponent()).
         */
        if (!sURL.match(/^[A-Z]:/i) && sURL.indexOf('?') < 0) {
            sURL = encodeURI(sURL);
        }

        let request;
        if (globals.window.XMLHttpRequest) {
            request = new globals.window.XMLHttpRequest();
        } else if (globals.window.ActiveXObject) {
            request = new globals.window.ActiveXObject("Microsoft.XMLHTTP");
        } else if (globals.window.fetch) {
            // Component.printf(MESSAGE.DEBUG + MESSAGE.LOG, "getResource.fetch(%s)\n", sURL);
            fetch(sURL)
            .then(response => {
                switch(type) {
                case "json":
                case "text":
                    return response.text();
                case "arraybuffer":
                    return response.arrayBuffer();
                default:
                    throw new Error("unsupported response type: " + type);
                }
            })
            .then(resource => {
                Component.printf(MESSAGE.DEBUG + MESSAGE.LOG, "getResource(%s): fetched %d bytes\n", sURL, resource.length);
                if (done) done(sURL, resource, nErrorCode);
            })
            .catch(error => {
                Component.printf(MESSAGE.LOG, "getResource(%s) fetch error: %d\n", sURL, nErrorCode);
                if (done) done(sURL, resource, nErrorCode);
            });
            return response;
        }

        let fArrayBuffer = false, fXHR2 = (typeof request.responseType === 'string');

        let callback = function getResourceDone() {
            if (request.readyState !== 4) {
                if (progress) progress(1);
                return null;
            }
            /*
             * The following line was recommended for WebKit, as a work-around to prevent the handler firing multiple
             * times when debugging.  Unfortunately, that's not the only XMLHttpRequest problem that occurs when
             * debugging, so I think the WebKit problem is deeper than that.  When we have multiple XMLHttpRequests
             * pending, any debugging activity means most of them simply get dropped on floor, so what may actually be
             * happening are mis-notifications rather than redundant notifications.
             *
             *      request.onreadystatechange = undefined;
             *
             * If the request failed due to, say, a CORS policy denial; eg:
             *
             *      Failed to load http://www.allbootdisks.com/downloads/Disks/Windows_95_Boot_Disk_Download48/Diskette%20Images/Windows95a.img:
             *      Redirect from 'http://www.allbootdisks.com/downloads/Disks/Windows_95_Boot_Disk_Download48/Diskette%20Images/Windows95a.img' to
             *      'http://www.allbootdisks.com/' has been blocked by CORS policy: No 'Access-Control-Allow-Origin' header is present on the requested resource.
             *      Origin 'http://pcjs:8088' is therefore not allowed access.
             *
             * and our request type was "arraybuffer", attempting to access responseText may trigger an exception; eg:
             *
             *      Uncaught DOMException: Failed to read the 'responseText' property from 'XMLHttpRequest': The value is only accessible if the object's
             *      'responseType' is '' or 'text' (was 'arraybuffer').
             *
             * We could tiptoe around these potential landmines, but the safest thing to do is wrap this code with try/catch.
             */
            try {
                resource = fArrayBuffer? request.response : request.responseText;
            } catch(err) {
                Component.printf(MESSAGE.LOG, "getResource(%s) exception: %s\n", sURL, err.message);
            }
            /*
             * The normal "success" case is a non-null resource and an HTTP status code of 200, but when loading files from the
             * local file system (ie, when using the "file:" protocol), we have to be a bit more flexible.
             */
            if (resource != null && (request.status == 200 || !request.status && resource.length && WebLib.getHostProtocol() == "file:")) {
                Component.printf(MESSAGE.DEBUG + MESSAGE.LOG, "getResource(%s): returned %d bytes\n", sURL, resource.length);
            }
            else {
                nErrorCode = request.status || -1;
                Component.printf(MESSAGE.DEBUG, "getResource(%s) error: %d\n", sURL, nErrorCode);
                if (!request.status && !WebLib.fAdBlockerWarning) {
                    let match = sURL.match(/(^https?:\/\/[^/]+)(.*)/);
                    if (match) {
                        WebLib.fAdBlockerWarning = true;
                        Component.alertUser("PCjs was unable to perform a cross-origin resource request to '" + match[1] + "'.\n\nIf you're running an ad blocker, try adding '" + WebLib.getHostOrigin() + "' to your whitelist (or find a smarter ad blocker).");
                    }
                }
            }
            if (progress) progress(2);
            if (done) done(sURL, resource, nErrorCode);
            return [resource, nErrorCode];
        };

        if (fAsync) {
            request.onreadystatechange = callback;
        }

        if (progress) progress(0);

        if (type && typeof type == "object") {
            let sPost = "";
            for (let p in type) {
                if (!type.hasOwnProperty(p)) continue;
                if (sPost) sPost += "&";
                sPost += p + '=' + encodeURIComponent(type[p]);
            }
            sPost = sPost.replace(/%20/g, '+');
            Component.printf(MESSAGE.DEBUG + MESSAGE.LOG, "getResource(%s): posted %d bytes\n", sURL, sPost.length);
            request.open("POST", sURL, fAsync);
            request.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
            request.send(sPost);
        } else {
            // Component.printf(MESSAGE.DEBUG + MESSAGE.LOG, "getResource.get(%s)\n", sURL);
            request.open("GET", sURL, fAsync);
            if (type == "arraybuffer") {
                if (fXHR2) {
                    fArrayBuffer = true;
                    request.responseType = type;
                } else {
                    request.overrideMimeType("text/plain; charset=x-user-defined");
                }
            }
            request.send();
        }

        if (!fAsync) {
            request.readyState = 4;     // this may already be set for synchronous requests, but I don't want to take any chances
            response = callback();
        }
        return response;
    }

    /**
     * parseMemoryResource(sURL, sData)
     *
     * This converts a variety of JSON-style data streams into an Object with the following properties:
     *
     *      aBytes
     *      aSymbols
     *      addrLoad
     *      addrExec
     *
     * If the source data contains a 'bytes' array, it's passed through to 'aBytes'; alternatively, if
     * it contains a 'words' array, the values are converted from 16-bit to 8-bit and stored in 'aBytes',
     * and if it contains a 'longs' array, the values are converted from 32-bit longs into bytes and
     * stored in 'aBytes'.
     *
     * Alternatively, if the source data contains a 'data' array, we simply pass that through to the output
     * object as:
     *
     *      aData
     *
     * @param {string} sURL
     * @param {string} sData
     * @returns {Object|null} (resource)
     */
    static parseMemoryResource(sURL, sData)
    {
        let i;
        let resource = {
            aBytes: null,
            aSymbols: null,
            addrLoad: null,
            addrExec: null
        };

        if (sData.charAt(0) == "[" || sData.charAt(0) == "{") {
            try {
                let a, ib, data;

                if (sData.substr(0, 1) == "<") {    // if the "data" begins with a "<"...
                    /*
                     * Early server configs reported an error (via the nErrorCode parameter) if a tape URL was invalid,
                     * but more recent server configs now display a somewhat friendlier HTML error page.  The downside,
                     * however, is that the original error has been buried, and we've received "data" that isn't actually
                     * tape data.  So if the data we've received appears to be "HTML-like", we treat it as an error message.
                     */
                    throw new Error(sData);
                }

                /*
                 * TODO: IE9 is rather unfriendly and restrictive with regard to how much data it's willing to
                 * eval().  In particular, the 10Mb disk image we use for the Windows 1.01 demo config fails in
                 * IE9 with an "Out of memory" exception.  One work-around would be to chop the data into chunks
                 * (perhaps one track per chunk, using regular expressions) and then manually re-assemble it.
                 *
                 * However, it turns out that using JSON.parse(sDiskData) instead of eval("(" + sDiskData + ")")
                 * is a much easier fix. The only drawback is that we must first quote any unquoted property names
                 * and remove any comments, because while eval() was cool with them, JSON.parse() is more particular;
                 * the following RegExp replacements take care of those requirements.
                 *
                 * The use of hex values is something else that eval() was OK with, but JSON.parse() is not, and
                 * while I've stopped using hex values in DumpAPI responses (at least when "format=json" is specified),
                 * I can't guarantee they won't show up in "legacy" images, and there's no simple RegExp replacement
                 * for transforming hex values into decimal values, so I cop out and fall back to eval() if I detect
                 * any hex prefixes ("0x") in the sequence.  Ditto for error messages, which appear like so:
                 *
                 *      ["unrecognized disk path: test.img"]
                 */
                if (sData.indexOf("0x") < 0 && sData.indexOf("0o") < 0 && sData.substr(0, 2) != '["') {
                    if (sData.indexOf('"values"') < 0) sData = sData.replace(/([a-z]+):/gm, '"$1":').replace(/\/\/[^\n]*/gm, "");
                    data = JSON.parse(sData);
                } else {
                    data = eval("(" + sData + ")");
                }

                resource.addrLoad = data['load'];
                resource.addrExec = data['exec'];

                let width = data['width'];
                let values = data['values'];
                if (width && values) {
                    if (width == 8) {
                        data['bytes'] = values;
                    } else if (width == 16) {
                        data['words'] = values;
                    } else if (width == 32) {
                        data['longs'] = values;
                    } else {
                        data['data'] = values;
                    }
                }

                if ((a = data['bytes'])) {
                    resource.aBytes = a;
                }
                else if ((a = data['words'])) {
                    /*
                     * Convert all words into bytes
                     */
                    resource.aBytes = new Array(a.length * 2);
                    for (i = 0, ib = 0; i < a.length; i++) {
                        resource.aBytes[ib++] = a[i] & 0xff;
                        resource.aBytes[ib++] = (a[i] >> 8) & 0xff;

                    }
                }
                else if ((a = data['longs'])) {
                    /*
                     * Convert all dwords (longs) into bytes
                     */
                    resource.aBytes = new Array(a.length * 4);
                    for (i = 0, ib = 0; i < a.length; i++) {
                        resource.aBytes[ib++] = a[i] & 0xff;
                        resource.aBytes[ib++] = (a[i] >> 8) & 0xff;
                        resource.aBytes[ib++] = (a[i] >> 16) & 0xff;
                        resource.aBytes[ib++] = (a[i] >> 24) & 0xff;
                    }
                }
                else if ((a = data['data'])) {
                    resource.aData = a;
                }
                else {
                    resource.aBytes = data;
                }

                if (resource.aBytes) {
                    if (!resource.aBytes.length) {
                        Component.error("Empty resource: " + sURL);
                        resource = null;
                    }
                    else if (resource.aBytes.length == 1) {
                        Component.error(resource.aBytes[0]);
                        resource = null;
                    }
                }
                resource.aSymbols = data['symbols'];

            } catch (e) {
                Component.error("Resource data error (" + sURL + "): " + e.message);
                resource = null;
            }
        }
        else {
            /*
             * Parse the data manually; we assume it's a series of hex byte-values separated by whitespace.
             */
            let ab = [];
            let sHexData = sData.replace(/\n/gm, " ").replace(/ +$/, "");
            let asHexData = sHexData.split(" ");
            for (i = 0; i < asHexData.length; i++) {
                let n = parseInt(asHexData[i], 16);
                if (isNaN(n)) {
                    Component.error("Resource data error (" + sURL + "): invalid hex byte (" + asHexData[i] + ")");
                    break;
                }
                ab.push(n & 0xff);
            }
            if (i == asHexData.length) resource.aBytes = ab;
        }
        return resource;
    }

    /**
     * redirectResource(sPath)
     *
     * The following replacements should only be necessary for (old) saved states; none of our disk manifests
     * should be using any of these deprecated paths anymore.
     *
     * @param {string} sPath
     * @returns {string}
     */
    static redirectResource(sPath)
    {
        sPath = sPath.replace("/disks/pc/", "/disks/pcx86/");
        sPath = sPath.replace("/disks/pcx86/private/", "/disks-private/pcx86/");
        if (sPath.indexOf("archive.pcjs.org") < 0) {
            sPath = sPath.replace("/disks/pcx86/", "/disks-demo/pcx86/");
        }
        sPath = sPath.replace("/pcjs-disks/", "/disks-demo/");
        sPath = sPath.replace("/pcjs-games/", "/disks-game/");
        sPath = sPath.replace("/disks-demo/pcx86/games/", "/disks-game/pcx86/");
        sPath = sPath.replace("/private-disks/", "/disks-private/");
        sPath = sPath.replace("/fixed/", "/drives/");
        return sPath;
    }

    /**
     * sendReport(sApp, sVer, sURL, sUser, sType, sReport, sHostName)
     *
     * Send a report (eg, bug report) to the server.
     *
     * @param {string} sApp (eg, "PCjs")
     * @param {string} sVer (eg, "1.02")
     * @param {string} sURL (eg, "/devices/pc/machine/5150/mda/64kb/machine.xml")
     * @param {string} sUser (ie, the user key, if any)
     * @param {string} sType (eg, "bug"); one of ReportAPI.TYPE.*
     * @param {string} sReport (eg, unparsed state data)
     * @param {string} [sHostName] (default is SITEURL)
     */
    static sendReport(sApp, sVer, sURL, sUser, sType, sReport, sHostName)
    {
        let dataPost = {};
        dataPost[ReportAPI.QUERY.APP] = sApp;
        dataPost[ReportAPI.QUERY.VER] = sVer;
        dataPost[ReportAPI.QUERY.URL] = sURL;
        dataPost[ReportAPI.QUERY.USER] = sUser;
        dataPost[ReportAPI.QUERY.TYPE] = sType;
        dataPost[ReportAPI.QUERY.DATA] = sReport;
        let sReportURL = (sHostName? sHostName : SITEURL) + ReportAPI.ENDPOINT;
        WebLib.getResource(sReportURL, dataPost, true);
    }

    /**
     * getHost()
     *
     * This is like getHostName() but with the port number, if any.
     *
     * @returns {string}
     */
    static getHost()
    {
        return globals.window.location? globals.window.location.host : "localhost";
    }

    /**
     * getHostName()
     *
     * @returns {string}
     */
    static getHostName()
    {
        return globals.window.location? globals.window.location.hostname : "localhost";
    }

    /**
     * getHostOrigin()
     *
     * This could also be implemented with window.location.origin, but that wasn't originally available in all browsers.
     *
     * @returns {string}
     */
    static getHostOrigin()
    {
        return globals.window.location? globals.window.location.protocol + "//" + globals.window.location.host : SITEURL;
    }

    /**
     * getHostProtocol()
     *
     * @returns {string}
     */
    static getHostProtocol()
    {
        return globals.window.location? globals.window.location.protocol : "file:";
    }

    /**
     * getHostURL()
     *
     * @returns {string|null}
     */
    static getHostURL()
    {
        return globals.window.location? globals.window.location.href : null;
    }

    /**
     * getUserAgent()
     *
     * @returns {string}
     */
    static getUserAgent()
    {
        return globals.window.navigator? globals.window.navigator.userAgent : "";
    }

    /**
     * hasLocalStorage
     *
     * true if localStorage support exists, is enabled, and works; false otherwise
     *
     * @returns {boolean}
     */
    static hasLocalStorage()
    {
        if (WebLib.fLocalStorage == null) {
            let f = false;
            if (globals.window.localStorage) {
                try {
                    globals.window.localStorage.setItem(WebLib.sLocalStorageTest, WebLib.sLocalStorageTest);
                    f = (globals.window.localStorage.getItem(WebLib.sLocalStorageTest) == WebLib.sLocalStorageTest);
                    globals.window.localStorage.removeItem(WebLib.sLocalStorageTest);
                } catch (e) {
                    WebLib.printLocalStorageError(e);
                    f = false;
                }
            }
            WebLib.fLocalStorage = f;
        }
        return WebLib.fLocalStorage;
    }

    /**
     * printLocalStorageError(e)
     *
     * @param {Error} e is an exception
     */
    static printLocalStorageError(e)
    {
        Component.printf(MESSAGE.ERROR, "Local storage error: %s\n", e.message);
    }

    /**
     * getLocalStorageItem(sKey)
     *
     * Returns the requested key value, or null if the key does not exist, or undefined if localStorage is not available
     *
     * @param {string} sKey
     * @returns {string|null|undefined} sValue
     */
    static getLocalStorageItem(sKey)
    {
        let sValue;
        if (WebLib.hasLocalStorage()) {
            try {
                sValue = globals.window.localStorage.getItem(sKey);
            } catch (e) {
                WebLib.printLocalStorageError(e);
            }
        }
        return sValue;
    }

    /**
     * setLocalStorageItem(sKey, sValue)
     *
     * @param {string} sKey
     * @param {string} sValue
     * @returns {boolean} true if localStorage is available, false if not
     */
    static setLocalStorageItem(sKey, sValue)
    {
        if (WebLib.hasLocalStorage()) {
            try {
                globals.window.localStorage.setItem(sKey, sValue);
                return true;
            } catch (e) {
                WebLib.printLocalStorageError(e);
            }
        }
        return false;
    }

    /**
     * removeLocalStorageItem(sKey)
     *
     * @param {string} sKey
     */
    static removeLocalStorageItem(sKey)
    {
        if (WebLib.hasLocalStorage()) {
            try {
                globals.window.localStorage.removeItem(sKey);
            } catch (e) {
                WebLib.printLocalStorageError(e);
            }
        }
    }

    /**
     * getLocalStorageKeys()
     *
     * @returns {Array}
     */
    static getLocalStorageKeys()
    {
        let a = [];
        if (WebLib.hasLocalStorage()) {
            try {
                for (let i = 0, c = globals.window.localStorage.length; i < c; i++) {
                    a.push(globals.window.localStorage.key(i));
                }
            } catch (e) {
                WebLib.printLocalStorageError(e);
            }
        }
        return a;
    }

    /**
     * reloadPage()
     */
    static reloadPage()
    {
        if (globals.window.location) globals.window.location.reload();
    }

    /**
     * isUserAgent(s)
     *
     * Check the browser's user-agent string for the given substring; "iOS" and "MSIE" are special values you can
     * use that will match any iOS or MSIE browser, respectively (even IE11, in the case of "MSIE").
     *
     * 2013-11-06: In a questionable move, MSFT changed the user-agent reported by IE11 on Windows 8.1, eliminating
     * the "MSIE" string (which MSDN calls a "version token"; see http://msdn.microsoft.com/library/ms537503.aspx);
     * they say "public websites should rely on feature detection, rather than browser detection, in order to design
     * their sites for browsers that don't support the features used by the website." So, in IE11, we get a user-agent
     * that tries to fool apps into thinking the browser is more like WebKit or Gecko:
     *
     *      Mozilla/5.0 (Windows NT 6.3; Trident/7.0; rv:11.0) like Gecko
     *
     * That's a nice idea, but in the meantime, they hosed the XSL transform code in embed.js, which contained
     * some very critical browser-specific code; turning on IE's "Compatibility Mode" didn't help either, because
     * that's a sledgehammer solution which restores the old user-agent string but also disables other features like
     * HTML5 canvas support. As an interim solution, I'm treating any "MSIE" check as a check for either "MSIE" or
     * "Trident".
     *
     * UPDATE: I've since found ways to make the code in embed.js more browser-agnostic, so for now, there's isn't
     * any code that cares about "MSIE", but I've left the change in place, because I wouldn't be surprised if I'll
     * need more IE-specific code in the future, perhaps for things like copy/paste functionality, or mouse capture.
     *
     * 2019-10-26: Apple has pulled a stunt in iPadOS 13 similar to MSFT: trying to pretend that Safari on iPadOS is
     * indistinguishable from the desktop version.  Except that there are still situations where we need to know the
     * difference (eg, when there's only a soft keyboard as opposed to a dedicated keyboard).  See monitor.js for details.
     *
     * @param {string} s is a substring to search for in the user-agent; as noted above, "iOS" and "MSIE" are special values
     * @returns {boolean} is true if the string was found, false if not
     */
    static isUserAgent(s)
    {
        if (globals.window.navigator) {
            let userAgent = WebLib.getUserAgent();
            /*
             * Here's one case where we have to be careful with Component, because when isUserAgent() is called by
             * the init code below, component.js hasn't been loaded yet.  The simple solution for now is to remove the call.
             *
             *      Component.printf("agent: %s\n", userAgent);
             *
             * And yes, it would be pointless to use the conditional (?) operator below, if not for the Google Closure
             * Compiler (v20130823) failing to detect the entire expression as a boolean.
             */
            return s == "iOS" && (!!userAgent.match(/(iPod|iPhone|iPad)/) || (globals.window.navigator.platform === 'MacIntel' && globals.window.navigator.maxTouchPoints > 1)) || s == "MSIE" && !!userAgent.match(/(MSIE|Trident)/) || (userAgent.indexOf(s) >= 0);
        }
        return false;
    }

    /**
     * isMobile(sDevice)
     *
     * Checks the URL for a "mobile" parameter, and failing that, checks the browser's user-agent string for the
     * substring "Mobi", as per Mozilla recommendation:
     *
     *      https://developer.mozilla.org/en-US/docs/Browser_detection_using_the_user_agent
     *
     * @param {string} [sDevice] (eg, "iPad" to check for iPad, or "!iPad" to specifically exclude it)
     * @returns {boolean} is true if the browser appears to be a mobile (ie, non-desktop) web browser, false if not
     */
    static isMobile(sDevice)
    {
        let sMobile = WebLib.getURLParm("mobile");
        if (sMobile) return sMobile == "true";
        if (WebLib.isUserAgent("Mobi")) {
            if (!sDevice) return true;
            let fInvert = sDevice[0] == '!';
            if (fInvert) sDevice = sDevice.substr(1);
            return WebLib.isUserAgent(sDevice) != fInvert;
        }
        return false;
    }

    /**
     * findProperty(obj, sProp, sSuffix)
     *
     * If both sProp and sSuffix are set, then any browser-specific prefixes are inserted between sProp and sSuffix,
     * and if a match is found, it is returned without sProp.
     *
     * For example, if findProperty(document, 'on', 'fullscreenchange') discovers that 'onwebkitfullscreenchange' exists,
     * it will return 'webkitfullscreenchange', in preparation for an addEventListener() call.
     *
     * More commonly, sSuffix is not used, so whatever property is found is returned as-is.
     *
     * @param {Object|null|undefined} obj
     * @param {string} sProp
     * @param {string} [sSuffix]
     * @returns {string|null}
     */
    static findProperty(obj, sProp, sSuffix)
    {
        if (obj) {
            for (let i = 0; i < WebLib.asBrowserPrefixes.length; i++) {
                let sName = WebLib.asBrowserPrefixes[i];
                if (sSuffix) {
                    sName += sSuffix;
                    let sEvent = sProp + sName;
                    if (sEvent in obj) return sName;
                } else {
                    if (!sName) {
                        sName = sProp[0];
                    } else {
                        sName += sProp[0].toUpperCase();
                    }
                    sName += sProp.substr(1);
                    if (sName in obj) return sName;
                }
            }
        }
        return null;
    }

    /**
     * getURLParm(sParm)
     *
     * First looks for sParm exactly as specified, then looks for the lower-case version.
     *
     * @param {string} sParm
     * @returns {string|undefined}
     */
    static getURLParm(sParm)
    {
        if (!WebLib.parmsURL) {
            WebLib.parmsURL = WebLib.parseURLParms();
        }
        return WebLib.parmsURL[sParm] || WebLib.parmsURL[sParm.toLowerCase()];
    }

    /**
     * parseURLParms(sParms)
     *
     * @param {string} [sParms] containing the parameter portion of a URL (ie, after the '?')
     * @returns {Object} containing properties for each parameter found
     */
    static parseURLParms(sParms)
    {
        let aParms = {};
        if (globals.window.location) {
            if (!sParms) {
                /*
                 * Note that window.location.href returns the entire URL, whereas window.location.search
                 * returns only the parameters, if any (starting with the '?', which we skip over with a substr() call).
                 */
                sParms = globals.window.location.search.substr(1);
            }
            let match;
            let pl = /\+/g; // RegExp for replacing addition symbol with a space
            let search = /([^&=]+)=?([^&]*)/g;
            let decode = function(s)
            {
                return decodeURIComponent(s.replace(pl, " "));
            };

            while ((match = search.exec(sParms))) {
                aParms[decode(match[1])] = decode(match[2]);
            }
        }
        return aParms;
    }

    /**
     * downloadFile(sData, sType, fBase64, sFileName)
     *
     * @param {string|Uint8Array} sData
     * @param {string} sType
     * @param {boolean} [fBase64]
     * @param {string} [sFileName]
     */
    static downloadFile(sData, sType, fBase64, sFileName)
    {
        let link = null, sAlert, sURI;

        if (typeof sData != 'string') {
            if (typeof Blob == 'function' && typeof URL != 'undefined' && URL && typeof URL.createObjectURL == 'function') {
                let blob = new Blob([sData], {type: 'application/octet-stream'});
                sURI = URL.createObjectURL(blob);
            }
        }
        else {
            sURI = "data:application/" + sType + (fBase64? ";base64" : "") + ",";
            sURI += (fBase64? sData : encodeURIComponent(sData));
        }
        if (!sURI) {
            sAlert = 'Operation unsupported by your browser.';
        }
        else {
            if (sFileName) {
                link = document.createElement('a');
                if (typeof link.download != 'string') link = null;
            }
            if (link) {
                link.href = sURI;
                link.download = sFileName;
                document.body.appendChild(link);    // Firefox allegedly requires the link to be in the body
                link.click();
                document.body.removeChild(link);
                sAlert = 'Check your Downloads folder for ' + sFileName + '.';
                // if (WebLib.isUserAgent("Chrome")) {
                //     sAlert += '\n\nIn Chrome, after clicking OK, you may ALSO have to select the "Window" menu, choose "Downloads", and then locate this download and select "Keep".';
                //     sAlert += '\n\nThis is part of Chrome\'s "Security By Jumping Through Extra Hoops" technology, which is much easier for Google to implement than actually checking for something malicious.';
                //     sAlert += '\n\nAnd for the record, there is nothing malicious on the PCjs website.';
                // }
            }
            else if (globals.window.open) {
                globals.window.open(sURI);
                sAlert = 'Check your browser for a new window/tab containing the requested data' + (sFileName? (' (' + sFileName + ')') : '') + '.';
            }
        }
        return sAlert;
    }

    /**
     * onCountRepeat(n, fnRepeat, fnComplete, msDelay)
     *
     * Call fnRepeat() n times with an msDelay millisecond delay between calls,
     * then call fnComplete() when n has been exhausted OR fnRepeat() returns false.
     *
     * @param {number} n
     * @param {function()} fnRepeat
     * @param {function()} fnComplete
     * @param {number} [msDelay]
     */
    static onCountRepeat(n, fnRepeat, fnComplete, msDelay)
    {
        let fnTimeout = function doCountRepeat()
        {
            n -= 1;
            if (n >= 0) {
                if (!fnRepeat()) n = 0;
            }
            if (n > 0) {
                setTimeout(fnTimeout, msDelay || 0);
                return;
            }
            fnComplete();
        };
        fnTimeout();
    }

    /**
     * onClickRepeat(e, msDelay, msRepeat, fn)
     *
     * Repeatedly call fn() with an initial msDelay, and an msRepeat delay thereafter,
     * as long as HTML control Object e has an active "down" event and fn() returns true.
     *
     * @param {Object} e
     * @param {number} msDelay
     * @param {number} msRepeat
     * @param {function(boolean)} fn is passed false on the first call, true on all repeated calls
     */
    static onClickRepeat(e, msDelay, msRepeat, fn)
    {
        let ms = 0, timer = null, fIgnoreMouseEvents = false;

        let fnRepeat = function doClickRepeat()
        {
            if (fn(ms === msRepeat)) {
                timer = setTimeout(fnRepeat, ms);
                ms = msRepeat;
            }
        };
        e.onmousedown = function()
        {
            // Component.printf(MESSAGE.DEBUG, "onMouseDown()\n");
            if (!fIgnoreMouseEvents) {
                if (!timer) {
                    ms = msDelay;
                    fnRepeat();
                }
            }
        };
        e.ontouchstart = function()
        {
            // Component.printf(MESSAGE.DEBUG, "onTouchStart()\n");
            if (!timer) {
                ms = msDelay;
                fnRepeat();
            }
        };
        e.onmouseup = e.onmouseout = function()
        {
            // Component.printf(MESSAGE.DEBUG, "onMouseUp()/onMouseOut()\n");
            if (timer) {
                clearTimeout(timer);
                timer = null;
            }
        };
        e.ontouchend = e.ontouchcancel = function()
        {
            // Component.printf(MESSAGE.DEBUG, "onTouchEnd()/onTouchCancel()\n");
            if (timer) {
                clearTimeout(timer);
                timer = null;
            }
            /*
             * Devices that generate ontouch* events ALSO generate onmouse* events,
             * and generally do so immediately after all the touch events are complete,
             * so unless we want double the action, we need to ignore mouse events.
             */
            fIgnoreMouseEvents = true;
        };
    }

    /**
     * addPageEvent(sEvent, fn)
     *
     * For 'load', 'unload', and 'pageshow' events, most callers should NOT use this function, but instead use
     * WebLib.onInit(), WebLib.onShow(), and WebLib.onExit(), respectively.
     *
     * The only components that should still use addPageEvent() are THIS component (see the bottom of this file)
     * and components that need to capture other events (eg, the 'resize' event in the Video component).
     *
     * @param {string} sEvent
     * @param {function()} fn
     */
    static addPageEvent(sEvent, fn)
    {
        if (globals.window.addEventListener) {
            globals.window.addEventListener(sEvent, fn);
        }
    }

    /**
     * onInit(fn)
     *
     * Use this instead of setting window.onload.  Allows multiple JavaScript modules to define their own 'load' event handler.
     *
     * @param {function()} fn
     */
    static onInit(fn)
    {
        WebLib.aPageEventHandlers['init'].push(fn);
    }

    /**
     * onShow(fn)
     *
     * @param {function()} fn
     *
     * Use this instead of setting window.onpageshow.  Allows multiple JavaScript modules to define their own 'pageshow' event handler.
     */
    static onShow(fn)
    {
        WebLib.aPageEventHandlers['show'].push(fn);
    }

    /**
     * onError(sMessage)
     *
     * @param {string} sMessage
     */
    static onError(sMessage)
    {
        Component.printf(MESSAGE.NOTICE, "%s\n\nIf it happens again, please send the URL to support@pcjs.org. Thanks.\n", sMessage);
    }

    /**
     * onExit(fn)
     *
     * @param {function()} fn
     *
     * Use this instead of setting window.onunload.  Allows multiple JavaScript modules to define their own 'unload' event handler.
     */
    static onExit(fn)
    {
        WebLib.aPageEventHandlers['exit'].push(fn);
    }

    /**
     * doPageEvent(sEvent, browser)
     *
     * @param {string} sEvent (one of 'init', 'show' or 'exit')
     * @param {boolean} [browser] (true if generated by the browser)
     */
    static doPageEvent(sEvent, browser)
    {
        let afn = WebLib.aPageEventHandlers[sEvent];
        if (afn && WebLib.fPageEventsEnabled) {
            try {
                for (let i = 0; i < afn.length; i++) {
                    afn[i]();
                }
            } catch (e) {
                WebLib.onError("An unexpected error occurred: " + e.message);
            }
        }
    }

    /**
     * enablePageEvents(fEnable)
     *
     * @param {boolean} fEnable is true to enable page events, false to disable (they're enabled by default)
     */
    static enablePageEvents(fEnable)
    {
        if (!WebLib.fPageEventsEnabled && fEnable) {
            WebLib.fPageEventsEnabled = true;
            if (WebLib.fPageLoaded) WebLib.doPageEvent('init');
            if (WebLib.fPageShowed) WebLib.doPageEvent('show');
            return;
        }
        WebLib.fPageEventsEnabled = fEnable;
    }

    /**
     * doPageInit()
     */
    static doPageInit()
    {
        WebLib.fPageLoaded = true;
        WebLib.doPageEvent('init', true);
    }

    /**
     * doPageShow()
     */
    static doPageShow()
    {
        WebLib.fPageShowed = true;
        WebLib.doPageEvent('show', true);
    }

    /**
     * doPageExit()
     */
    static doPageExit()
    {
        WebLib.doPageEvent('exit', true);
    }

    /**
     * doPageReset()
     */
    static doPageReset()
    {
        if (WebLib.fPageLoaded) {
            WebLib.fPageLoaded = false;
            WebLib.fPageShowed = false;
            /*
             * TODO: Anything else?
             */
        }
    }
}

WebLib.parmsURL = null;            // initialized on first call to parseURLParms()

WebLib.aPageEventHandlers = {
    'init': [],                 // list of 'load' handlers
    'show': [],                 // list of 'pageshow' handlers
    'exit': []                  // list of 'unload' handlers (although we prefer to use 'beforeunload' if possible)
};

WebLib.asBrowserPrefixes = ['', 'moz', 'ms', 'webkit'];

WebLib.fPageLoaded = false;        // set once the page's first 'load' event has occurred
WebLib.fPageShowed = false;        // set once the page's first 'pageshow' event has occurred
WebLib.fPageEventsEnabled = true;  // default is true, set to false (or true) by enablePageEvents()
WebLib.fAdBlockerWarning = false;

/**
 * fLocalStorage
 *
 * true if localStorage support exists, is enabled, and works; "falsey" otherwise
 *
 * @type {boolean|null}
 */
WebLib.fLocalStorage = null;

/**
 * TODO: Is there any way to get the Closure Compiler to stop inlining this string?  This isn't cutting it.
 *
 * @const {string}
 */
WebLib.sLocalStorageTest = "PCjs.localStorage";

WebLib.addPageEvent('load', WebLib.doPageInit);
WebLib.addPageEvent('pageshow', WebLib.doPageShow);
WebLib.addPageEvent(WebLib.isUserAgent("iOS")? 'pagehide' : (WebLib.isUserAgent("Opera")? 'unload' : 'beforeunload'), WebLib.doPageExit);

/*
 * If this is DEBUG (eg, un-COMPILED) code, then allow the user to override DEBUG with a "debug=false" embedded in
 * the URL; note that the Closure Compiler won't let us alter the DEBUG variable, because it's defined as a @define, which
 * implies @const as well, so we must resort to modifying it indirectly, using the global window object.
 *
 * TODO: Consider yet another embedXXX() parameter that would also allow DEBUG to be turned off on a page-by-page basis;
 * it's low priority, because it would only affect machines that explicitly request un-COMPILED code, and there are very
 * few such machines (eg, /blog/_posts/2015/2015-01-17-pcjs-uncompiled.md).
 *
 * Deal with WebLib.getURLParm("backtrack") in /machines/pcx86/modules/v2/defines.js at the same time.
 */
if (DEBUG) {
    let debug = WebLib.getURLParm("debug");
    if (debug == "false") {
        globals.window['DEBUG'] = false;
    }
}

/**
 * @copyright https://www.pcjs.org/machines/modules/v2/component.js (C) 2012-2024 Jeff Parsons
 */

/*
 * All PCjs components now use JSDoc types, primarily so that Google's Closure Compiler will compile
 * everything with zero warnings when ADVANCED_OPTIMIZATIONS are enabled.  For more information about
 * the JSDoc types supported by the Closure Compiler:
 *
 *      https://developers.google.com/closure/compiler/docs/js-for-compiler#types
 *
 * I also attempted to validate this code with JSLint, but it complained too much; eg, it didn't like
 * "while (true)", a tried and "true" programming convention for decades, and it wanted me to replace
 * all "++" and "--" operators with "+= 1" and "-= 1", use "(s || '')" instead of "(s? s : '')", etc.
 *
 * I prefer sticking with traditional C-style idioms, in part because they are more portable.  That
 * does NOT mean I'm trying to write "portable JavaScript," but some of this code was ported from C code
 * I'd written long ago, so portability is good, and I'm not going to throw that away if there's no need.
 *
 * UPDATE: I've since switched from JSLint to JSHint, which seems to have more reasonable defaults.
 * And for new code, I have adopted some popular JavaScript idioms, like "(s || '')", although the need
 * for those kinds of expressions will be reduced as I also start adopting some ES6 features, like
 * default parameters.
 */


/**
 * Since the Closure Compiler treats ES6 classes as @struct rather than @dict by default,
 * it deters us from defining named properties on our components; eg:
 *
 *      this['exports'] = {...}
 *
 * results in an error:
 *
 *      Cannot do '[]' access on a struct
 *
 * So, in order to define 'exports', we must override the @struct assumption by annotating
 * the class as @unrestricted (or @dict).  Note that this must be done both here and in the
 * subclass (eg, SerialPort), because otherwise the Compiler won't allow us to *reference*
 * the named property either.
 *
 * TODO: Consider marking ALL our classes unrestricted, because otherwise it forces us to
 * define every single property the class uses in its constructor, which results in a fair
 * bit of redundant initialization, since many properties aren't (and don't need to be) fully
 * initialized until the appropriate init(), reset(), restore(), etc. function is called.
 *
 * The upside, however, may be that since the structure of the class is completely defined by
 * the constructor, JavaScript engines may be able to optimize and run more efficiently.
 *
 * @class Component
 * @unrestricted
 */
class Component {
    /*
    * Types recognized and supported by selected functions (eg, Computer.getMachineParm())
    */
    static TYPE = {
        NUMBER:     "number",
        OBJECT:     "object",
        STRING:     "string"
    };

    /*
    * Every component created on the current page is recorded in this array (see Component.add()),
    * enabling any component to locate another component by ID (see Component.getComponentByID())
    * or by type (see Component.getComponentByType()).
    *
    * Every machine on the page are now recorded as well, by their machine ID.  We then record the
    * various resources used by that machine.
    */

    static asyncCommands = [
        'hold', 'sleep', 'wait'
    ];

    static globalCommands = {
        'alert': Component.scriptAlert,
        'sleep': Component.scriptSleep
    };

    static componentCommands = {
        'select':   Component.scriptSelect
    };

    static lastUID = 0;

    /**
     * Component(type, parms, bitsMessage)
     *
     * A Component object requires:
     *
     *      type: a user-defined type name (eg, "CPU")
     *
     * and accepts any or all of the following (parms) properties:
     *
     *      id: component ID (default is "")
     *      name: component name (default is ""; if blank, toString() will use the type name only)
     *      comment: component comment string (default is undefined)
     *
     * Component subclasses will usually have additional (parms) properties.
     *
     * @param {string} type
     * @param {Object} [parms]
     * @param {number} [bitsMessage] selects message(s) that the component wants to enable (default is 0)
     */
    constructor(type, parms, bitsMessage)
    {
        this.type = type;

        if (!parms) parms = {'id': "", 'name': ""};

        this.name = parms['name'];
        this.comment = parms['comment'];
        this.parms = parms;
        this.uid = ++Component.lastUID;

        /*
         * The following Component properties need to be accessible by other machines and/or command scripts;
         * well, OK, or we could have exported some new functions to walk the contents of these properties, as we
         * did with findMachineComponent(), but this works just as well.
         *
         * Also, while the double-assignment looks silly (ie, using both dot and bracket property notation), it
         * resolves a complaint from the Closure Compiler, because if we use ONLY bracket notation here, then the
         * Compiler wants us to change all the other references to bracket notation as well.
         */
        this.id = this['id'] = parms['id'] || "";
        this.exports = this['exports'] = {};
        this.bindings = this['bindings'] = {};

        let i = this.id.indexOf('.');
        if (i < 0) {
            this.idMachine = "PCjs";
            this.idComponent = this.id;
        } else {
            this.idMachine = this.id.substr(0, i);
            this.idComponent = this.id.substr(i + 1);
        }

        /*
         * Gather all the various component flags (booleans) into a single "flags" object, and encourage
         * subclasses to do the same, to reduce the property clutter we have to wade through while debugging.
         */
        this.flags = {
            ready:      false,
            busy:       false,
            busyCancel: false,
            initDone:   false,
            powered:    false,
            unloading:  false,
            error:      false
        };

        this.fnReady = null;
        this.clearError();
        this.bitsMessage = bitsMessage || 0;

        this.cmp = null;
        this.bus = null;
        this.cpu = null;
        this.dbg = null;

        /*
         * TODO: Consider adding another parameter to the Component() constructor that allows components to tell
         * us if they support single or multiple instances per machine.  For example, there can be multiple SerialPort
         * components per machine, but only one CPU component (some machines also support an FPU, but that component
         * is considered separate from the CPU).
         *
         * It's not critical, but it would help catch machine configuration errors; for example, a machine that mistakenly
         * includes two CPU components may, aside from wasting memory, end up with odd side-effects, like unresponsive
         * CPU controls.
         */
        Component.add(this);
    }

    /**
     * Component.add(component)
     *
     * @param {Component} component
     */
    static add(component)
    {
        /*
         * This just generates a lot of useless noise, handy in the early days, not so much these days....
         *
         *      if (DEBUG) Component.printf("Component.add(%s,%s)\n", component.type, component.id);
         */
        globals.pcjs['components'].push(component);
    }

    /**
     * Component.addMachine(idMachine)
     *
     * @param {string} idMachine
     */
    static addMachine(idMachine)
    {
        globals.pcjs['machines'][idMachine] = {};
    }

    /**
     * Component.destroyMachine(idMachine)
     *
     * @param {string} idMachine
     * @returns {boolean} true if the machine was destroyed, false if it didn't exist
     */
    static destroyMachine(idMachine)
    {
        if (globals.pcjs['machines'][idMachine]) {
            let components = globals.pcjs['components'];
            for (let i = 0; i < components.length; i++) {
                let component = components[i];
                if (component.id.indexOf(idMachine) == 0) {
                    components.splice(i--, 1);
                }
            }
            delete globals.pcjs['machines'][idMachine];
            return true;
        }
        return false;
    }

    /**
     * Component.getMachines()
     *
     * @returns {Array.<string>}
     */
    static getMachines()
    {
        return Object.keys(globals.pcjs['machines']);
    }

    /**
     * Component.addMachineResource(idMachine, sName, data)
     *
     * @param {string} idMachine
     * @param {string|null} sName (name of the resource)
     * @param {*} data
     */
    static addMachineResource(idMachine, sName, data)
    {
        /*
         * I used to assert(machines[idMachine]), but when we're running as a Node app, embed.js is not used,
         * so addMachine() is never called, so resources do not need to be recorded.
         */
        if (globals.pcjs['machines'][idMachine] && sName) {
            globals.pcjs['machines'][idMachine][sName] = data;
            if (sName == 'parms' && typeof data == "string") {
                globals.pcjs['machines'][idMachine]['config'] = eval('(' + data + ')');
            }
        }
    }

    /**
     * Component.getMachineResources(idMachine)
     *
     * @param {string} idMachine
     * @returns {Object|undefined}
     */
    static getMachineResources(idMachine)
    {
        return globals.pcjs['machines'][idMachine];
    }

    /**
     * Component.getTime()
     *
     * @returns {number} the current time, in milliseconds
     */
    static getTime()
    {
        return Date.now() || +new Date();
    }

    /**
     * Component.printf(format, ...args)
     *
     * If format is a number, it's used as a message number, and the format string is the first arg.
     *
     * @param {string|number} format
     * @param {...} args
     */
    static printf(format, ...args)
    {
        let bitsMessage = 0;
        if (typeof format == "number") {
            bitsMessage = format;
            format = args.shift();
        }
        if (DEBUG || bitsMessage >= MESSAGE.LOG && bitsMessage <= MESSAGE.ERROR) {
            let alert = false;
            if (bitsMessage == MESSAGE.ERROR) {
                alert = true;
                format = "Error: " + format;
            } else if (bitsMessage == MESSAGE.WARNING) {
                alert = true;
                format = "Warning: " + format;
            } else if (bitsMessage == MESSAGE.NOTICE) {
                alert = true;
            }
            let sMessage = StrLib.sprintf(format, ...args).trim();
            if (!alert) {
                console.log(sMessage);
            } else {
                Component.alertUser(sMessage);
            }
        }
    }

    /**
     * Component.assert(f, s)
     *
     * Verifies conditions that must be true (for DEBUG builds only).
     *
     * The Closure Compiler should automatically remove all references to Component.assert() in non-DEBUG builds.
     * TODO: Add a task to the build process that "asserts" there are no instances of "assertion failure" in RELEASE builds.
     *
     * @param {boolean|number|undefined} f is the expression we are asserting to be true
     * @param {string} [s] is description of the assertion on failure
     */
    static assert(f, s)
    {
        if (DEBUG) {
            if (!f) {
                if (!s) s = "assertion failure";
                /*
                 * Why do we throw an Error only to immediately catch and ignore it?  Simply to give
                 * any IDE the opportunity to inspect the application's state.  Even when the IDE has
                 * control, you should still be able to invoke Debugger commands from the IDE's REPL,
                 * using the global function that the Debugger constructor defines; eg:
                 *
                 *      pcx86('r')
                 *      pcx86('dw 0:0')
                 *      pcx86('h')
                 *      ...
                 *
                 * If you have no desire to stop on assertions, consider this a no-op.  However, another
                 * potential benefit of creating an Error object is that, for browsers like Chrome, we get
                 * a stack trace, too.
                 */
                try {
                    throw new Error(s);
                } catch(e) {
                    Component.printf(MESSAGE.ERROR, "%s\n", e.stack || e.message);
                }
            }
        }
    }

    /**
     * Component.warning(s)
     *
     * @param {string} s describes the warning
     */
    static warning(s)
    {
        Component.printf(MESSAGE.WARNING, s);
    }

    /**
     * Component.error(s)
     *
     * @param {string} s describes the error; an alert() is displayed as well
     */
    static error(s)
    {
        Component.printf(MESSAGE.ERROR, s);
    }

    /**
     * Component.alertUser(sMessage, fPrinted)
     *
     * @param {string} sMessage
     * @param {boolean} [fPrinted] (true if the message has already been printed)
     */
    static alertUser(sMessage, fPrinted)
    {
        if (globals.window.alert) {
            globals.window.alert(sMessage);
        }
        if (!fPrinted) console.log(sMessage);
    }

    /**
     * Component.confirmUser(sPrompt)
     *
     * @param {string} sPrompt
     * @returns {boolean} true if the user clicked OK, false if Cancel/Close
     */
    static confirmUser(sPrompt)
    {
        let fResponse = false;
        if (globals.window.confirm) {
            fResponse = globals.window.confirm(sPrompt);
        }
        return fResponse;
    }

    /**
     * Component.promptUser()
     *
     * @param {string} sPrompt
     * @param {string} [sDefault]
     * @returns {string|null}
     */
    static promptUser(sPrompt, sDefault)
    {
        let sResponse = null;
        if (globals.window.prompt) {
            sResponse = globals.window.prompt(sPrompt, sDefault === undefined? "" : sDefault);
        }
        return sResponse;
    }

    /**
     * Component.appendControl(control, sText)
     *
     * @param {Object} control
     * @param {string} sText
     */
    static appendControl(control, sText)
    {
        control.value += sText;
        /*
         * Prevent the <textarea> from getting too large; otherwise, printing becomes slower and slower.
         */
        if (COMPILED) {
            sText = control.value;
            if (sText.length > 8192) control.value = sText.substr(sText.length - 4096);
        }
        control.scrollTop = control.scrollHeight;
    }

    /**
     * Component.replaceControl(control, sSearch, sReplace)
     *
     * @param {Object} control
     * @param {string} sSearch
     * @param {string} sReplace
     */
    static replaceControl(control, sSearch, sReplace)
    {
        let sText = control.value;
        let i = sText.lastIndexOf(sSearch);
        if (i < 0) {
            sText += sSearch + '\n';
        } else {
            sText = sText.substr(0, i) + sReplace + sText.substr(i + sSearch.length);
        }
        /*
         * Prevent the <textarea> from getting too large; otherwise, printing becomes slower and slower.
         */
        if (COMPILED && sText.length > 8192) sText = sText.substr(sText.length - 4096);
        control.value = sText;
        control.scrollTop = control.scrollHeight;
    }

    /**
     * Component.bindExternalControl(component, sBinding, sType)
     *
     * @param {Component} component
     * @param {string} sBinding
     * @param {string} [sType] is the external component type (default is "Panel")
     */
    static bindExternalControl(component, sBinding, sType = "Panel")
    {
        if (sBinding) {
            let target = Component.getComponentByType(sType, component.id);
            if (target) {
                let control = target.bindings[sBinding];
                if (control) {
                    component.setBinding("", sBinding, control);
                }
            }
        }
    }

    /**
     * Component.bindComponentControls(component, element, sAppClass)
     *
     * @param {Component} component
     * @param {HTMLElement} element (from the DOM)
     * @param {string} sAppClass
     */
    static bindComponentControls(component, element, sAppClass)
    {
        let aeControls = Component.getElementsByClass(sAppClass + "-control", "", element.parentNode);

        for (let iControl = 0; iControl < aeControls.length; iControl++) {

            let aeChildNodes = aeControls[iControl].childNodes;

            for (let iNode = 0; iNode < aeChildNodes.length; iNode++) {
                let control = aeChildNodes[iNode];
                if (control.nodeType !== 1 /* document.ELEMENT_NODE */) {
                    continue;
                }
                let sClass = control.getAttribute("class");
                if (!sClass) continue;
                let aClasses = sClass.split(" ");
                for (let iClass = 0; iClass < aClasses.length; iClass++) {
                    let parms;
                    sClass = aClasses[iClass];
                    switch (sClass) {
                        case sAppClass + "-binding":
                            parms = Component.getComponentParms(/** @type {HTMLElement} */(control));
                            if (parms && parms['binding'] !== undefined) {
                                component.setBinding(parms['type'], parms['binding'], /** @type {HTMLElement} */(control), parms['value']);
                            } else if (!parms || parms['type'] != "description") {
                                Component.printf(MESSAGE.WARNING, "Component \"%s\" missing binding%s\n", component.toString(), (parms? " for " + parms['type'] : ""));
                            }
                            iClass = aClasses.length;
                            break;
                        default:
                            // if (DEBUG) Component.printf(MESSAGE.WARNING, "Component.bindComponentControls(%s): unrecognized control class \"%s\"\n", component.toString(), sClass);
                            break;
                    }
                }
            }
        }
    }

    /**
     * Component.getComponents(idRelated)
     *
     * We could store components as properties, using the component's ID, and change
     * this linear lookup into a property lookup, but some components may have no ID.
     *
     * @param {string} [idRelated] of related component, if any
     * @returns {Array} of components
     */
    static getComponents(idRelated)
    {
        let i;
        let aComponents = [];
        /*
         * If idRelated is provided, we check it for a machine prefix, and use any
         * existing prefix to constrain matches to IDs with the same prefix, in order to
         * avoid matching components belonging to other machines.
         */
        if (idRelated && (i = idRelated.indexOf('.')) > 0) {
            idRelated = idRelated.substr(0, i + 1);
        }
        let components = globals.pcjs['components'];
        for (i = 0; i < components.length; i++) {
            let component = components[i];
            if (!idRelated || component.id.indexOf(idRelated) == 0) {
                aComponents.push(component);
            }
        }
        return aComponents;
    }

    /**
     * Component.getComponentByID(id, idRelated)
     *
     * We could store components as properties, using the component's ID, and change
     * this linear lookup into a property lookup, but some components may have no ID.
     *
     * @param {string} id of the desired component
     * @param {string|boolean} [idRelated] of related component
     * @returns {Component|null}
     */
    static getComponentByID(id, idRelated)
    {
        if (id !== undefined) {
            let i;
            /*
             * If idRelated is provided, we check it for a machine prefix, and use any
             * existing prefix to constrain matches to IDs with the same prefix, in order to
             * avoid matching components belonging to other machines.
             */
            if (idRelated && (i = idRelated.indexOf('.')) > 0) {
                id = idRelated.substr(0, i + 1) + id;
            }
            let components = globals.pcjs['components'];
            for (i = 0; i < components.length; i++) {
                if (components[i]['id'] === id) {
                    return components[i];
                }
            }
            if (components.length && idRelated !== false) {
                Component.printf(MESSAGE.WARNING, "Component ID \"%s\" not found\n", id);
            }
        }
        return null;
    }

    /**
     * Component.getComponentByType(sType, idRelated, componentPrev)
     *
     * @param {string} sType of the desired component
     * @param {string} [idRelated] of related component
     * @param {Component|boolean|null} [componentPrev] of previously returned component, if any
     * @returns {Component|null}
     */
    static getComponentByType(sType, idRelated, componentPrev = null)
    {
        if (sType !== undefined) {
            let i;
            /*
             * If idRelated is provided, we check it for a machine prefix, and use any
             * existing prefix to constrain matches to IDs with the same prefix, in order to
             * avoid matching components belonging to other machines.
             */
            if (idRelated) {
                if ((i = idRelated.indexOf('.')) > 0) {
                    idRelated = idRelated.substr(0, i + 1);
                } else {
                    idRelated = "";
                }
            }
            let components = globals.pcjs['components'];
            for (i = 0; i < components.length; i++) {
                if (componentPrev) {
                    if (componentPrev == components[i]) componentPrev = null;
                    continue;
                }
                if (sType == components[i].type && (!idRelated || !components[i].id.indexOf(idRelated))) {
                    return components[i];
                }
            }
            if (MAXDEBUG && componentPrev !== false) {
                Component.printf(MESSAGE.WARNING, "Component type \"%s\" not found\n", sType);
            }
        }
        return null;
    }

    /**
     * Component.getComponentParms(element)
     *
     * @param {HTMLElement} element (from the DOM)
     * @returns {Object|null}
     */
    static getComponentParms(element)
    {
        let parms = null;
        if (element.getAttribute) {
            let sParms = element.getAttribute("data-value");
            if (sParms) {
                try {
                    parms = /** @type {Object} */ (eval('(' + sParms + ')'));
                    /*
                    * We can no longer invoke removeAttribute() because some components (eg, Panel) need
                    * to run their initXXX() code more than once, to avoid initialization-order dependencies.
                    *
                    *      if (!DEBUG) {
                    *          element.removeAttribute("data-value");
                    *      }
                    */
                } catch(e) {
                    Component.error(e.message + " (" + sParms + ")");
                }
            }
        } else {
            parms = element['config'] || null;
            if (parms) {
                let idMachine = element['id'], idComponent = parms['id'];
                if (idMachine && idComponent && idComponent.indexOf('.') < 0) parms['id'] = idMachine + '.' + idComponent;
            }
        }
        return parms;
    }

    /**
     * Component.getElementsByClass(sClass, sComponent, element)
     *
     * This is a cross-browser helper function, since not all browser's support getElementsByClassName()
     *
     * TODO: This should probably be moved into weblib.js at some point, along with the control binding functions above,
     * to keep all the browser-related code together.
     *
     * @param {string} sClass
     * @param {string} [sComponent]
     * @param {HTMLElement|Object} [element] (from the DOM; default is document)
     * @returns {Array|NodeList}
     */
    static getElementsByClass(sClass, sComponent = "", element = globals.document)
    {
        let ae = [];
        if (sComponent) {
            sClass += '-' + sComponent;
            if (sComponent != "machine") sClass += "-object";
        }
        /*
         * Use the browser's built-in getElementsByClassName() if it appears to be available
         * (for example, it's not available in IE8, but it should be available in IE9 and up)
         */
        if (globals.browser) {
            if (element.getElementsByClassName) {
                ae = element.getElementsByClassName(sClass);
            }
            else if (element.getElementsByTagName) {
                let i, j;
                let aeAll = element.getElementsByTagName("*");
                let re = new RegExp('(^| )' + sClass + '( |$)');
                for (i = 0, j = aeAll.length; i < j; i++) {
                    if (re.test(aeAll[i].className)) {
                        ae.push(aeAll[i]);
                    }
                }
            }
        } else {
            let machineIDs = Object.keys(globals.pcjs['machines']);
            for (let iMachine = 0; iMachine < machineIDs.length; iMachine++) {
                let idMachine = machineIDs[iMachine];
                let configMachine = globals.pcjs['machines'][idMachine]['config'];
                if (configMachine) {
                    let configComponent = configMachine[sComponent];
                    if (configComponent) {
                        if (!Array.isArray(configComponent)) {
                            configComponent = [configComponent];
                        }
                        for (let component of configComponent) {
                            let fakeElement = {
                                'id': idMachine,
                                'config': component
                            };
                            ae.push(fakeElement);
                        }
                    }
                }
            }
        }
        if (!ae.length) {
            if (MAXDEBUG) Component.printf(MESSAGE.WARNING, "No elements of class \"%s\" found\n", sClass);
        }
        return ae;
    }

    /**
     * Component.getScriptCommands(sScript)
     *
     * This is a simple parser that breaks sScript into an array of commands, where each command
     * is an array of tokens, where tokens are sequences of characters separated by any of: tab, space,
     * carriage-return (CR), line-feed (LF), semicolon, single-quote, or double-quote; if a quote is
     * used, all characters up to the next matching quote become part of the token, allowing any of the
     * other separators to be part of the token.  CR, LF and semicolon also serve to terminate a command,
     * with semicolon being preferred, because it's 1) more visible, and 2) essential when the entire
     * script is a multi-line string where all CR/LF were replaced by spaces (which is what Jekyll does,
     * and since we can't change Jekyll, it's what our own MarkDown Front Matter parser does as well;
     * see convertMD() in markout.js, where the aCommandDefs array is built).
     *
     * Backslash sequences like \n, \r, and \\ have already been converted to LF, CR and backslash
     * characters, since the entire script string is injected into a JavaScript function call, so any
     * backslash sequence that JavaScript supports is automatically converted:
     *
     *      \0  \'  \"  \\  \n  \r  \v  \t  \b  \f  \uXXXX \xXX
     *                      ^J  ^M  ^K  ^I  ^H  ^L
     *
     * To support any other non-printable 8-bit character, such as ESC, you should use \xXX, where XX
     * is the ASCII code in hex.  For ESC, that would be \x1B.
     *
     * @param {string} sScript
     * @returns {Array}
     */
    static getScriptCommands(sScript)
    {
        let cch = sScript.length;
        let commands = [], aTokens = [], sToken = "", chQuote = null;
        for (let i = 0; i < cch; i++) {
            let ch = sScript[i];
            if (ch == '"' || ch == "'") {
                if (chQuote && ch != chQuote) {
                    sToken += ch;
                    continue;
                }
                if (!chQuote) {
                    chQuote = ch;
                } else {
                    chQuote = null;
                }
                if (sToken) {
                    aTokens.push(sToken);
                    sToken = "";
                }
                continue;
            }
            if (!chQuote) {
                if (ch == '\r' || ch == '\n') {
                    ch = ';';
                }
                if (ch == ' ' || ch == '\t' || ch == ';') {
                    if (sToken) {
                        aTokens.push(sToken);
                        sToken = "";
                    }
                    if (ch == ';' && aTokens.length) {
                        commands.push(aTokens);
                        aTokens = [];
                    }
                    continue;
                }
            }
            sToken += ch;
        }
        if (sToken) {
            aTokens.push(sToken);
        }
        if (aTokens.length) {
            commands.push(aTokens);
        }
        return commands;
    }

    /**
     * Component.processScript(idMachine, sScript)
     *
     * @param {string} idMachine
     * @param {string} [sScript]
     * @returns {boolean}
     */
    static processScript(idMachine, sScript)
    {
        let fSuccess = false;
        let commands = globals.pcjs['commands'];
        idMachine += ".machine";
        if (!sScript) {
            delete commands[idMachine];
            fSuccess = true;
        }
        else if (typeof sScript == "string" && !commands[idMachine]) {
            fSuccess = true;
            commands[idMachine] = Component.getScriptCommands(sScript);
            if (!Component.processCommands(idMachine)) {
                fSuccess = false;
            }
        }
        return fSuccess;
    }

    /**
     * Component.processCommands(idMachine)
     *
     * @param {string} idMachine
     * @returns {boolean}
     */
    static processCommands(idMachine)
    {
        let fSuccess = true;
        let commands = globals.pcjs['commands'][idMachine];

     // let dbg = Component.getComponentByType("Debugger", idMachine);

        while (commands && commands.length) {

            let aTokens = commands.splice(0, 1)[0];
            let sCommand = aTokens[0];

            /*
             * It's possible to route this output to the Debugger window with dbg.printf()
             * instead, but it's a bit too confusing mingling script output in a window that
             * already mingles Debugger and machine output.
             */
            Component.printf(MESSAGE.SCRIPT, aTokens.join(' '));

            let fnCallReady = null;
            if (Component.asyncCommands.indexOf(sCommand) >= 0) {
                fnCallReady = function processNextCommand() {
                    return function() {
                        Component.processCommands(idMachine);
                    };
                }();
            }

            let fnCommand = Component.globalCommands[sCommand];
            if (fnCommand) {
                if (!fnCallReady) {
                    fSuccess = fnCommand(aTokens[1], aTokens[2], aTokens[3]);
                } else {
                    if (!fnCommand(fnCallReady, aTokens[1], aTokens[2], aTokens[3])) break;
                }
            }
            else {
                fSuccess = false;
                let component = Component.getComponentByType(aTokens[1], idMachine);
                if (component) {
                    fnCommand = Component.componentCommands[sCommand];
                    if (fnCommand) {
                        fSuccess = fnCommand(component, aTokens[2], aTokens[3]);
                    }
                    else {
                        let exports = component['exports'];
                        if (exports) {
                            fnCommand = exports[sCommand];
                            if (fnCommand) {
                                fSuccess = true;
                                if (!fnCallReady) {
                                    fSuccess = fnCommand.call(component, aTokens[2], aTokens[3]);
                                } else {
                                    if (!fnCommand.call(component, fnCallReady, aTokens[2], aTokens[3])) break;
                                }
                            }
                        }
                    }
                }
            }

            if (!fSuccess) {
                Component.alertUser("Script error: '" + sCommand + "' command " + (fnCommand? " failed" : " not recognized"));
                break;
            }
        }

        if (commands && !commands.length) {
            delete globals.pcjs['commands'][idMachine];
        }

        return fSuccess;
    }

    /**
     * Component.scriptAlert(sMessage)
     *
     * @param {string} sMessage
     * @returns {boolean}
     */
    static scriptAlert(sMessage)
    {
        Component.alertUser(sMessage);
        return true;
    }

    /**
     * Component.scriptSelect(component, sBinding, sValue)
     *
     * @param {Component} component
     * @param {string} sBinding
     * @param {string} sValue
     * @returns {boolean}
     */
    static scriptSelect(component, sBinding, sValue)
    {
        let fSuccess = false;
        let aBindings = component['bindings'];
        let control = aBindings[sBinding];
        if (control) {
            for (let i = 0; i < control.options.length; i++) {
                if (control.options[i].textContent == sValue) {
                    if (control.selectedIndex != i) {
                        control.selectedIndex = i;
                    }
                    fSuccess = true;
                    break;
                }
            }
        }
        return fSuccess;
    }

    /**
     * Component.scriptSleep(fnCallback, sDelay)
     *
     * @param {function()} fnCallback
     * @param {string} sDelay (in milliseconds)
     * @returns {boolean}
     */
    static scriptSleep(fnCallback, sDelay)
    {
        setTimeout(fnCallback, +sDelay);
        return false;
    }

    /**
     * toString()
     *
     * @this {Component}
     * @returns {string}
     */
    toString()
    {
        return (this.name? this.name : (this.id || this.type));
    }

    /**
     * getMachineNum()
     *
     * @this {Component}
     * @returns {number} unique machine number
     */
    getMachineNum()
    {
        let nMachine = 1;
        if (this.idMachine) {
            let aDigits = this.idMachine.match(/\d+/);
            if (aDigits !== null) {
                nMachine = parseInt(aDigits[0], 10);
            }
        }
        return nMachine;
    }

    /**
     * setBinding(sHTMLType, sBinding, control, sValue)
     *
     * Component's setBinding() method is intended to be overridden by subclasses.
     *
     * @this {Component}
     * @param {string} sHTMLType is the type of the HTML control (eg, "button", "list", "text", "submit", "textarea", "canvas")
     * @param {string} sBinding is the value of the 'binding' parameter stored in the HTML control's "data-value" attribute (eg, 'print')
     * @param {HTMLElement} control is the HTML control DOM object (eg, HTMLButtonElement)
     * @param {string} [sValue] optional data value
     * @returns {boolean} true if binding was successful, false if unrecognized binding request
     */
    setBinding(sHTMLType, sBinding, control, sValue)
    {
        switch (sBinding) {

        case 'clear':
            if (!this.bindings[sBinding]) {
                this.bindings[sBinding] = control;
                control.onclick = (function(component) {
                    return function clearControl() {
                        if (component.bindings['print']) {
                            component.bindings['print'].value = "";
                        }
                    };
                }(this));
            }
            return true;

        case 'print':
            if (!this.bindings[sBinding]) {
                let controlTextArea = /** @type {HTMLTextAreaElement} */(control);
                this.bindings[sBinding] = controlTextArea;
                /*
                 * This was added for Firefox (Safari will clear the <textarea> on a page reload, but Firefox does not).
                 */
                controlTextArea.value = "";
                this.print = function(component, control) {
                    return function printControl(sMessage, bitsMessage = 0) {
                        if (!sMessage) sMessage = "";
                        if (bitsMessage == MESSAGE.PROGRESS && sMessage.slice(-4) == "...\n") {
                            Component.replaceControl(control, sMessage.slice(0, -1), sMessage.slice(0, -1) + ".");
                        } else {
                            Component.appendControl(control, sMessage);
                        }
                        if (!COMPILED) Component.printf(sMessage);
                    };
                }(this, controlTextArea);
            }
            return true;

        default:
            return false;
        }
    }

    /**
     * assert(f, s)
     *
     * Verifies conditions that must be true (for DEBUG builds only).
     *
     * WARNING: Make sure you preface all calls to this.assert() with "if (DEBUG)", because unlike Component.assert(),
     * the Closure Compiler can't be sure that this instance method hasn't been overridden, so it refuses to treat it as
     * dead code in non-DEBUG builds.
     *
     * TODO: Add a task to the build process that "asserts" there are no instances of "assertion failure" in RELEASE builds.
     *
     * @this {Component}
     * @param {boolean|number|undefined} f is the expression asserted to be true
     * @param {string} [s] is a description of the assertion to be displayed or logged on failure
     */
    assert(f, s)
    {
        if (DEBUG) {
            if (!f) {
                s = "assertion failure in " + (this.id || this.type) + (s? ": " + s : "");
                if (DEBUGGER && this.dbg) {
                    this.dbg.stopCPU();
                }

            }
        }
    }

    /**
     * print(s, bitsMessage)
     *
     * Components using print() should wait until after their constructor has run to display any messages;
     * if a Control Panel has been loaded, its override will not take effect until its own constructor has run.
     *
     * @this {Component}
     * @param {string} s
     * @param {number} [bitsMessage] (optional; this method doesn't use it, but some overrides do)
     */
    print(s, bitsMessage = 0)
    {
        Component.printf(bitsMessage, s);
    }

    /**
     * setError(s)
     *
     * Set a fatal error condition
     *
     * TODO: Any cases where we should still prefix the string with "Fatal error: "?
     *
     * @this {Component}
     * @param {string} s describes a fatal error condition
     */
    setError(s)
    {
        this.flags.error = true;
        this.printf(MESSAGE.NOTICE, "%s\n", s);
    }

    /**
     * clearError()
     *
     * Clear any fatal error condition
     *
     * @this {Component}
     */
    clearError() {
        this.flags.error = false;
    }

    /**
     * isError()
     *
     * Report any fatal error condition
     *
     * @this {Component}
     * @returns {boolean} true if a fatal error condition exists, false if not
     */
    isError()
    {
        if (this.flags.error) {
            this.print(this.toString() + " error\n");
            return true;
        }
        return false;
    }

    /**
     * isReady(fnReady)
     *
     * Return the "ready" state of the component; if the component is not ready, it will queue the optional
     * notification function, otherwise it will immediately call the notification function, if any, without queuing it.
     *
     * NOTE: Since only the Computer component actually cares about the "readiness" of other components, the so-called
     * "queue" of notification functions supports exactly one function.  This keeps things nice and simple.
     *
     * @this {Component}
     * @param {function()} [fnReady]
     * @returns {boolean} true if the component is in a "ready" state, false if not
     */
    isReady(fnReady)
    {
        if (fnReady) {
            if (this.flags.ready) {
                fnReady();
            } else {
                if (MAXDEBUG) this.printf(MESSAGE.LOG, "NOT ready\n");
                this.fnReady = fnReady;
            }
        }
        return this.flags.ready;
    }

    /**
     * setReady(fReady)
     *
     * Set the "ready" state of the component to true, and call any queued notification functions.
     *
     * @this {Component}
     * @param {boolean} [fReady] is assumed to indicate "ready" unless EXPLICITLY set to false
     */
    setReady(fReady)
    {
        if (!this.flags.error) {
            this.flags.ready = (fReady !== false);
            if (this.flags.ready) {
                if (MAXDEBUG /* || this.name */) this.printf(MESSAGE.LOG, "ready\n");
                let fnReady = this.fnReady;
                this.fnReady = null;
                if (fnReady) fnReady();
            }
        }
    }

    /**
     * isBusy(fCancel)
     *
     * Return the "busy" state of the component
     *
     * @this {Component}
     * @param {boolean} [fCancel] is set to true to cancel a "busy" state
     * @returns {boolean} true if "busy", false if not
     */
    isBusy(fCancel)
    {
        if (this.flags.busy) {
            if (fCancel) {
                this.flags.busyCancel = true;
            } else if (fCancel === undefined) {
                this.print(this.toString() + " busy\n");
            }
        }
        return this.flags.busy;
    }

    /**
     * setBusy(fBusy)
     *
     * Update the current busy state; if a busyCancel request is pending, it will be honored now.
     *
     * @this {Component}
     * @param {boolean} fBusy
     * @returns {boolean}
     */
    setBusy(fBusy)
    {
        if (this.flags.busyCancel) {
            this.flags.busy = false;
            this.flags.busyCancel = false;
            return false;
        }
        if (this.flags.error) {
            this.print(this.toString() + " error\n");
            return false;
        }
        this.flags.busy = fBusy;
        return this.flags.busy;
    }

    /**
     * powerUp(fSave)
     *
     * @this {Component}
     * @param {Object|null} data
     * @param {boolean} [fRepower] is true if this is "repower" notification
     * @returns {boolean} true if successful, false if failure
     */
    powerUp(data, fRepower)
    {
        this.flags.powered = true;
        return true;
    }

    /**
     * powerDown(fSave, fShutdown)
     *
     * @this {Component}
     * @param {boolean} fSave
     * @param {boolean} [fShutdown]
     * @returns {Object|boolean} component state if fSave; otherwise, true if successful, false if failure
     */
    powerDown(fSave, fShutdown)
    {
        if (fShutdown) this.flags.powered = false;
        return true;
    }

    /**
     * clearBits(num, bits)
     *
     * Helper function for clearing bits in numbers with more than 32 bits.
     *
     * @param {number} num
     * @param {number} bits
     * @returns {number}
     */
    static clearBits(num, bits)
    {
        let shift = Math.pow(2, 32);
        let numHi = (num / shift)|0;
        let bitsHi = (bits / shift)|0;
        return (num & ~bits) + (numHi & ~bitsHi) * shift;
    }

    /**
     * maskBits(num, bits)
     *
     * Helper function for returning bits in numbers with more than 32 bits.
     *
     * @param {number} num
     * @param {number} bits
     * @returns {number}
     */
    static maskBits(num, bits)
    {
        let shift = Math.pow(2, 32);
        let numHi = (num / shift)|0;
        let bitsHi = (bits / shift)|0;
        return (num & bits) + (numHi & bitsHi) * shift;
    }

    /**
     * setBits(num, bits)
     *
     * Helper function for setting bits in numbers with more than 32 bits.
     *
     * @param {number} num
     * @param {number} bits
     * @returns {number}
     */
    static setBits(num, bits)
    {
        let shift = Math.pow(2, 32);
        let numHi = (num / shift)|0;
        let bitsHi = (bits / shift)|0;
        return (num | bits) + (numHi | bitsHi) * shift;
    }

    /**
     * testBits(num, bits)
     *
     * Helper function for testing bits in numbers with more than 32 bits.
     *
     * @param {number} num
     * @param {number} bits
     * @returns {boolean} (true if ALL specified bits are set, false if not)
     */
    static testBits(num, bits)
    {
        let shift = Math.pow(2, 32);
        let numHi = (num / shift)|0;
        let bitsHi = (bits / shift)|0;
        return ((num & bits) == (bits|0) && (numHi & bitsHi) == bitsHi);
    }

    /**
     * messageEnabled(bitsMessage)
     *
     * If bitsMessage is MESSAGE.NONE (0), then the component's Messages category is used.
     *
     * @this {Component}
     * @param {number} [bitsMessage] is zero or more Message flags
     * @returns {boolean} true if the specified message(s) are enabled, false if not
     */
    messageEnabled(bitsMessage = 0)
    {
        /*
         * It's important to subtract MESSAGE.ADDR from bitsMessage before testing for MESSAGE.NONE, because
         * if MESSAGE.ADDR was the ONLY bit specified, we still want to default to the component's message category.
         */
        if (bitsMessage & MESSAGE.ADDR) bitsMessage -= MESSAGE.ADDR;
        bitsMessage = bitsMessage || this.bitsMessage;
        /*
         * printf() calls that specify MESSAGE.DEBUG should be stripped out of non-DEBUG builds, but just in case
         * any of those calls slipped through the cracks, we ensure that DEBUG messages are only printed in DEBUG builds.
         */
        if (DEBUG || !Component.testBits(bitsMessage, MESSAGE.DEBUG)) {
            /*
             * The debugger has the ability to filter any messages listed in MESSAGE.NAMES, and that currently
             * includes message types LOG and WARNING, so if the debugger is loaded, subtract those from the types we allow
             * by default.
             */
            let allowedMessages = MESSAGE.TYPES - (this.dbg? MESSAGE.LOG + MESSAGE.WARNING : 0);
            if (Component.testBits(allowedMessages, bitsMessage) || this.dbg && Component.testBits(this.dbg.bitsMessage, bitsMessage)) {
                return true;
            }
        }
        return false;
    }

    /**
     * printf(format, ...args)
     *
     * If format is a number, it's used as a message number, and the format string is the first arg; the call
     * will be suppressed unless the corresponding message category has been enabled by the debugger.
     *
     * Most components provide a default message number to their constructor, so any printf() without an explicit
     * message number will use that default.  If the caller wants a particular call to ALWAYS print, regardless
     * of whether the debugger has enabled it, the caller can use printf(MESSAGE.NONE), and if the caller wants
     * EVERY call to print, then simply omit any message number from their constructor AND all printf() calls.
     *
     * @this {Component}
     * @param {string|number} format
     * @param {...} args
     */
    printf(format, ...args)
    {
        let bitsMessage = 0;
        if (typeof format == "number") {
            bitsMessage = format || MESSAGE.PROGRESS;
            format = args.shift();
            if (Component.testBits(bitsMessage, MESSAGE.LOG)) {
                format = (this.id || this.type || "log") + ": " + format;
            }
            else if (Component.testBits(bitsMessage, MESSAGE.STATUS)) {
                format = this.type + ": " + format;
            }
        }
        if (this.messageEnabled(bitsMessage)) {
            let sMessage = StrLib.sprintf(format, ...args);
            if (this.dbg && this.dbg.message) {
                this.dbg.message(sMessage, bitsMessage);
            } else {
                this.print(sMessage, bitsMessage);
            }
        }
    }

    /**
     * printIO(port, bOut, addrFrom, name, bIn, bitsMessage)
     *
     * If bitsMessage is not specified, the component's Messages category is used,
     * and if bitsMessage is true, the message is displayed if MESSAGE.PORT is enabled also.
     *
     * @this {Component}
     * @param {number} port
     * @param {number} [bOut] if an output operation
     * @param {number} [addrFrom]
     * @param {string} [name] of the port, if any
     * @param {number} [bIn] is the input value, if known, on an input operation
     * @param {number|boolean} [bitsMessage] is zero or more Messages flag(s)
     */
    printIO(port, bOut, addrFrom, name, bIn, bitsMessage = this.bitsMessage)
    {
        if (DEBUGGER && this.dbg) {
            if (bitsMessage === true) {
                bitsMessage = 0;
            }
            this.dbg.messageIO(this, port, bOut, addrFrom, name, bIn, bitsMessage);
        }
    }
}

/*
 * The following polyfills provide ES5 functionality that's missing in older browsers (eg, IE8),
 * allowing PCjs apps to run without slamming into exceptions; however, due to the lack of HTML5 canvas
 * support in those browsers, all you're likely to see are "soft" errors (eg, "Missing <canvas> support").
 *
 * Perhaps we can implement a text-only faux video display for a fun retro-browser experience someday.
 *
 * TODO: Come up with a better place to put these polyfills.  We will likely have more if we decide to
 * make the leap from ES5 to ES6 features.
 */

/*
 * See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf
 */
if (!Array.prototype.indexOf) {
    Array.prototype.indexOf = function(obj, start) {
        for (let i = (start || 0), j = this.length; i < j; i++) {
            if (this[i] === obj) { return i; }
        }
        return -1;
    };
}

/*
 * See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray
 */
if (!Array.isArray) {
    Array.isArray = function(arg) {
        return Object.prototype.toString.call(arg) === '[object Array]';
    };
}

/*
 * See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind
 */
if (!Function.prototype.bind) {
    Function.prototype.bind = function(obj) {
        if (typeof this != "function") {
            // Closest thing possible to the ECMAScript 5 internal IsCallable function
            throw new TypeError("Function.prototype.bind: non-callable object");
        }
        let args = Array.prototype.slice.call(arguments, 1);
        let fToBind = this;
        let fnNOP = /** @constructor */ (function() {});
        let fnBound = function() {
            return fToBind.apply(this instanceof fnNOP && obj? this : obj, args.concat(/** @type {Array} */(Array.prototype.slice.call(arguments))));
        };
        fnNOP.prototype = this.prototype;
        fnBound.prototype = new fnNOP();
        return fnBound;
    };
}

/**
 * @copyright https://www.pcjs.org/machines/modules/v2/jsonlib.js (C) 2012-2024 Jeff Parsons
 */

/**
 * @class JSONLib
 */
class JSONLib {
    /**
     * parseDiskettes(aDiskettes, library, propPath, server, hostName, limits)
     *
     * @param {Array} aDiskettes
     * @param {Object} library
     * @param {string} [propPath]
     * @param {string} [server]
     * @param {string} [hostName]
     * @param {Array} [limits] (optional drive limits from FDC.getDriveLimits())
     */
    static parseDiskettes(aDiskettes, library, propPath = "/pcx86", server = "", hostName = "", limits = [])
    {
        for (let category in library) {
            if (category[0] == '@') {
                if (category == '@server') server = library[category];
                continue;
            }
            let group = library[category];
            let products = group['@products'];
            if (products) {
                JSONLib.parseDiskettes(aDiskettes, products, propPath + '/' + category, server, hostName, limits);
                continue;
            }
            let versions = group['@versions'];
            if (versions) {
                if (group['@server']) server = group['@server'];
                for (let version in versions) {
                    let release = versions[version];
                    let media = release['@media'];
                    if (!media) continue;
                    for (let i = 0; i < media.length; i++) {
                        let item = media[i];
                        if (!item['@diskette']) continue;
                        /**
                         * One advantage of the new JSON library manifest is that it gives us more information about the
                         * available diskettes before loading any of them.  For example, if the drives support only one head,
                         * we can avoid including any diskette whose '@format' is "PC320K", "PC360K", etc; and if the drives
                         * don't support 80 tracks, we can skip any "PC1200K" and "PC1440K" diskettes.
                         *
                         * Unfortunately, either of those drive criteria must be true for ALL installed drives, due to the way
                         * our UI works, which displays only one list of diskettes for all drives.  But that's reasonable,
                         * since most (if not all) of our machines have matching diskette drives.
                         *
                         * NOTE: It's best not to check for specific '@format' values, because there were many unusual diskette
                         * formats.
                         *
                         * Standard PC formats included:
                         *
                         *      PC160K
                         *      PC180K
                         *      PC320K
                         *      PC360K
                         *      PC720K
                         *      PC1200K
                         *      PC1440K
                         *
                         * Non-standard PC formats included:
                         *
                         *      PC1840K (eg, XDF diskettes that shipped with PC DOS 7.0)
                         *      PC1680K (eg, DMF diskettes that shipped with Windows 95)
                         *
                         * and this list should certainly NOT be considered exhaustive.  Non-PC formats would include things like
                         * game disks with unusual track formats, assorted UNIX distribution diskettes, etc; for those disks,
                         * we haven't come up with a format nomenclature yet, so no '@format' will be specified.  Any disk of unknown
                         * format should always be included.
                         */
                        let format = item['@format'];
                        if (format && limits.length) {
                            let match = format.match(/^PC([0-9]+)K$/);
                            if (match) {
                                let size = +match[1];
                                if (limits[0] == 1 && size > 180 || limits[1] == 40 && size > 360) {
                                    continue;
                                }
                            }
                        }
                        let name = item['@title'];
                        if (!name) {
                            name = release['@title'];
                            if (!name) {
                                name = group['@title'];
                                if (version) name += ' ' + version;
                            }
                            if (media.length > 1) {
                                name += " (Disk " + (i + 1) + ")";
                            }
                        }
                        let path = item['@link'] || (server + propPath + '/' + category + '/' + (version? version + '/' : '') + item['@diskette']);
                        let diskette = {
                            'name': name,
                            'path': path
                        };
                        /**
                         * The FDC calls us with drive limits, and all it cares about is the 'name' and 'path' of each diskette,
                         * so we use those two facts to limit what each diskette object returns.  Other callers, like the DiskImage
                         * utility, want ALL the diskette details.
                         *
                         * All these optional properties are either strings or booleans, except for '@hardware', which is an object
                         * that may contain:
                         *
                         *      'url':      URL of the preferred machine to run the software (eg, "/machines/pcx86/ibm/5150/cga/")
                         *      'config':   a specific configuration file (eg, "/machines/pcx86/ibm/5170/vga/2048kb/machine.xml")
                         *      'drives':   one of more hard drive configs (eg, "[{name:\"20Mb Hard Disk\",type:2,path:\"/harddisks/pcx86/20mb/PCDOS330-WIN310-VGA.json\"}]")
                         *      'options':  assorted hardware options (eg, "mouse")
                         *      'autoType': if present, overrides any '@autoType' set for the software
                         *
                         * The @hardware 'url' parameter is currently only used by /_includes/explorer/software.html, which will craft
                         * a link to the specified machine URL with the first software diskette loaded into one of the disk drives; however,
                         * that feature isn't used much anymore, since we use "diskimage.js --all --checkpage --rebuild" to build dedicated
                         * pages for most every piece of software.
                         *
                         * The 'url' property may take on significance again if we ever provide some kind of UI for launching software
                         * EITHER with a generic machine OR on a dedicated page.
                         */
                        if (!COMPILED) {
                            let title = release['@title'] || group['@title'];
                            if (library['@title'] && title.indexOf(library['@title']) < 0 && library['@title'].indexOf("Misc") < 0) {
                                title = library['@title'] + ' ' + title;
                            }
                            let archive = item['@archive'];
                            let label = item['@label'];
                            let args = item['@args'];
                            let kryoflux = item['@kryoflux'];
                            let normalize = item['@normalize'];
                            let hidden = group['@hidden'] || release['@hidden'];
                            let bootable = release['@bootable'];
                            let autoType = release['@autoType'];
                            let hardware = release['@hardware'];
                            let demos = release['@demos'];
                            let source = item['@source'];
                            let documents = release['@documents'];
                            let info = item['@diskInfo'];
                            if (title) diskette['title'] = title;                       // the software title (as opposed to the diskette name)
                            if (format) diskette['format'] = format;                    // eg, "PC360K"
                            if (archive) diskette['archive'] = archive;                 // eg, "folder", or the name of a specific ".img" file, etc
                            if (label) diskette['label'] = label;                       // the volume label to use (eg, for a diskette generated from a folder)
                            if (args) diskette['args'] = args;                          // DiskImage command-line arguments
                            if (kryoflux) diskette['kryoflux'] = true;                  // true if a Kryoflux dump is available
                            if (normalize) diskette['normalize'] = true;                // true if a line-endings in known text files should be "normalized"
                            if (hidden) diskette['hidden'] = true;                      // true if hidden from the Explorer (still in the library)
                            if (bootable) diskette['bootable'] = true;                  // true if diskette marked bootable
                            if (autoType) diskette['autoType'] = autoType;              // optional custom autoType string
                            if (hardware) diskette['hardware'] = hardware;              // hardware configuration
                            if (demos) diskette['demos'] = demos;                       // names, if any, of pages created to demo the disk(s)
                            if (source) diskette['source'] = source;                    // source (eg, URL) of our copy of the media
                            if (documents) diskette['documents'] = documents;
                            if (info) diskette['info'] = info;
                        }
                        if (!item['@localonly'] || hostName == "localhost") {
                            aDiskettes.push(diskette);
                        }
                    }
                }
                continue;
            }
            if (category[0] == '@') continue;
            JSONLib.parseDiskettes(aDiskettes, group, propPath + '/' + category, group['@server'] || server, hostName, limits);
        }
    }
}

/**
 * @copyright https://www.pcjs.org/machines/pcx86/modules/v2/defines.js (C) 2012-2024 Jeff Parsons
 */

/**
 * @define {string}
 */
const APPCLASS = "pcx86";               // this @define is the default application class (eg, "pcx86", "c1pjs")

/**
 * @define {string}
 */
const APPNAME = "PCx86";                // this @define is the default application name (eg, "PCx86", "C1Pjs")

/**
 * BACKTRACK enables backtracking: a mechanism that allows us to tag every byte of incoming data and follow the
 * flow of that data.
 *
 * It is enabled only if DEBUG is set (implying an un-COMPILED build) and the DEBUGGER is enabled (since it's
 * really only of use to someone using the built-in debugger).
 *
 * TODO: BACKTRACK support may need to be disabled until we have a chance to investigate the problem discussed in
 * Bus.addBackTrackObject(); BACKTRACK support also needs to be updated for the 80386 at some point.
 *
 * @define {boolean}
 */
var BACKTRACK = /* DEBUG && DEBUGGER */ false;

/**
 * BUGS_8086 enables support for known 8086 bugs.  It's turned off by default, because 1) it adds overhead, and
 * 2) it's hard to imagine any software actually being dependent on any of the bugs covered by this (eg, the failure
 * to inhibit hardware interrupts following SS segment loads).
 *
 * This does NOT enable what must be regarded as 8086 "features", such as failing to properly restart string
 * instructions with multiple prefixes after a hardware interrupt, which we simulate regardless, because some software
 * (eg, Central Point Software's PC Tools) uses that to differentiate processors (eg, the Intel 8088 from the NEC V20).
 *
 * @define {boolean}
 */
const BUGS_8086 = false;

/**
 * BYTEARRAYS is a Closure Compiler compile-time option that allocates an Array of numbers for every Memory block,
 * where each a number represents ONE byte; very wasteful, but potentially slightly faster.
 *
 * See the Memory component for details.
 *
 * @define {boolean}
 */
const BYTEARRAYS = false;

/**
 * I386 enables 80386 support.  My preference continues to be one "binary" that supports all implemented CPUs, but
 * I'm providing this to enable a slimmed-down binary, at least until 80386 support is actually finished; at the
 * moment, there's just a lot of scaffolding that bloats the compiled version without adding any real functionality.
 *
 * @define {boolean}
 */
const I386 = true;

/**
 * DESKPRO386 enables COMPAQ DeskPro 386 support.  Requires I386 support as well (duh).
 *
 * @define {boolean}
 */
const DESKPRO386 = I386;

/**
 * PAGEBLOCKS enables 80386 paging support with assistance from the Bus component.  This affects how the Bus component
 * defines physical memory parameters for a 32-bit bus.  With the 8086 and 80286 processors, the Bus component was free
 * to choose any block size for physical memory allocations that made sense for the bus width (eg, 4Kb blocks for a
 * 20-bit bus, or 16Kb blocks for a 24-bit bus).
 *
 * However, for the 80386 processor, it makes more sense to choose a block size that matches the page size (ie, 4Kb),
 * because then we have the option of altering the address-to-memory mapping for any block to match whatever page table
 * mapping is in effect for that address, if any, without requiring another layer of address translation.
 *
 * @define {boolean}
 */
const PAGEBLOCKS = I386;

/**
 * PREFETCH enables the use of a prefetch queue.  As of v1.20.0, PREFETCH support has been updated and retested,
 * but as currently implemented, it does not yield as much improvement as I'd hoped when paging is enabled, so PREFETCH
 * is still off by default.
 *
 * @define {boolean}
 */
const PREFETCH = false;

/**
 * SYMBOLS enables automatic symbol generation from known DLL, EXE and VXD file formats.  It's currently
 * enabled whenever DEBUGGER support is enabled.
 *
 * @define {boolean}
 */
var SYMBOLS = DEBUGGER;

/**
 * TYPEDARRAYS enables use of typed arrays for Memory blocks.  This used to be a compile-time-only option, but I've
 * added Memory access functions for typed arrays (see Memoryx86.afnTypedArray), so support can be enabled dynamically now.
 *
 * See the Memory component for details.
 *
 * @define {boolean}
 */
const TYPEDARRAYS = true; // (typeof ArrayBuffer !== 'undefined');

/**
 * If this is DEBUG (eg, un-COMPILED) code, then allow the user to override BACKTRACK with a "backtrack=false" embedded in
 * the URL; note that the Closure Compiler won't let us alter the BACKTRACK variable, because it's defined as a @define, which
 * implies @const as well, so we must resort to modifying it indirectly, using the global window object.
 *
 * TODO: Consider yet another embedXXX() parameter that would also allow BACKTRACK to be turned off on a page-by-page basis.
 *
 * Deal with WebLib.getURLParm("debug") in /machines/modules/v2/weblib.js at the same time.
 */

if (DEBUG) {
    let backTrack = WebLib.getURLParm("backtrack");
    if (backTrack == "false") {
        globals.window['BACKTRACK'] = false;
    }
}


/**
 * @copyright https://www.pcjs.org/machines/pcx86/modules/v2/message.js (C) 2012-2024 Jeff Parsons
 */

/**
 * PCx86 machine message flags.
 *
 * NOTE: Because this machine defines more than 32 message categories, some of these message flags
 * exceed 32 bits, so when concatenating, be sure to use "+", not "|".
 */
MESSAGE.CPU         = 0x000000000002;
MESSAGE.SEG         = 0x000000000004;
MESSAGE.DESC        = 0x000000000008;
MESSAGE.TSS         = 0x000000000010;
MESSAGE.PORT        = 0x000000000020;
MESSAGE.IOPM        = 0x000000000040;
MESSAGE.NMI         = 0x000000000080;
MESSAGE.TRAP        = 0x000000000100;
MESSAGE.FAULT       = 0x000000000200;
MESSAGE.INT         = 0x000000000400;
MESSAGE.IRQ         = 0x000000000800;
MESSAGE.BUS         = 0x000000001000;
MESSAGE.MEM         = 0x000000002000;
MESSAGE.DMA         = 0x000000004000;
MESSAGE.FDC         = 0x000000008000;
MESSAGE.HDC         = 0x000000010000;
MESSAGE.DISK        = 0x000000020000;
MESSAGE.PIC         = 0x000000040000;
MESSAGE.TIMER       = 0x000000080000;
MESSAGE.CMOS        = 0x000000100000;
MESSAGE.RTC         = 0x000000200000;
MESSAGE.C8042       = 0x000000400000;
MESSAGE.KBD         = 0x000000800000;
MESSAGE.PARALLEL    = 0x000001000000;
MESSAGE.SERIAL      = 0x000002000000;
MESSAGE.MOUSE       = 0x000004000000;
MESSAGE.SPEAKER     = 0x000008000000;
MESSAGE.CHIPSET     = 0x000010000000;
MESSAGE.VIDEO       = 0x000020000000;
MESSAGE.COMPUTER    = 0x000040000000;
MESSAGE.DATA        = 0x000080000000;
MESSAGE.DOS         = 0x000100000000;
MESSAGE.EVENT       = 0x000200000000;
MESSAGE.KEY         = 0x000400000000;
MESSAGE.RESERVED    = 0xfff000000000;

MESSAGE.NAMES['cpu']        = MESSAGE.CPU;
MESSAGE.NAMES['seg']        = MESSAGE.SEG;
MESSAGE.NAMES['desc']       = MESSAGE.DESC;
MESSAGE.NAMES['port']       = MESSAGE.PORT;
MESSAGE.NAMES['tss']        = MESSAGE.TSS;
MESSAGE.NAMES['iopm']       = MESSAGE.IOPM;
MESSAGE.NAMES['int']        = MESSAGE.INT;
MESSAGE.NAMES['nmi']        = MESSAGE.NMI;
MESSAGE.NAMES['fault']      = MESSAGE.FAULT;
MESSAGE.NAMES['trap']       = MESSAGE.TRAP;
MESSAGE.NAMES['bus']        = MESSAGE.BUS;
MESSAGE.NAMES['irq']        = MESSAGE.IRQ;
MESSAGE.NAMES['mem']        = MESSAGE.MEM;
MESSAGE.NAMES['dma']        = MESSAGE.DMA;
MESSAGE.NAMES['fdc']        = MESSAGE.FDC;
MESSAGE.NAMES['hdc']        = MESSAGE.HDC;
MESSAGE.NAMES['disk']       = MESSAGE.DISK;
MESSAGE.NAMES['pic']        = MESSAGE.PIC;
MESSAGE.NAMES['timer']      = MESSAGE.TIMER;
MESSAGE.NAMES['cmos']       = MESSAGE.CMOS;
MESSAGE.NAMES['rtc']        = MESSAGE.RTC;
MESSAGE.NAMES['8042']       = MESSAGE.C8042;
MESSAGE.NAMES['kbd']        = MESSAGE.KBD;
MESSAGE.NAMES['parallel']   = MESSAGE.PARALLEL;
MESSAGE.NAMES['serial']     = MESSAGE.SERIAL;
MESSAGE.NAMES['mouse']      = MESSAGE.MOUSE;
MESSAGE.NAMES['speaker']    = MESSAGE.SPEAKER;
MESSAGE.NAMES['chipset']    = MESSAGE.CHIPSET;
MESSAGE.NAMES['video']      = MESSAGE.VIDEO;
MESSAGE.NAMES['computer']   = MESSAGE.COMPUTER;
MESSAGE.NAMES['dos']        = MESSAGE.DOS;
MESSAGE.NAMES['data']       = MESSAGE.DATA;
MESSAGE.NAMES['event']      = MESSAGE.EVENT;
MESSAGE.NAMES['key']        = MESSAGE.KEY;


/**
 * @copyright https://www.pcjs.org/machines/pcx86/modules/v2/x86.js (C) 2012-2024 Jeff Parsons
 */

const X86 = {
    /**
     * CPU model numbers (supported)
     */
    MODEL_8086:     8086,
    MODEL_8088:     8088,
    MODEL_80186:    80186,
    MODEL_80188:    80188,
    MODEL_80286:    80286,
    MODEL_80386:    80386,

    /**
     * 80386 CPU stepping identifiers (supported)
     */
    STEPPING_80386_A0: (80386+0xA0),    // we have very little information about this stepping...
    STEPPING_80386_A1: (80386+0xA1),    // we know much more about the A1 stepping (see /blog/2015/02/23/README.md)
    STEPPING_80386_B0: (80386+0xB0),    // for now, the only B0 difference in PCx86 is support for XBTS and IBTS
    STEPPING_80386_B1: (80386+0xB1),    // our implementation of the B1 stepping also includes the infamous 32-bit multiplication bug
    STEPPING_80386_B2: (80386+0xB2),    // this is an imaginary stepping that simply means "B1 without the 32-bit multiplication bug" (ie, a B1 with the "double sigma" stamp)
    STEPPING_80386_C0: (80386+0xC0),    // this presumably fixed lots of B1 issues, but it seems to have been quickly superseded by the D0
    STEPPING_80386_D0: (80386+0xD0),    // we don't have any detailed information (eg, errata) for these later steppings
    STEPPING_80386_D1: (80386+0xD1),
    STEPPING_80386_D2: (80386+0xD2),

    /**
     * This constant is used to mark points in the code where the physical address being returned
     * is invalid and should not be used.
     *
     * This value is also used to indicate non-existent EA address calculations, which are usually
     * detected with "regEA === ADDR_INVALID" and "regEAWrite === ADDR_INVALID" tests.  Which means
     * that, technically, we should not use any signed 32-bit value, such as -1 (0xffffffff), since
     * that could also be a valid address on a 32-bit CPU.  So we also leave open the possibility of
     * using a non-numeric value such undefined or null, which is why all ADDR_INVALID tests should
     * use strict equality operators.
     *
     * WARNING: Like many of the properties defined here, ADDR_INVALID is a common constant, which the
     * Closure Compiler will happily inline (with or without @const annotations; in fact, I've yet to
     * see a @const annotation EVER improve automatic inlining).  However, if you don't make ABSOLUTELY
     * certain that this file is included BEFORE the first reference to any of these properties, that
     * automatic inlining will no longer occur.
     */
    ADDR_INVALID: 0x100000000,

    /**
     * Processor Exception Interrupts
     *
     * Of the following exceptions, all are designed to be restartable, except for 0x08 and 0x09 (and 0x0D
     * after an attempt to write to a read-only segment).
     *
     * Error codes are pushed onto the stack for 0x08 (always 0) and 0x0A through 0x0E.
     *
     * Priority: Instruction exception, TRAP, NMI, Processor Extension Segment Overrun, and finally INTR.
     *
     * All exceptions can also occur in real-mode, except where noted.  A GP_FAULT in real-mode can be triggered
     * by "any memory reference instruction that attempts to reference [a] 16-bit word at offset 0xFFFF".
     *
     * Interrupts beyond 0x10 (up through 0x1F) are reserved for future exceptions.
     *
     * Implementation Detail: For any opcode we know must generate a UD_FAULT interrupt, we invoke opInvalid(),
     * NOT opUndefined().  UD_FAULT is for INVALID opcodes, Intel's choice of term "undefined" notwithstanding.
     *
     * We reserve the term "undefined" for opcodes that require more investigation, and we invoke opUndefined()
     * ONLY until an opcode's behavior has finally been defined, at which point it becomes either valid or invalid.
     * The term "illegal" seems completely superfluous; we don't need a third way of describing invalid opcodes.
     *
     * The term "undocumented" should be limited to operations that are valid but Intel simply never documented.
     */
    EXCEPTION: {
        DE_EXC:     0x00,       // Divide Error Exception                   (#DE: fault, no error code)
        DB_EXC:     0x01,       // Debug (aka Single Step Trap) Exception   (#DB: fault or trap)
        NMI:        0x02,       // Non-Maskable Interrupt
        BP_TRAP:    0x03,       // Breakpoint Exception                     (#BP: trap)
        OF_TRAP:    0x04,       // INTO Overflow Exception                  (#OF: trap)
        BR_FAULT:   0x05,       // BOUND Error Exception                    (#BR: fault, no error code)
        UD_FAULT:   0x06,       // Invalid (aka Undefined/Illegal) Opcode   (#UD: fault, no error code)
        NM_FAULT:   0x07,       // No Math Unit Available; see ESC or WAIT  (#NM: fault, no error code)
        DF_FAULT:   0x08,       // Double Fault; see LIDT                   (#DF: fault, with error code)
        MP_FAULT:   0x09,       // Math Unit Protection Fault; see ESC      (#MP: fault, no error code)
        TS_FAULT:   0x0A,       // Invalid Task State Segment Fault         (#TS: fault, with error code; protected-mode only)
        NP_FAULT:   0x0B,       // Not Present Fault                        (#NP: fault, with error code; protected-mode only)
        SS_FAULT:   0x0C,       // Stack Fault                              (#SS: fault, with error code; protected-mode only)
        GP_FAULT:   0x0D,       // General Protection Fault                 (#GP: fault, with error code)
        PF_FAULT:   0x0E,       // Page Fault                               (#PF: fault, with error code)
        MF_FAULT:   0x10        // Math Fault; see ESC or WAIT              (#MF: fault, no error code)
    },
    /**
     * Processor Status flag definitions (stored in regPS)
     */
    PS: {
        CF:     0x0001,     // bit 0: Carry flag
        BIT1:   0x0002,     // bit 1: reserved, always set
        PF:     0x0004,     // bit 2: Parity flag
        BIT3:   0x0008,     // bit 3: reserved, always clear
        AF:     0x0010,     // bit 4: Auxiliary Carry flag (aka Arithmetic flag)
        BIT5:   0x0020,     // bit 5: reserved, always clear
        ZF:     0x0040,     // bit 6: Zero flag
        SF:     0x0080,     // bit 7: Sign flag
        TF:     0x0100,     // bit 8: Trap flag
        IF:     0x0200,     // bit 9: Interrupt flag
        DF:     0x0400,     // bit 10: Direction flag
        OF:     0x0800,     // bit 11: Overflow flag
        IOPL: {
         MASK:  0x3000,     // bits 12-13: I/O Privilege Level (always set on 8086/80186; clear on 80286 reset)
         SHIFT: 12
        },
        NT:     0x4000,     // bit 14: Nested Task flag (always set on 8086/80186; clear on 80286 reset)
        BIT15:  0x8000,     // bit 15: reserved (always set on 8086/80186; clear otherwise)
        RF:    0x10000,     // bit 16: Resume Flag (temporarily disables debug exceptions; 80386 only)
        VM:    0x20000      // bit 17: Virtual 8086 Mode (80386 only)
    },
    CR0: {
        /**
         * Machine Status Word (MSW) bit definitions
         */
        MSW: {
            PE:     0x0001, // protected-mode enabled
            MP:     0x0002, // monitor processor extension (ie, coprocessor)
            EM:     0x0004, // emulate processor extension
            TS:     0x0008, // task switch indicator
            ON:     0xFFF0, // on the 80286, these bits are always on (TODO: Verify)
            MASK:   0xFFFF  // these are the only (MSW) bits that the 80286 can access (within CR0)
        },
        ET: 0x00000010,     // coprocessor type (80287 or 80387); always 1 on post-80386 CPUs
        ON: 0x7FFFFFE0,     // CR0 bits that are always on
        PG: 0x80000000|0,   // 0: paging disabled
    },
    DR7: {                  // Debug Control Register
        L0:     0x00000001,
        G0:     0x00000002,
        L1:     0x00000004,
        G1:     0x00000008,
        L2:     0x00000010,
        G2:     0x00000020,
        L3:     0x00000040,
        G3:     0x00000080,
        ENABLE: 0x000000FF,
        LE:     0x00000100,
        GE:     0x00000200,
        RW0:    0x00030000, // 00: exec-only  01: write-only  10: undefined  11: read/write-only
        LEN0:   0x000C0000, // 00: one-byte,  01: two-byte,   10: undefined  11: four-byte
        RW1:    0x00300000, // 00: exec-only  01: write-only  10: undefined  11: read/write-only
        LEN1:   0x00C00000, // 00: one-byte,  01: two-byte,   10: undefined  11: four-byte
        RW2:    0x03000000, // 00: exec-only  01: write-only  10: undefined  11: read/write-only
        LEN2:   0x0C000000, // 00: one-byte,  01: two-byte,   10: undefined  11: four-byte
        RW3:    0x30000000, // 00: exec-only  01: write-only  10: undefined  11: read/write-only
        LEN3:   0xC0000000|0// 00: one-byte,  01: two-byte,   10: undefined  11: four-byte
    },
    DR6: {                  // Debug Status Register
        B0:     0x00000001,
        B1:     0x00000002,
        B2:     0x00000004,
        B3:     0x00000008,
        BD:     0x00002000, // set if the next instruction will read or write one of the eight debug registers and ICE-386 is also using them
        BS:     0x00004000, // set if the debug handler is entered due to the TF (trap flag) bit set in the EFLAGS register
        BT:     0x00008000  // set before entering the DEBUG handler if a task switch has occurred and the T-bit of the new TSS is set
    },
    SEL: {
        RPL:    0x0003,     // requested privilege level (0-3)
        LDT:    0x0004,     // table indicator (0: GDT, 1: LDT)
        MASK:   0xFFF8      // table offset
    },
    DESC: {                 // Descriptor Table Entry
        LIMIT: {            // LIMIT bits 0-15 (or OFFSET if this is an INTERRUPT or TRAP gate)
            OFFSET:     0x0
        },
        BASE: {             // BASE bits 0-15 (or SELECTOR if this is a TASK, INTERRUPT or TRAP gate)
            OFFSET:     0x2
        },
        ACC: {              // bit definitions for the access word (offset 0x4)
            OFFSET:     0x4,
            BASE1623:                       0x00FF,     // (not used if this a TASK, INTERRUPT or TRAP gate; bits 0-5 are parm count for CALL gates)
            TYPE: {
                OFFSET: 0x5,
                MASK:                       0x1F00,
                SEG:                        0x1000,
                NONSEG:                     0x0F00,
                /**
                 * The following bits apply only when SEG is set
                 */
                CODE:                       0x0800,     // set for CODE, clear for DATA
                ACCESSED:                   0x0100,     // set if accessed, clear if not accessed
                READABLE:                   0x0200,     // CODE: set if readable, clear if exec-only
                WRITABLE:                   0x0200,     // DATA: set if writable, clear if read-only
                CONFORMING:                 0x0400,     // CODE: set if conforming, clear if not
                EXPDOWN:                    0x0400,     // DATA: set if expand-down, clear if not
                /**
                 * Assorted bits that apply only within NONSEG values
                 */
                TSS_BUSY:                   0x0200,
                NONSEG_386:                 0x0800,     // 80386 and up
                /**
                 * The following are all the possible (valid) types (well, except for the variations
                 * of DATA and CODE where the ACCESSED bit (0x0100) may also be set)
                 */
                TSS286:                     0x0100,
                LDT:                        0x0200,
                TSS286_BUSY:                0x0300,
                GATE_CALL:                  0x0400,
                GATE_TASK:                  0x0500,
                GATE286_INT:                0x0600,
                GATE286_TRAP:               0x0700,
                TSS386:                     0x0900,     // 80386 and up
                TSS386_BUSY:                0x0B00,     // 80386 and up
                GATE386_CALL:               0x0C00,     // 80386 and up
                GATE386_INT:                0x0E00,     // 80386 and up
                GATE386_TRAP:               0x0F00,     // 80386 and up
                CODE_OR_DATA:               0x1E00,
                DATA_READONLY:              0x1000,
                DATA_WRITABLE:              0x1200,
                DATA_EXPDOWN:               0x1400,
                DATA_EXPDOWN_WRITABLE:      0x1600,
                CODE_EXECONLY:              0x1800,
                CODE_READABLE:              0x1A00,
                CODE_CONFORMING:            0x1C00,
                CODE_CONFORMING_READABLE:   0x1E00
            },
            DPL: {
                MASK:                       0x6000,
                SHIFT:                      13
            },
            PRESENT:                        0x8000,
            INVALID:    0   // use X86.DESC.ACC.INVALID for invalid ACC values
        },
        EXT: {              // descriptor extension word (reserved on the 80286; "must be zero")
            OFFSET:     0x6,
            LIMIT1619:                      0x000F,
            AVAIL:                          0x0010,     // NOTE: set in various descriptors in OS/2
            /**
             * The BIG bit is known as the D bit for code segments; when set, all addresses and operands
             * in that code segment are assumed to be 32-bit.
             *
             * The BIG bit is known as the B bit for data segments; when set, it indicates: 1) all pushes,
             * pops, calls and returns use ESP instead of SP, and 2) the upper bound of an expand-down segment
             * is 0xffffffff instead of 0xffff.
             */
            BIG:                            0x0040,     // clear if default operand/address size is 16-bit, set if 32-bit
            LIMITPAGES:                     0x0080,     // clear if limit granularity is bytes, set if limit granularity is 4Kb pages
            BASE2431:                       0xFF00
        },
        INVALID: 0          // use X86.DESC.INVALID for invalid DESC values
    },
    LADDR: {                // linear address
        PDE: {              // index of page directory entry
            MASK:   0xFFC00000|0,
            SHIFT:  20      // (addr & DIR.MASK) >>> DIR.SHIFT yields a page directory offset (ie, index * 4)
        },
        PTE: {              // index of page table entry
            MASK:   0x003FF000,
            SHIFT:  10      // (addr & PAGE.MASK) >>> PAGE.SHIFT yields a page table offset (ie, index * 4)
        },
        OFFSET:     0x00000FFF
    },
    PTE: {
        FRAME:      0xFFFFF000|0,
        DIRTY:      0x00000040,         // page has been modified
        ACCESSED:   0x00000020,         // page has been accessed
        USER:       0x00000004,         // set for user level (CPL 3), clear for supervisor level (CPL 0-2)
        READWRITE:  0x00000002,         // set for read/write, clear for read-only (affects CPL 3 only)
        PRESENT:    0x00000001          // set for present page, clear for not-present page
    },
    TSS286: {
        PREV_TSS:   0x00,
        CPL0_SP:    0x02,   // start of values altered by task switches
        CPL0_SS:    0x04,
        CPL1_SP:    0x06,
        CPL1_SS:    0x08,
        CPL2_SP:    0x0A,
        CPL2_SS:    0x0C,
        TASK_IP:    0x0E,
        TASK_PS:    0x10,
        TASK_AX:    0x12,
        TASK_CX:    0x14,
        TASK_DX:    0x16,
        TASK_BX:    0x18,
        TASK_SP:    0x1A,
        TASK_BP:    0x1C,
        TASK_SI:    0x1E,
        TASK_DI:    0x20,
        TASK_ES:    0x22,
        TASK_CS:    0x24,
        TASK_SS:    0x26,
        TASK_DS:    0x28,   // end of values altered by task switches
        TASK_LDT:   0x2A
    },
    TSS386: {
        PREV_TSS:   0x00,
        CPL0_ESP:   0x04,   // start of values altered by task switches
        CPL0_SS:    0x08,
        CPL1_ESP:   0x0c,
        CPL1_SS:    0x10,
        CPL2_ESP:   0x14,
        CPL2_SS:    0x18,
        TASK_CR3:   0x1C,   // (not in TSS286)
        TASK_EIP:   0x20,
        TASK_PS:    0x24,
        TASK_EAX:   0x28,
        TASK_ECX:   0x2C,
        TASK_EDX:   0x30,
        TASK_EBX:   0x34,
        TASK_ESP:   0x38,
        TASK_EBP:   0x3C,
        TASK_ESI:   0x40,
        TASK_EDI:   0x44,
        TASK_ES:    0x48,
        TASK_CS:    0x4C,
        TASK_SS:    0x50,
        TASK_DS:    0x54,
        TASK_FS:    0x58,   // (not in TSS286)
        TASK_GS:    0x5C,   // (not in TSS286) end of values altered by task switches
        TASK_LDT:   0x60,
        TASK_IOPM:  0x64    // (not in TSS286)
    },
    ERRCODE: {
        EXT:        0x0001,
        IDT:        0x0002,
        LDT:        0x0004,
        SELMASK:    0xFFFC
    },
    RESULT: {
        /**
         * Flags were originally computed using 16-bit result registers:
         *
         *      CF: resultZeroCarry & resultSize (ie, 0x100 or 0x10000)
         *      PF: resultParitySign & 0xff
         *      AF: (resultParitySign ^ resultAuxOverflow) & 0x0010
         *      ZF: resultZeroCarry & (resultSize - 1)
         *      SF: resultParitySign & (resultSize >> 1)
         *      OF: (resultParitySign ^ resultAuxOverflow ^ (resultParitySign >> 1)) & (resultSize >> 1)
         *
         * I386 support requires that we now rely on 32-bit result registers:
         *
         *      resultDst, resultSrc, resultArith, resultLogic and resultType
         *
         * and flags are now computed as follows:
         *
         *      CF: ((resultDst ^ ((resultDst ^ resultSrc) & (resultSrc ^ resultArith))) & resultType)
         *      PF: (resultLogic & 0xff)
         *      AF: ((resultArith ^ (resultDst ^ resultSrc)) & 0x0010)
         *      ZF: (resultLogic & ((resultType - 1) | resultType))
         *      SF: (resultLogic & resultType)
         *      OF: (((resultDst ^ resultArith) & (resultSrc ^ resultArith)) & resultType)
         *
         * where resultType contains both a size, which must be one of BYTE (0x80), WORD (0x8000),
         * or DWORD (0x80000000), along with bits for each of the arithmetic and/or logical flags that
         * are currently "cached" in the result registers (eg, X86.RESULT.CF for carry, X86.RESULT.OF
         * for overflow, etc).
         *
         * WARNING: Do not confuse these RESULT flag definitions with the PS flag definitions.  RESULT
         * flags are used only as "cached" flag indicators, packed into bits 0-5 of resultType; they do
         * not match the actual flag bit definitions within the Processor Status (PS) register.
         *
         * Arithmetic operations should call:
         *
         *      setArithResult(dst, src, value, type)
         * eg:
         *      setArithResult(dst, src, dst+src, X86.RESULT.BYTE | X86.RESULT.ALL)
         *
         * and logical operations should call:
         *
         *      setLogicResult(value, type [, carry [, overflow]])
         *
         * Since most logical operations clear both CF and OF, most calls to setLogicResult() can omit the
         * last two optional parameters.
         *
         * The type parameter of these methods indicates both the size of the result (BYTE, WORD or DWORD)
         * and which of the flags should now be considered "cached" by the result registers.  If the previous
         * resultType specifies any flags not present in the new type parameter, then those flags are
         * calculated and written to the appropriate regPS bit(s) *before* the result registers are updated.
         *
         * Arithmetic operations are assumed to represent an "added" result; if a "subtracted" result is
         * provided instead (eg, from CMP, DEC, SUB, etc), then setArithResult() must include a 5th parameter
         * (fSubtract); eg:
         *
         *      setArithResult(dst, src, dst-src, X86.RESULT.BYTE | X86.RESULT.ALL, true)
         *
         * TODO: Consider separating setArithResult() into two functions: setAddResult() and setSubResult().
         */
        BYTE:       0x80,       // result is byte value
        WORD:       0x8000,     // result is word value
        DWORD:      0x80000000|0,
        TYPE:       0x80008080|0,
        CF:         0x01,       // carry flag is cached
        PF:         0x02,       // parity flag is cached
        AF:         0x04,       // aux carry flag is cached
        ZF:         0x08,       // zero flag is cached
        SF:         0x10,       // sign flag is cached
        OF:         0x20,       // overflow flag is cached
        ALL:        0x3F,       // all result flags are cached
        LOGIC:      0x1A,       // all logical flags are cached; see setLogicResult()
        NOTCF:      0x3E        // all result flags EXCEPT carry are cached
    },
    /**
     * Bit values for opFlags, which are all reset to zero prior to each instruction
     */
    OPFLAG: {
        NOREAD:     0x0001,     // disable memory reads for the remainder of the current instruction
        NOWRITE:    0x0002,     // disable memory writes for the remainder of the current instruction
        NOINTR:     0x0004,     // a segreg has been set, or a prefix, or an STI (delay INTR acknowledgement)
        WRAP:       0x0008,     // a segment wrap-around has occurred (relevant to 8086/8088 only)
        SEG:        0x0010,     // segment override
        LOCK:       0x0020,     // lock prefix
        REPZ:       0x0040,     // repeat while Z (NOTE: this value MUST match PS.ZF; see opCMPSb/opCMPSw/opSCASb/opSCASw)
        REPNZ:      0x0080,     // repeat while NZ
        REPEAT:     0x0100,     // an instruction is being repeated (ie, some iteration AFTER the first)
        PUSHSP:     0x0200,     // the SP register is potentially being referenced by a PUSH SP opcode, adjustment may be required
        DATASIZE:   0x0400,     // data size override
        ADDRSIZE:   0x0800,     // address size override
        FAULT:      0x1000,     // a fault occurred during the current instruction
        DBEXC:      0x2000,     // a DB_EXC exception occurred during the current instruction
        IRET:       0x4000      // remembers if we arrived at the current instruction via IRET (used for 8086/8088 "feature" simulation)
    },
    /**
     * Bit values for intFlags
     */
    INTFLAG: {
        NONE:       0x00,
        INTR:       0x01,       // h/w interrupt requested
        TRAP:       0x02,       // trap (INT 0x01) requested
        HALT:       0x04,       // halt (HLT) requested
        DMA:        0x08,       // async DMA operation in progress
        DEBUGGER:   0x10        // debugger checks enabled
    },
    /**
     * Common opcodes (and/or any opcodes we need to refer to explicitly)
     */
    OPCODE: {
        ES:         0x26,       // opES()
        CS:         0x2E,       // opCS()
        SS:         0x36,       // opSS()
        DS:         0x3E,       // opDS()
        PUSHSP:     0x54,       // opPUSHSP()
        PUSHA:      0x60,       // opPUSHA()    (80186 and up)
        POPA:       0x61,       // opPOPA()     (80186 and up)
        BOUND:      0x62,       // opBOUND()    (80186 and up)
        ARPL:       0x63,       // opARPL()     (80286 and up)
        FS:         0x64,       // opFS()       (80386 and up)
        GS:         0x65,       // opGS()       (80386 and up)
        OS:         0x66,       // opOS()       (80386 and up)
        AS:         0x67,       // opAS()       (80386 and up)
        PUSHN:      0x68,       // opPUSHn()    (80186 and up)
        IMULN:      0x69,       // opIMULn()    (80186 and up)
        PUSH8:      0x6A,       // opPUSH8()    (80186 and up)
        IMUL8:      0x6B,       // opIMUL8()    (80186 and up)
        INSB:       0x6C,       // opINSb()     (80186 and up)
        INSW:       0x6D,       // opINSw()     (80186 and up)
        OUTSB:      0x6E,       // opOUTSb()    (80186 and up)
        OUTSW:      0x6F,       // opOUTSw()    (80186 and up)
        ENTER:      0xC8,       // opENTER()    (80186 and up)
        LEAVE:      0xC9,       // opLEAVE()    (80186 and up)
        CALLF:      0x9A,       // opCALLF()
        PUSHF:      0x9C,       // opPUSHF()
        POPF:       0x9D,       // opPOPF()
        MOVSB:      0xA4,       // opMOVSb()
        MOVSW:      0xA5,       // opMOVSw()
        CMPSB:      0xA6,       // opCMPSb()
        CMPSW:      0xA7,       // opCMPSw()
        STOSB:      0xAA,       // opSTOSb()
        STOSW:      0xAB,       // opSTOSw()
        LODSB:      0xAC,       // opLODSb()
        LODSW:      0xAD,       // opLODSw()
        SCASB:      0xAE,       // opSCASb()
        SCASW:      0xAF,       // opSCASw()
        INT3:       0xCC,       // opINT3()
        INTN:       0xCD,       // opINTn()
        INTO:       0xCE,       // opINTO()
        IRET:       0xCF,       // opIRET()
        ESC0:       0xD8,       // opESC0()
        ESC1:       0xD9,       // opESC1()
        ESC2:       0xDA,       // opESC2()
        ESC3:       0xDB,       // opESC3()
        ESC4:       0xDC,       // opESC4()
        ESC5:       0xDD,       // opESC5()
        ESC6:       0xDE,       // opESC6()
        ESC7:       0xDF,       // opESC7()
        LOOPNZ:     0xE0,       // opLOOPNZ()
        LOOPZ:      0xE1,       // opLOOPZ()
        LOOP:       0xE2,       // opLOOP()
        INB:        0xE4,       // opINb()
        INW:        0xE5,       // opINw()
        OUTB:       0xE6,       // opOUTb()
        OUTW:       0xE7,       // opOUTw()
        CALL:       0xE8,       // opCALL()
        JMP:        0xE9,       // opJMP()      (2-byte displacement)
        JMPF:       0xEA,       // opJMPF()
        JMPS:       0xEB,       // opJMPs()     (1-byte displacement)
        INDXB:      0xEC,       // opINDXb()
        INDXW:      0xED,       // opINDXw()
        OUTDXB:     0xEE,       // opOUTDXb()
        OUTDXW:     0xEF,       // opOUTDXw()
        LOCK:       0xF0,       // opLOCK()
        INT1:       0xF1,       // opINT1()
        REPNZ:      0xF2,       // opREPNZ()
        REPZ:       0xF3,       // opREPZ()
        CLI:        0xFA,       // opCLI()
        STI:        0xFB,       // opSTI()
        CLD:        0xFC,       // opCLD()
        STD:        0xFD,       // opSTD()
        GRP4W:      0xFF,
        CALLW:      0x10FF,     // GRP4W: fnCALLw()
        CALLFDW:    0x18FF,     // GRP4W: fnCALLFdw()
        CALLMASK:   0x38FF,     // mask 2-byte GRP4W opcodes with this before comparing to CALLW or CALLFDW
        UD2:        0x0B0F      // UD2 (invalid opcode "guaranteed" to generate UD_FAULT on all post-8086 processors)
    },
    /**
     * Floating Point Unit (FPU), aka Numeric Data Processor (NDP), aka Numeric Processor Extension (NPX), aka Coprocessor definitions
     */
    FPU: {
        MODEL_8087:     8087,
        MODEL_80287:    80287,
        MODEL_80287XL:  80387,  // internally, the 80287XL was an 80387SX, so generally, we treat this as MODEL_80387
        MODEL_80387:    80387,
        CONTROL: {              // FPU Control Word
            IM:     0x0001,     // bit 0: Invalid Operation Mask
            DM:     0x0002,     // bit 1: Denormalized Operand Mask
            ZM:     0x0004,     // bit 2: Zero Divide Mask
            OM:     0x0008,     // bit 3: Overflow Mask
            UM:     0x0010,     // bit 4: Underflow Mask
            PM:     0x0020,     // bit 5: Precision Mask
            EXC:    0x003F,     // all of the above exceptions
            IEM:    0x0080,     // bit 7: Interrupt Enable Mask (0 enables interrupts, 1 masks them; 8087 only)
            PC:     0x0300,     // bits 8-9: Precision Control
            RC: {               // bits 10-11: Rounding Control
              NEAR: 0x0000,
              DOWN: 0x0400,
              UP:   0x0800,
              CHOP: 0x0C00,
              MASK: 0x0C00
            },
            IC:     0x1000,     // bit 12: Infinity Control (0 for Projective, 1 for Affine)
            UNUSED: 0xE040,     // bits 6,13-15: unused
            INIT:   0x03BF      // X86.FPU.CONTROL.IM | X86.FPU.CONTROL.DM | X86.FPU.CONTROL.ZM | X86.FPU.CONTROL.OM | X86.FPU.CONTROL.UM | X86.FPU.CONTROL.PM | X86.FPU.CONTROL.IEM | X86.FPU.CONTROL.PC
        },
        STATUS: {               // FPU Status Word
            IE:     0x0001,     // bit 0: Invalid Operation
            DE:     0x0002,     // bit 1: Denormalized Operand
            ZE:     0x0004,     // bit 2: Zero Divide
            OE:     0x0008,     // bit 3: Overflow
            UE:     0x0010,     // bit 4: Underflow
            PE:     0x0020,     // bit 5: Precision
            SF:     0x0040,     // bit 6: Stack Fault (80387 and later; triggers an Invalid Operation exception)
            EXC:    0x007F,     // all of the above exceptions
            ES:     0x0080,     // bit 7: Error/Exception Status/Summary (Interrupt Request on 8087)
            C0:     0x0100,     // bit 8: Condition Code 0
            C1:     0x0200,     // bit 9: Condition Code 1
            C2:     0x0400,     // bit 10: Condition Code 2
            ST:     0x3800,     // bits 11-13: Stack Top
            ST_SHIFT: 11,
            C3:     0x4000,     // bit 14: Condition Code 3
            CC:     0x4700,     // all condition code bits
            BUSY:   0x8000      // bit 15: Busy
        },
        TAGS: {
            VALID:  0x0,
            ZERO:   0x1,
            SPECIAL:0x2,
            EMPTY:  0x3,
            MASK:   0x3
        }
        /**
            C3 C2 C1 C0     Condition Code (CC) values following an Examine

            0  0  0  0      Valid, positive unnormalized (+Unnormal)
            0  0  0  1      Invalid, positive, exponent=0 (+NaN)
            0  0  1  0      Valid, negative, unnormalized (-Unnormal)
            0  0  1  1      Invalid, negative, exponent=0 (-NaN)
            0  1  0  0      Valid, positive, normalized (+Normal)
            0  1  0  1      Infinity, positive (+Infinity)
            0  1  1  0      Valid, negative, normalized (-Normal)
            0  1  1  1      Infinity, negative (-Infinity)
            1  0  0  0      Zero, positive (+0)
            1  0  0  1      Empty
            1  0  1  0      Zero, negative (-0)
            1  0  1  1      Empty
            1  1  0  0      Invalid, positive, exponent=0 (+Denormal)
            1  1  0  1      Empty
            1  1  1  0      Invalid, negative, exponent=0 (-Denormal)
            1  1  1  1      Empty

                            Condition Code (CC) values following an FCOM or FTST

            0  0  ?  0      ST > source operand (FCOM); ST > 0 (FTST)
            0  0  ?  1      ST < source operand (FCOM); ST < 0 (FTST)
            1  0  ?  0      ST = source operand (FCOM); ST = 0 (FTST)
            1  1  ?  1      ST is not comparable

                            Condition Code (CC) values following a Remainder

            Q1 0  Q0 Q2     Complete reduction (three low bits of quotient stored in C0, C3, and C1)
            ?  1  ?  ?      Incomplete reduction
         */
    },
    CYCLES_8088: {
        nWordCyclePenalty:          4,      // NOTE: accurate for the 8088/80188 only (on the 8086/80186, it applies to odd addresses only)
        nEACyclesBase:              5,      // base or index only (BX, BP, SI or DI)
        nEACyclesDisp:              6,      // displacement only
        nEACyclesBaseIndex:         7,      // base + index (BP+DI and BX+SI)
        nEACyclesBaseIndexExtra:    8,      // base + index (BP+SI and BX+DI require an extra cycle)
        nEACyclesBaseDisp:          9,      // base or index + displacement
        nEACyclesBaseIndexDisp:     11,     // base + index + displacement (BP+DI+n and BX+SI+n)
        nEACyclesBaseIndexDispExtra:12,     // base + index + displacement (BP+SI+n and BX+DI+n require an extra cycle)
        nOpCyclesAAA:               4,      // AAA, AAS, DAA, DAS, TEST acc,imm
        nOpCyclesAAD:               60,
        nOpCyclesAAM:               83,
        nOpCyclesArithRR:           3,      // ADC, ADD, AND, OR, SBB, SUB, XOR and CMP reg,reg cycle time
        nOpCyclesArithRM:           9,      // ADC, ADD, AND, OR, SBB, SUB, and XOR reg,mem (and CMP mem,reg) cycle time
        nOpCyclesArithMR:           16,     // ADC, ADD, AND, OR, SBB, SUB, and XOR mem,reg cycle time
        nOpCyclesArithMID:          1,      // ADC, ADD, AND, OR, SBB, SUB, XOR and CMP mem,imm cycle delta
        nOpCyclesCall:              19,
        nOpCyclesCallF:             28,
        nOpCyclesCallWR:            16,
        nOpCyclesCallWM:            21,
        nOpCyclesCallDM:            37,
        nOpCyclesCLI:               2,
        nOpCyclesCompareRM:         9,      // CMP reg,mem cycle time (same as nOpCyclesArithRM on an 8086 but not on a 80286)
        nOpCyclesCWD:               5,
        nOpCyclesBound:             33,     // N/A if 8086/8088, 33-35 if 80186/80188 (TODO: Determine what the range means for an 80186/80188)
        nOpCyclesInP:               10,
        nOpCyclesInDX:              8,
        nOpCyclesIncR:              3,      // INC reg, DEC reg
        nOpCyclesIncM:              15,     // INC mem, DEC mem
        nOpCyclesInt:               51,
        nOpCyclesInt3D:             1,
        nOpCyclesIntOD:             2,
        nOpCyclesIntOFall:          4,
        nOpCyclesIRet:              32,
        nOpCyclesJmp:               15,
        nOpCyclesJmpF:              15,
        nOpCyclesJmpC:              16,
        nOpCyclesJmpCFall:          4,
        nOpCyclesJmpWR:             11,
        nOpCyclesJmpWM:             18,
        nOpCyclesJmpDM:             24,
        nOpCyclesLAHF:              4,      // LAHF, SAHF, MOV reg,imm
        nOpCyclesLEA:               2,
        nOpCyclesLS:                16,     // LDS, LES
        nOpCyclesLoop:              17,     // LOOP, LOOPNZ
        nOpCyclesLoopZ:             18,     // LOOPZ, JCXZ
        nOpCyclesLoopNZ:            19,     // LOOPNZ
        nOpCyclesLoopFall:          5,      // LOOP
        nOpCyclesLoopZFall:         6,      // LOOPZ, JCXZ
        nOpCyclesMovRR:             2,
        nOpCyclesMovRM:             8,
        nOpCyclesMovMR:             9,
        nOpCyclesMovRI:             10,
        nOpCyclesMovMI:             10,
        nOpCyclesMovAM:             10,
        nOpCyclesMovMA:             10,
        nOpCyclesDivBR:             80,     // range of 80-90
        nOpCyclesDivWR:             124,    // range of 144-162 (lowered to produce a Norton SI performance index of 1.0)
        nOpCyclesDivBM:             86,     // range of 86-96
        nOpCyclesDivWM:             134,    // range of 154-172 (lowered to produce a Norton SI performance index of 1.0)
        nOpCyclesIDivBR:            101,    // range of 101-112
        nOpCyclesIDivWR:            145,    // range of 165-184 (lowered to produce a Norton SI performance index of 1.0)
        nOpCyclesIDivBM:            107,    // range of 107-118
        nOpCyclesIDivWM:            151,    // range of 171-190 (lowered to produce a Norton SI performance index of 1.0)
        nOpCyclesMulBR:             70,     // range of 70-77
        nOpCyclesMulWR:             93,     // range of 113-118 (lowered to produce a Norton SI performance index of 1.0)
        nOpCyclesMulBM:             76,     // range of 76-83
        nOpCyclesMulWM:             104,    // range of 124-139 (lowered to produce a Norton SI performance index of 1.0)
        nOpCyclesIMulBR:            80,     // range of 80-98
        nOpCyclesIMulWR:            108,    // range of 128-154 (lowered to produce a Norton SI performance index of 1.0)
        nOpCyclesIMulBM:            86,     // range of 86-104
        nOpCyclesIMulWM:            114,    // range of 134-160 (lowered to produce a Norton SI performance index of 1.0)
        nOpCyclesNegR:              3,      // NEG reg, NOT reg
        nOpCyclesNegM:              16,     // NEG mem, NOT mem
        nOpCyclesOutP:              10,
        nOpCyclesOutDX:             8,
        nOpCyclesPopAll:            51,     // N/A if 8086/8088, 51 if 80186, 83 if 80188 (TODO: Verify)
        nOpCyclesPopReg:            8,
        nOpCyclesPopMem:            17,
        nOpCyclesPushAll:           36,     // N/A if 8086/8088, 36 if 80186, 68 if 80188 (TODO: Verify)
        nOpCyclesPushReg:           11,     // NOTE: "The 8086 Book" claims this is 10, but it's an outlier....
        nOpCyclesPushMem:           16,
        nOpCyclesPushSeg:           10,
        nOpCyclesPrefix:            2,
        nOpCyclesCmpS:              18,
        nOpCyclesCmpSr0:            9-2,    // reduced by nOpCyclesPrefix
        nOpCyclesCmpSrn:            17-2,   // reduced by nOpCyclesPrefix
        nOpCyclesLodS:              12,
        nOpCyclesLodSr0:            9-2,    // reduced by nOpCyclesPrefix
        nOpCyclesLodSrn:            13-2,   // reduced by nOpCyclesPrefix
        nOpCyclesMovS:              18,
        nOpCyclesMovSr0:            9-2,    // reduced by nOpCyclesPrefix
        nOpCyclesMovSrn:            17-2,   // reduced by nOpCyclesPrefix
        nOpCyclesScaS:              15,
        nOpCyclesScaSr0:            9-2,    // reduced by nOpCyclesPrefix
        nOpCyclesScaSrn:            15-2,   // reduced by nOpCyclesPrefix
        nOpCyclesStoS:              11,
        nOpCyclesStoSr0:            9-2,    // reduced by nOpCyclesPrefix
        nOpCyclesStoSrn:            10-2,   // reduced by nOpCyclesPrefix
        nOpCyclesRet:               8,
        nOpCyclesRetn:              12,
        nOpCyclesRetF:              18,
        nOpCyclesRetFn:             17,
        nOpCyclesShift1M:           15,     // ROL/ROR/RCL/RCR/SHL/SHR/SAR reg,1
        nOpCyclesShiftCR:           8,      // ROL/ROR/RCL/RCR/SHL/SHR/SAR reg,CL
        nOpCyclesShiftCM:           20,     // ROL/ROR/RCL/RCR/SHL/SHR/SAR mem,CL
        nOpCyclesShiftCS:           2,      // this is the left-shift value used to convert the count to the cycle cost
        nOpCyclesTestRR:            3,
        nOpCyclesTestRM:            9,
        nOpCyclesTestRI:            5,
        nOpCyclesTestMI:            11,
        nOpCyclesXchgRR:            4,
        nOpCyclesXchgRM:            17,
        nOpCyclesXLAT:              11
    },
    CYCLES_80286: {
        nWordCyclePenalty:          0,
        nEACyclesBase:              0,
        nEACyclesDisp:              0,
        nEACyclesBaseIndex:         0,
        nEACyclesBaseIndexExtra:    0,
        nEACyclesBaseDisp:          0,
        nEACyclesBaseIndexDisp:     1,
        nEACyclesBaseIndexDispExtra:1,
        nOpCyclesAAA:               3,
        nOpCyclesAAD:               14,
        nOpCyclesAAM:               16,
        nOpCyclesArithRR:           2,
        nOpCyclesArithRM:           7,
        nOpCyclesArithMR:           7,
        nOpCyclesArithMID:          0,
        nOpCyclesCall:              7,      // on the 80286, this ALSO includes the number of bytes in the target instruction
        nOpCyclesCallF:             13,     // on the 80286, this ALSO includes the number of bytes in the target instruction
        nOpCyclesCallWR:            7,      // on the 80286, this ALSO includes the number of bytes in the target instruction
        nOpCyclesCallWM:            11,     // on the 80286, this ALSO includes the number of bytes in the target instruction
        nOpCyclesCallDM:            16,     // on the 80286, this ALSO includes the number of bytes in the target instruction
        nOpCyclesCLI:               3,
        nOpCyclesCompareRM:         6,
        nOpCyclesCWD:               2,
        nOpCyclesBound:             13,
        nOpCyclesInP:               5,
        nOpCyclesInDX:              5,
        nOpCyclesIncR:              2,
        nOpCyclesIncM:              7,
        nOpCyclesInt:               23,     // on the 80286, this ALSO includes the number of bytes in the target instruction
        nOpCyclesInt3D:             0,
        nOpCyclesIntOD:             1,
        nOpCyclesIntOFall:          3,
        nOpCyclesIRet:              17,     // on the 80286, this ALSO includes the number of bytes in the target instruction
        nOpCyclesJmp:               7,      // on the 80286, this ALSO includes the number of bytes in the target instruction
        nOpCyclesJmpF:              11,     // on the 80286, this ALSO includes the number of bytes in the target instruction
        nOpCyclesJmpC:              7,      // on the 80286, this ALSO includes the number of bytes in the target instruction
        nOpCyclesJmpCFall:          3,
        nOpCyclesJmpWR:             7,      // on the 80286, this ALSO includes the number of bytes in the target instruction
        nOpCyclesJmpWM:             11,     // on the 80286, this ALSO includes the number of bytes in the target instruction
        nOpCyclesJmpDM:             15,     // on the 80286, this ALSO includes the number of bytes in the target instruction
        nOpCyclesLAHF:              2,
        nOpCyclesLEA:               3,
        nOpCyclesLS:                7,
        nOpCyclesLoop:              8,      // on the 80286, this ALSO includes the number of bytes in the target instruction
        nOpCyclesLoopZ:             8,      // on the 80286, this ALSO includes the number of bytes in the target instruction
        nOpCyclesLoopNZ:            8,      // on the 80286, this ALSO includes the number of bytes in the target instruction
        nOpCyclesLoopFall:          4,
        nOpCyclesLoopZFall:         4,
        nOpCyclesMovRR:             2,      // this is actually the same as the 8086...
        nOpCyclesMovRM:             3,
        nOpCyclesMovMR:             5,
        nOpCyclesMovRI:             2,
        nOpCyclesMovMI:             3,
        nOpCyclesMovAM:             5,      // this is actually slower than the MOD/RM form of MOV AX,mem (see nOpCyclesMovRM)
        nOpCyclesMovMA:             3,
        nOpCyclesDivBR:             14,
        nOpCyclesDivWR:             22,
        nOpCyclesDivBM:             17,
        nOpCyclesDivWM:             25,
        nOpCyclesIDivBR:            17,
        nOpCyclesIDivWR:            25,
        nOpCyclesIDivBM:            20,
        nOpCyclesIDivWM:            28,
        nOpCyclesMulBR:             13,
        nOpCyclesMulWR:             21,
        nOpCyclesMulBM:             16,
        nOpCyclesMulWM:             24,
        nOpCyclesIMulBR:            13,
        nOpCyclesIMulWR:            21,
        nOpCyclesIMulBM:            16,
        nOpCyclesIMulWM:            24,
        nOpCyclesNegR:              2,
        nOpCyclesNegM:              7,
        nOpCyclesOutP:              5,
        nOpCyclesOutDX:             5,
        nOpCyclesPopAll:            19,
        nOpCyclesPopReg:            5,
        nOpCyclesPopMem:            5,
        nOpCyclesPushAll:           17,
        nOpCyclesPushReg:           3,
        nOpCyclesPushMem:           5,
        nOpCyclesPushSeg:           3,
        nOpCyclesPrefix:            0,
        nOpCyclesCmpS:              8,
        nOpCyclesCmpSr0:            5,
        nOpCyclesCmpSrn:            9,
        nOpCyclesLodS:              5,
        nOpCyclesLodSr0:            5,
        nOpCyclesLodSrn:            4,
        nOpCyclesMovS:              5,
        nOpCyclesMovSr0:            5,
        nOpCyclesMovSrn:            4,
        nOpCyclesScaS:              7,
        nOpCyclesScaSr0:            5,
        nOpCyclesScaSrn:            8,
        nOpCyclesStoS:              3,
        nOpCyclesStoSr0:            4,
        nOpCyclesStoSrn:            3,
        nOpCyclesRet:               11,     // on the 80286, this ALSO includes the number of bytes in the target instruction
        nOpCyclesRetn:              11,     // on the 80286, this ALSO includes the number of bytes in the target instruction
        nOpCyclesRetF:              15,     // on the 80286, this ALSO includes the number of bytes in the target instruction
        nOpCyclesRetFn:             15,     // on the 80286, this ALSO includes the number of bytes in the target instruction
        nOpCyclesShift1M:           7,
        nOpCyclesShiftCR:           5,
        nOpCyclesShiftCM:           8,
        nOpCyclesShiftCS:           0,
        nOpCyclesTestRR:            2,
        nOpCyclesTestRM:            6,
        nOpCyclesTestRI:            3,
        nOpCyclesTestMI:            6,
        nOpCyclesXchgRR:            3,
        nOpCyclesXchgRM:            5,
        nOpCyclesXLAT:              5
    },
    /**
     * TODO: All 80386 cycle counts are based on 80286 counts until I have time to hand-generate an 80386-specific table;
     * the values below are used by selected 32-bit opcode handlers only.
     */
    CYCLES_80386: {
        nEACyclesBase:              0,
        nEACyclesDisp:              0,
        nEACyclesBaseIndex:         0,
        nEACyclesBaseIndexExtra:    0,
        nEACyclesBaseDisp:          0,
        nEACyclesBaseIndexDisp:     1,
        nEACyclesBaseIndexDispExtra:1
    }
};

/**
 * BACKTRACK-related definitions (used only if BACKTRACK is defined)
 */
X86.BTINFO = {
    SP_LO:  0,
    SP_HI:  0
};

/**
 * These PS flags are always stored directly in regPS for the 8086/8088, hence the
 * "direct" designation; other processors must adjust these bits accordingly.  The final
 * adjusted value is stored in PS_DIRECT (ie, 80286 and up also include PS.IOPL.MASK and
 * PS.NT in PS_DIRECT).
 */
X86.PS_DIRECT_8086 = (X86.PS.TF | X86.PS.IF | X86.PS.DF);

/**
 * These are the default "always set" PS bits for the 8086/8088; other processors must
 * adjust these bits accordingly.  The final adjusted value is stored in PS_SET.
 */
X86.PS_SET_8086 = (X86.PS.BIT1 | X86.PS.IOPL.MASK | X86.PS.NT | X86.PS.BIT15);

/**
 * These PS arithmetic and logical flags may be "cached" across several result registers;
 * whether or not they're currently cached depends on the RESULT bits in resultType.
 */
X86.PS_CACHED = (X86.PS.CF | X86.PS.PF | X86.PS.AF | X86.PS.ZF | X86.PS.SF | X86.PS.OF);

/**
 * PS_SAHF is a subset of the arithmetic flags, and refers only to those flags that the
 * SAHF and LAHF "8080 legacy" opcodes affect.
 */
X86.PS_SAHF = (X86.PS.CF | X86.PS.PF | X86.PS.AF | X86.PS.ZF | X86.PS.SF);

/**
 * Before we zero opFlags, we first see if any of the following PREFIX bits were set.  If any were set,
 * they are OR'ed into opPrefixes; otherwise, opPrefixes is zeroed as well.  This gives prefix-conscious
 * instructions like LODS, MOVS, STOS, CMPS, etc, a way of determining which prefixes, if any, immediately
 * preceded them.
 */
X86.OPFLAG_PREFIXES = (X86.OPFLAG.SEG | X86.OPFLAG.LOCK | X86.OPFLAG.REPZ | X86.OPFLAG.REPNZ | X86.OPFLAG.DATASIZE | X86.OPFLAG.ADDRSIZE);


/**
 * @copyright https://www.pcjs.org/machines/pcx86/modules/v2/charset.js (C) 2012-2024 Jeff Parsons
 */

/**
 * This class is primarily concerned with converting characters between CP437 and UTF-8, when
 * extracting files from PC media or recreating files onto PC media, which is why it is located
 * in the "pcx86" section of the project.
 *
 * @class CharSet
 */
class CharSet {

    /**
     * fromCP437(data, translateControl)
     *
     * @param {number|Array|string|DataBuffer} data
     * @param {boolean} [translateControl] (true to translate control characters; default is false)
     * @returns {string}
     */
    static fromCP437(data, translateControl = false)
    {
        let u = "";
        if (typeof data == "number") data = [data];
        for (let i = 0; i < data.length; i++) {
            let c;
            if (Array.isArray(data)) {
                c = data[i];
            } else {
                c = typeof data == "string"? data.charCodeAt(i) : data.readUInt8(i);
            }
            if (c < CharSet.CP437.length && (c >= 32 || translateControl)) {
                u += CharSet.CP437[c];
            } else {
                u += String.fromCharCode(c);
            }
        }
        return u;
    }

    /**
     * toCP437(u)
     *
     * @param {string} u
     * @returns {string}
     */
    static toCP437(u)
    {
        let s = "";
        for (let i = 0; i < u.length; i++) {
            let c = CharSet.CP437.indexOf(u[i]);
            if (c > 0) {
                s += String.fromCharCode(c);
            } else {
                s += u[i];
            }
        }
        return s;
    }

    /**
     * isCP437(c)
     *
     * @param {string} c
     * @returns {boolean} (true if UTF-8 character exists in CP437 character set)
     */
    static isCP437(c)
    {
        return CharSet.CP437.indexOf(c) >= 0;
    }

    /**
     * isText(data)
     *
     * It can be hard to differentiate between a binary file and a text file that's using
     * lots of IBM PC graphics characters.  Control characters are often red flags, but they
     * can also be interpreted as graphics characters.
     *
     * @param {string} data
     * @returns {boolean} true if data is entirely non-NULL 7-bit ASCII and/or valid CP437 characters
     */
    static isText(data)
    {
        for (let i = 0; i < data.length; i++) {
            let b = data.charCodeAt(i);
            if (b == 0 || b >= 0x80 && !CharSet.isCP437(data[i])) {
                return false;
            }
        }
        return true;
    }

    /**
     * toUpperCaseASCII(s)
     *
     * @param {string} s
     * @returns {string}
     */
    static toUpperCaseASCII(s)
    {
        let u = "";
        for (let i = 0; i < s.length; i++) {
            let c = s.charCodeAt(i);
            if (c >= 0x61 && c <= 0x7a) {
                c -= 0x20;
            }
            u += String.fromCharCode(c);
        }
        return u;
    }
}

/**
 * Table to convert CP437 characters to Unicode.
 *
 * Refer to: https://en.wikipedia.org/wiki/Code_page_437
 */
CharSet.CP437 = [
    '\u0000', '\u263A', '\u263B', '\u2665', '\u2666', '\u2663', '\u2660', '\u2022',
    '\u25D8', '\u25CB', '\u25D9', '\u2642', '\u2640', '\u266A', '\u266B', '\u263C',
    '\u25BA', '\u25C4', '\u2195', '\u203C', '\u00B6', '\u00A7', '\u25AC', '\u21A8',
    '\u2191', '\u2193', '\u2192', '\u2190', '\u221F', '\u2194', '\u25B2', '\u25BC',
    '\u0020', '\u0021', '\u0022', '\u0023', '\u0024', '\u0025', '\u0026', '\u0027',
    '\u0028', '\u0029', '\u002A', '\u002B', '\u002C', '\u002D', '\u002E', '\u002F',
    '\u0030', '\u0031', '\u0032', '\u0033', '\u0034', '\u0035', '\u0036', '\u0037',
    '\u0038', '\u0039', '\u003A', '\u003B', '\u003C', '\u003D', '\u003E', '\u003F',
    '\u0040', '\u0041', '\u0042', '\u0043', '\u0044', '\u0045', '\u0046', '\u0047',
    '\u0048', '\u0049', '\u004A', '\u004B', '\u004C', '\u004D', '\u004E', '\u004F',
    '\u0050', '\u0051', '\u0052', '\u0053', '\u0054', '\u0055', '\u0056', '\u0057',
    '\u0058', '\u0059', '\u005A', '\u005B', '\u005C', '\u005D', '\u005E', '\u005F',
    '\u0060', '\u0061', '\u0062', '\u0063', '\u0064', '\u0065', '\u0066', '\u0067',
    '\u0068', '\u0069', '\u006A', '\u006B', '\u006C', '\u006D', '\u006E', '\u006F',
    '\u0070', '\u0071', '\u0072', '\u0073', '\u0074', '\u0075', '\u0076', '\u0077',
    '\u0078', '\u0079', '\u007A', '\u007B', '\u007C', '\u007D', '\u007E', '\u2302',
    '\u00C7', '\u00FC', '\u00E9', '\u00E2', '\u00E4', '\u00E0', '\u00E5', '\u00E7',
    '\u00EA', '\u00EB', '\u00E8', '\u00EF', '\u00EE', '\u00EC', '\u00C4', '\u00C5',
    '\u00C9', '\u00E6', '\u00C6', '\u00F4', '\u00F6', '\u00F2', '\u00FB', '\u00F9',
    '\u00FF', '\u00D6', '\u00DC', '\u00A2', '\u00A3', '\u00A5', '\u20A7', '\u0192',
    '\u00E1', '\u00ED', '\u00F3', '\u00FA', '\u00F1', '\u00D1', '\u00AA', '\u00BA',
    '\u00BF', '\u2310', '\u00AC', '\u00BD', '\u00BC', '\u00A1', '\u00AB', '\u00BB',
    '\u2591', '\u2592', '\u2593', '\u2502', '\u2524', '\u2561', '\u2562', '\u2556',
    '\u2555', '\u2563', '\u2551', '\u2557', '\u255D', '\u255C', '\u255B', '\u2510',
    '\u2514', '\u2534', '\u252C', '\u251C', '\u2500', '\u253C', '\u255E', '\u255F',
    '\u255A', '\u2554', '\u2569', '\u2566', '\u2560', '\u2550', '\u256C', '\u2567',
    '\u2568', '\u2564', '\u2565', '\u2559', '\u2558', '\u2552', '\u2553', '\u256B',
    '\u256A', '\u2518', '\u250C', '\u2588', '\u2584', '\u258C', '\u2590', '\u2580',
    '\u03B1', '\u00DF', '\u0393', '\u03C0', '\u03A3', '\u03C3', '\u00B5', '\u03C4',
    '\u03A6', '\u0398', '\u03A9', '\u03B4', '\u221E', '\u03C6', '\u03B5', '\u2229',
    '\u2261', '\u00B1', '\u2265', '\u2264', '\u2320', '\u2321', '\u00F7', '\u2248',
    '\u00B0', '\u2219', '\u00B7', '\u221A', '\u207F', '\u00B2', '\u25A0', '\u00A0'
];

// CharSet.CP437Visual = [
//     " ",    "âº",    "â»",    "â¥",    "â¦",    "â£",    "â ",    "â¢",    "â",    "â",    "â",    "â",    "â",    "âª",    "â«",    "â¼",
//     "âº",    "â",    "â",    "â¼",    "Â¶",    "Â§",    "â¬",    "â¨",    "â",    "â",    "â",    "â",    "â",    "â",    "â²",    "â¼",
//     " ",    "!",    "\"",   "#",    "$",    "%",    "&",    "'",    "(",    ")",    "*",    "+",    ",",    "-",    ".",    "/",
//     "0",    "1",    "2",    "3",    "4",    "5",    "6",    "7",    "8",    "9",    ":",    ";",    "<",    "=",    ">",    "?",
//     "@",    "A",    "B",    "C",    "D",    "E",    "F",    "G",    "H",    "I",    "J",    "K",    "L",    "M",    "N",    "O",
//     "P",    "Q",    "R",    "S",    "T",    "U",    "V",    "W",    "X",    "Y",    "Z",    "[",    "\\",   "]",    "^",    "_",
//     "`",    "a",    "b",    "c",    "d",    "e",    "f",    "g",    "h",    "i",    "j",    "k",    "l",    "m",    "n",    "o",
//     "p",    "q",    "r",    "s",    "t",    "u",    "v",    "w",    "x",    "y",    "z",    "{",    "|",    "}",    "~",    "â",
//     "Ã",    "Ã¼",    "Ã©",    "Ã¢",    "Ã¤",    "Ã ",    "Ã¥",    "Ã§",    "Ãª",    "Ã«",    "Ã¨",    "Ã¯",    "Ã®",    "Ã¬",    "Ã",    "Ã",
//     "Ã",    "Ã¦",    "Ã",    "Ã´",    "Ã¶",    "Ã²",    "Ã»",    "Ã¹",    "Ã¿",    "Ã",    "Ã",    "Â¢",    "Â£",    "Â¥",    "â§",    "Æ",
//     "Ã¡",    "Ã­",    "Ã³",    "Ãº",    "Ã±",    "Ã",    "Âª",    "Âº",    "Â¿",    "â",    "Â¬",    "Â½",    "Â¼",    "Â¡",    "Â«",    "Â»",
//     "â",    "â",    "â",    "â",    "â¤",    "â¡",    "â¢",    "â",    "â",    "â£",    "â",    "â",    "â",    "â",    "â",    "â",
//     "â",    "â´",    "â¬",    "â",    "â",    "â¼",    "â",    "â",    "â",    "â",    "â©",    "â¦",    "â ",    "â",    "â¬",    "â§",
//     "â¨",    "â¤",    "â¥",    "â",    "â",    "â",    "â",    "â«",    "âª",    "â",    "â",    "â",    "â",    "â",    "â",    "â",
//     "Î±",    "Ã",    "Î",    "Ï",    "Î£",    "Ï",    "Âµ",    "Ï",    "Î¦",    "Î",    "Î©",    "Î´",    "â",    "Ï",    "Îµ",    "â©",
//     "â¡",    "Â±",    "â¥",    "â¤",    "â ",    "â¡",    "Ã·",    "â",    "Â°",    "â¢",    "Â·",    "â",    "â¿",    "Â²",    "â ",    " "
// ];

/**
 * @copyright https://www.pcjs.org/machines/pcx86/modules/v2/driveinfo.js (C) 2012-2024 Jeff Parsons
 */

/**
 * Starting with the IBM PC XT, the ROM defined a "Fixed Disk Parameter Table" (FD_TBL) that contained 16 bytes
 * at the following offsets for each of 4 drive types (see IBM 5160 Tech Ref, April 1983, p. A-94):
 *
 *      0: maximum number of cylinders (word)
 *      2: maximum number of heads
 *      3: starting reduced write current cylinder (word)
 *      5: starting write precompensation cylinder (word)
 *      7: maximum ECC data burst length
 *      8: control byte (drive step option)
 *          bit 7: disable disk-access retries
 *          bit 6: disable ECC retries
 *          bits 5-3: zero
 *          bits 2-0: drive option
 *      9: standard time-out value
 *      A: time-out value for format drive
 *      B: time-out value for check drive
 *      C: reserved
 *      D: reserved
 *      E: reserved
 *      F: reserved
 *
 * Notice that there is nothing in the PC XT table to indicate the number of sectors/track; this is because
 * the XT BIOS assumed 17 sectors/track; in fact, the number 17 (0x11) is hard-coded in the BIOS function (0x08)
 * that returns drive parameters.
 *
 * Starting with the IBM PC AT, the ROM defined a "Fixed Disk Parameter Table" (FD_TBL) that contained 16 bytes
 * at the following offsets for each of 47 drive types (see IBM 5170 Tech Ref, March 1986, p. 5-185):
 *
 *      0: maximum number of cylinders (word)
 *      2: maximum number of heads
 *      3: not used
 *      5: starting write precompensation cylinder (word)
 *      7: not used
 *      8: control byte (drive step option)
 *          bit 7: disable retries -OR-
 *          bit 6: disable retries
 *          bit 3: more than 8 heads
 *      9: not used
 *      A: not used
 *      B: not used
 *      C: landing zone (word)
 *      E: number of sectors/track (NOTE: all PC AT drive types specified 17 sectors/track)
 *      F: reserved
 *
 * NOTE: While drive type 0 was a valid type in the PC XT, it was NOT a valid drive type in the PC AT; zero was used
 * to indicate that no hard drive was installed.
 *
 * All of the predefined PC AT drive types still used only 17 sectors/track -- but unlike the PC XT, user-defined drive
 * parameter tables could now specify different values.
 *
 * Of the 47 PC AT drive types, the first 14 (1-E) could be selected by 4 bits in CMOS byte 0x12.  Drive type 15 was not
 * a valid type but rather an indicator that CMOS byte 0x19 (or 0x1A) contained the actual drive type, which technically
 * could contain any value from 0-255, but was documented as being limited to values 16-255.  And in fact, the ROM only
 * contained entries for drive types 1-47, and of those, only drive types 1-14 and 16-23 were valid; the rest (15 and 24-47)
 * were marked "RESERVED" and contained zeros.
 *
 * If a system needed a drive type that wasn't defined by the ROM, it could be placed in RAM, as the ROM explained:
 *
 *      To dynamically define a set of parameters, build a table for up to 15 types and place
 *      the corresponding vector into interrupt 0x41 for drive 0 and interrupt 0x46 for drive 1.
 *
 * To make PCjs easier to configure, we have three drive tables (for XT, AT, and COMPAQ machines), each of which
 * contains DriveArrays for the various DriveTypes supported by each machine.  Each DriveArray contains the following
 * subset of "Fixed Disk Parameter Table" information:
 *
 *      [0]: total cylinders
 *      [1]: total heads
 *      [2]: total sectors/tracks (optional; default is 17)
 *      [3]: total bytes/sector (optional; default is 512)
 *
 * verifyDrive() attempts to confirm that these values agree with the programmed drive characteristics.
 *
 * NOTE: For the record, PCjs considers 1Kb to be 1 kilobyte (1,024 bytes, not 1,000 bytes) and 1Mb to be 1 megabyte
 * (1024*1024 or 1,048,576 bytes, not 1,000,000 bytes).
 *
 * Apparently, in 1998, it was decided that a kilobyte should be 1,000 bytes and a megabyte should be 1,000,000 bytes,
 * and that if you really meant 2^10 (1,024) or 2^20 (1,048,576), you should use "kibibyte" (KiB) or "mebibyte" (MiB)
 * instead.  But since PCjs simulates machines that pre-date 1998, I have chosen to retain the more "traditional"
 * understanding of Kb and Mb; I never use KiB or MiB.
 */

/**
 * Drive type tables differed across IBM controller models (XTC drive types don't match ATC drive types) and across OEMs
 * (e.g., COMPAQ drive types only match a few IBM drive types), so you must use iDeviceType to index the correct table type
 * inside both DRIVE_CTRLS and DRIVE_TYPES.
 */
const DRIVE_CTRLS = ["XT", "AT", "COMPAQ"];

const DRIVE_TYPES = [
    /**
     * DRIVE_TYPES[0] is for the IBM PC XT (XTC) controller.
     */
    {
         0: [ 306,  2],         //  5Mb ( 5.08Mb: 306*2*17*512 or  5,326,848 bytes)
         1: [ 375,  8],         // 25Mb (24.90Mb: 375*8*17*512 or 26,112,000 bytes)
         2: [ 306,  6],         // 15Mb (15.24Mb: 306*6*17*512 or 15,980,544 bytes)
         3: [ 306,  4]          // 10Mb (10.16Mb: 306*4*17*512 or 10,653,696 bytes) (default XTC drive type: 3)
    },
    /**
     * DRIVE_TYPES[1] is for the IBM PC AT (ATC) controller.
     */
    {
         0: [1024,16,21,2048],  // arbitrary (reserved for CD-ROMs)
         1: [ 306,  4],         //  10,653,696  10.16
         2: [ 615,  4],         //  21,411,840  20.42 (default ATC drive type)
         3: [ 615,  6],         //  32,117,760  30.63
         4: [ 940,  8],         //  65,454,080  62.42
         5: [ 940,  6],         //  49,090,560  46.82
         6: [ 615,  4],         //  21,411,840  20.42
         7: [ 462,  8],         //  32,169,984  30.68
         8: [ 733,  5],         //  31,900,160  30.42
         9: [ 900, 15],         // 117,504,000 112.06
        10: [ 820,  3],         //  21,411,840  20.42
        11: [ 855,  5],         //  37,209,600  35.49
        12: [ 855,  7],         //  52,093,440  49.68
        13: [ 306,  8],         //  21,307,392  20.32
        14: [ 733,  7],         //  44,660,224  42.59
        /**
         * Since the remaining drive types are > 15, they must be stored in either EXTHDRIVE0 or EXTHDRIVE1 CMOS bytes (0x19 or 0x1A)
         */
        16: [ 612,  4],         //  21,307,392  20.32
        17: [ 977,  5],         //  42,519,040  40.55
        18: [ 977,  7],         //  59,526,656  56.77
        19: [1024,  7],         //  62,390,272  59.50
        20: [ 733,  5],         //  31,900,160  30.42
        21: [ 733,  7],         //  44,660,224  42.59
        22: [ 733,  5],         //  31,900,160  30.42
        23: [ 306,  4]          //  10,653,696  10.16
    },
    /**
     * DRIVE_TYPES[2] is for the COMPAQ DeskPro (ATC) controller.
     *
     * NOTE: According to COMPAQ, drive type 25 (0x19) must be used with their 130Mb drive when using MS-DOS 3.1
     * or earlier, or when using any [unspecified] application software that supports only 17 sectors per track;
     * otherwise, use drive type 35 (0x23), which uses the drive's full capacity of 34 sectors per track.
     */
    {
         0: [1024,16,21,2048],  // arbitrary (reserved for CD-ROMs)
         1: [ 306,  4],         //  306   4  17  512    10,653,696   10.16  (same as IBM)
         2: [ 615,  4],         //  615   4  17  512    21,411,840   20.42  (same as IBM)
         3: [ 615,  6],         //  615   6  17  512    32,117,760   30.63  (same as IBM)
         4: [1023,  8],         // 1023   8  17  512    71,233,536   67.93  (TODO: Cylinders is listed as 1024 in the COMPAQ TechRef; confirm)
         5: [ 940,  6],         //  940   6  17  512    49,090,560   46.82  (same as IBM)
         6: [ 697,  5],         //  697   5  17  512    30,333,440   28.93
         7: [ 462,  8],         //  462   8  17  512    32,169,984   30.68  (same as IBM)
         8: [ 925,  5],         //  925   5  17  512    40,256,000   38.39
         9: [ 900, 15],         //  900  15  17  512   117,504,000  112.06  (same as IBM)
        10: [ 980,  5],         //  980   5  17  512    42,649,600   40.67
        11: [ 925,  7],         //  925   7  17  512    56,358,400   53.75
        12: [ 925,  9],         //  925   9  17  512    72,460,800   69.10
        13: [ 612,  8],         //  612   8  17  512    42,614,784   40.64
        14: [ 980,  4],         //  980   4  17  512    34,119,680   32.54
        /**
         * Since the remaining drive types are > 15, they must be stored in either EXTHDRIVE0 or EXTHDRIVE1 CMOS bytes (0x19 or 0x1A)
         */
        16: [ 612,  4],         //  612   4  17  512    21,307,392   20.32  (same as IBM)
        17: [ 980,  5],         //  980   5  17  512    42,649,600   40.67
        18: [ 966,  6],         //  966   6  17  512    50,448,384   48.11
        19: [1023,  8],         // 1023   8  17  512    71,233,536   67.93
        20: [ 733,  5],         //  733   5  17  512    31,900,160   30.42  (same as IBM)
        21: [ 733,  7],         //  733   7  17  512    44,660,224   42.59  (same as IBM)
        22: [ 768,  6],         //  768   6  17  512    40,108,032   38.25  (DeskPro 386/25 TechRef: [ 524,  4, 40]; May 1987 80286 TechRef: [ 805,  6, 17])
        23: [ 771,  6],         //  771   6  17  512    40,264,704   38.40  (DeskPro 386/25 TechRef: [ 924,  8, 17])
        24: [ 966, 14],         //  966  14  17  512   117,712,896  112.26
        25: [ 966, 16],         //  966  16  17  512   134,529,024  128.30
        26: [1023, 14],         // 1023  14  17  512   124,658,688  118.88
        27: [ 966, 10],         //  966  10  17  512    84,080,640   80.19  (DeskPro 386/25 TechRef: [ 832,  6, 33])
        28: [ 771,  3],         //  771   3  17  512    20,132,352   19.20  (DeskPro 386/25 TechRef: [1222, 15, 34]; May 1987 80286 TechRef: [ 748, 16, 17])
        29: [ 578,  4],         //  578   4  17  512    20,123,648   19.19  (DeskPro 386/25 TechRef: [1240,  7, 34]; May 1987 80286 TechRef: [ 805,  6, 26])
        30: [ 615,  4, 25],     //  615   4  25  512    31,488,000   30.03
        31: [ 615,  8, 25],     //  615   8  25  512    62,976,000   60.06
        32: [ 966,  3, 34],     //  966   3  34  512    50,448,384   48.11  (DeskPro 386/25 TechRef: [ 905,  9, 25])
        33: [ 966,  5, 34],     //  966   5  34  512    84,080,640   80.19  (DeskPro 386/25 TechRef: [ 832,  8, 33]; May 1987 80286 TechRef: [ 748,  8, 34])
        34: [ 966,  7, 34],     //  966   7  34  512   117,712,896  112.26
        35: [ 966,  8, 34],     //  966   8  34  512   134,529,024  128.30
        36: [ 966,  9, 34],     //  966   9  34  512   151,345,152  144.33
        37: [ 966,  5, 34],     //  966   5  34  512    84,080,640   80.19
        38: [1023,  9, 33],     // 1023   9  33  512   155,561,472  148.35  (DeskPro 386/25 TechRef: [ 611, 16, 63]; May 1987 80286 TechRef: [ 611, 16, 63])
        39: [1023, 11, 33],     // 1023  11  33  512   190,130,688  181.32
        40: [1023, 13, 33],     // 1023  13  33  512   224,699,904  214.29  (DeskPro 386/25 TechRef: [1023, 15, 34])
        41: [1023, 15, 33],     // 1023  15  33  512   259,269,120  247.26  (DeskPro 386/25 TechRef: [1630, 15, 52])
        42: [1023, 16, 34],     // 1023  16  34  512   284,934,144  271.73  (DeskPro 386/25 TechRef: [1023, 16, 63])
        43: [ 756,  4, 26],     //  756   4  26  512    40,255,488   38.39  (DeskPro 386/25 TechRef: [ 805,  4, 26])
        44: [ 756,  2, 26],     //  756   2  26  512    20,127,744   19.20  (DeskPro 386/25 TechRef: [ 805,  2, 26])
        45: [ 768,  4, 26],     //  768   4  26  512    40,894,464   39.00  (DeskPro 386/25 TechRef: [ 748,  8, 33])
        46: [ 768,  2, 26],     //  768   2  26  512    20,447,232   19.50  (DeskPro 386/25 TechRef: [ 748,  6, 33])
        47: [ 966,  5, 25]      //  966   5  25  512    61,824,000   58.96
    }
];


/**
 * @copyright https://www.pcjs.org/machines/pcx86/modules/v2/errors.js (C) 2012-2024 Jeff Parsons
 */

const Errors = {
    DOS: {
        INVALID_FUNC:           0x01,       // Invalid function number
        FILE_NOT_FOUND:         0x02,       // File not found
        PATH_NOT_FOUND:         0x03,       // Path not found
        TOO_MANY_OPEN_FILES:    0x04,       // Too many open files (no handles left)
        ACCESS_DENIED:          0x05,       // Access denied
        INVALID_HANDLE:         0x06,       // Invalid handle
        MEM_BLOCK_DAMAGED:      0x07,       // Memory control blocks destroyed
        OUT_OF_MEMORY:          0x08,       // Insufficient memory
        INVALID_MEM_BLOCK:      0x09,       // Invalid memory block address
        INVALID_ENV:            0x0A,       // Invalid environment
        INVALID_FORMAT:         0x0B,       // Invalid format
        INVALID_ACCESS:         0x0C,       // Invalid access code
        INVALID_DATA:           0x0D,       // Invalid data
        INVALID_DRIVE:          0x0F        // Invalid drive specified
    }
};


/**
 * @copyright https://www.pcjs.org/machines/pcx86/modules/v2/interrupts.js (C) 2012-2024 Jeff Parsons
 */

const Interrupts = {
    /**
     * The original ROM BIOS defined vectors 0x08-0x1F with a table at F000:FEF3 (VECTOR_TABLE).
     */
    VIDEO:      0x10,
    EQUIPMENT:  0x11,
    MEM_SIZE:   0x12,
    DISK:       0x13,
    SERIAL:     0x14,
    CASSETTE:   0x15,
    KEYBOARD:   0x16,
    PARALLEL:   0x17,
    BASIC:      0x18,               // normally F600:0000
    BOOTSTRAP:  0x19,
    TIMER:      0x1A,
    KBD_BREAK:  0x1B,
    TMR_BREAK:  0x1C,               // invoked by the BIOS timer interrupt handler (normally vector 0x08)
    VID_PARMS:  0x1D,
    DSK_PARMS:  0x1E,               // vector for Diskette Parameter Table (DPT)
    /**
     * For characters 0x00-0x7F, the original ROM BIOS used a built-in table at F000:FA6E (CRT_CHAR_GEN),
     * since the MDA/CGA font ROM was not CPU-addressable, but presumably there wasn't enough room in the
     * ROM BIOS for all 256 characters, so if software wanted to draw any characters 0x80-0xFF in graphics
     * mode, it was up to software to provide the font data and set the VID_EXT vector to point to it.
     */
    VID_EXT:    0x1F,               // graphics characters 0x80-0xFF (aka EXT_PTR)
    DOS_EXIT:   0x20,
    DOS:        0x21,
    DOS_IDLE:   0x28,
    DOS_NETBIOS:0x2A,
    MOUSE:      0x33,
    ALT_DISK:   0x40,               // HDC ROM saves original FDC vector here
    HD0_PARMS:  0x41,               // vector for Fixed Disk Parameter Table (FDPT) for hard drive 0
    VID_PLANAR: 0x42,               // EGA ROM saves original VIDEO ("planar ROM") vector here
    EGA_GRX:    0x43,               // EGA ROM provides a complete set of mode-appropriate font data here (0000:010C)
    HD1_PARMS:  0x46,               // vector for Fixed Disk Parameter Table (FDPT) for hard drive 1
    HD_PARMS: {
        MAX_CYL:    0x00,           // maximum cylinders (2 bytes)
        MAX_HEADS:  0x02,           // maximum heads (1 byte)
        WP_CYL:     0x05,           // write precompensation cylinder (2 bytes)
        MAX_ECC:    0x07,           // max ECC burst (1 byte)
        DRIVE_CTRL: 0x08,           // drive control (1 byte)
        PARK_CYL:   0x0C,           // landing zone cylinder (2 bytes)
        SEC_TRACK:  0x0E            // sectors per track (1 byte)
    },
    WINCB: {
        VECTOR:     0x30            // Windows PM call-back interface (aka Transfer Space Fault)
    },
    WINDBG: {                       // Windows Debugger protected-mode interface
        VECTOR:     0x41,           // (AX is one of the following DS commands)
        OUTCHAR:    0x0000,         // DS_Out_Char (display the char in DL)
        INCHAR:     0x0001,         // DS_In_Char (read a char into AL)
        OUTSTR:     0x0002,         // DS_Out_Str (display a NUL terminated string pointed to by DS:ESI)
        ISCHAR:     0x0003,         // DS_Is_Char (non-blocking In_Chr)
        OUTSTR16:   0x0012,         // DS_Out_Str16 (display a NUL terminated string pointed to by DS:SI; same as DS_Out_Str but for 16-bit callers)
        FORCEDGO16: 0x0040,         // DS_ForcedGO16 (enter the debugger and perform the equivalent of a GO command to force a stop at the specified CS:IP; CX is the desired CS and BX is the desired IP)
        LINKMAP:    0x0045,         // DS_LinkMap (DX:(E)DI = ptr to paragraph in front of map)
        UNLINKMAP:  0x0046,         // DS_UnlinkMap (DX:(E)DI = ptr to paragraph in front of map)
        CHECKMAP:   0x0047,         // DS_CheckMap (DX:(E)DI = pointer to module name; returns AX != 0 if map found or AX == 0 if map not found)
        AUTOLOAD:   0x0048,         // DS_IsAutoLoadSym (returns AX != 0, auto load symbols; AX == 0, don't auto load symbols)
        IS_LOADED:  0x004F,         // DS_DebLoaded
        LOADED:     0xF386,         // DS_DebPresent (returned in AX in response to DS_DebLoaded if Windows Debugger loaded)
        LOADSEG:    0x0050,         // DS_LoadSeg (SI is 0 if code sel, 1 if data sel, 0x80 if code seg, 0x81 if data seg; BX is segnum-1; CX is sel or seg; DX is data instance; ES:[E]DI -> module name)
        LOADSEG32:  0x0150,         // DS_LoadSeg_32 (SI is 0 0 if code, 1 if data; DX:EBX -> D386_Device_Params)
        FREESEG:    0x0052,         // DS_FreeSeg (BX == segment)
        KRNLVARS:   0x005A,         // DS_Kernel_Vars
        RELSEG:     0x005C,         // DS_ReleaseSeg (same as DS_FreeSeg but "restores any breakpoints first")
        LOADHIGH:   0x005D,         // D386_LoadCodeDataHigh
        EXITCALL:   0x0062,         // DS_EXITCALL
        LOADDLL:    0x0064,         // DS_LOADDLL
        DELMODULE:  0x0065,         // DS_DELMODULE
        UNKNOWN66:  0x0066,         // Unknown (but I suspect it isn't good)
        UNKNOWN67:  0x0067,         // Unknown (but I suspect it isn't good)
        REGDOTCMD:  0x0070,         // DS_RegisterDotCommand
        CHECKFAULT: 0x007F,         // DS_CheckFault (BX == fault #, CX == FAULTTYPE bits; return AX=0 to handle fault normally, 1 to issue TRAPFAULT)
        FAULTTYPE: {
            V86:    0x0001,
            PM:     0x0002,
            RING0:  0x0004,
            FIRST:  0x0008,
            LAST:   0x0010
        },
        TRAPFAULT:  0x0083,         // DS_TrapFault (BX == fault #, CX == faulting CS, EDX == faulting EIP, ESI == fault error, EDI == fault flags)
        GETSYMBOL:  0x008D,         // DS_GetSymbol (DS:ESI -> symbol; return AX == 0 if success, 1 if not found, 2 if memory not loaded yet)
        FREESEG32:  0x0152,         // DS_FreeSeg_32 (BX == segment, DX:EDI -> module name)
        CONDBP:     0xF001,         // DS_CondBP (break here if WDEB386 was run with /B; ESI -> string to display)
        FORCEDBP:   0xF002,         // DS_ForcedBP
        FORCEDGO:   0xF003,         // DS_ForcedGO (enter the debugger and perform the equivalent of a GO command to force a stop at the specified CS:EIP; CX is the desired CS, EBX is the desired EIP)
        HARDINT1:   0xF004,         // DS_HardINT1 (check to see if INT 1 hooked for all rings;  ENTER: nothing, EXIT: AX = 0, if no, 1, if yes)
        ENABLED:    true            // support for WINDBG interrupts can be disabled (but NOT if WINDBGRM is enabled)
    },
    WINDBGRM: {                     // Windows Debugger real-mode interface
        VECTOR:     0x68,           // (AH is one of the following D386 commands)
        IS_LOADED:  0x43,           // D386_Identify
        LOADED:     0xF386,         // D386_Id (returned in AX if Windows Debugger loaded)
        PREP_PMODE: 0x44,           // D386_Prepare_PMode (must return a 16:32 address in ES:EDI to a "PMinit" handler)
        FREESEG:    0x48,           // D386_Free_Segment (BX == real-mode segment)
        REMOVESEGS: 0x4F,           // D386_Remove_Segs (remove any undefined segments from the named module at ES:DI)
        LOADSEG:    0x50,           // D386_Load_Segment (AL=segment type, ES:DI -> D386_Device_Params)
        ENABLED:    true            // support for WINDBGRM interrupts can be disabled
    },
    VIDEO_VGA:  0x6D,               // VGA ROM entry point (the default VGA INT 10h handler invokes this interrupt and IRETs)
    FUNCS: {}                       // filled in only if DEBUGGER is true
};

Interrupts.BIOS_DATA = {
    0x400:  ["RS232_BASE",8],       // BASE ADDRESSES OF RS232 ADAPTERS
    0x408:  ["PRINTER_BASE",8],     // BASE ADDRESSES OF PRINTER ADAPTERS
    0x410:  ["EQUIP_FLAG",2],       // INSTALLED HARDWARE FLAGS
    0x412:  ["MFG_TST",1],          // INITIALIZATION FLAGS
    0x413:  ["MEMORY_SIZE",2],      // BASE MEMORY SIZE IN K BYTES  (X 1024)
    0x415:  ["MFG_ERR_FLAG",2],     // SCRATCHPAD FOR MANUFACTURING ERROR CODES
    0x417:  ["KB_FLAG",1],          // KEYBOARD SHIFT STATE AND STATUS FLAGS
    0x418:  ["KB_FLAG_1",1],        // SECOND BYTE OF KEYBOARD STATUS
    0x419:  ["ALT_INPUT",1],        // STORAGE FOR ALTERNATE KEY PAD ENTRY
    0x41A:  ["BUFFER_HEAD",2],      // POINTER TO HEAD OF KEYBOARD BUFFER
    0x41C:  ["BUFFER_TAIL",2],      // POINTER TO TAIL OF KEYBOARD BUFFER
    0x41E:  ["KB_BUFFER",32],       // ROOM FOR 15 SCAN CODE ENTRIES
    0x43E:  ["SEEK_STATUS",1],      // DRIVE RECALIBRATION STATUS (BIT 3-0 = DRIVE 3-0 RECALIBRATION BEFORE NEXT SEEK IF BIT IS = 0)
    0x43F:  ["MOTOR_STATUS",1],     // MOTOR STATUS (BIT 3-0 = DRIVE 3-0 CURRENTLY RUNNING, BIT 7 = CURRENT OPERATION IS A WRITE)
    0x440:  ["MOTOR_COUNT",1],      // TIME OUT COUNTER FOR MOTOR(S) TURN OFF
    0x441:  ["DISKETTE_STATUS",1],  // RETURN CODE STATUS BYTE
    0x442:  ["NEC_STATUS",7],       // STATUS BYTES FROM DISKETTE OPERATION
    0x449:  ["CRT_MODE",1],         // CURRENT DISPLAY MODE (TYPE)
    0x44A:  ["CRT_COLS",2],         // NUMBER OF COLUMNS ON SCREEN
    0x44C:  ["CRT_LEN",2],          // LENGTH OF REGEN BUFFER IN BYTES
    0x44E:  ["CRT_START",2],        // STARTING ADDRESS IN REGEN BUFFER
    0x450:  ["CURSOR_POSN",16],     // CURSOR FOR EACH OF UP TO 8 PAGES
    0x460:  ["CURSOR_MODE",2],      // CURRENT CURSOR MODE SETTING
    0x462:  ["ACTIVE_PAGE",1],      // CURRENT PAGE BEING DISPLAYED
    0x463:  ["ADDR_6845",2],        // BASE ADDRESS FOR ACTIVE DISPLAY CARD
    0x465:  ["CRT_MODE_SET",1],     // CURRENT SETTING OF THE 3X8 REGISTER
    0x466:  ["CRT_PALETTE",1],      // CURRENT PALETTE SETTING - COLOR CARD
    0x467:  ["IO_ROM_INIT",2],      // POINTER TO ROM INITIALIZATION ROUTINE
    0x469:  ["IO_ROM_SEG",2],       // POINTER TO I/O ROM SEGMENT
    0x46B:  ["INTR_FLAG",1],        // FLAG INDICATING AN INTERRUPT HAPPENED
    0x46C:  ["TIMER_LOW",2],        // LOW WORD OF TIMER COUNT
    0x46E:  ["TIMER_HIGH",2],       // HIGH WORD OF TIMER COUNT
    0x470:  ["TIMER_OFL",1],        // TIMER HAS ROLLED OVER SINCE LAST READ
    0x471:  ["BIOS_BREAK",1],       // BIT 7=1 IF BREAK KEY HAS BEEN PRESSED
    0x472:  ["RESET_FLAG",2],       // WORD=1234H IF KEYBOARD RESET UNDERWAY
    0x474:  ["DISK_STATUS1",1],     // FIXED DISK STATUS
    0x475:  ["HF_NUM",1],           // COUNT OF FIXED DISK DRIVES
    0x476:  ["CONTROL_BYTE",1],     // HEAD CONTROL BYTE
    0x477:  ["PORT_OFF",1],         // RESERVED (PORT OFFSET)
    0x478:  ["PRINT_TIM_OUT",4],    // TIME OUT COUNTERS FOR PRINTER RESPONSE
    0x47C:  ["RS232_TIM_OUT",4],    // TIME OUT COUNTERS FOR RS232 RESPONSE
    0x480:  ["BUFFER_START",2],     // OFFSET OF KEYBOARD BUFFER START
    0x482:  ["BUFFER_END",2],       // OFFSET OF END OF BUFFER
    0x484:  ["ROWS",1],             // ROWS ON THE ACTIVE SCREEN (LESS 1)
    0x485:  ["POINTS",2],           // BYTES PER CHARACTER
    0x487:  ["INFO",1],             // MODE OPTIONS
    0x488:  ["INFO_3",3],           // FEATURE BIT SWITCHES
    0x48B:  ["LASTRATE",1],         // LAST DISKETTE DATA RATE SELECTED
    0x48C:  ["HF_STATUS",1],        // STATUS REGISTER
    0x48D:  ["HF_ERROR",1],         // ERROR REGISTER
    0x48E:  ["HF_INT_FLAG",1],      // FIXED DISK INTERRUPT FLAG
    0x48F:  ["HF_CNTRL",1],         // COMBO FIXED DISK/DISKETTE CARD BIT 0=1
    0x490:  ["DSK_STATE",4],        // DRIVE 0 MEDIA STATE, DRIVE 1 MEDIA STATE, DRIVE 0 OPERATION START STATE, DRIVE 1 OPERATION START STATE
    0x494:  ["DSK_TRK",2],          // DRIVE 0 PRESENT CYLINDER, DRIVE 1 PRESENT CYLINDER
    0x496:  ["KB_FLAG_3",1],        // KEYBOARD MODE STATE AND TYPE FLAGS
    0x497:  ["KB_FLAG_2",1],        // KEYBOARD LED FLAGS
    0x498:  ["USER_FLAG",2],        // OFFSET ADDRESS OF USERS WAIT FLAG
    0x49A:  ["USER_FLAG_SEG",2],    // SEGMENT ADDRESS OF USER WAIT FLAG
    0x49C:  ["RTC_LOW",2],          // LOW WORD OF USER WAIT FLAG
    0x49E:  ["RTC_HIGH",2],         // HIGH WORD OF USER WAIT FLAG
    0x4A0:  ["RTC_WAIT_FLAG",1],    // WAIT ACTIVE FLAG (01=BUSY, 80=POSTED) (00=POST ACKNOWLEDGED)
    0x4A1:  ["NET",7],              // RESERVED FOR NETWORK ADAPTERS
    0x4A8:  ["SAVE_PTR",4]          // POINTER TO EGA PARAMETER CONTROL BLOCK
};

/**
 * See Debuggerx86.prototype.replaceRegs() for the rules governing how register contents are replaced in the strings below.
 *
 * Replacements occur in the following order:
 *
 *      Replace every @XX (or @XXX), where XX (or XXX) is a register, with the register's value.
 *      Replace every #XX, where XX is a hex byte value, with the corresponding ASCII character (if printable).
 *      Replace every $XXXX:XXXX, where XXXX:XXXX is a segmented address, with the zero-terminated string at that address.
 *      Replace every ^XXXX:XXXX, where XXXX:XXXX is a segmented address, with the FCB filename stored at that address.
 *
 * The last replacement is obviously DOS-specific, since FCBs are DOS constructs.
 */
Interrupts.FUNCS[Interrupts.VIDEO] = {
    0x00: "set mode (@AL)",
    0x01: "set cursor type (start=@CH,end=@CL)",
    0x02: "set cursor pos (row=@DH,col=@DL,page=@BH)",
    0x03: "read cursor pos (page=@BH)",
    0x04: "read light pen",
    0x05: "set display page (@AL)",
    0x06: "scroll up (lines=@AL)",
    0x07: "scroll down (lines=@AL)",
    0x08: "read character (page=@BH)",
    0x09: "write char/attr (@AL,attr=@BL,count=@CX)",
    0x0A: "write char (@AL,count=@CX)",
    0x0B: "set palette (id=@BH,color=@BL)",
    0x0C: "write dot (row=@DX,col=@CX)",
    0x0D: "read dot (row=@DX,col=@CX)",
    0x0E: "write tty (@AL)"
};

Interrupts.FUNCS[Interrupts.DISK] = {
    0x00: "disk reset",
    0x01: "get status",
    0x02: "read drive @DL (@CH:@DH:@CL,@AL) into @ES:@BX",
    0x03: "write drive @DL (@CH:@DH:@CL,@AL) from @ES:@BX",
    0x04: "verify drive @DL (@CH:@DH:@CL,@AL)",
    0x05: "format drive @DL using @ES:@BX",
    0x08: "read drive @DL parameters",
    0x15: "get drive @DL DASD type",
    0x16: "get drive @DL change line status",
    0x17: "set drive @DL DASD type",
    0x18: "set drive @DL media type"
    /**
     * Here's an additional function reference, previously in the HDC component, but moved here
     * because our components are hardware emulations, not BIOS emulations, so this information is
     * really only of interest to the Debugger (or the casual observer).
     *
     *      RESET:          0x00,
     *      GET_STATUS:     0x01,
     *      READ_SECTORS:   0x02,
     *      WRITE_SECTORS:  0x03,
     *      VERIFY_SECTORS: 0x04,
     *      FORMAT_TRK:     0x05,
     *      FORMAT_BAD:     0x06,
     *      FORMAT_DRIVE:   0x07,
     *      GET_DRIVEPARMS: 0x08,
     *      SET_DRIVEPARMS: 0x09,
     *      READ_LONG:      0x0A,
     *      WRITE_LONG:     0x0B,
     *      SEEK:           0x0C,
     *      ALT_RESET:      0x0D,
     *      READ_BUFFER:    0x0E,
     *      WRITE_BUFFER:   0x0F,
     *      TEST_READY:     0x10,
     *      RECALIBRATE:    0x11,
     *      RAM_DIAGNOSTIC: 0x12,
     *      DRV_DIAGNOSTIC: 0x13,
     *      CTL_DIAGNOSTIC: 0x14
     */
};

Interrupts.FUNCS[Interrupts.CASSETTE] = {
    0x80: "open device",
    0x81: "close device",
    0x82: "program termination",
    0x83: "wait @CX:@DXus for event",
    0x84: "joystick support",
    0x85: "SYSREQ pressed",
    0x86: "wait @CX:@DXus",
    0x87: "move block (@CX words)",
    0x88: "get extended memory size",
    0x89: "processor to virtual mode",
    0x90: "device busy loop",
    0x91: "interrupt complete flag set"
};

Interrupts.FUNCS[Interrupts.DOS] = {
    0x00: "terminate program",
    0x01: "read character (AL) from stdin with echo",
    0x02: "write character #@DL to stdout",
    0x03: "read character (AL) from stdaux",                                // eg, COM1
    0x04: "write character #@DL to stdaux",                                 // eg, COM1
    0x05: "write character #@DL to stdprn",                                 // eg, LPT1
    0x06: "direct console output (input if @DL=FF)",
    0x07: "direct console input without echo",
    0x08: "read character (AL) from stdin without echo",
    0x09: "write string $@DS:@DX to stdout",
    0x0A: "buffered input (DS:DX)",                                         // byte 0 is maximum chars, byte 1 is number of previous characters, byte 2 is number of characters read
    0x0B: "get stdin status",
    0x0C: "flush buffer and read stdin",                                    // AL is a function # (0x01, 0x06, 0x07, 0x08, or 0x0A)
    0x0D: "disk reset",
    0x0E: "select default drive @DL",                                       // returns # of available drives in AL
    0x0F: "open file using FCB ^@DS:@DX",                                   // DS:DX -> unopened File Control Block
    0x10: "close file using FCB ^@DS:@DX",
    0x11: "find first matching file using FCB ^@DS:@DX",
    0x12: "find next matching file using FCB ^@DS:@DX",
    0x13: "delete file using FCB ^@DS:@DX",
    0x14: "sequential read from file using FCB ^@DS:@DX",
    0x15: "sequential write to file using FCB ^@DS:@DX",
    0x16: "create or truncate file using FCB ^@DS:@DX",
    0x17: "rename file using FCB ^@DS:@DX",
    0x19: "get current default drive (AL)",
    0x1A: "set disk transfer area (DTA=@DS:@DX)",
    0x1B: "get allocation information for default drive",
    0x1C: "get allocation information for specific drive @DL",
    0x1F: "get drive parameter block for default drive",
    0x21: "read random record from file using FCB ^@DS:@DX",
    0x22: "write random record to file using FCB ^@DS:@DX",
    0x23: "get file size using FCB ^@DS:@DX",
    0x24: "set random record number for FCB ^@DS:@DX",
    0x25: "set address @DS:@DX of interrupt vector @AL",
    0x26: "create new PSP at segment @DX",
    0x27: "random block read from file using FCB ^@DS:@DX",
    0x28: "random block write to file using FCB ^@DS:@DX",
    0x29: "parse filename $@DS:@SI into FCB @ES:@DI using @AL",
    0x2A: "get system date (year=CX, mon=DH, day=DL)",
    0x2B: "set system date (year=@CX, mon=@DH, day=@DL)",
    0x2C: "get system time (hour=CH, min=CL, sec=DH, 100ths=DL)",
    0x2D: "set system time (hour=@CH, min=@CL, sec=@DH, 100ths=@DL)",
    0x2E: "set verify flag @AL",
    0x2F: "get disk transfer area (DTA=ES:BX)",                             // DOS 2.00+
    0x30: "get DOS version (AL=major, AH=minor)",
    0x31: "terminate and stay resident",
    0x32: "get drive parameter block (DPB=DS:BX) for drive @DL",
    0x33: "extended break check",
    0x34: "get address (ES:BX) of InDOS flag",
    0x35: "get address (ES:BX) of interrupt vector @AL",
    0x36: "get free disk space of drive @DL",
    0x37: "get(0)/set(1) switch character @DL (@AL)",
    0x38: "get country-specific information",
    0x39: "create subdirectory $@DS:@DX",
    0x3A: "remove subdirectory $@DS:@DX",
    0x3B: "set current directory $@DS:@DX",
    0x3C: "create or truncate file $@DS:@DX with attributes @CX",
    0x3D: "open file $@DS:@DX with mode @AL",
    0x3E: "close file @BX",
    0x3F: "read @CX bytes from file @BX into buffer @DS:@DX",
    0x40: "write @CX bytes to file @BX from buffer @DS:@DX",
    0x41: "delete file $@DS:@DX",
    0x42: "set position @CX:@DX of file @BX relative to @AL",
    0x43: "get(0)/set(1) attributes @CX of file $@DS:@DX (@AL)",
    0x44: "get device information (IOCTL)",
    0x45: "duplicate file handle @BX",
    0x46: "force file handle @CX to duplicate file handle @BX",
    0x47: "get current directory (DS:SI) for drive @DL",
    0x48: "allocate memory segment with @BX paragraphs",
    0x49: "free memory segment @ES",
    0x4A: "resize memory segment @ES to @BX paragraphs",
    0x4B: "load program $@DS:@DX using parameter block @ES:@BX",
    0x4C: "terminate with return code @AL",
    0x4D: "get return code (AL)",
    0x4E: "find first matching file $@DS:@DX with attributes @CX",
    0x4F: "find next matching file",
    0x50: "set current PSP @BX",
    0x51: "get current PSP (bx)",
    0x52: "get system variables (ES:BX)",
    0x53: "translate BPB @DS:@SI to DPB (ES:BP)",
    0x54: "get verify flag (AL)",
    0x55: "create child PSP at segment @DX",
    0x56: "rename file $@DS:@DX to $@ES:@DI",
    0x57: "get(0)/set(1) file @BX date @DX and time @CX (@AL)",
    0x58: "get(0)/set(1) memory allocation strategy (@AL)",                 // DOS 2.11+
    0x59: "get extended error information",                                 // DOS 3.00+
    0x5A: "create temporary file $@DS:@DX with attributes @CX",             // DOS 3.00+
    0x5B: "create file $@DS:@DX with attributes @CX",                       // DOS 3.00+ (doesn't truncate existing files like 0x3C)
    0x5C: "lock(0)/unlock(1) file @BX region @CX:@DX length @SI:@DI (@AL)", // DOS 3.00+
    0x5D: "critical error information (@AL)",                               // DOS 3.00+ (undocumented)
    0x60: "get fully-qualified filename from $@DS:@SI",                     // DOS 3.00+ (undocumented)
    0x63: "get lead byte table (@AL)",                                      // DOS 2.25 and 3.20+
    0x6C: "extended open file $@DS:@SI"                                     // DOS 4.00+
};

Interrupts.FUNCS[Interrupts.WINDBG.VECTOR] = {
    0x004F: "check debugger loaded"         // WINDBG.IS_LOADED returns WINDBG.LOADED (0xF386) if debugger loaded
};

/**
 * DOS function reference (from https://pcdosretro.github.io/dosfunc.txt)
 *
 *      INT 20 Program terminate (1.0+)
 *      Entry: CS=PSP
 *      Exit:  Does not return to caller
 *
 *      INT 21 Execute DOS function
 *      00 Program terminate (1.0+)
 *         Entry: CS=PSP
 *         Exit:  Does not return to caller
 *      01 Character input (1.0+)
 *         Entry: None
 *         Exit:  AL=character
 *      02 Character output (1.0+)
 *         Entry: DL=character
 *         Exit:  None
 *      03 Auxiliary input (1.0+)
 *         Entry: None
 *         Exit:  AL=character
 *      04 Auxiliary output (1.0+)
 *         Entry: DL=character
 *         Exit:  None
 *      05 Printer output (1.0+)
 *         Entry: DL=character
 *         Exit:  None
 *      06 Direct console I/O (1.0+)
 *         Entry: DL=FF for console input
 *                DL=character for console output
 *         Exit:  ZF=0 if a character is ready, AL=character
 *                ZF=1 if no character is ready
 *      07 Direct console input without echo (1.0+)
 *         Entry: None
 *         Exit:  AL=character
 *      08 Console input without echo (1.0+)
 *         Entry: None
 *         Exit:  AL=character
 *      09 Display string (1.0+)
 *         Entry: DS:DX-&gt;string ending with $
 *         Exit:  None
 *      0A Buffered keyboard input (1.0+)
 *         Entry: DS:DX-&gt;input buffer (first byte of buffer=maximum input length)
 *         Exit:  second byte of buffer=actual input length
 *      0B Get input status (1.0+)
 *         Entry: None
 *         Exit:  AL=00 no character available
 *                AL=FF character available
 *      0C Flush input buffer and input (1.0+)
 *         Entry: AL=function number (01,06,07,08,or 0A otherwise flush only)
 *                DS:DX-&gt;input buffer if function 0A
 *         Exit:  AL=character unless function 0A
 *      0D Disk reset (1.0+)
 *         Entry: None
 *         Exit:  None
 *      0E Set default drive (1.0+)
 *         Entry: DL=drive code (0=A)
 *         Exit:  AL=number of logical drives
 *      0F Open file (1.0+)
 *         Entry: DS:DX-&gt;unopened FCB
 *         Exit:  AL=00 file opened
 *                AL=FF file not found
 *      10 Close file (1.0+)
 *         Entry: DS:DX-&gt;opened FCB
 *         Exit:  AL=00 file closed
 *                AL=FF file not found
 *      11 Find first file (1.0+)
 *         Entry: DS:DX-&gt;unopened FCB
 *         Exit:  AL=00 matching filename found
 *                      buffer at DTA receives an unopened FCB and directory entry
 *                      original FCB contents:
 *                      FCB    search drive code (1=A)
 *                      FCB+1  specified filespec
 *                      FCB+12 search attribute byte
 *                      FCB+13 directory entry offset
 *                      FCB+15 directory cluster (0=root)
 *                      FCB+17 unused
 *                      FCB+21 actual drive code (1=A)
 *                AL=FF matching filename not found
 *         Note:  The file's directory entry is returned after the FCB drive code.
 *                If a character device is found then the directory attribute byte
 *                is set to 40h.
 *      12 Find next file (1.0+)
 *         Entry: DS:DX-&gt;unopened FCB from previous 11 or 12 call
 *         Exit:  AL=00 matching filename found
 *                      buffer at DTA receives an unopened FCB and directory entry
 *                AL=FF matching filename not found
 *         Note:  The file's directory entry is returned after the FCB drive code.
 *      13 Delete file (1.0+)
 *         Entry: DS:DX-&gt;unopened FCB
 *         Exit:  AL=00 file deleted
 *                AL=FF matching filename not found or files are read-only
 *      14 Sequential read (1.0+)
 *         Entry: DS:DX-&gt;opened FCB
 *         Exit:  AL=00 file was read
 *                AL=01 EOF (no data read)
 *                AL=02 segment wrap
 *                AL=03 EOF (partial read)
 *      15 Sequential write (1.0+)
 *         Entry: DS:DX-&gt;opened FCB
 *         Exit:  AL=00 file was written
 *                AL=01 disk full
 *                AL=02 segment wrap
 *      16 Create or truncate file (1.0+)
 *         Entry: DS:DX-&gt;unopened FCB
 *         Exit:  AL=00 file created
 *                AL=FF directory full
 *      17 Rename file (1.0+)
 *         Entry: DS:DX-&gt;rename FCB (FCB+11h-&gt;new filename)
 *         Exit:  AL=00 file renamed
 *                AL=FF no matching files found or new filename already exists
 *      18 Reserved
 *      19 Get default drive (1.0+)
 *         Entry: None
 *         Exit:  AL=drive code (0=A)
 *      1A Set disk transfer address (1.0+)
 *         Entry: DS:DX=new DTA
 *         Exit:  None
 *      1B Get allocation info for default drive (1.0+)
 *         Entry: None
 *         Exit:  AL=sectors per cluster
 *                CX=bytes per sector
 *                DX=clusters per drive
 *                DS:BX-&gt;media descriptor byte
 *                AL=FF invalid drive
 *      1C Get allocation info for specified drive (1.1+)
 *         Entry: DL=drive code (0=default)
 *         Exit:  Same as function 1B
 *      1D Reserved
 *      1E Reserved
 *      1F Get disk parameter block for default drive (1.1+)
 *         Entry: None
 *         Exit:  AL=00 drive valid
 *                DS:BX-&gt;disk parameter block
 *                   0 drive code (0=A)             13 maximum cluster number
 *                   1 unit code                    15 sectors per FAT
 *                   2 bytes per sector             17 first directory sector
 *                   4 sectors per cluster-1        19 pointer to device driver
 *                   5 cluster shift factor         23 media descriptor byte
 *                   6 first FAT sector             24 access flag (0=accessed)
 *                   8 number of FATs               25 pointer to next DPB
 *                   9 number of directory entries  29 last cluster allocated
 *                  11 first data sector            31 free clusters (-1=unknown)
 *                AL=FF drive invalid
 *         Note:  (3.x) The sectors per FAT field is one byte and all following
 *                fields are moved back one byte.
 *      20 Reserved
 *      21 Random read (1.0+)
 *         Entry: DS:DX-&gt;opened FCB
 *         Exit:  AL=00 file was read
 *                AL=01 EOF (no data read)
 *                AL=02 segment wrap
 *                AL=03 EOF (partial read)
 *      22 Random write (1.0+)
 *         Entry: DS:DX-&gt;opened FCB
 *         Exit:  AL=00 file was written
 *                AL=01 disk full
 *                AL=02 segment wrap
 *      23 Get file size in records (1.0+)
 *         Entry: DS:DX-&gt;unopened FCB
 *         Exit:  AL=00 random record field is set by dividing the file size by the
 *                      specified record size
 *                AL=FF file not found
 *      24 Set random record number (1.0+)
 *         Entry: DS:DX-&gt;opened FCB
 *         Exit:  random record field is set based on record size, current record,
 *                and current block
 *      25 Set interrupt vector (1.0+)
 *         Entry: DS:DX=new address
 *                AL=interrupt number
 *         Exit:  None
 *      26 Create PSP (1.0+)
 *         Entry: CS=PSP
 *                DX=segment for new PSP
 *         Exit:  None
 *      27 Random block read (1.0+)
 *         Entry: DS:DX-&gt;opened FCB
 *                CX=number of records to read
 *         Exit:  AL=00 file was read
 *                AL=01 EOF (no data read)
 *                AL=02 segment wrap
 *                AL=03 EOF (partial read)
 *                CX=actual number of records read
 *      28 Random block write (1.0+)
 *         Entry: DS:DX-&gt;opened FCB
 *                CX=number of records to write
 *         Exit:  AL=00 file was written
 *                AL=01 disk full
 *                AL=02 segment wrap
 *                CX=actual number of records written
 *      29 Parse filename (1.0+)
 *         Entry: DS:SI-&gt;string to parse
 *                ES:DI-&gt;buffer for unopened FCB
 *                AL=flags
 *                   Bit 0 1=ignore leading separators
 *                       1 1=modify FCB drive code byte only if a drive is specified
 *                       2 1=modify FCB filename only if a filename is specified
 *                       3 1=modify FCB extension only if an extension is specified
 *         Exit:  DS:SI-&gt;first character after parsed filename
 *                AL=00 no wildcard characters in string
 *                AL=01 wildcard characters in string
 *                AL=FF invalid drive
 *      2A Get date (1.0+)
 *         Entry: None
 *         Exit:  AL=weekday (0=Sunday)
 *                CX=year
 *                DH=month
 *                DL=day
 *      2B Set date (1.0+)
 *         Entry: CX=year
 *                DH=month
 *                DL=day
 *         Exit:  AL=00 date set
 *                AL=FF invalid date
 *      2C Get time (1.0+)
 *         Entry: None
 *         Exit:  CH=hours
 *                CL=minutes
 *                DH=seconds
 *                DL=hundredths
 *      2D Set time (1.0+)
 *         Entry: CH=hours
 *                CL=minutes
 *                DH=seconds
 *                DL=hundredths
 *         Exit:  AL=00 time set
 *                AL=FF invalid time
 *      2E Set verify flag (1.1+)
 *         Entry: AL=verify flag (0=off,1=on)
 *         Exit:  None
 *      2F Get disk transfer address (2.0+)
 *         Entry: None
 *         Exit:  ES:BX=DTA
 *      30 Get DOS version (2.0+)
 *         Entry: AL=0 return OEM number (5.0+)
 *                AL=1 return version flag (5.0+)
 *         Exit:  AL=major version number
 *                AH=minor version number
 *                BH=OEM number or version flag (00=RAM,08=ROM)
 *                BL:CX=24-bit serial number or 0
 *      31 Terminate and stay resident (2.0+)
 *         Entry: AL=return code
 *                DX=memory size in paragraphs (minimum 6)
 *         Exit:  Does not return to caller
 *      32 Get disk parameter block for specified drive (2.0+)
 *         Entry: DL=drive code (0=default)
 *         Exit:  Same as function 1F
 *      33 Get or set Ctrl-Break (2.0+)
 *         Entry: AL=0 get break
 *                AL=1 set break
 *                AL=2 swap break (*) (3.1+)
 *                AL=5 get boot drive (4.0+)
 *                AL=6 get DOS version (5.0+)
 *                DL=break flag if set or swap (0=off,1=on)
 *         Exit:  if function 00 or 02:
 *                   DL=break flag
 *                if function 05:
 *                   DL=boot drive code (1=A)
 *                if function 06:
 *                   BL=major version
 *                   BH=minor version
 *                   DL=revision (0=A)
 *                   DH=version flag (00=low,08=ROM,10=HMA)
 *      34 Get InDOS flag pointer (2.0+)
 *         Entry: None
 *         Exit:  ES:BX-&gt;InDOS flag
 *         Note:  The DOS critical error flag immediately precedes this byte.
 *      35 Get interrupt vector (2.0+)
 *         Entry: AL=interrupt number
 *         Exit:  ES:BX=interrupt address
 *      36 Get free disk space (2.0+)
 *         Entry: DL=drive code (0=default)
 *         Exit:  AX=sectors per cluster
 *                BX=free clusters
 *                CX=bytes per sector
 *                DX=clusters per drive
 *                AX=FFFF if drive invalid
 *      37 Get or set switch character (*) (2.0+)
 *         Entry: AL=0 get switch character
 *                AL=1 set switch character
 *                DL=switch character if set
 *         Exit:  DL=switch character if get
 *         Note:  (5.0+) Function 3701 has been disabled.
 *      38 Get or set country info (2.0+)
 *         Entry: AL=country code (0=default)
 *                BX=country code if AL=FF (3.0+)
 *                DX=FFFF if set request (2.11+)
 *                DS:DX-&gt;buffer if get request
 *         Exit:  CF=0 BX=country code if get request (3.0+)
 *                     buffer format:
 *                      0 date format (0=USA,1=Europe,2=Japan)
 *                      2 currency symbol string
 *                      7 thousands separator
 *                      9 decimal separator
 *                     11 date separator
 *                     13 time separator
 *                     15 currency format
 *                        0 symbol before amount, no space between
 *                        1 symbol after amount, no space between
 *                        2 symbol before amount, 1 space between
 *                        3 symbol after amount, 1 space between
 *                        4 symbol replaces decimal separator
 *                     16 digits after decimal in currency
 *                     17 time format (0=12-hour,1=24-hour)
 *                     18 case map call address
 *                     22 data list separator
 *                     24 reserved (10 bytes)
 *                CF=1 AX=error code
 *      39 Create directory (2.0+)
 *         Entry: DS:DX-&gt;directory name
 *         Exit:  CF=0 None
 *                CF=1 AX=error code
 *      3A Remove directory (2.0+)
 *         Entry: DS:DX-&gt;directory name
 *         Exit:  CF=0 None
 *                CF=1 AX=error code
 *      3B Change current directory (2.0+)
 *         Entry: DS:DX-&gt;directory name
 *         Exit:  CF=0 None
 *                CF=1 AX=error code
 *      3C Create or truncate file (2.0+)
 *         Entry: DS:DX-&gt;filename
 *                CX=file attributes
 *         Exit:  CF=0 AX=file handle
 *                CF=1 AX=error code
 *      3D Open file (2.0+)
 *         Entry: DS:DX-&gt;filename
 *                AL=open mode
 *                   Bit 0-2 access mode
 *                           000=read
 *                           001=write
 *                           010=read/write
 *                       4-6 sharing mode (3.0+)
 *                           000=compatibility
 *                           001=deny read/write access
 *                           010=deny write access
 *                           011=deny read access
 *                           100=deny none access
 *                         7 inheritance flag
 *                           0=file inherited by EXECed programs
 *                           1=file not inherited by EXECed programs
 *         Exit:  CF=0 AX=file handle
 *                CF=1 AX=error code
 *      3E Close file (2.0+)
 *         Entry: BX=file handle
 *         Exit:  CF=0 None
 *                CF=1 AX=error code
 *      3F Read file or device (2.0+)
 *         Entry: BX=file handle
 *                CX=bytes to read
 *                DS:DX-&gt;input buffer
 *         Exit:  CF=0 AX=number of bytes read (0=EOF)
 *                CF=1 AX=error code
 *      40 Write file or device (2.0+)
 *         Entry: BX=file handle
 *                CX=bytes to write (0=truncate file)
 *                DS:DX-&gt;output buffer
 *         Exit:  CF=0 AX=number of bytes written (0=disk full)
 *                CF=1 AX=error code
 *      41 Delete file (2.0+)
 *         Entry: DS:DX-&gt;filename
 *         Exit:  CF=0 None
 *                CF=1 AX=error code
 *      42 Move file pointer (2.0+)
 *         Entry: AL=code (0=absolute,1=relative,2=relative to EOF)
 *                BX=file handle
 *                CX:DX=offset
 *         Exit:  CF=0 DX:AX=new pointer
 *                CF=1 AX=error code
 *      43 Get or set file attributes (2.0+)
 *         Entry: AL=0 get attributes
 *                AL=1 set attributes
 *                CX=file attributes if set
 *                   Bit 0 1=read-only
 *                       1 1=hidden
 *                       2 1=system
 *                       4 1=directory (get only)
 *                       5 1=archive
 *                DS:DX-&gt;filename
 *         Exit:  CF=0 CX=file attributes if get
 *                CF=1 AX=error code
 *      44 I/O control for devices (2.0+)
 *         Notes: 1) Functions 02-05 work only if bit 14 of the device driver
 *                   attribute word is set.
 *                2) Function 08 works only if bit 11 of the device driver
 *                   attribute word is set.
 *                3) Functions 0C-0F work only if bit 6 of the device driver
 *                   attribute word is set.
 *                4) Functions 10-11 work only if bit 7 of the device driver
 *                   attribute word is set.
 *         00 Get device attributes (2.0+)
 *            Entry: BX=file handle
 *            Exit:  CF=0 DX=device attributes
 *                        Character devices:
 *                        Bit 0 1=console input
 *                            1 1=console output
 *                            2 1=NUL device
 *                            3 1=CLOCK device
 *                            4 1=INT 29 output (CON)
 *                            5 0=ASCII,1=binary
 *                            6 0=EOF on input
 *                            7 1=character device
 *                           11 1=open/close supported
 *                           13 1=output until busy supported
 *                           14 1=IOCTL supported
 *                        Block devices:
 *                        Bit 0-5 drive code (0=A)
 *                              6 0=file has been written
 *                              7 0=block device
 *                   CF=1 AX=error code
 *         01 Set device attributes (2.0+)
 *            Entry: BX=file handle (character devices only)
 *                   DX=device attributes (DH must be 0)
 *            Exit:  CF=0 None
 *                   CF=1 AX=error code
 *         02 Read from character device (2.0+)
 *         03 Write to character device (2.0+)
 *            Entry: BX=file handle
 *                   CX=number of bytes
 *                   DS:DX-&gt;buffer
 *            Exit:  CF=0 AX=number of bytes transferred
 *                   CF=1 AX=error code
 *         04 Read from block device (2.0+)
 *         05 Write to block device (2.0+)
 *            Entry: BL=drive code (0=default)
 *                   CX=number of bytes
 *                   DS:DX-&gt;buffer
 *            Exit:  CF=0 AX=number of bytes transferred
 *                   CF=1 AX=error code
 *         06 Get input status (2.0+)
 *         07 Get output status (2.0+)
 *            Entry: BX=file handle
 *            Exit:  CF=0 AL=status (00=not ready,FF=ready)
 *                   CF=1 AX=error code
 *         08 Removable media check (3.0+)
 *            Entry: BL=drive code (0=default)
 *            Exit:  CF=0 AX=value (0=removable,1=fixed)
 *                   CF=1 AX=error code
 *         09 Local/remote drive check (3.0+)
 *            Entry: BL=drive code (0=default)
 *            Exit:  CF=0 DX=device attributes
 *                        Bit 1 1=32-bit sectors supported
 *                            6 1=generic IOCTL calls supported
 *                            7 1=query IOCTL call supported
 *                            9 1=shared drive; direct I/O not allowed
 *                           11 1=removable media call supported
 *                           12 1=remote drive
 *                           13 1=media descriptor in FAT required
 *                           14 1=IOCTL calls supported
 *                           15 1=SUBSTed
 *                   CF=1 AX=error code
 *         0A Local/remote handle check (3.0+)
 *            Entry: BX=file handle
 *            Exit:  CF=0 DX=device attributes from SFT
 *                        Character devices:
 *                        Bit 0 1=console input
 *                            1 1=console output
 *                            2 1=NUL device
 *                            3 1=CLOCK device
 *                            4 1=INT 29 output (CON)
 *                            5 0=ASCII,1=binary
 *                            6 0=EOF on input
 *                            7 1=character device
 *                           11 1=network spooler
 *                           12 1=no inherit
 *                           13 1=named pipe
 *                           15 1=remote
 *                        Block devices:
 *                        Bit 0-5 drive code (0=A)
 *                              6 0=file has been written
 *                              7 0=block device
 *                             12 1=no inherit
 *                             14 1=date/time set
 *                             15 1=remote
 *                   CF=1 AX=error code
 *         0B Change sharing retry count (3.0+)
 *            Entry: CX=delay loop count
 *                   DX=retry count
 *            Exit:  None
 *         0C Generic IOCTL for handles (3.2+)
 *            Entry: BX=file handle
 *                   CH=category code (01=AUX,03=CON,05=PRN)
 *                   CL=function code
 *                      45 set printer retry count
 *                      4A set code page (3.3+)
 *                      4C prepare start (3.3+)
 *                      4D prepare end (3.3+)
 *                      5F set display info (4.0+)
 *                      65 get printer retry count
 *                      6A get code page (3.3+)
 *                      6B get prepare list (3.3+)
 *                      7F get display info (4.0+)
 *                   DS:DX-&gt;parameter block or retry count word
 *            Exit:  CF=0 None
 *                   CF=1 AX=error code
 *            Get/set code page and prepare end parameter block format:
 *               0 length (2)
 *               2 code page
 *            Prepare start parameter block format:
 *               0 flags (device specific)
 *               2 data length
 *               4 number of code pages
 *               6 code pages (-1=perform a refresh operation)
 *            Get prepare list parameter block format:
 *               0 data length
 *               2 number of hardware code pages
 *               4 hardware code pages
 *               n number of prepared code pages
 *             n+2 prepared code pages
 *            Display info parameter block format:
 *               0 info level (must be 0)
 *               1 reserved
 *               2 data length (14)
 *               4 flags
 *                 Bit 0 (0=blink,1=intensity)
 *               6 mode (1=text,2=graphics)
 *               7 reserved
 *               8 colors
 *              10 pixel columns
 *              12 pixel rows
 *              14 character columns
 *              16 character rows
 *         0D Generic IOCTL for drives (3.2+)
 *            Entry: BL=drive code (0=default)
 *                   CH=category code (08=disk)
 *                   CL=function code
 *                      40 set device parameters
 *                      41 write track
 *                      42 format track
 *                      46 set media info (4.0+)
 *                      47 set access flag (4.0+)
 *                      60 get device parameters
 *                      61 read track
 *                      62 verify track
 *                      66 get media info (4.0+)
 *                      67 get access flag (4.0+)
 *                      68 sense media type (5.0+)
 *                   DS:DX-&gt;parameter block
 *            Exit:  CF=0 None
 *                   CF=1 AX=error code
 *            Get/set device parameter block format:
 *               0 flags (only bit 0 is used by get)
 *                 Bit 0 0=return default BPB/build new BPB
 *                       1=return build BPB/use device BPB
 *                     1 0=read all fields
 *                       1=read track layout only
 *                     2 0=sector sizes vary
 *                       1=sector sizes equal
 *               1 drive type
 *                 0=360K             5=fixed
 *                 1=1.2M             6=tape
 *                 2=720K             7=1.44M
 *                 3=8" single sided  8=read/write optical
 *                 4=8" double sided  9=2.88M
 *               2 attributes
 *                 Bit 0 1=non-removable
 *                     1 1=changeline supported
 *               4 cylinders
 *               6 density (0=high,1=double)
 *               7 BIOS parameter block
 *              32 reserved
 *              38 track layout count
 *              40 track layout words (sector number,sector size)
 *              Note: Track layout fields are used by set only.
 *            Read/write parameter block format:
 *               0 reserved
 *               1 head
 *               3 cylinder
 *               5 sector
 *               7 number of sectors
 *               9 buffer address
 *            Format/verify parameter block format:
 *               0 reserved
 *               1 head
 *               3 cylinder
 *            Get/set media info parameter block format:
 *               0 info level (must be 0)
 *               2 volume serial number
 *               6 volume label
 *              17 8-byte file system type
 *            Get/set access flag parameter block format:
 *               0 reserved
 *               1 access flag (0=disallow disk access,1=allow disk access)
 *            Sense media type parameter block format:
 *               0 media type flag (0=other,1=default)
 *               1 media type (2=720K,7=1.44M,9=2.88M)
 *         0E Get logical drive map (3.2+)
 *         0F Set logical drive map (3.2+)
 *            Entry: BL=logical drive code (0=default)
 *            Exit:  CF=0 AL=physical drive code (0=only 1 logical drive mapped)
 *                   CF=1 AX=error code
 *         10 Query IOCTL for handles (5.0+)
 *            Entry: BX=file handle
 *                   CH=category code (01=AUX,03=CON,05=PRN)
 *                   CL=function code
 *            Exit:  CF=0 None
 *                   CF=1 AX=error code
 *         11 Query IOCTL for drives (5.0+)
 *            Entry: BL=drive code (0=default)
 *                   CH=category code (08=disk)
 *                   CL=function code
 *            Exit:  CF=0 None
 *                   CF=1 AX=error code
 *      45 Duplicate handle (2.0+)
 *         Entry: BX=file handle
 *         Exit:  CF=0 AX=new file handle
 *                CF=1 AX=error code
 *      46 Redirect handle (2.0+)
 *         Entry: BX=file handle
 *                CX=file handle to redirect
 *         Exit:  CF=0 None
 *                CF=1 AX=error code
 *         Note:  If the handle to redirect is opened then it is closed before
 *                being redirected.
 *      47 Get current directory (2.0+)
 *         Entry: DS:SI-&gt;64-byte buffer for pathname
 *                DL=drive code (0=default)
 *         Exit:  CF=0 None
 *                CF=1 AX=error code
 *      48 Allocate memory (2.0+)
 *         Entry: BX=number of paragraphs to allocate
 *         Exit:  CF=0 AX=segment of allocated block
 *                CF=1 AX=error code
 *                     BX=size of largest available block
 *      49 Release memory (2.0+)
 *         Entry: ES=segment of block to release
 *         Exit:  CF=0 None
 *                CF=1 AX=error code
 *      4A Reallocate memory (2.0+)
 *         Entry: BX=number of paragraphs to allocate
 *                ES=segment of block to reallocate
 *         Exit:  CF=0 None
 *                CF=1 AX=error code
 *                     BX=size of largest available block
 *      4B Execute program (2.0+)
 *         Entry: AL=0 execute program
 *                AL=1 load program
 *                AL=3 load overlay
 *                AL=5 enter exec state (5.0+)
 *                DS:DX-&gt;filename or exec state parameter block
 *                ES:BX-&gt;parameter block (unused by enter exec state)
 *                   if function 00 or 01:
 *                      0 environment block segment or 0
 *                      2 command tail pointer
 *                      6 FCB1 pointer
 *                     10 FCB2 pointer
 *                   if function 03:
 *                      0 segment where file will be loaded
 *                      2 relocation factor
 *                   if function 05:
 *                      0 reserved
 *                      2 flags (0=COM,1=EXE,2=overlay)
 *                      4 program name pointer
 *                      8 PSP
 *                     10 program CS:IP
 *                     14 doubleword program size
 *         Exit:  CF=0 BX and DX may be destroyed
 *                     parameter block if load only:
 *                       14 SS:SP of loaded program
 *                       18 CS:IP of loaded program
 *                CF=1 AX=error code
 *         Note:  After calling function 4B01 the current PSP is set to that of
 *                the loaded program. Before executing the program, DS and ES
 *                should be set to the program's PSP and the INT 22 vector in the
 *                program's PSP should be set to a valid return address.
 *      4C Terminate with return code (2.0+)
 *         Entry: AL=return code
 *         Exit:  Does not return to caller
 *      4D Get program return code (2.0+)
 *         Entry: None
 *         Exit:  AL=return code
 *                AH=exit type (0=normal,1=Ctrl-C,2=critical error,3=TSR)
 *      4E Find first file (2.0+)
 *         Entry: DS:DX-&gt;filespec
 *                CX=file attributes
 *         Exit:  CF=0 DTA    search drive code (1=A)
 *                     DTA+1  search filespec
 *                     DTA+12 search attribute byte
 *                     DTA+13 directory entry offset
 *                     DTA+15 directory cluster (0=root)
 *                     DTA+17 unused
 *                     DTA+21 attribute byte (40h=character device)
 *                     DTA+22 file time
 *                     DTA+24 file date
 *                     DTA+26 file size
 *                     DTA+30 filename
 *                CF=1 AX=error code
 *      4F Find next file (2.0+)
 *         Entry: Bytes 0-20 of buffer at DTA must be set from previous 4E or 4F call
 *         Exit:  Same as function 4E
 *      50 Set current PSP (2.0+)
 *         Entry: BX=PSP segment
 *         Exit:  None
 *      51 Get current PSP (2.0+)
 *         Entry: None
 *         Exit:  BX=PSP segment
 *      52 Get DOS internal pointers (*) (2.0+)
 *         Entry: None
 *         Exit:  ES:BX-&gt;DOS internal pointers
 *                  -02h memory chain anchor
 *                  +00h pointer to disk parameter blocks
 *                  +04h pointer to system file tables
 *                  +08h pointer to CLOCK$ device header
 *                  +0Ch pointer to CON device header
 *                  +10h disk buffer size
 *                  +12h pointer to disk buffer chain (3.x)
 *                       pointer to disk buffer control block (4.0+)
 *                  +16h pointer to current directory structures
 *                  +1Ah pointer to FCB system file tables
 *                  +1Eh FCB keep count
 *                  +20h number of actual drives
 *                  +21h number of logical drives
 *                  +22h NUL device header
 *      53 Create disk parameter block (*) (2.0+)
 *         Entry: DS:SI-&gt;BIOS parameter block
 *                   0 bytes per sector
 *                   2 sectors per cluster
 *                   3 number of reserved sectors
 *                   5 number of FATs
 *                   6 number of root directory entries
 *                   8 total number of sectors
 *                  10 media descriptor byte
 *                  11 sectors per FAT
 *                  13 sectors per track
 *                  15 number of heads
 *                  17 number of hidden sectors
 *                  21 32-bit number of sectors if word at 8=0
 *                ES:BP-&gt;buffer for disk parameter block
 *         Exit:  None
 *      54 Get verify flag (2.0+)
 *         Entry: None
 *         Exit:  AL=verify flag (0=off,1=on)
 *      55 Create program PSP (*) (2.0+)
 *         Entry: DX=segment for new PSP
 *                SI=new end of allocation
 *         Exit:  None
 *         Note:  After calling function 55 the current PSP is set to the new PSP.
 *      56 Rename file (2.0+)
 *         Entry: DS:DX-&gt;old filename
 *                ES:DI-&gt;new filename
 *         Exit:  CF=0 None
 *                CF=1 AX=error code
 *         Note:  This function can also rename a directory or move a file from
 *                one directory to another.
 *      57 Get or set file date and time (2.0+)
 *         Entry: AL=0 get date and time
 *                AL=1 set date and time
 *                BX=file handle
 *                CX=time if set
 *                   Bits 0-4 seconds/2 (0-29)
 *                       5-10 minutes (0-59)
 *                      11-15 hours (0-23)
 *                DX=date if set
 *                   Bits 0-4 day (1-31)
 *                        5-8 month (1-12)
 *                       9-15 year-1980
 *         Exit:  CF=0 CX=time if get
 *                     DX=date if get
 *                CF=1 AX=error code
 *      58 Get or set allocation strategy (2.11+)
 *         Entry: AL=0 get strategy
 *                AL=1 set strategy
 *                AL=2 get UMB link state (5.0+)
 *                AL=3 set UMB link state (5.0+)
 *                BX=strategy code or UMB link state (0=unlink,1=link)
 *                   00=first fit
 *                   01=best fit
 *                   02=last fit
 *                   40=first fit, high only (5.0+)
 *                   41=best fit, high only (5.0+)
 *                   42=last fit, high only (5.0+)
 *                   80=first fit, high first (5.0+)
 *                   81=best fit, high first (5.0+)
 *                   82=last fit, high first (5.0+)
 *         Exit:  CF=0 AX=strategy code or UMB link state if get
 *                CF=1 AX=error code
 *      59 Get extended error info (3.0+)
 *         Entry: None
 *         Exit:  AX=extended error code
 *                BH=error class
 *                BL=suggested action
 *                CH=locus
 *                ES:DI-&gt;volume label for invalid disk change error or 0
 *      5A Create unique file (3.0+)
 *         Entry: DS:DX-&gt;pathname ending with \
 *                CX=file attributes
 *         Exit:  CF=0 AX=file handle (filename is appended to pathname)
 *                CF=1 AX=error code
 *      5B Create new file (3.0+)
 *         Entry: DS:DX-&gt;filename
 *                CX=file attributes
 *         Exit:  CF=0 AX=file handle
 *                CF=1 AX=error code
 *      5C Lock or unlock file (3.0+)
 *         Entry: AL=0 lock
 *                AL=1 unlock
 *                BX=file handle
 *                CX:DX=region offset
 *                SI:DI=region length
 *         Exit:  CF=0 None
 *                CF=1 AX=error code
 *         Note:  File sharing (SHARE.EXE) must be loaded to use this function.
 *      5D File sharing functions (*) (3.0+)
 *         Notes: 1) Some functions use a parameter block with the following format:
 *                   AX,BX,CX,DX,SI,DI,DS,ES,reserved,machine #,process (PSP)
 *                2) Functions 02-05 work only if file sharing (SHARE.EXE) is loaded.
 *                3) Functions 07-09 work only if the redirector (REDIR.EXE) is loaded.
 *         00 Server DOS call (*) (3.0+)
 *            Entry: DS:DX-&gt;parameter block (AX,BX,CX,DX,SI,DI,DS,ES,machine #,process)
 *            Exit:  Depends on called function
 *         01 Commit all local files (*) (3.0+)
 *            Entry: None
 *            Exit:  None
 *         02 Close all occurrences of file (*) (3.0+)
 *            Entry: DS:DX-&gt;parameter block (DS:DX-&gt;qualified filespec)
 *            Exit:  CF=0 None
 *                   CF=1 AX=error code
 *         03 Close all files for machine (*) (3.0+)
 *            Entry: DS:DX-&gt;parameter block (machine #)
 *            Exit:  CF=0 None
 *                   CF=1 AX=error code
 *         04 Close all files for machine and process (*) (3.0+)
 *            Entry: DS:DX-&gt;parameter block (machine #,process)
 *            Exit:  CF=0 None
 *                   CF=1 AX=error code
 *         05 Get shared file info (*) (3.0+)
 *            Entry: DS:DX-&gt;parameter block (BX=share file table index,CX=SFT index)
 *            Exit:  CF=0 AX=device info from SFT
 *                        BX=machine #
 *                        CX=lock count
 *                        ES:DI-&gt;qualified filename
 *                   CF=1 AX=error code
 *         06 Get DOS swappable data area (*) (3.0+)
 *            Entry: None
 *            Exit:  DS:SI-&gt;DOS swappable data area
 *                   CX=DOS swappable data area length
 *                   DX=DOS critical data area length
 *            Note:  The first byte of the data area is the critical error flag.
 *         07 Get print stream state (*) (3.1+)
 *            Entry: None
 *            Exit:  DL=state (0=truncate off,1=truncate on)
 *         08 Set print stream state (*) (3.1+)
 *            Entry  DL=state (0=truncate off,1=truncate on)
 *            Exit:  None
 *         09 Truncate print stream (*) (3.1+)
 *            Entry  None
 *            Exit:  None
 *         0A Set extended error info (3.1+)
 *            Entry: DS:DX-&gt;parameter block (see function 59 for affected registers)
 *            Exit:  None
 *      5E Network functions (3.0+)
 *         Note: Functions 02-05 work only if the redirector (REDIR.EXE) is loaded.
 *         00 Get machine name (3.0+)
 *            Entry: DS:DX-&gt;buffer for machine name
 *            Exit:  CH=validity flag (0=invalid,1=valid)
 *                   CL=netbios number
 *         01 Set machine name (*) (3.0+)
 *            Entry: DS:DX-&gt;machine name
 *                   CH=validity flag (0=invalid,1=valid)
 *                   CL=netbios number
 *            Exit:  None
 *         02 Set printer string (3.1+)
 *            Entry: DS:SI-&gt;printer setup string
 *                   BX=redirection list index
 *                   CX=printer setup string length
 *            Exit:  CF=0 None
 *                   CF=1 AX=error code
 *         03 Get printer string (3.1+)
 *            Entry: ES:DI-&gt;buffer for printer setup string
 *                   BX=redirection list index
 *            Exit:  CF=0 CX=printer setup string length
 *                   CF=1 AX=error code
 *         04 Set print mode (*) (3.1+)
 *            Entry: BX=redirection list index
 *                   DX=print mode (0=text,1=binary)
 *            Exit:  CF=0 None
 *                   CF=1 AX=error code
 *         05 Get print mode (*) (3.1+)
 *            Entry: BX=redirection list index
 *            Exit:  CF=0 DX=print mode (0=text,1=binary)
 *                   CF=1 AX=error code
 *      5F Network redirection functions (3.1+)
 *         Notes: 1) Functions 00-05 work only if the redirector (REDIR.EXE) is loaded.
 *                2) Functions 07-08 work only on builtin drives.
 *         00 Get redirection mode (*) (3.1+)
 *            Entry: BL=device type (3=printer,4=disk)
 *            Exit:  CF=0 BH=redirection mode (0=off,1=on)
 *                   CF=1 AX=error code
 *         01 Set redirection mode (*) (3.1+)
 *            Entry: BL=device type (3=printer,4=disk)
 *                   BH=redirection mode (0=off,1=on)
 *            Exit:  CF=0 None
 *                   CF=1 AX=error code
 *         02 Get redirection list entry (3.1+)
 *            Entry: DS:SI-&gt;16-byte buffer for local device name
 *                   ES:DI-&gt;128-byte buffer for remote device name
 *                   BX=redirection list index
 *            Exit:  CF=0 BH=status (0=valid,1=invalid)
 *                        BL=device type (3=printer,4=disk)
 *                        CX=user word
 *                   CF=1 AX=error code
 *         03 Set redirection list entry (3.1+)
 *            Entry: DS:SI-&gt;local device name
 *                   ES:DI-&gt;remote device name
 *                   BL=device type (3=printer,4=disk)
 *                   CX=user word
 *            Exit:  CF=0 None
 *                   CF=1 AX=error code
 *         04 Cancel redirection list entry (3.1+)
 *            Entry: DS:SI-&gt;local device name
 *            Exit:  CF=0 None
 *                   CF=1 AX=error code
 *         05 Get redirection list entry extended (*) (4.0+)
 *            Entry: DS:SI-&gt;16-byte buffer for local device name
 *                   ES:DI-&gt;128-byte buffer for remote device name
 *                   BX=redirection list index
 *            Exit:  CF=0 BH=status (0=valid,1=invalid)
 *                        BL=device type (3=printer,4=disk)
 *                        CX=user word
 *                        BP=netbios session number
 *                   CF=1 AX=error code
 *         07 Enable drive (*) (4.0+)
 *            Entry: DL=drive code (0=default)
 *            Exit:  CF=0 None
 *                   CF=1 AX=error code
 *         08 Disable drive (*) (4.0+)
 *            Entry: DL=drive code (0=default)
 *            Exit:  CF=0 None
 *                   CF=1 AX=error code
 *      60 Qualify filename (*) (3.0+)
 *         Entry: DS:SI-&gt;filespec
 *                ES:DI-&gt;buffer for qualified filespec
 *         Exit:  CF=0 None
 *                CF=1 AX=error code
 *      61 Reserved
 *      62 Get current PSP (3.0+)
 *         Entry: None
 *         Exit:  BX=PSP segment
 *      63 Get DBCS lead byte table pointer (*) (3.0+)
 *         Entry: AL must be 0
 *         Exit:  DS:SI-&gt;DBCS lead byte table
 *      64 Set wait for external event flag (*) (3.2+)
 *         Entry: AL=flag (0=enable,&gt;0=disable)
 *         Exit:  None
 *         Note:  This function affects the PC Convertible only.
 *                If enabled and the default console driver is being used then
 *                INT 15 function 41 is issued while waiting for console input
 *                during functions 01,08,0A,and 3F.
 *      65 Get extended country info (3.3+)
 *         Entry: AL=01 get extended country info
 *                   02 get country uppercase table
 *                   03 get country lowercase table (reserved until 6.2)
 *                   04 get country filename uppercase table
 *                   05 get country filename character table
 *                   06 get country collating table
 *                   07 get DBCS vector table (4.0+)
 *                   20 uppercase character (4.0+)
 *                   21 uppercase string (4.0+)
 *                   22 uppercase ASCIIZ string (4.0+)
 *                   23 yes/no check (*) (4.0+)
 *                   A0 uppercase filename character (*) (4.0+)
 *                   A1 uppercase filename string (*) (4.0+)
 *                   A2 uppercase filename ASCIIZ string (*) (4.0+)
 *                   A3 yes/no check (*) (4.0+)
 *                if function 01-07:
 *                   BX=code page (-1=active code page)
 *                   CX=length to return (must be at least 5)
 *                   DX=country code (-1=default)
 *                   ES:DI-&gt;return buffer
 *                if function 20,23,A0,A3:
 *                   DL=character
 *                if function 21,A1:
 *                   DS:DX-&gt;string
 *                   CX=string length
 *                if function 22,A2:
 *                   DS:DX-&gt;string
 *         Exit:  CF=0 CX=data length if function 01-07
 *                     DL=character if function 20
 *                     AX=code if function 23,A3 (0=no,1=yes,2=neither)
 *                CF=1 AX=error code
 *                buffer format if function 01:
 *                 0 info ID
 *                 1 length
 *                 3 country code
 *                 5 code page
 *                 7 country info (same format as function 38)
 *                buffer format if function 02-07:
 *                 0 info ID
 *                 1 pointer to requested table (word length followed by data)
 *      66 Get or set code page (3.3+)
 *         Entry: AL=1 get code page
 *                AL=2 set code page
 *                BX=active code page if set
 *         Exit:  CF=0 BX=active code page if get
 *                     DX=default code page if get
 *                CF=1 AX=error code
 *      67 Set handle count (3.3+)
 *         Entry: BX=handle count
 *         Exit:  CF=0 None
 *                CF=1 AX=error code
 *      68 Commit file (3.3+)
 *         Entry: BX=file handle
 *         Exit:  CF=0 None
 *                CF=1 AX=error code
 *      69 Get or set media info (*) (4.0+)
 *         Entry: AL=0 get media info
 *                AL=1 set media info
 *                BL=drive code (0=default)
 *                DS:DX-&gt;media info
 *         Exit:  CF=0 None
 *                CF=1 AX=error code
 *         Media info format:
 *            0 info level (must be 0)
 *            2 volume serial number
 *            6 volume label
 *           17 8-byte file system type
 *      6A Commit file (*) (4.0+)
 *         Entry: Same as function 68
 *         Exit:  Same as function 68
 *      6B Reserved
 *      6C Extended open/create file (4.0+)
 *         Entry: DS:SI-&gt;filename
 *                BX=open mode
 *                   Bit 0-2 access mode
 *                           000=read
 *                           001=write
 *                           010=read/write
 *                       4-6 sharing mode
 *                           000=compatibility
 *                           001=deny read/write access
 *                           010=deny write access
 *                           011=deny read access
 *                           100=deny none access
 *                         7 inheritance flag
 *                           0=file inherited by EXECed programs
 *                           1=file not inherited by EXECed programs
 *                        13 critical error handling
 *                           0=execute INT 24
 *                           1=return error code
 *                        14 buffering
 *                           0=buffer writes
 *                           1=don't buffer writes
 *                CX=file attributes
 *                DX=open flags
 *                   Bit 0-3 0000=fail if exists
 *                           0001=open if exists
 *                           0010=truncate if exists
 *                       4-7 0000=fail if doesn't exist
 *                           0001=create if doesn't exist
 *         Exit:  CF=0 AX=file handle
 *                     CX=action code (1=file opened,2=file created,3=file truncated)
 *                CF=1 AX=error code
 *
 *      INT 22 Terminate address (1.0+)
 *             This is the address that DOS returns to after program termination.
 *             It is set during execute program (function 4B) processing.
 *
 *      INT 23 Ctrl-Break handler address (1.0+)
 *             This routine is entered when Ctrl-Break is detected by DOS.
 *             On entry the registers are set to the values they had at the start
 *             of the interrupted function call. Control may be returned via
 *             IRET or FAR RET, if FAR RET is used and the carry flag is set
 *             then the program is aborted otherwise the function is restarted.
 *      Note:  Any DOS function may be issued from an INT 23 handler.
 *
 *      INT 24 Critical error handler address (1.0+)
 *      Entry: AH=error indicator
 *                Bit 0 0=read error
 *                      1=write error
 *                  1-2 disk area
 *                      00=DOS area
 *                      01=FAT
 *                      10=directory
 *                      11=data area
 *                    3 1=fail allowed
 *                    4 1=retry allowed
 *                    5 1=ignore allowed
 *                    7 0=block device error
 *                      1=character device error
 *             AL=drive code (0=A)
 *             DI=error code (lower half of DI)
 *                00=write-protect error           07=unknown media type
 *                01=unknown unit                  08=sector not found
 *                02=drive not ready               09=printer out of paper
 *                03=unknown command               0A=write fault
 *                04=data error (CRC)              0B=read fault
 *                05=bad request structure length  0C=general failure
 *                06=seek error                    0F=invalid disk change
 *             BP:SI=pointer to device driver header
 *      Exit:  Control may be returned to DOS via IRET with an action code in AL
 *                0=ignore error (fail if ignore is unallowed)
 *                1=retry function (fail if retry is unallowed)
 *                2=abort program
 *                3=fail system call (abort if fail is unallowed)
 *             Control may be returned directly to the program by removing the
 *             INT 24 registers (IP,CS,flags) from the stack, restoring the
 *             program's registers (AX,BX,CX,DX,SI,DI,BP,DS,ES) and issuing
 *             an IRET. This will leave DOS in an unstable state because the
 *             critical error flag is set until a DOS function other than 01-0C,
 *             33,50,51,59,62,or 64 is issued.
 *      Note:  Only DOS functions 01-0C,33,50,51,59,62,or 64 should be issued from
 *             an INT 24 handler.
 *
 *      INT 25 Absolute disk read (1.0+)
 *      Entry: AL=drive number (0=A)
 *             CX=number of sectors or -1 if &gt;32M partition
 *             DX=starting sector number
 *             DS:BX-&gt;data buffer or parameter block
 *               parameter block (3.31+)
 *                 0 starting sector number
 *                 4 number of sectors
 *                 6 data buffer
 *      Exit:  CF=0 None
 *             CF=1 AH=error code
 *                     01=bad command
 *                     02=bad address mark
 *                     03=write-protect error
 *                     04=sector not found
 *                     08=DMA overrun
 *                     10=data error (bad CRC)
 *                     20=controller error
 *                     40=seek error
 *                     80=timed-out
 *                  AL=device error code (same as lower byte of DI for INT 24)
 *      Notes: 1) The CPU flags are still on the stack after an INT 25 or INT 26.
 *             2) All registers except the segment registers and SP may be destroyed.
 *
 *      INT 26 Absolute disk write (1.0+)
 *      Entry: Same as INT 25
 *      Exit:  Same as INT 25
 *
 *      INT 27 Terminate and stay resident (1.0+)
 *      Entry: CS=PSP
 *             DX=number of bytes to stay resident (minimum 96)
 *      Exit:  Does not return to caller
 *
 *      INT 28 Idle handler (2.0+)
 *             This interrupt is issued by DOS during functions 01-0C to indicate
 *             that a TSR program may safely issue a non-character I/O DOS
 *             function even though the InDOS flag is not zero.
 *             DOS functions 01-0C should not be issued from a INT 28 handler
 *             unless the critical error flag is set first.
 *
 *      INT 29 Character output (2.0+)
 *      Entry: AL=character
 *      Exit:  None
 *      Note:  This interrupt is called for character output if the console
 *             device has bit 4 in the device attribute word set.
 *
 *      INT 2A Network/critical section (*) (3.0+)
 *      00 Network installation check (3.0+)
 *         Entry: None
 *         Exit:  AH=00 not installed
 *                AH=FF installed
 *      01 Execute NETBIOS request with no error retry (*) (3.0+)
 *         Entry: ES:BX-&gt;network control block
 *         Exit:  AH=0 no error
 *                AH=1 AL=error code
 *      02 Set network printer parameters (*) (3.0+)
 *         Entry: DS:SI-&gt;16-byte buffer for local device name
 *                BX=characters per line (-1=use current)
 *                CX=lines per inch (-1=use current)
 *         Exit:  CF=0 None
 *                CF=1 AX=error code
 *      03 Check direct I/O (3.0+)
 *         Entry: DS:SI-&gt;ASCIIZ disk name (d:)
 *         Exit:  CF=0 direct I/O allowed
 *                CF=1 direct I/O not allowed
 *      04 Execute NETBIOS request (3.0+)
 *         Entry: AL=error retry flag (0=retry,1=no retry)
 *                ES:BX-&gt;network control block
 *         Exit:  AH=0 no error
 *                AH=1 AL=error code
 *      05 Get network resource information (3.0+)
 *         Entry: None
 *         Exit:  BX=available network name count
 *                CX=available network control block count
 *                DX=available network session count
 *      06 Network print stream control (3.0+)
 *         Entry: AL=mode (1=concatenation,2=truncation,3=truncate stream)
 *         Exit:  CF=0 None
 *                CF=1 AX=error code
 *      80 Begin critical section (*) (3.0+)
 *         Entry: AL=critical section number
 *         Exit:  None
 *      81 End critical section (*) (3.0+)
 *         Entry: AL=critical section number
 *         Exit:  None
 *      82 End all critical sections (*) (3.0+)
 *         Entry: None
 *         Exit:  None
 *      84 Keyboard idle loop (*) (3.0+)
 *         Entry: None
 *         Exit:  None
 *
 *      INT 2E Execute command (*) (2.0+)
 *      Entry: DS:SI-&gt;command string-1 followed by a carriage return
 *      Exit:  All registers except CS and IP are destroyed
 *      Note:  This function is not re-entrant and should not be issued from a
 *             batch file.
 *
 *      INT 2F Multiplex (3.0+)
 *      Entry: AH=program identifier
 *             AL=function code
 *             Other registers depend on the function
 *      Exit:  Depends on the function
 *
 *      Program identifier codes:
 *      01 Print queueing (PRINT) (3.0+)
 *      02 Network printer control (REDIR) (3.1+)
 *      05 Network error message lookup (REDIR) (3.0+)
 *      06 ASSIGN (3.1+)
 *      08 IBMBIO drive services (used by DRIVER.SYS) (3.2+)
 *      10 File sharing (SHARE) (3.0+)
 *      11 Redirector services (REDIR and MSCDEX) (3.0+)
 *      12 DOS internal services (used by REDIR and MSCDEX) (3.0+)
 *      13 Swap INT 13 vector (3.2+)
 *      14 NLS support (NLSFUNC) (3.3+)
 *      15 CD-ROM extensions (MSCDEX)
 *      16 Windows services
 *      17 Windows clipboard services
 *      1A ANSI.SYS (4.0+)
 *      43 XMS services (HIMEM.SYS)
 *      46 Windows support
 *      48 DOSKEY (5.0+)
 *      4A DOS services (HMA, RPL), SMARTDRV (5.0+)
 *      53 POWER (APM events broadcast) (5.02+)
 *      54 POWER (main API) (5.02+)
 *      55 COMMAND.COM (5.0+)
 *      56 INTERLNK (5.02+)
 *      AC GRAPHICS (5.0+)
 *      AD DISPLAY.SYS, KEYB (3.3+)
 *      AE Installable command support (APPEND) (3.3+)
 *      B0 GRAFTABL (3.3+)
 *      B7 APPEND (3.2+)
 *
 *      DOS extended error information:
 *
 *      Extended error code:                    Error class:
 *      01 Invalid function number              01 Out of resource
 *      02 File not found                       02 Temporary situation
 *      03 Path not found                       03 Authorization error
 *      04 Too many open files                  04 Internal DOS error
 *      05 Access denied                        05 Hardware failure
 *      06 Invalid handle                       06 System software failure
 *      07 Memory control blocks destroyed      07 Application program error
 *      08 Insufficient memory                  08 Not found
 *      09 Invalid memory block address         09 Invalid format
 *      0A Invalid environment                  0A File locked
 *      0B Invalid format                       0B Media error
 *      0C Invalid access code                  0C Already exists
 *      0D Invalid data                         0D Unknown
 *      0E Reserved
 *      0F Invalid drive                        Suggested action:
 *      10 Attempt to remove current directory  01 Retry
 *      11 Not same device                      02 Delay and retry
 *      12 No more files                        03 Get corrected user input
 *      13 Write-protect error                  04 Exit with cleanup
 *      14 Unknown unit                         05 Exit without cleanup
 *      15 Drive not ready                      06 Ignore error
 *      16 Unknown command                      07 Retry after user intervention
 *      17 Data error (CRC)
 *      18 Bad request structure length         Error locus:
 *      19 Seek error                           01 Unknown
 *      1A Unknown medium type                  02 Block device error
 *      1B Sector not found                     03 Network error
 *      1C Printer out of paper                 04 Character device error
 *      1D Write fault                          05 Memory error
 *      1E Read fault
 *      1F General failure
 *      20 Sharing violation
 *      21 Lock violation
 *      22 Invalid disk change
 *      23 FCB unavailable
 *      24 Sharing buffer overflow
 *      25 Code page mismatch (4.0+)
 *      26 Out of input (4.0+)
 *      27 Insufficient disk space (4.0+)
 *      32 Function not supported
 *      41 Network access denied
 *      50 File exists
 *      51 Reserved
 *      52 Cannot make directory entry
 *      53 Fail on INT 24
 *
 * DOS table and structure reference (from https://pcdosretro.github.io/dosblks.txt)
 *
 *      Program Segment Prefix (100h bytes)
 *      00 INT 20
 *      02 End of allocation segment
 *      04 Reserved
 *      05 Far call to DOS
 *      0A Saved INT 22 vector
 *      0E Saved INT 23 vector
 *      12 Saved INT 24 vector (1.1+)
 *      16 Caller PSP segment (2.0+)
 *      18 File table (2.0+)
 *      2C Environment segment (2.0+)
 *      2E Stack pointer after last DOS call (2.0+)
 *      32 File table size (3.0+)
 *      34 Pointer to file table (3.0+)
 *      38 Pointer to next PSP (SHARE only) (3.0+)
 *      3C Reserved
 *      40 DOS version (4.0+)
 *      42 Reserved
 *      50 INT 21,RETF (2.0+)
 *      53 Reserved
 *      5C FCB 1
 *      6C FCB 2
 *      7C Unused
 *      80 Command tail
 *
 *      File Control Block (25h bytes)
 *      00 Drive code (1=A)
 *      01 Filename
 *      09 Extension
 *      0C Current block number
 *      0E Record size
 *      10 File size
 *      14 Date
 *      16 Time
 *      18 Reserved
 *      20 Current record number
 *      21 Random record number
 *
 *      Extended FCB (2Ch bytes)
 *      00 FF (Extended FCB indicator)
 *      01 Reserved
 *      06 Attribute byte
 *      07 Standard FCB
 *
 *      Disk partition table entry (10h bytes)
 *      00 Status (00=non-bootable,80=bootable)
 *      01 Starting head
 *      02 Starting cylinder and sector (INT 13 format)
 *      04 Type (0=unknown,1=FAT12,4=FAT16,5=extended,6=BIGDOS)
 *      05 Ending head
 *      06 Ending cylinder and sector (INT 13 format)
 *      08 Starting absolute sector
 *      0C Number of sectors
 *      Note: There are 4 entries starting at offset 1BE
 *
 *      Disk boot sector (200h bytes)
 *      00 Jump to boot code
 *      03 OEM name
 *      0B Bytes per sector
 *      0D Sectors per cluster
 *      0E Number of reserved sectors
 *      10 Number of FATs
 *      11 Number of root directory entries
 *      13 Total number of sectors
 *      15 Media descriptor byte
 *         F0 1.44M (2 sides,18 sectors/track,80 tracks)
 *            2.88M (2 sides,36 sectors/track,80 tracks)
 *         F8 fixed disk
 *         F9 720K (2 sides,9 sectors/track,80 tracks)
 *            1.2M (2 sides,15 sectors/track,80 tracks)
 *         FC 180K (1 side,9 sectors/track,40 tracks)
 *         FD 360K (2 sides,9 sectors/track,40 tracks)
 *         FE 160K (1 side,8 sectors/track,40 tracks)
 *         FF 320K (2 sides,8 sectors/track,40 tracks)
 *      16 Sectors per FAT
 *      18 Sectors per track
 *      1A Number of heads
 *      1C Number of hidden sectors
 *      20 32-bit number of sectors if word at 13=0 (3.31+)
 *      24 Drive number (4.0+)
 *      25 Reserved (4.0+)
 *      26 Extended boot record ID (29) (4.0+)
 *      27 Serial number (4.0+)
 *      2B Volume label (4.0+)
 *      36 8-byte file system name (4.0+)
 *      Note: Bytes 0B-23 are the BIOS parameter block
 *
 *      Directory entry (20h bytes)
 *      00 Filename
 *      08 Extension
 *      0B Attribute byte
 *         01=Read-only
 *         02=Hidden
 *         04=System
 *         08=Volume label (2.0+)
 *         10=Directory (2.0+)
 *         20=Archive (2.0+)
 *      0C Reserved
 *      16 Time
 *         Bits 0-4 Seconds/2 (0-29)
 *             5-10 Minutes (0-59)
 *            11-15 Hours (0-23)
 *      18 Date
 *         Bits 0-4 Day (1-31)
 *              5-8 Month (1-12)
 *             9-15 Year-1980
 *      1A Starting cluster number
 *      1C File size
 *
 *      Disk parameter block (20h bytes in 3.x, 21h bytes in 4.0+)
 *      00 Drive code (0=A)
 *      01 Unit code
 *      02 Bytes per sector
 *      04 Sectors per cluster-1
 *      05 Cluster shift factor (2**n sectors per cluster)
 *      06 First FAT sector
 *      08 Number of FATs
 *      09 Number of directory entries
 *      0B First data sector
 *      0D Maximum cluster number
 *      0F Sectors per FAT
 *      11 First directory sector
 *      13 Pointer to device driver
 *      17 Media descriptor byte
 *      18 Access flag (00=accessed,FF=not accessed)
 *      19 Pointer to next DPB
 *      1D Last cluster allocated
 *      1F Number of free clusters (-1 if unknown)
 *      Note: (3.x) The sectors per FAT field is one byte and all following
 *            fields are moved back one byte.
 *
 *      System file table (35h bytes in 3.x, 3Bh bytes in 4.0+)
 *      00 Open count
 *      02 Open mode
 *         Bit 0-2 access mode
 *                 000=read
 *                 001=write
 *                 010=read/write
 *             4-6 sharing mode
 *                 000=compatibility
 *                 001=deny read/write
 *                 010=deny write
 *                 011=deny read
 *                 100=deny none
 *              13 critical error handling
 *                 0=execute INT 24
 *                 1=return error code
 *              14 buffering
 *                 0=buffer writes
 *                 1=don't buffer writes
 *              15 1=FCB SFT
 *      04 Attribute byte
 *      05 Device info
 *         Character devices:          Block devices:
 *         Bit 0 1=console input       Bit 0-5 drive code (0=A)
 *             1 1=console output            6 0=file has been written
 *             2 1=NUL device                7 0=block device
 *             3 1=CLOCK device             12 1=no inherit
 *             4 1=INT 29 output (CON)      14 1=date/time set
 *             5 0=ASCII,1=binary           15 1=redirected file
 *             6 0=EOF on input
 *             7 1=character device
 *            11 1=network spooler
 *            12 1=no inherit
 *            13 1=named pipe
 *            15 1=redirected device
 *      07 Pointer to device driver or disk parameter block
 *      0B First cluster number
 *      0D Time
 *      0F Date
 *      11 File size
 *      15 File pointer
 *      19 Current relative cluster number
 *      1B 32-bit directory entry sector (4.0+)
 *      1B Current absolute cluster number (3.x)
 *      1D Directory entry sector (3.x)
 *      1F Directory entry position in sector
 *      20 Filename
 *      28 Extension
 *      2B Pointer to next SFT for the same file (SHARE only)
 *      2F Machine number
 *      31 PSP of owner
 *      33 SHARE file table offset
 *      35 Current absolute cluster number (4.0+)
 *      37 Reserved (4.0+)
 *
 *      SHARE file table
 *      00 Entry flag (1=open,0=unused,-1=end of list)
 *      01 Entry length
 *      03 Filespec checksum
 *      04 First lock table offset
 *      06 Pointer to system file table
 *      0A SHARE file number
 *      0C Filespec
 *
 *      SHARE lock table (10h bytes)
 *      00 Offset to next lock table for file
 *      02 Start of lock region
 *      06 End of lock region
 *      0A Pointer to system file table
 *      0E PSP of owner
 *
 *      Current directory structure (51h bytes in 3.x, 58h bytes in 4.0+)
 *      00 Current directory
 *      43 Drive type
 *         1000=SUBSTed drive
 *         2000=JOINed drive
 *         4000=valid drive
 *         8000=redirected drive
 *      45 Pointer to disk parameter block
 *      49 Cluster number of current directory (0=root)
 *      4B Reserved
 *      4F Length of root directory name starting at offset 0
 *      51 Reserved (4.0+)
 *
 *      Disk buffer header (10h bytes) (3.x)
 *      00 Pointer to next buffer
 *      04 Drive code (0=A,FF=unused)
 *      05 Flags
 *         Bit 0 reserved
 *             1 1=FAT sector
 *             2 1=directory sector
 *             3 1=data sector
 *             4 reserved
 *             5 1=buffer read
 *             6 1=buffer written
 *             7 reserved
 *      06 Sector number
 *      08 Number of FATs (if FAT) or 1
 *      09 Sectors per FAT (if FAT) or 0
 *      0A Pointer to DPB
 *      0E Reserved
 *      10 Buffered sector
 *
 *      Disk buffer header (14h bytes) (4.0+)
 *      00 Pointer to next buffer
 *      02 Pointer to previous buffer
 *      04 Drive code (0=A,FF=unused)
 *      05 Flags
 *         Bit 0 reserved
 *             1 1=FAT sector
 *             2 1=directory sector
 *             3 1=data sector
 *             4 reserved
 *             5 1=buffer read (4.0)
 *             6 1=buffer written
 *             7 reserved
 *      06 Sector number
 *      0A Number of FATs (if FAT) or 1
 *      0B Sectors per FAT (if FAT) or 0
 *      0D Pointer to DPB
 *      11 Reserved
 *      14 Buffered sector
 *
 *      Disk buffer control block (4.0)
 *      00 Pointer to buffer chain array
 *      04 Number of chains
 *      06 Pointer to sector lookahead buffers
 *      0A Number of sector lookahead buffers
 *      0C Unknown
 *
 *      Disk buffer control block (5.0+)
 *      00 Pointer to buffer chain
 *      04 Number of modified buffers
 *      06 Pointer to sector lookahead buffers
 *      0A Number of sector lookahead buffers
 *      0C HMA flag (1=buffers in HMA)
 *      0D Pointer to HMA transfer buffer
 *
 *      Disk buffer chain array entry (8 bytes) (4.0)
 *      00 Reserved
 *      02 Pointer to last accessed buffer
 *      06 Number of modified buffers
 *      07 Reserved
 *
 *      Stacks block header (12h bytes)
 *      00 Reserved
 *      02 Number of stacks
 *      04 Offset of stacks
 *      06 Stack size
 *      08 Pointer to stacks table (descriptors followed by stacks)
 *      0C Offset of first stacks descriptor
 *      0E Offset of last stacks descriptor
 *      10 Offset of current stacks descriptor
 *
 *      Stacks descriptor (8 bytes)
 *      00 Flag (0=free,1=in use)
 *      02 Save area for SS:SP
 *      06 Offset of end of stack
 *
 *      Device driver header (12h bytes)
 *      00 Pointer to next device driver or -1
 *      04 Attribute word
 *         Bit 0 1=console input
 *             1 1=console output (character devices)
 *               1=32-bit sectors supported (block devices) (3.31+)
 *             2 1=NUL device
 *             3 1=CLOCK device
 *             4 1=INT 29 output (CON)
 *             6 1=extended functions supported (13,17,18) (3.2+)
 *             7 1=query IOCTL function supported (19) (5.0+)
 *            11 1=open/close/removable media supported (3.0+)
 *            13 1=output until busy supported (character devices) (3.0+)
 *               1=media descriptor in FAT required (block devices)
 *            14 1=IOCTL supported
 *            15 0=block device
 *               1=character device
 *      06 Strategy address
 *      08 Interrupt address
 *      0A Device name or number of units
 *
 *      Device driver request header (common fields)
 *      00 Request header length
 *      01 Unit number
 *      02 Command code
 *         00=Init                   0B=Flush output buffers
 *         01=Media check            0C=I/O control write
 *         02=Build BPB              0D=Open (3.0+)
 *         03=I/O control read       0E=Close (3.0+)
 *         04=Read                   0F=Removable media check (3.0+)
 *         05=Non-destructive read   10=Output until busy (3.0+)
 *         06=Input status           13=Generic I/O control (3.2+)
 *         07=Flush input buffers    17=Get drive map (3.2+)
 *         08=Write                  18=Set drive map (3.2+)
 *         09=Write with verify      19=Query I/O control (5.0+)
 *         0A=Output status
 *      03 Return status word
 *         Bit 0-7 if error
 *                 00=write-protect error  07=unknown medium
 *                 01=unknown unit         08=sector not found
 *                 02=drive not ready      09=printer out of paper
 *                 03=unknown command      0A=write fault
 *                 04=data error (CRC)     0B=read fault
 *                 05=bad request length   0C=general failure
 *                 06=seek error           0F=invalid disk change
 *               8 1=done
 *               9 1=busy
 *              15 1=error
 *      05 Reserved (8 bytes)
 *
 *      Device driver request headers:
 *      Init
 *      00 Common (length=17h in 3.x, 19h in 4.0+)
 *      0D Number of units (set by driver)
 *      0E End of available memory (5.0+)
 *         End of resident code (set by driver)
 *      12 Pointer to string after DEVICE=
 *         BPB array pointer (set by driver)
 *      16 Drive code of first unit (0=A)
 *      17 Error message flag (1=display message) (4.0+)
 *
 *      Media check
 *      00 Common (length=13h)
 *      0D Media descriptor byte
 *      0E Status (set by driver: 1=unchanged,0=unknown,-1=changed)
 *      0F Pointer to previous disk label (set by driver if disk changed)
 *
 *      Build BPB
 *      00 Common (length=16h)
 *      0D Media descriptor byte
 *      0E Pointer to sector buffer
 *      12 Pointer to BPB (set by driver)
 *      Note: The sector buffer contains the first sector of the FAT if bit 13 in the
 *            device attribute word is zero otherwise it may be used as scratch space.
 *
 *      IOCTL read, Read, Write, Write with verify, IOCTL write, Output until busy
 *      00 Common (length=14h)
 *      0D Unused
 *      0E Pointer to data buffer
 *      12 Byte count (set by driver to number of bytes transferred)
 *      Notes: 1) The IOCTL functions are called only if bit 14 in the device
 *                attribute word is set.
 *             2) The output until busy function is called only if bit 13 in the
 *                device attribute word is set.
 *
 *      Read, Write, Write with verify
 *      00 Common (length=16h-1Eh)
 *      0D Media descriptor byte
 *      0E Pointer to data buffer
 *      12 Sector count (set by driver to number of sectors transferred)
 *      14 Starting sector number (-1=if 32-bit sectors)
 *      16 Pointer to previous disk label (set by driver if error 0F)
 *      1A 32-bit starting sector number
 *      Note: The 32-bit starting sector number is used only if bit 1 in the
 *            device attribute word is set.
 *
 *      Non-destructive read
 *      00 Common (length=0Eh)
 *      0D Character (set by driver)
 *      Note: This function sets the busy bit (bit 9) in the request header
 *            if no character is ready.
 *
 *      Input status, Output status
 *      00 Common (length=0Dh)
 *      Note: These functions set the busy bit (bit 9) in the request header
 *            to indicate device status.
 *
 *      Flush input buffers, Flush output buffers
 *      00 Common (length=0Dh)
 *
 *      Open, Close, Removable media check
 *      00 Common (length=0Dh)
 *      Notes: 1) These functions are called only if bit 11 in the device
 *                attribute word is set.
 *             2) The removable media check function sets bit 9 in the status word
 *                if the device is non-removable.
 *
 *      Generic IOCTL, Query IOCTL
 *      00 Common (length=17h)
 *      0D Category code
 *      0E Function code
 *      0F Unused
 *      13 Parameter buffer pointer
 *      Notes: 1) The Generic IOCTL function is called only if bit 6 in the device
 *                attribute word is set.
 *             2) The Query IOCTL function is called only if bit 7 in the device
 *                attribute word is set.
 *
 *      Get drive map, Set drive map
 *      00 Common (length=0Dh)
 *      Notes: 1) These functions are called only if bit 6 in the device
 *                attribute word is set.
 *             2) These functions set the unit field (byte 1) in the request
 *                header to the physical drive code.
 *
 *      Clock device info (6 bytes)
 *      00 Days since 1/1/80
 *      02 Minutes
 *      03 Hours
 *      04 Hundredths
 *      05 Seconds
 *
 *      Memory Control Block (10h bytes)
 *      00 Type ('M' or 'Z' if last)
 *      01 PSP segment of owner (0=free,8=DOS)
 *      03 Size (paragraphs)
 *      05 Unused
 *      08 Program name (4.0+)
 *
 *      EXE file header
 *      00 'MZ'
 *      02 Size of last page
 *      04 File size in 512-byte pages
 *      06 Relocation table count
 *      08 Header size (paragraphs)
 *      0A Minimum allocation (paragraphs)
 *      0C Maximum allocation (paragraphs)
 *      0E Initial SS
 *      10 Initial SP
 *      12 Checksum
 *      14 Initial IP
 *      16 Initial CS
 *      18 Offset of relocation table
 *         Table entry format:
 *         0 offset of relocation
 *         2 segment of relocation
 *      1A Overlay number
 *
 *      EXEPACK header
 *      00 Actual IP
 *      02 Actual CS
 *      04 0 (set to PSP+10h by unpack code)
 *      06 Unpack code and data size (including relocation table)
 *      08 Actual SP
 *      0A Actual SS
 *      0C Actual code and data size
 *
 *      Note: If an EXE file is packed then CS:IP-2 points to 'RB' and CS:0
 *            points to the EXEPACK header, this is followed by the unpack code
 *            and a relocation table containing a word count and relocation
 *            entries for 16 segments.
 */

/**
 * Other miscellaneous definitions for historical reference.
 *
 * From DEBUGSYS.INC:
 *
 * D386_Device_Params STRUC
 *      DD_logical_seg  dw  ?   ; logical segment # from map
 *      DD_actual_sel   dw  ?   ; actual selector value
 *      DD_base         dd  ?   ; linear address offset for start of segment
 *      DD_length       dd  ?   ; actual length of segment
 *      DD_name         df  ?   ; 16:32 ptr to null terminated device name
 *      DD_sym_name     df  ?   ; 16:32 ptr to null terminated symbolic module name  (i.e. Win386)
 *      DD_alias_sel    dw  ?   ; alias selector value (0 = none)
 *  D386_Device_Params ENDS
 */

Interrupts.VxD = {
    VECTOR: 0x20,
    "VMM": {
        id: 0x0001,
        fn: [
            "Get_VMM_Version",
            "Get_Cur_VM_Handle",
            "Test_Cur_VM_Handle",
            "Get_Sys_VM_Handle",
            "Test_Sys_VM_Handle",
            "Validate_VM_Handle",
            "Get_VMM_Reenter_Count",
            "Begin_Reentrant_Execution",
            "End_Reentrant_Execution",
            "Install_V86_Break_Point",
            "Remove_V86_Break_Point",
            "Allocate_V86_Call_Back",
            "Allocate_PM_Call_Back",
            "Call_When_VM_Returns",
            "Schedule_Global_Event",
            "Schedule_VM_Event",
            "Call_Global_Event",
            "Call_VM_Event",
            "Cancel_Global_Event",
            "Cancel_VM_Event",
            "Call_Priority_VM_Event",
            "Cancel_Priority_VM_Event",
            "Get_NMI_Handler_Addr",
            "Set_NMI_Handler_Addr",
            "Hook_NMI_Event",
            "Call_When_VM_Ints_Enabled",
            "Enable_VM_Ints",
            "Disable_VM_Ints",
            "Map_Flat",
            "Map_Lin_To_VM_Addr",
            "Adjust_Exec_Priority",
            "Begin_Critical_Section",
            "End_Critical_Section",
            "End_Crit_And_Suspend",
            "Claim_Critical_Section",
            "Release_Critical_Section",
            "Call_When_Not_Critical",
            "Create_Semaphore",
            "Destroy_Semaphore",
            "Wait_Semaphore",
            "Signal_Semaphore",
            "Get_Crit_Section_Status",
            "Call_When_Task_Switched",
            "Suspend_VM",
            "Resume_VM",
            "No_Fail_Resume_VM",
            "Nuke_VM",
            "Crash_Cur_VM",
            "Get_Execution_Focus",
            "Set_Execution_Focus",
            "Get_Time_Slice_Priority",
            "Set_Time_Slice_Priority",
            "Get_Time_Slice_Granularity",
            "Set_Time_Slice_Granularity",
            "Get_Time_Slice_Info",
            "Adjust_Execution_Time",
            "Release_Time_Slice",
            "Wake_Up_VM",
            "Call_When_Idle",
            "Get_Next_VM_Handle",
            "Set_Global_Time_Out",
            "Set_VM_Time_Out",
            "Cancel_Time_Out",
            "Get_System_Time",
            "Get_VM_Exec_Time",
            "Hook_V86_Int_Chain",
            "Get_V86_Int_Vector",
            "Set_V86_Int_Vector",
            "Get_PM_Int_Vector",
            "Set_PM_Int_Vector",
            "Simulate_Int",
            "Simulate_Iret",
            "Simulate_Far_Call",
            "Simulate_Far_Jmp",
            "Simulate_Far_Ret",
            "Simulate_Far_Ret_N",
            "Build_Int_Stack_Frame",
            "Simulate_Push",
            "Simulate_Pop",
            "_HeapAllocate",
            "_HeapReAllocate",
            "_HeapFree",
            "_HeapGetSize",
            "_PageAllocate",
            "_PageReAllocate",
            "_PageFree",
            "_PageLock",
            "_PageUnLock",
            "_PageGetSizeAddr",
            "_PageGetAllocInfo",
            "_GetFreePageCount",
            "_GetSysPageCount",
            "_GetVMPgCount",
            "_MapIntoV86",
            "_PhysIntoV86",
            "_TestGlobalV86Mem",
            "_ModifyPageBits",
            "_CopyPageTable",
            "_LinMapIntoV86",
            "_LinPageLock",
            "_LinPageUnLock",
            "_SetResetV86Pageable",
            "_GetV86PageableArray",
            "_PageCheckLinRange",
            "_PageOutDirtyPages",
            "_PageDiscardPages",
            "_GetNulPageHandle",
            "_GetFirstV86Page",
            "_MapPhysToLinear",
            "_GetAppFlatDSAlias",
            "_SelectorMapFlat",
            "_GetDemandPageInfo",
            "_GetSetPageOutCount",
            "Hook_V86_Page",
            "_Assign_Device_V86_Pages",
            "_DeAssign_Device_V86_Pages",
            "_Get_Device_V86_Pages_Array",
            "MMGR_SetNULPageAddr",
            "_Allocate_GDT_Selector",
            "_Free_GDT_Selector",
            "_Allocate_LDT_Selector",
            "_Free_LDT_Selector",
            "_BuildDescriptorDWORDs",
            "_GetDescriptor",
            "_SetDescriptor",
            "_MMGR_Toggle_HMA",
            "Get_Fault_Hook_Addrs",
            "Hook_V86_Fault",
            "Hook_PM_Fault",
            "Hook_VMM_Fault",
            "Begin_Nest_V86_Exec",
            "Begin_Nest_Exec",
            "Exec_Int",
            "Resume_Exec",
            "End_Nest_Exec",
            "Allocate_PM_App_CB_Area",
            "Get_Cur_PM_App_CB",
            "Set_V86_Exec_Mode",
            "Set_PM_Exec_Mode",
            "Begin_Use_Locked_PM_Stack",
            "End_Use_Locked_PM_Stack",
            "Save_Client_State",
            "Restore_Client_State",
            "Exec_VxD_Int",
            "Hook_Device_Service",
            "Hook_Device_V86_API",
            "Hook_Device_PM_API",
            "System_Control",
            "Simulate_IO",
            "Install_Mult_IO_Handlers",
            "Install_IO_Handler",
            "Enable_Global_Trapping",
            "Enable_Local_Trapping",
            "Disable_Global_Trapping",
            "Disable_Local_Trapping",
            "List_Create",
            "List_Destroy",
            "List_Allocate",
            "List_Attach",
            "List_Attach_Tail",
            "List_Insert",
            "List_Remove",
            "List_Deallocate",
            "List_Get_First",
            "List_Get_Next",
            "List_Remove_First",
            "_AddInstanceItem",
            "_Allocate_Device_CB_Area",
            "_Allocate_Global_V86_Data_Area",
            "_Allocate_Temp_V86_Data_Area",
            "_Free_Temp_V86_Data_Area",
            "Get_Profile_Decimal_Int",
            "Convert_Decimal_String",
            "Get_Profile_Fixed_Point",
            "Convert_Fixed_Point_String",
            "Get_Profile_Hex_Int",
            "Convert_Hex_String",
            "Get_Profile_Boolean",
            "Convert_Boolean_String",
            "Get_Profile_String",
            "Get_Next_Profile_String",
            "Get_Environment_String",
            "Get_Exec_Path",
            "Get_Config_Directory",
            "OpenFile",
            "Get_PSP_Segment",
            "GetDOSVectors",
            "Get_Machine_Info",
            "GetSet_HMA_Info",
            "Set_System_Exit_Code",
            "Fatal_Error_Handler",
            "Fatal_Memory_Error",
            "Update_System_Clock",
            "Test_Debug_Installed",
            "Out_Debug_String",
            "Out_Debug_Chr",
            "In_Debug_Chr",
            "Debug_Convert_Hex_Binary",
            "Debug_Convert_Hex_Decimal",
            "Debug_Test_Valid_Handle",
            "Validate_Client_Ptr",
            "Test_Reenter",
            "Queue_Debug_String",
            "Log_Proc_Call",
            "Debug_Test_Cur_VM",
            "Get_PM_Int_Type",
            "Set_PM_Int_Type",
            "Get_Last_Updated_System_Time",
            "Get_Last_Updated_VM_Exec_Time",
            "Test_DBCS_Lead_Byte",
            "_AddFreePhysPage",
            "_PageResetHandlePAddr",
            "_SetLastV86Page",
            "_GetLastV86Page",
            "_MapFreePhysReg",
            "_UnmapFreePhysReg",
            "_XchgFreePhysReg",
            "_SetFreePhysRegCalBk",
            "Get_Next_Arena",
            "Get_Name_Of_Ugly_TSR",
            "Get_Debug_Options",
            "Set_Physical_HMA_Alias",
            "_GetGlblRng0V86IntBase",
            "_Add_Global_V86_Data_Area",
            "GetSetDetailedVMError",
            "Is_Debug_Chr",
            "Clear_Mono_Screen",
            "Out_Mono_Chr",
            "Out_Mono_String",
            "Set_Mono_Cur_Pos",
            "Get_Mono_Cur_Pos",
            "Get_Mono_Chr",
            "Locate_Byte_In_ROM",
            "Hook_Invalid_Page_Fault",
            "Unhook_Invalid_Page_Fault",
            "Set_Delete_On_Exit_File",
            "Close_VM",
            "Enable_Touch_1st_Meg",
            "Disable_Touch_1st_Meg",
            "Install_Exception_Handler",
            "Remove_Exception_Handler",
            "Get_Crit_Status_No_Block",
            "_GetLastUpdatedThreadExecTime",
            "_Trace_Out_Service",
            "_Debug_Out_Service",
            "_Debug_Flags_Service",
            "VMMAddImportModuleName",
            "VMM_Add_DDB",
            "VMM_Remove_DDB",
            "Test_VM_Ints_Enabled",
            "_BlockOnID",
            "Schedule_Thread_Event",
            "Cancel_Thread_Event",
            "Set_Thread_Time_Out",
            "Set_Async_Time_Out",
            "_AllocateThreadDataSlot",
            "_FreeThreadDataSlot",
            "_CreateMutex",
            "_DestroyMutex",
            "_GetMutexOwner",
            "Call_When_Thread_Switched",
            "VMMCreateThread",
            "_GetThreadExecTime",
            "VMMTerminateThread",
            "Get_Cur_Thread_Handle",
            "Test_Cur_Thread_Handle",
            "Get_Sys_Thread_Handle",
            "Test_Sys_Thread_Handle",
            "Validate_Thread_Handle",
            "Get_Initial_Thread_Handle",
            "Test_Initial_Thread_Handle",
            "Debug_Test_Valid_Thread_Handle",
            "Debug_Test_Cur_Thread",
            "VMM_GetSystemInitState",
            "Cancel_Call_When_Thread_Switched",
            "Get_Next_Thread_Handle",
            "Adjust_Thread_Exec_Priority",
            "_Deallocate_Device_CB_Area",
            "Remove_IO_Handler",
            "Remove_Mult_IO_Handlers",
            "Unhook_V86_Int_Chain",
            "Unhook_V86_Fault",
            "Unhook_PM_Fault",
            "Unhook_VMM_Fault",
            "Unhook_Device_Service",
            "_PageReserve",
            "_PageCommit",
            "_PageDecommit",
            "_PagerRegister",
            "_PagerQuery",
            "_PagerDeregister",
            "_ContextCreate",
            "_ContextDestroy",
            "_PageAttach",
            "_PageFlush",
            "_SignalID",
            "_PageCommitPhys",
            "_Register_Win32_Services",
            "Cancel_Call_When_Not_Critical",
            "Cancel_Call_When_Idle",
            "Cancel_Call_When_Task_Switched",
            "_Debug_Printf_Service",
            "_EnterMutex",
            "_LeaveMutex",
            "Simulate_VM_IO",
            "Signal_Semaphore_No_Switch",
            "_ContextSwitch",
            "_PageModifyPermissions",
            "_PageQuery",
            "_EnterMustComplete",
            "_LeaveMustComplete",
            "_ResumeExecMustComplete",
            "_GetThreadTerminationStatus",
            "_GetInstanceInfo",
            "_ExecIntMustComplete",
            "_ExecVxDIntMustComplete",
            "Begin_V86_Serialization",
            "Unhook_V86_Page",
            "VMM_GetVxDLocationList",
            "VMM_GetDDBList",
            "Unhook_NMI_Event",
            "Get_Instanced_V86_Int_Vector",
            "Get_Set_Real_DOS_PSP",
            "Call_Priority_Thread_Event",
            "Get_System_Time_Address",
            "Get_Crit_Status_Thread",
            "Get_DDB",
            "Directed_Sys_Control",
            "_RegOpenKey",
            "_RegCloseKey",
            "_RegCreateKey",
            "_RegDeleteKey",
            "_RegEnumKey",
            "_RegQueryValue",
            "_RegSetValue",
            "_RegDeleteValue",
            "_RegEnumValue",
            "_RegQueryValueEx",
            "_RegSetValueEx",
            "_CallRing3",
            "Exec_PM_Int",
            "_RegFlushKey",
            "_PageCommitContig",
            "_GetCurrentContext",
            "_LocalizeSprintf",
            "_LocalizeStackSprintf",
            "Call_Restricted_Event",
            "Cancel_Restricted_Event",
            "Register_PEF_Provider",
            "_GetPhysPageInfo",
            "_RegQueryInfoKey",
            "MemArb_Reserve_Pages",
            "Time_Slice_Sys_VM_Idle",
            "Time_Slice_Sleep",
            "Boost_With_Decay",
            "Set_Inversion_Pri",
            "Reset_Inversion_Pri",
            "Release_Inversion_Pri",
            "Get_Thread_Win32_Pri",
            "Set_Thread_Win32_Pri",
            "Set_Thread_Static_Boost",
            "Set_VM_Static_Boost",
            "Release_Inversion_Pri_ID",
            "Attach_Thread_To_Group",
            "Detach_Thread_From_Group",
            "Set_Group_Static_Boost",
            "_GetRegistryPath",
            "_GetRegistryKey",
            "Cleanup_Thread_State",
            "_RegRemapPreDefKey",
            "End_V86_Serialization",
            "_Assert_Range",
            "_Sprintf",
            "_PageChangePager",
            "_RegCreateDynKey",
            "_RegQueryMultipleValues",
            "Boost_Thread_With_VM",
            "Get_Boot_Flags",
            "Set_Boot_Flags",
            "_lstrcpyn",
            "_lstrlen",
            "_lmemcpy",
            "_GetVxDName",
            "Force_Mutexes_Free",
            "Restore_Forced_Mutexes",
            "_AddReclaimableItem",
            "_SetReclaimableItem",
            "_EnumReclaimableItem",
            "Time_Slice_Wake_Sys_VM",
            "VMM_Replace_Global_Environment",
            "Begin_Non_Serial_Nest_V86_Exec",
            "Get_Nest_Exec_Status",
            "Open_Boot_Log",
            "Write_Boot_Log",
            "Close_Boot_Log",
            "EnableDisable_Boot_Log",
            "_Call_On_My_Stack",
            "Get_Inst_V86_Int_Vec_Base",
            "_lstrcmpi",
            "_strupr",
            "Log_Fault_Call_Out",
            "_AtEventTime"
        ]
    },
    "DEBUG": {
        id: 0x0002,
        fn: [
            "DEBUG_Get_Version",
            "DEBUG_Fault",
            "DEBUG_CheckFault",
            "_DEBUG_LoadSyms"
        ]
    },
    "VPICD": {
        id: 0x0003,
        fn: [
            "VPICD_Get_Version",
            "VPICD_Virtualize_IRQ",
            "VPICD_Set_Int_Request",
            "VPICD_Clear_Int_Request",
            "VPICD_Phys_EOI",
            "VPICD_Get_Complete_Status",
            "VPICD_Get_Status",
            "VPICD_Test_Phys_Request",
            "VPICD_Physically_Mask",
            "VPICD_Physically_Unmask",
            "VPICD_Set_Auto_Masking",
            "VPICD_Get_IRQ_Complete_Status",
            "VPICD_Convert_Handle_To_IRQ",
            "VPICD_Convert_IRQ_To_Int",
            "VPICD_Convert_Int_To_IRQ",
            "VPICD_Call_When_Hw_Int",
            "VPICD_Force_Default_Owner",
            "VPICD_Force_Default_Behavior",
            "VPICD_Auto_Mask_At_Inst_Swap",
            "VPICD_Begin_Inst_Page_Swap",
            "VPICD_End_Inst_Page_Swap",
            "VPICD_Virtual_EOI",
            "VPICD_Get_Virtualization_Count",
            "VPICD_Post_Sys_Critical_Init",
            "VPICD_VM_SlavePIC_Mask_Change"
        ]
    },
    "VDMAD": {
        id: 0x0004,
        fn: [
            "VDMAD_Get_Version",
            "VDMAD_Virtualize_Channel",
            "VDMAD_Get_Region_Info",
            "VDMAD_Set_Region_Info",
            "VDMAD_Get_Virt_State",
            "VDMAD_Set_Virt_State",
            "VDMAD_Set_Phys_State",
            "VDMAD_Mask_Channel",
            "VDMAD_UnMask_Channel",
            "VDMAD_Lock_DMA_Region",
            "VDMAD_Unlock_DMA_Region",
            "VDMAD_Scatter_Lock",
            "VDMAD_Scatter_Unlock",
            "VDMAD_Reserve_Buffer_Space",
            "VDMAD_Request_Buffer",
            "VDMAD_Release_Buffer",
            "VDMAD_Copy_To_Buffer",
            "VDMAD_Copy_From_Buffer",
            "VDMAD_Default_Handler",
            "VDMAD_Disable_Translation",
            "VDMAD_Enable_Translation",
            "VDMAD_Get_EISA_Adr_Mode",
            "VDMAD_Set_EISA_Adr_Mode",
            "VDMAD_Unlock_DMA_Region_No_Dirty",
            "VDMAD_Phys_Mask_Channel",
            "VDMAD_Phys_Unmask_Channel",
            "VDMAD_Unvirtualize_Channel",
            "VDMAD_Set_IO_Add",
            "VDMAD_Get_Phys_Count",
            "VDMAD_Get_Phys_Status",
            "VDMAD_Get_Max_Phys_Page",
            "VDMAD_Set_Channel_Callbacks",
            "VDMAD_Get_Virt_Count",
            "VDMAD_Set_Virt_Count"
        ]
    },
    "VTD": {
        id: 0x0005,
        fn: [
            "VTD_Get_Version",
            "VTD_Update_System_Clock",
            "VTD_Get_Interrupt_Period",
            "VTD_Begin_Min_Int_Period",
            "VTD_End_Min_Int_Period",
            "VTD_Disable_Trapping",
            "VTD_Enable_Trapping",
            "VTD_Get_Real_Time",
            "VTD_Get_Date_And_Time",
            "VTD_Adjust_VM_Count",
            "VTD_Delay"
        ]
    },
    "V86MMGR": {
        id: 0x0006,
        fn: [
            "V86MMGR_Get_Version",
            "V86MMGR_Allocate_V86_Pages",
            "V86MMGR_Set_EMS_XMS_Limits",
            "V86MMGR_Get_EMS_XMS_Limits",
            "V86MMGR_Set_Mapping_Info",
            "V86MMGR_Get_Mapping_Info",
            "V86MMGR_Xlat_API",
            "V86MMGR_Load_Client_Ptr",
            "V86MMGR_Allocate_Buffer",
            "V86MMGR_Free_Buffer",
            "V86MMGR_Get_Xlat_Buff_State",
            "V86MMGR_Set_Xlat_Buff_State",
            "V86MMGR_Get_VM_Flat_Sel",
            "V86MMGR_Map_Pages",
            "V86MMGR_Free_Page_Map_Region",
            "V86MMGR_LocalGlobalReg",
            "V86MMGR_GetPgStatus",
            "V86MMGR_SetLocalA20",
            "V86MMGR_ResetBasePages",
            "V86MMGR_SetAvailMapPgs",
            "V86MMGR_NoUMBInitCalls",
            "V86MMGR_Get_EMS_XMS_Avail",
            "V86MMGR_Toggle_HMA",
            "V86MMGR_Dev_Init",
            "V86MMGR_Alloc_UM_Page"
        ]
    },
    "PAGESWAP": {
        id: 0x0007,
        fn: [
            "PageSwap_Get_Version",
            "PageSwap_Invalid_Service1",
            "PageSwap_Invalid_Service2",
            "PageSwap_Invalid_Service3",
            "PageSwap_Invalid_Service4",
            "PageSwap_Invalid_Service5",
            "PageSwap_Test_IO_Valid",
            "PageSwap_Read_Or_Write",
            "PageSwap_Grow_File",
            "PageSwap_Init_File"
        ]
    },
    "PARITY": {
        id: 0x0008
    },
    "REBOOT": {
        id: 0x0009,
        fn: [
            "REBOOT_Get_Version",
            "REBOOT_Enable_Real_Reboot",
            "REBOOT_Disable_Real_Reboot",
            "REBOOT_Processor_Now"
        ]
    },
    "VDD": {
        id: 0x000A,
        fn: [
            "VDD_Get_Version",
            "VDD_PIF_State",
            "VDD_Get_GrabRtn",
            "VDD_Hide_Cursor",
            "VDD_Set_VMType",
            "VDD_Get_ModTime",
            "VDD_Set_HCurTrk",
            "VDD_Msg_ClrScrn",
            "VDD_Msg_ForColor",
            "VDD_Msg_BakColor",
            "VDD_Msg_TextOut",
            "VDD_Msg_SetCursPos",
            "VDD_Query_Access",
            "VDD_Check_Update_Soon"
        ]
    },
    "VSD": {
        id: 0x000B,
        fn: [
            "VSD_Get_Version",
            "VSD_Bell",
            "VSD_SoundOn",
            "VSD_TakeSoundPort"
        ]
    },
    "VMD": {
        id: 0x000C,
        alt: "VMOUSE",
        fn: [
            "VMD_Get_Version",
            "VMD_Set_Mouse_Type",
            "VMD_Get_Mouse_Owner",
            "VMD_Post_Pointer_Message",
            "VMD_Set_Cursor_Proc",
            "VMD_Call_Cursor_Proc",
            "VMD_Set_Mouse_Data",
            "VMD_Get_Mouse_Data",
            "VMD_Manipulate_Pointer_Message",
            "VMD_Set_Middle_Button",
            "VMD_Enable_Disable_Mouse_Events",
            "VMD_Post_Absolute_Pointer_Message",
        ]
    },
    "VKD": {
        id: 0x000D,
        fn: [
            "VKD_Get_Version",
            "VKD_Define_Hot_Key",
            "VKD_Remove_Hot_Key",
            "VKD_Local_Enable_Hot_Key",
            "VKD_Local_Disable_Hot_Key",
            "VKD_Reflect_Hot_Key",
            "VKD_Cancel_Hot_Key_State",
            "VKD_Force_Keys",
            "VKD_Get_Kbd_Owner",
            "VKD_Define_Paste_Mode",
            "VKD_Start_Paste",
            "VKD_Cancel_Paste",
            "VKD_Get_Msg_Key",
            "VKD_Peek_Msg_Key",
            "VKD_Flush_Msg_Key_Queue",
            "VKD_Enable_Keyboard",
            "VKD_Disable_Keyboard",
            "VKD_Get_Shift_State",
            "VKD_Filter_Keyboard_Input",
            "VKD_Put_Byte",
            "VKD_Set_Shift_State"
        ]
    },
    "VCD": {
        id: 0x000E,
        fn: [
            "VCD_Get_Version",
            "VCD_Set_Port_Global",
            "VCD_Get_Focus",
            "VCD_Virtualize_Port",
            "VCD_Acquire_Port",
            "VCD_Free_Port",
            "VCD_Acquire_Port_Windows_Style",
            "VCD_Free_Port_Windows_Style",
            "VCD_Steal_Port_Windows_Style",
            "VCD_Find_COM_Index",
            "VCD_Set_Port_Global_Special",
            "VCD_Virtualize_Port_Dynamic",
            "VCD_Unvirtualize_Port_Dynamic"
        ]
    },
    "VPD": {
        id: 0x000F
    },
    "BLOCKDEV": {
        id: 0x0010,
        fn: [
            "BlockDev_Get_Version",
            "BlockDev_Register_Device",
            "BlockDev_Find_Int13_Drive",
            "BlockDev_Get_Device_List",
            "BlockDev_Send_Command",
            "BlockDev_Command_Complete",
            "BlockDev_Synchronous_Command"
        ]
    },
    "VMCPD": {
        id: 0x0011,
        fn: [
            "VMCPD_Get_Version",
            "VMCPD_Get_Virt_State",
            "VMCPD_Set_Virt_State",
            "VMCPD_Get_CR0_State",
            "VMCPD_Set_CR0_State",
            "VMCPD_Get_Thread_State",
            "VMCPD_Set_Thread_State",
            "_VMCPD_Get_FP_Instruction_Size",
            "VMCPD_Set_Thread_Precision"
        ]
    },
    "EBIOS": {
        id: 0x0012,
        fn: [
            "EBIOS_Get_Version",
            "EBIOS_Get_Unused_Mem"
        ]
    },
    "BIOSXLAT": {
        id: 0x0013
    },
    "VNETBIOS": {
        id: 0x0014,
        fn: [
            "VNETBIOS_Get_Version",
            "VNETBIOS_Register",
            "VNETBIOS_Submit",
            "VNETBIOS_Enum",
            "VNETBIOS_Deregister",
            "VNETBIOS_Register2",
            "VNETBIOS_Map",
            "VNETBIOS_Enum2"
        ]
    },
    "DOSMGR": {
        id: 0x0015,
        fn: [
            "DOSMGR_Get_Version",
            "_DOSMGR_Set_Exec_VM_Data",
            "DOSMGR_Copy_VM_Drive_State",
            "_DOSMGR_Exec_VM",
            "DOSMGR_Get_IndosPtr",
            "DOSMGR_Add_Device",
            "DOSMGR_Remove_Device",
            "DOSMGR_Instance_Device",
            "DOSMGR_Get_DOS_Crit_Status",
            "DOSMGR_Enable_Indos_Polling",
            "DOSMGR_BackFill_Allowed",
            "DOSMGR_LocalGlobalReg",
            "DOSMGR_Init_UMB_Area",
            "DOSMGR_Begin_V86_App",
            "DOSMGR_End_V86_App",
            "DOSMGR_Alloc_Local_Sys_VM_Mem",
            "DOSMGR_Grow_CDSs",
            "DOSMGR_Translate_Server_DOS_Call",
            "DOSMGR_MMGR_PSP_Change_Notifier"
        ]
    },
    "WINLOAD": {
        id: 0x0016
    },
    "SHELL": {
        id: 0x0017,
        fn: [
            "SHELL_Get_Version",
            "SHELL_Resolve_Contention",
            "SHELL_Event",
            "SHELL_SYSMODAL_Message",
            "SHELL_Message",
            "SHELL_GetVMInfo",
            "_SHELL_PostMessage",
            "_SHELL_ShellExecute",
            "_SHELL_PostShellMessage",
            "SHELL_DispatchRing0AppyEvents",
            "SHELL_Hook_Properties",
            "SHELL_Unhook_Properties",
            "SHELL_Update_User_Activity",
            "_SHELL_QueryAppyTimeAvailable",
            "_SHELL_CallAtAppyTime",
            "_SHELL_CancelAppyTimeEvent",
            "_SHELL_BroadcastSystemMessage",
            "_SHELL_HookSystemBroadcast",
            "_SHELL_UnhookSystemBroadcast",
            "_SHELL_LocalAllocEx",
            "_SHELL_LocalFree",
            "_SHELL_LoadLibrary",
            "_SHELL_FreeLibrary",
            "_SHELL_GetProcAddress",
            "_SHELL_CallDll",
            "_SHELL_SuggestSingleMSDOSMode",
            "SHELL_CheckHotkeyAllowed",
            "_SHELL_GetDOSAppInfo"
        ]
    },
    "VMPOLL": {
        id: 0x0018,
        fn: [
            "VMPoll_Get_Version",
            "VMPoll_Enable_Disable",
            "VMPoll_Reset_Detection",
            "VMPoll_Check_Idle"
        ]
    },
    "VPROD": {
        id: 0x0019
    },
    "DOSNET": {
        id: 0x001A,
        fn: [
            "DOSNET_Get_Version",
            "DOSNET_Send_FILESYSCHANGE",
            "DOSNET_Do_PSP_Adjust"
        ]
    },
    "VFD": {
        id: 0x001B,
        fn: [
            "VFD_Get_Version"
        ]
    },
    "VDD2": {
        id: 0x001C,
        fn: [
            "VDD2_Get_Version"
        ]
    },
    "WINDEBUG": {
        id: 0x001D
    },
    "TSRLOAD": {
        id: 0x001E
    },
    "BIOSHOOK": {
        id: 0x001F
    },
    "INT13": {
        id: 0x0020,
        fn: [
            "Int13_Get_Version",
            "Int13_Device_Registered",
            "Int13_Translate_VM_Int",
            "Int13_Hooking_BIOS_Int",
            "Int13_Unhooking_BIOS_Int"
        ]
    },
    "PAGEFILE": {
        id: 0x0021,
        fn: [
            "PageFile_Get_Version",
            "PageFile_Init_File",
            "PageFile_Clean_Up",
            "PageFile_Grow_File",
            "PageFile_Read_Or_Write",
            "PageFile_Cancel",
            "PageFile_Test_IO_Valid",
            "PageFile_Get_Size_Info",
            "PageFile_Set_Async_Manager",
            "PageFile_Call_Async_Manager"
        ]
    },
    "SCSI": {
        id: 0x0022
    },
    "MCA_POS": {
        id: 0x0023
    },
    "SCSIFD": {
        id: 0x0024
    },
    "VPEND": {
        id: 0x0025
    },
    "APM": {
        id: 0x0026
    },
    "VXDLDR": {
        id: 0x0027,
        fn: [
            "VXDLDR_GetVersion",
            "VXDLDR_LoadDevice",
            "VXDLDR_UnloadDevice",
            "VXDLDR_DevInitSucceeded",
            "VXDLDR_DevInitFailed",
            "VXDLDR_GetDeviceList",
            "VXDLDR_UnloadMe",
            "_PELDR_LoadModule",
            "_PELDR_GetModuleHandle",
            "_PELDR_GetModuleUsage",
            "_PELDR_GetEntryPoint",
            "_PELDR_GetProcAddress",
            "_PELDR_AddExportTable",
            "_PELDR_RemoveExportTable",
            "_PELDR_FreeModule",
            "VXDLDR_Notify",
            "_PELDR_InitCompleted",
            "_PELDR_LoadModuleEx"
        ]
    },
    "NDIS": {
        id: 0x0028
    },
    "BIOS_EXT": {
        id: 0x0029,
        fn: [
            "_BIOSEXTGetVersion",
            "_BIOSEXTGetHeader",
            "_BIOSEXTCallBIOS"
        ]
    },
    "VWIN32": {
        id: 0x002A
    },
    "VCOMM": {
        id: 0x002B,
        fn: [
            "VCOMM_Get_Version",
            "_VCOMM_Register_Port_Driver",
            "_VCOMM_Acquire_Port",
            "_VCOMM_Release_Port",
            "_VCOMM_OpenComm",
            "_VCOMM_SetCommState",
            "_VCOMM_GetCommState",
            "_VCOMM_SetupComm",
            "_VCOMM_TransmitCommChar",
            "_VCOMM_CloseComm",
            "_VCOMM_GetCommQueueStatus",
            "_VCOMM_ClearCommError",
            "_VCOMM_GetModemStatus",
            "_VCOMM_GetCommProperties",
            "_VCOMM_EscapeCommFunction",
            "_VCOMM_PurgeComm",
            "_VCOMM_SetCommEventMask",
            "_VCOMM_GetCommEventMask",
            "_VCOMM_WriteComm",
            "_VCOMM_ReadComm",
            "_VCOMM_EnableCommNotification",
            "_VCOMM_GetLastError",
            "_VCOMM_Steal_Port",
            "_VCOMM_SetReadCallBack",
            "_VCOMM_SetWriteCallBack",
            "_VCOMM_Add_Port",
            "_VCOMM_GetSetCommTimeouts",
            "_VCOMM_SetWriteRequest",
            "_VCOMM_SetReadRequest",
            "_VCOMM_Dequeue_Request",
            "_VCOMM_Enumerate_DevNodes",
            "VCOMM_Map_Win32DCB_To_Ring0",
            "VCOMM_Map_Ring0DCB_To_Win32",
            "_VCOMM_Get_Contention_Handler",
            "_VCOMM_Map_Name_To_Resource"
        ]
    },
    "SPOOLER": {
        id: 0x002C
    },
    "WIN32S": {
        id: 0x002D
    },
    "DEBUGCMD": {
        id: 0x002E
    },
    "CONFIGMG": {
        id: 0x0033,
        fn: [
            "_CONFIGMG_Get_Version",
            "_CONFIGMG_Initialize",
            "_CONFIGMG_Locate_DevNode",
            "_CONFIGMG_Get_Parent",
            "_CONFIGMG_Get_Child",
            "_CONFIGMG_Get_Sibling",
            "_CONFIGMG_Get_Device_ID_Size",
            "_CONFIGMG_Get_Device_ID",
            "_CONFIGMG_Get_Depth",
            "_CONFIGMG_Get_Private_DWord",
            "_CONFIGMG_Set_Private_DWord",
            "_CONFIGMG_Create_DevNode",
            "_CONFIGMG_Query_Remove_SubTree",
            "_CONFIGMG_Remove_SubTree",
            "_CONFIGMG_Register_Device_Driver",
            "_CONFIGMG_Register_Enumerator",
            "_CONFIGMG_Register_Arbitrator",
            "_CONFIGMG_Deregister_Arbitrator",
            "_CONFIGMG_Query_Arbitrator_Free_Size",
            "_CONFIGMG_Query_Arbitrator_Free_Data",
            "_CONFIGMG_Sort_NodeList",
            "_CONFIGMG_Yield",
            "_CONFIGMG_Lock",
            "_CONFIGMG_Unlock",
            "_CONFIGMG_Add_Empty_Log_Conf",
            "_CONFIGMG_Free_Log_Conf",
            "_CONFIGMG_Get_First_Log_Conf",
            "_CONFIGMG_Get_Next_Log_Conf",
            "_CONFIGMG_Add_Res_Des",
            "_CONFIGMG_Modify_Res_Des",
            "_CONFIGMG_Free_Res_Des",
            "_CONFIGMG_Get_Next_Res_Des",
            "_CONFIGMG_Get_Performance_Info",
            "_CONFIGMG_Get_Res_Des_Data_Size",
            "_CONFIGMG_Get_Res_Des_Data",
            "_CONFIGMG_Process_Events_Now",
            "_CONFIGMG_Create_Range_List",
            "_CONFIGMG_Add_Range",
            "_CONFIGMG_Delete_Range",
            "_CONFIGMG_Test_Range_Available",
            "_CONFIGMG_Dup_Range_List",
            "_CONFIGMG_Free_Range_List",
            "_CONFIGMG_Invert_Range_List",
            "_CONFIGMG_Intersect_Range_List",
            "_CONFIGMG_First_Range",
            "_CONFIGMG_Next_Range",
            "_CONFIGMG_Dump_Range_List",
            "_CONFIGMG_Load_DLVxDs",
            "_CONFIGMG_Get_DDBs",
            "_CONFIGMG_Get_CRC_CheckSum",
            "_CONFIGMG_Register_DevLoader",
            "_CONFIGMG_Reenumerate_DevNode",
            "_CONFIGMG_Setup_DevNode",
            "_CONFIGMG_Reset_Children_Marks",
            "_CONFIGMG_Get_DevNode_Status",
            "_CONFIGMG_Remove_Unmarked_Children",
            "_CONFIGMG_ISAPNP_To_CM",
            "_CONFIGMG_CallBack_Device_Driver",
            "_CONFIGMG_CallBack_Enumerator",
            "_CONFIGMG_Get_Alloc_Log_Conf",
            "_CONFIGMG_Get_DevNode_Key_Size",
            "_CONFIGMG_Get_DevNode_Key",
            "_CONFIGMG_Read_Registry_Value",
            "_CONFIGMG_Write_Registry_Value",
            "_CONFIGMG_Disable_DevNode",
            "_CONFIGMG_Enable_DevNode",
            "_CONFIGMG_Move_DevNode",
            "_CONFIGMG_Set_Bus_Info",
            "_CONFIGMG_Get_Bus_Info",
            "_CONFIGMG_Set_HW_Prof",
            "_CONFIGMG_Recompute_HW_Prof",
            "_CONFIGMG_Query_Change_HW_Prof",
            "_CONFIGMG_Get_Device_Driver_Private_DWord",
            "_CONFIGMG_Set_Device_Driver_Private_DWord",
            "_CONFIGMG_Get_HW_Prof_Flags",
            "_CONFIGMG_Set_HW_Prof_Flags",
            "_CONFIGMG_Read_Registry_Log_Confs",
            "_CONFIGMG_Run_Detection",
            "_CONFIGMG_Call_At_Appy_Time",
            "_CONFIGMG_Fail_Change_HW_Prof",
            "_CONFIGMG_Set_Private_Problem",
            "_CONFIGMG_Debug_DevNode",
            "_CONFIGMG_Get_Hardware_Profile_Info",
            "_CONFIGMG_Register_Enumerator_Function",
            "_CONFIGMG_Call_Enumerator_Function",
            "_CONFIGMG_Add_ID",
            "_CONFIGMG_Find_Range",
            "_CONFIGMG_Get_Global_State",
            "_CONFIGMG_Broadcast_Device_Change_Message",
            "_CONFIGMG_Call_DevNode_Handler",
            "_CONFIGMG_Remove_Reinsert_All"
        ]
    },
    "DWCFGMG": {
        id: 0x0034
    },
    "SCSIPORT": {
        id: 0x0035
    },
    "VFBACKUP": {
        id: 0x0036,
        fn: [
            "VFBACKUP_Get_Version",
            "VFBACKUP_Lock_NEC",
            "VFBACKUP_UnLock_NEC",
            "VFBACKUP_Register_NEC",
            "VFBACKUP_Register_VFD",
            "VFBACKUP_Lock_All_Ports"
        ]
    },
    "ENABLE": {
        id: 0x0037,
        fn: [
            "VMINI_GetVersion",
            "VMINI_Update",
            "VMINI_Status",
            "VMINI_DisplayError",
            "VMINI_SetTimeStamp",
            "VMINI_Siren",
            "VMINI_RegisterAccess",
            "VMINI_GetData",
            "VMINI_ShutDownItem",
            "VMINI_RegisterSK"
        ]
    },
    "VCOND": {
        id: 0x0038,
        fn: [
            "VCOND_Get_Version",
            "VCOND_Launch_ConApp_Inherited"
        ]
    },
    "ISAPNP": {
        id: 0x003C
    },
    "BIOS": {
        id: 0x003D,
        fn: [
            "_BIOSGetVersion",
            "_BIOSSoftUndock",
            "_BIOSGetCapabilities",
            "_BIOSGetAPMTable"
        ]
    },
    "IFSMGR": {
        id: 0x0040,
        fn: [
            "IFSMgr_Get_Version",
            "IFSMgr_RegisterMount",
            "IFSMgr_RegisterNet",
            "IFSMgr_RegisterMailSlot",
            "IFSMgr_Attach",
            "IFSMgr_Detach",
            "IFSMgr_Get_NetTime",
            "IFSMgr_Get_DOSTime",
            "IFSMgr_SetupConnection",
            "IFSMgr_DerefConnection",
            "IFSMgr_ServerDOSCall",
            "IFSMgr_CompleteAsync",
            "IFSMgr_RegisterHeap",
            "IFSMgr_GetHeap",
            "IFSMgr_RetHeap",
            "IFSMgr_CheckHeap",
            "IFSMgr_CheckHeapItem",
            "IFSMgr_FillHeapSpare",
            "IFSMgr_Block",
            "IFSMgr_Wakeup",
            "IFSMgr_Yield",
            "IFSMgr_SchedEvent",
            "IFSMgr_QueueEvent",
            "IFSMgr_KillEvent",
            "IFSMgr_FreeIOReq",
            "IFSMgr_MakeMailSlot",
            "IFSMgr_DeleteMailSlot",
            "IFSMgr_WriteMailSlot",
            "IFSMgr_PopUp",
            "IFSMgr_printf",
            "IFSMgr_AssertFailed",
            "IFSMgr_LogEntry",
            "IFSMgr_DebugMenu",
            "IFSMgr_DebugVars",
            "IFSMgr_GetDebugString",
            "IFSMgr_GetDebugHexNum",
            "IFSMgr_NetFunction",
            "IFSMgr_DoDelAllUses",
            "IFSMgr_SetErrString",
            "IFSMgr_GetErrString",
            "IFSMgr_SetReqHook",
            "IFSMgr_SetPathHook",
            "IFSMgr_UseAdd",
            "IFSMgr_UseDel",
            "IFSMgr_InitUseAdd",
            "IFSMgr_ChangeDir",
            "IFSMgr_DelAllUses",
            "IFSMgr_CDROM_Attach",
            "IFSMgr_CDROM_Detach",
            "IFSMgr_Win32DupHandle",
            "IFSMgr_Ring0_FileIO",
            "IFSMgr_Win32_Get_Ring0_Handle",
            "IFSMgr_Get_Drive_Info",
            "IFSMgr_Ring0GetDriveInfo",
            "IFSMgr_BlockNoEvents",
            "IFSMgr_NetToDosTime",
            "IFSMgr_DosToNetTime",
            "IFSMgr_DosToWin32Time",
            "IFSMgr_Win32ToDosTime",
            "IFSMgr_NetToWin32Time",
            "IFSMgr_Win32ToNetTime",
            "IFSMgr_MetaMatch",
            "IFSMgr_TransMatch",
            "IFSMgr_CallProvider",
            "UniToBCS",
            "UniToBCSPath",
            "BCSToUni",
            "UniToUpper",
            "UniCharToOEM",
            "CreateBasis",
            "MatchBasisName",
            "AppendBasisTail",
            "FcbToShort",
            "ShortToFcb",
            "IFSMgr_ParsePath",
            "Query_PhysLock",
            "_VolFlush",
            "NotifyVolumeArrival",
            "NotifyVolumeRemoval",
            "QueryVolumeRemoval",
            "IFSMgr_FSDUnmountCFSD",
            "IFSMgr_GetConversionTablePtrs",
            "IFSMgr_CheckAccessConflict",
            "IFSMgr_LockFile",
            "IFSMgr_UnlockFile",
            "IFSMgr_RemoveLocks",
            "IFSMgr_CheckLocks",
            "IFSMgr_CountLocks",
            "IFSMgr_ReassignLockFileInst",
            "IFSMgr_UnassignLockList",
            "IFSMgr_MountChildVolume",
            "IFSMgr_UnmountChildVolume",
            "IFSMgr_SwapDrives",
            "IFSMgr_FSDMapFHtoIOREQ",
            "IFSMgr_FSDParsePath",
            "IFSMgr_FSDAttachSFT",
            "IFSMgr_GetTimeZoneBias",
            "IFSMgr_PNPEvent",
            "IFSMgr_RegisterCFSD",
            "IFSMgr_Win32MapExtendedHandleToSFT",
            "IFSMgr_DbgSetFileHandleLimit",
            "IFSMgr_Win32MapSFTToExtendedHandle",
            "IFSMgr_FSDGetCurrentDrive",
            "IFSMgr_InstallFileSystemApiHook",
            "IFSMgr_RemoveFileSystemApiHook",
            "IFSMgr_RunScheduledEvents",
            "IFSMgr_CheckDelResource",
            "IFSMgr_Win32GetVMCurdir",
            "IFSMgr_SetupFailedConnection",
            "_GetMappedErr",
            "ShortToLossyFcb",
            "IFSMgr_GetLockState",
            "BcsToBcs",
            "IFSMgr_SetLoopback",
            "IFSMgr_ClearLoopback",
            "IFSMgr_ParseOneElement",
            "BcsToBcsUpper"
        ]
    },
    "VCDFSD": {
        id: 0x0041,
        fn: [
            "_VCDFSD_Get_Version",
            "_VCDFSD_GetCDFSInfo",
            "_VCDFSD_Hook",
            "_VCDFSD_Unhook"
        ]
    },
    "MRCI2": {
        id: 0x0042,
        fn: [
            "MRCI_Get_Version",
            "_MRCI_Fast_Compress",
            "_MRCI_Fast_Decompress"
        ]
    },
    "PCI": {
        id: 0x0043
    },
    "PELOADER": {
        id: 0x0044
    },
    "EISA": {
        id: 0x0045
    },
    "DRAGCLI": {
        id: 0x0046
    },
    "DRAGSRV": {
        id: 0x0047
    },
    "PERF": {
        id: 0x0048,
        fn: [
            "PERF_Get_Version",
            "PERF_Server_Register",
            "PERF_Server_Deregister",
            "PERF_Server_Add_Stat",
            "PERF_Server_Remove_Stat"
        ]
    },
    "AWREDIR": {
        id: 0x0049
    },
    "ETEN": {
        id: 0x0060
    },
    "CHBIOS": {
        id: 0x0061
    },
    "VMSGD": {
        id: 0x0062
    },
    "VPPID": {
        id: 0x0063
    },
    "VIME": {
        id: 0x0064,
        fn: [
            "VIME_Register_UI",
            "VIME_Control_IME"
        ]
    },
    "VHBIOSD": {
        id: 0x0065
    }
};


/**
 * @copyright https://www.pcjs.org/machines/pcx86/modules/v2/panel.js (C) 2012-2024 Jeff Parsons
 */

/** @typedef {{ iBlock: number, cBlocks: number, type: number }} */
let Region;

/**
 * @class Color
 * @unrestricted
 */
class Color {
    /**
     * Color(r, g, b, a)
     *
     * @this {Color}
     * @param {number} [r]
     * @param {number} [g]
     * @param {number} [b]
     * @param {number} [a]
     */
    constructor(r, g, b, a)
    {
        this.rgb = [r, g, b, a];
        this.sValue = null;
        if (r === undefined) this.randomize();
    }

    /**
     * getRandom(nLimit)
     *
     * @this {Color}
     * @param {number} [nLimit]
     */
    getRandom(nLimit)
    {
        return (Math.random() * (nLimit || 0x100)) | 0;
    }

    /**
     * randomize()
     *
     * @this {Color}
     */
    randomize()
    {
        this.rgb[0] = this.getRandom(); this.rgb[1] = this.getRandom(); this.rgb[2] = this.getRandom(); this.rgb[3] = 0xff;
        this.sValue = null;
    }

    /**
     * toString()
     *
     * @this {Color}
     * @returns {string}
     */
    toString()
    {
        if (!this.sValue) this.sValue = '#' + StrLib.toHex(this.rgb[0], 2) + StrLib.toHex(this.rgb[1], 2) + StrLib.toHex(this.rgb[2], 2);
        return this.sValue;
    }
}

/**
 * @class Rectangle
 * @unrestricted
 */
class Rectangle {
    /**
     * Rectangle(x, y, cx, cy)
     *
     * @this {Rectangle}
     * @param {number} x
     * @param {number} y
     * @param {number} cx
     * @param {number} cy
     */
    constructor(x, y, cx, cy)
    {
        this.x = x;
        this.y = y;
        this.cx = cx;
        this.cy = cy;
    }

    /**
     * contains(x, y)
     *
     * @this {Rectangle}
     * @param {number} x
     * @param {number} y
     * @returns {boolean} true if (x,y) lies within the rectangle, false if not
     */
    contains(x, y)
    {
        return (x >= this.x && x < this.x + this.cx && y >= this.y && y < this.y + this.cy);
    }

    /**
     * subDivide(units, unitsTotal, fHorizontal)
     *
     * Return a new rectangle that is a subset of the current rectangle, based on the ratio of
     * units to unitsTotal, and then update the dimensions of the current rectangle.  Whether the
     * original rectangle is divided horizontally or vertically is entirely arbitrary; currently,
     * the criteria is horizontal if the ratio is 1/4 or more, vertical otherwise.
     *
     * @this {Rectangle}
     * @param {number} units
     * @param {number} unitsTotal
     * @param {boolean} [fHorizontal]
     * @returns {Rectangle}
     */
    subDivide(units, unitsTotal, fHorizontal)
    {
        let rect;
        if (fHorizontal === undefined) {
            fHorizontal = units >= (unitsTotal >> 2);
        }
        if (fHorizontal) {
            rect = new Rectangle(this.x, this.y, this.cx, ((this.cy * units) / unitsTotal) | 0);
            this.y += rect.cy;
            this.cy -= rect.cy;

        } else {
            rect = new Rectangle(this.x, this.y, ((this.cx * units) / unitsTotal) | 0, this.cy);
            this.x += rect.cx;
            this.cx -= rect.cx;

        }
        return rect;
    }

    /**
     * drawWith(context, color)
     *
     * @this {Rectangle}
     * @param {Object} context
     * @param {Color|string} [color]
     */
    drawWith(context, color)
    {
        if (!color) color = new Color();
        context.strokeStyle = "black";
        context.strokeRect(this.x, this.y, this.cx, this.cy);
        context.fillStyle = (typeof color == "string"? color : color.toString());
        context.fillRect(this.x, this.y, this.cx, this.cy);
    }
}

/**
 * @class HTMLLED
 * @unrestricted
 */
class HTMLLED {
    /**
     * HTMLLED(control, color)
     *
     * @this {HTMLLED}
     * @param {HTMLElement} control
     * @param {string} [color]
     */
    constructor(control, color)
    {
        this.active = false;
        this.control = control;
        this.colorActive = null;
        this.color = control.style.backgroundColor;
        this.setColor(color);
        this.draw();
    }

    /**
     * draw()
     *
     * @this {HTMLLED}
     */
    draw()
    {
        if (this.colorActive != this.color) {
            this.colorActive = this.color;
            this.control.style.backgroundColor = this.color || Panel.COLOR.BLACK;
        }
        else if (!this.active) {
            this.color = null;
        }
    }

    /**
     * setColor(color)
     *
     * Components are allowed to call this, via Panel.setLED(), as frequently as they like; we
     *
     * @this {HTMLLED}
     * @param {string} [color] (omit to turn LED "off")
     */
    setColor(color)
    {
        if (color) {
            this.color = color;
            this.active = true;
        } else {
            this.active = false;
        }
    }
}

/**
 * @class Panel
 * @unrestricted (allows the class to define properties, both dot and named, outside of the constructor)
 */
class Panel extends Component {

    static COLOR = {
        BLACK:  "#000000",
        RED:    "#ff0000",
        BLUE:   "#0000ff",
        GREEN:  "#00ff00"
    };

    static STATE = {
        NONE:   Panel.COLOR.BLACK,
        WRITE:  Panel.COLOR.RED,
        READ:   Panel.COLOR.GREEN,
        SEEK:   Panel.COLOR.BLUE
    };

    /**
     * The "Live" canvases that we create internally have the following fixed dimensions, to make drawing
     * simpler.  We then render, via drawImage(), these canvases onto the supplied canvas, which will automatically
     * stretch the live images to fit.
     */
    static LIVECANVAS = {
        CX:         1280,
        CY:         720,
        FONT:       {
            CY:     18,
            FACE:   "Monaco, Lucida Console, Courier New"
        }
    };

    static LIVEMEM = {
        CX: (Panel.LIVECANVAS.CX * 3) >> 2,
        CY: (Panel.LIVECANVAS.CY)
    };

    static LIVEREGS = {
        CX:     (Panel.LIVECANVAS.CX - Panel.LIVEMEM.CX),
        CY:     (Panel.LIVECANVAS.CY),
        COLOR:  "black"
    };

    static LIVEDUMP = {
        CX: (Panel.LIVECANVAS.CX - Panel.LIVEMEM.CX),
        CY: (Panel.LIVECANVAS.CY >> 1)
    };

    /**
     * findRegions() records block numbers in bits 0-14, a BackTrack "mod" bit in bit 15, and the block type at bit 16.
     */
    static REGION = {
        MASK:           0x7fff,
        BTMOD_SHIFT:    15,
        TYPE_SHIFT:     16
    };

    static UPDATES_PER_SECOND = 10;

    /**
     * Panel(parmsPanel)
     *
     * The Panel component has no required (parmsPanel) properties.
     *
     * @this {Panel}
     * @param {Object} [parmsPanel]
     */
    constructor(parmsPanel)
    {
        super("Panel", parmsPanel);

        this.leds = {};
        this.cLEDs = 0;
        this.canvas = null;
        this.lockMouse = -1;
        this.fMouseDown = false;
        this.xMouse = this.yMouse = -1;
        this.timer = -1;
        this.busInfo = null;
        this.fVisual = false;
    }

    /**
     * initBus(cmp, bus, cpu, dbg)
     *
     * @this {Panel}
     * @param {Computer} cmp
     * @param {Busx86} bus
     * @param {CPUx86} cpu
     * @param {Debuggerx86} dbg
     */
    initBus(cmp, bus, cpu, dbg)
    {
        this.cmp = cmp;
        this.bus = bus;
        this.cpu = cpu;
        this.dbg = dbg;
        this.kbd = cmp.getMachineComponent("Keyboard");
        this.startTimer();
    }

    /**
     * setBinding(sHTMLType, sBinding, control, sValue)
     *
     * Most panel layouts don't have bindings of their own, so we pass along all binding requests to the
     * Computer, CPU, Keyboard and Debugger components first.  The order shouldn't matter, since any component
     * that doesn't recognize the specified binding should simply ignore it.
     *
     * @this {Panel}
     * @param {string} sHTMLType is the type of the HTML control (eg, "button", "list", "text", "submit", "textarea", "canvas")
     * @param {string} sBinding is the value of the 'binding' parameter stored in the HTML control's "data-value" attribute (eg, "reset")
     * @param {HTMLElement} control is the HTML control DOM object (eg, HTMLButtonElement)
     * @param {string} [sValue] optional data value
     * @returns {boolean} true if binding was successful, false if unrecognized binding request
     */
    setBinding(sHTMLType, sBinding, control, sValue)
    {
        if (this.cmp && this.cmp.setBinding(sHTMLType, sBinding, control, sValue)) return true;
        if (this.cpu && this.cpu.setBinding(sHTMLType, sBinding, control, sValue)) return true;
        if (this.kbd && this.kbd.setBinding(sHTMLType, sBinding, control, sValue)) return true;
        if (DEBUGGER && this.dbg && this.dbg.setBinding(sHTMLType, sBinding, control, sValue)) return true;

        if (sHTMLType.substr(-3, 3) == "led") {
            this.leds[sBinding] = new HTMLLED(control, sValue);
            this.cLEDs++;
            this.startTimer();
            return true;
        }

        if (!this.canvas && sHTMLType == "canvas") {

            this.fVisual = true;
            this.canvas = /** @type {HTMLCanvasElement} */ (control);
            this.context = /** @type {CanvasRenderingContext2D} */ (this.canvas.getContext("2d"));

            /**
             * Employ the same gross onresize() hack for IE9/IE10 that we had to use for the Video canvas
             */
            if (WebLib.getUserAgent().indexOf("MSIE") >= 0) {
                this.canvas['onresize'] = function(canvas, cx, cy) {
                    return function onResizeVideo() {
                        canvas.style.height = (((canvas.clientWidth * cy) / cx) | 0) + "px";
                    };
                }(this.canvas, this.canvas.width, this.canvas.height);
                this.canvas['onresize'](null);
            }

            this.xMem = this.yMem = 0;
            this.cxMem = ((this.canvas.width * Panel.LIVEMEM.CX) / Panel.LIVECANVAS.CX) | 0;
            this.cyMem = this.canvas.height;

            this.xReg = this.cxMem;
            this.yReg = 0;
            this.cxReg = this.canvas.width - this.cxMem;
            this.cyReg = this.canvas.height;

            this.xDump = this.xReg;
            this.yDump = ((this.canvas.height * (Panel.LIVEREGS.CY - Panel.LIVEDUMP.CY)) / Panel.LIVECANVAS.CY) | 0;
            this.cxDump = this.cxReg;
            this.cyDump = ((this.canvas.height * Panel.LIVEDUMP.CY) / Panel.LIVECANVAS.CY) | 0;

            this.canvasLiveMem = document.createElement("canvas");
            this.canvasLiveMem.width = Panel.LIVEMEM.CX;
            this.canvasLiveMem.height = Panel.LIVEMEM.CY;
            this.contextLiveMem = this.canvasLiveMem.getContext("2d");
            this.imageLiveMem = this.contextLiveMem.createImageData(this.canvasLiveMem.width, this.canvasLiveMem.height);

            this.canvasLiveRegs = document.createElement("canvas");
            this.canvasLiveRegs.width = Panel.LIVEREGS.CX;
            this.canvasLiveRegs.height = Panel.LIVEREGS.CY;
            this.contextLiveRegs = this.canvasLiveRegs.getContext("2d");

            let panel = this;
            this.canvas.addEventListener(
                'mousemove',
                function onMouseMove(event) {
                    panel.moveMouse(event);
                },
                false               // we'll specify false for the 'useCapture' parameter for now...
            );
            this.canvas.addEventListener(
                'mousedown',
                function onMouseDown(event) {
                    panel.clickMouse(event, true);
                },
                false               // we'll specify false for the 'useCapture' parameter for now...
            );
            this.canvas.addEventListener(
                'mouseup',
                function onMouseUp(event) {
                    panel.clickMouse(event, false);
                },
                false               // we'll specify false for the 'useCapture' parameter for now...
            );

            this.fRedraw = true;
            this.startTimer();
            return true;
        }
        return super.setBinding(sHTMLType, sBinding, control, sValue);
    }

    /**
     * setLED(sBinding, color)
     *
     * @this {Panel}
     * @param {string} sBinding
     * @param {string} [color] (omit to turn LED "off")
     */
    setLED(sBinding, color)
    {
        let led = this.leds[sBinding];
        if (led) led.setColor(color);
    }

    /**
     * startTimer()
     *
     * This timer replaces the CPU's old dedicated VIDEO_UPDATES_PER_SECOND logic, which periodically called
     * the Computer's updateVideo() function, which in turn called our updateAnimation() function; periodic
     * animation updates are now our own responsibility.
     *
     * @this {Panel}
     */
    startTimer()
    {
        if (this.timer < 0 && (this.cLEDs || this.canvas) && this.cpu) {
            let panel = this;
            this.timer = this.cpu.addTimer(this.id, function updateAnimationTimer() {
                panel.updateAnimation();
            }, 1000 / Panel.UPDATES_PER_SECOND);
        }
    }

    /**
     * powerUp(data, fRepower)
     *
     * @this {Panel}
     * @param {Object|null} data
     * @param {boolean} [fRepower]
     * @returns {boolean} true if successful, false if failure
     */
    powerUp(data, fRepower)
    {
        if (!fRepower) Panel.init();
        /**
         * TODO: Investigate what changed since the "visual" portion of the Panel module was originally written,
         * because now, when updateAnimation() is first called, the machine's memory map hasn't been initialized yet,
         * so no regions are displayed, and since no other code was setting fRedraw, no regions were ever displayed.
         */
        if (this.canvas) this.fRedraw = true;
        return true;
    }

    /**
     * powerDown(fSave, fShutdown)
     *
     * @this {Panel}
     * @param {boolean} [fSave]
     * @param {boolean} [fShutdown]
     * @returns {Object|boolean} component state if fSave; otherwise, true if successful, false if failure
     */
    powerDown(fSave, fShutdown)
    {
        return true;
    }

    /**
     * clickMouse(event, fDown)
     *
     * @this {Panel}
     * @param {Object} event object from a 'mousedown' or 'mouseup' event
     * @param {boolean} fDown
     */
    clickMouse(event, fDown)
    {
        /**
         * event.button is 0 for the LEFT button and 2 for the RIGHT button
         */
        if (!event.button) {
            this.lockMouse = fDown? 0 : -1;
            this.fMouseDown = fDown;
            this.updateMouse(event, fDown);
        }
    }

    /**
     * moveMouse(event)
     *
     * @this {Panel}
     * @param {Object} event object from a 'mousemove' event
     */
    moveMouse(event)
    {
        this.updateMouse(event);
    }

    /**
     * updateMouse(event, fDown)
     *
     * MouseEvent objects contain, among other things, the following properties:
     *
     *      clientX
     *      clientY
     *
     * I've selected the above properties because they're widely supported, not because I need
     * client-area coordinates.  In fact, layerX and layerY are probably closer to what I really want,
     * but I don't think they're available in all browsers.  screenX and screenY would work as well.
     *
     * @this {Panel}
     * @param {Object} event object from a mouse event (specifically, a MouseEvent object)
     * @param {boolean} [fDown] is true or false if this was a click event, otherwise it's just a move event
     */
    updateMouse(event, fDown)
    {
        /**
         * Due to the responsive nature of our pages, the displayed size of the canvas may be smaller than the
         * allocated size, and the coordinates we receive from mouse events are based on the currently displayed size.
         */
        let xScale = Panel.LIVECANVAS.CX / this.canvas.offsetWidth;
        let yScale = Panel.LIVECANVAS.CY / this.canvas.offsetHeight;

        let rect = this.canvas.getBoundingClientRect();
        let x = ((event.clientX - rect.left) * xScale) | 0;
        let y = ((event.clientY - rect.top) * yScale) | 0;

        if (fDown == null) {
            if (!this.lockMouse) {
                this.lockMouse = Math.abs(this.xMouse - x) > Math.abs(this.yMouse - y)? 1 : 2;
            }
            if (this.lockMouse == 1) {
                y = this.yMouse;
            } else if (this.lockMouse == 2) {
                x = this.xMouse;
            }
        }

        this.xMouse = x;
        this.yMouse = y;

        if (MAXDEBUG) this.printf(MESSAGE.LOG, "Panel.moveMouse(%d,%d)\n", x, y);

        if (x >= 0 && x < Panel.LIVECANVAS.CX && y >= 0 && y < Panel.LIVECANVAS.CY) {
            /**
             * Convert the mouse position into the corresponding memory address, assuming it's over the live memory area
             */
            let addr = this.findAddress(x, y);
            if (addr !== X86.ADDR_INVALID) {
                addr &= ~0xf;
                if (addr != this.addrDumpLast) {
                    this.dumpMemory(addr, true);
                    this.addrDumpLast = addr;
                }
            }
        }
    }

    /**
     * findAddress(x, y)
     *
     * @this {Panel}
     * @param {number} x
     * @param {number} y
     * @returns {number} address corresponding to (x,y) canvas coordinates, or ADDR_INVALID if none
     */
    findAddress(x, y)
    {
        if (x < Panel.LIVEMEM.CX && this.busInfo && this.busInfo.aRects) {
            let i, rect;
            for (i = 0; i < this.busInfo.aRects.length; i++) {
                rect = this.busInfo.aRects[i];
                if (rect.contains(x, y)) {
                    x -= rect.x;
                    y -= rect.y;
                    let region = this.busInfo.aRegions[i];
                    let iBlock = UsrLib.getBitField(/** @type {BitField} */ (Busx86.BlockInfo.num), this.busInfo.aBlocks[region.iBlock]);
                    let addr = iBlock * this.bus.nBlockSize;
                    let addrLimit = (iBlock + region.cBlocks) * this.bus.nBlockSize - 1;

                    /**
                     * If you want memory to be arranged "vertically" instead of "horizontally", do this:
                     *
                     *      if (x > 0) addr += rect.cy * (x - 1) * this.ratioMemoryToPixels;
                     *      addr += (y * this.ratioMemoryToPixels);
                     */
                    if (y > 0) addr += rect.cx * (y - 1) * this.ratioMemoryToPixels;
                    addr += (x * this.ratioMemoryToPixels);

                    addr |= 0;
                    if (addr > addrLimit) addr = addrLimit;
                    if (MAXDEBUG) this.printf(MESSAGE.LOG, "Panel.findAddress(%d,%d) found type %s, address %#010x\n", x, y, Memoryx86.TYPE.NAMES[region.type], addr);
                    return addr;
                }
            }
        }
        return X86.ADDR_INVALID;
    }

    /**
     * updateAnimation()
     *
     * If the given Control Panel contains a canvas requiring animation (eg, "vpanel"), then this is where that happens.
     *
     * @this {Panel}
     */
    updateAnimation()
    {
        for (let s in this.leds ) {
            let led = this.leds[s];
            led.draw();
        }

        if (this.fRedraw) {

            this.initPen(10, Panel.LIVECANVAS.FONT.CY, this.canvasLiveMem, this.contextLiveMem, this.canvas.style.color);

            if (this.fVisual) {
                if (DEBUG) this.printf(MESSAGE.LOG, "begin scanMemory()\n");
                this.busInfo = this.bus.scanMemory(this.busInfo);
                /**
                 * Calculate the pixel-to-memory-address ratio
                 */
                this.ratioMemoryToPixels = (this.busInfo.cBlocks * this.bus.nBlockSize) / (Panel.LIVEMEM.CX * Panel.LIVEMEM.CY);
                /**
                 * Update the BusInfo object with region information (cRegions and aRegions); return true if region
                 * information has changed since the last call.
                 */
                if (this.findRegions()) {
                    /**
                     * For each region, I choose a slice of the LiveMem canvas and record the corresponding rectangle
                     * within an aRects array (parallel to the aRegions array) in the BusInfo object.
                     *
                     * I don't need a sophisticated Treemap algorithm, because at this level, the data is not hierarchical.
                     * subDivide() makes a simple horizontal or vertical slicing decision based on the ratio of region blocks
                     * to remaining blocks.
                     */
                    let i;
                    let rect;
                    let rectAvail = new Rectangle(0, 0, this.canvasLiveMem.width, this.canvasLiveMem.height);
                    this.busInfo.aRects = [];
                    let cBlocksRemaining = this.busInfo.cBlocks;

                    for (i = 0; i < this.busInfo.cRegions; i++) {
                        let cBlocksRegion = this.busInfo.aRegions[i].cBlocks;
                        this.busInfo.aRects.push(rect = rectAvail.subDivide(cBlocksRegion, cBlocksRemaining, !i));
                        if (MAXDEBUG) this.printf(MESSAGE.LOG, "region %d rectangle (x=%d,y=%d cx=%d,cy=%d)\n", i, rect.x, rect.y, rect.cx, rect.cy);
                        cBlocksRemaining -= cBlocksRegion;
                    }

                    /**
                     * Assert that not only did all the specified regions account for all the specified blocks, but also that
                     * the series of subDivide() calls exhausted the original rectangle to one of either zero width or zero height.
                     */


                    /**
                     * Now draw all the rectangles produced by the series of subDivide() calls.
                     */
                    for (i = 0; i < this.busInfo.aRects.length; i++) {
                        let region = this.busInfo.aRegions[i];
                        rect = this.busInfo.aRects[i];
                        rect.drawWith(this.contextLiveMem, Memoryx86.TYPE.COLORS[region.type]);
                        this.centerPen(rect);
                        this.centerText(Memoryx86.TYPE.NAMES[region.type] + " (" + (((region.cBlocks * this.bus.nBlockSize) / 1024) | 0) + "Kb)");
                    }
                }
                if (DEBUG) this.printf(MESSAGE.LOG, "end scanMemory(): %d total bytes, %d total blocks, %d total regions\n", this.busInfo.cbTotal, this.busInfo.cBlocks, this.busInfo.cRegions);
            } else {
                this.drawText("This space intentionally left blank");
            }
            this.context.drawImage(this.canvasLiveMem, 0, 0, this.canvasLiveMem.width, this.canvasLiveMem.height, this.xMem, this.yMem, this.cxMem, this.cyMem);
            this.fRedraw = false;
        }
    }

    /**
     * updateStatus(fForce)
     *
     * Update function for Panels containing elements with high-frequency display requirements.
     *
     * For older (and slower) DOM-based display elements, those are sill being managed by the CPUx86 component,
     * so it has its own updateStatus() handler.
     *
     * The Computer's updateStatus() handler is currently responsible for calling both our handler and the CPU's handler.
     *
     * @this {Panel}
     * @param {boolean} [fForce] (true will display registers even if the CPU is running and "live" registers are not enabled)
     */
    updateStatus(fForce)
    {
        if (this.canvas) {
            this.dumpRegisters();
            this.updateAnimation();
        }
    }

    /**
     * findRegions()
     *
     * This takes the BusInfo object produced by scanMemory() and adds the following:
     *
     *      cRegions:   number of contiguous memory regions
     *      aRegions:   array of aBlocks [index, count, type] objects
     *
     * It calls addRegion() for each discrete region (set of contiguous blocks with the same type) that it finds.
     *
     * @this {Panel}
     * @returns {boolean} true if current region checksum differed from previous checksum (ie, one or more regions changed)
     */
    findRegions()
    {
        let checksum = 0;
        this.busInfo.cRegions = 0;
        if (!this.busInfo.aRegions) this.busInfo.aRegions = [];

        let typeRegion = -1, iBlock = 0, iBlockRegion = 0, addrRegion = 0, nBlockPrev = -1;

        for (; iBlock < this.busInfo.cBlocks; iBlock++) {
            let blockInfo = this.busInfo.aBlocks[iBlock];
            let typeBlock = UsrLib.getBitField(/** @type {BitField} */ (Busx86.BlockInfo.type), blockInfo);
            let nBlockCurr = UsrLib.getBitField(/** @type {BitField} */ (Busx86.BlockInfo.num), blockInfo);
            if (typeBlock != typeRegion || nBlockCurr != nBlockPrev + 1) {
                let cBlocks = iBlock - iBlockRegion;
                if (cBlocks) {
                    checksum += this.addRegion(addrRegion, iBlockRegion, cBlocks, typeRegion);
                }
                typeRegion = typeBlock;
                iBlockRegion = iBlock;
                addrRegion = nBlockCurr << this.bus.nBlockShift;
            }
            nBlockPrev = nBlockCurr;
        }

        checksum += this.addRegion(addrRegion, iBlockRegion, iBlock - iBlockRegion, typeRegion);

        let fChanged = (this.busInfo.checksumRegions != checksum);
        this.busInfo.checksumRegions = checksum;
        return fChanged;
    }

    /**
     * addRegion(addr, iBlock, cBlocks, type)
     *
     * @this {Panel}
     * @param {number} addr
     * @param {number} iBlock
     * @param {number} cBlocks
     * @param {number} type
     * @returns {number} bitfield containing the above values (used for checksum)
     */
    addRegion(addr, iBlock, cBlocks, type)
    {
        if (DEBUG) this.printf(MESSAGE.LOG, "region %d (addr %#010x, type %s) contains %d blocks\n", this.busInfo.cRegions, addr, Memoryx86.TYPE.NAMES[type], cBlocks);
        this.busInfo.aRegions[this.busInfo.cRegions++] = {iBlock: iBlock, cBlocks: cBlocks, type: type};
        return UsrLib.initBitFields(/** @type {BitFields} */ (Busx86.BlockInfo), iBlock, cBlocks, 0, type);
    }

    /**
     * dumpRegisters()
     *
     * Updates the live register portion of the panel.
     *
     * @this {Panel}
     */
    dumpRegisters()
    {
        if (this.context && this.canvasLiveRegs && this.contextLiveRegs) {

            let cpu = this.cpu;
            let x = 0, y = 0, cx = this.canvasLiveRegs.width, cy = this.canvasLiveRegs.height;

            this.contextLiveRegs.fillStyle = Panel.LIVEREGS.COLOR;
            this.contextLiveRegs.fillRect(x, y, cx, cy);

            this.initPen(x + 10, y + Panel.LIVECANVAS.FONT.CY, this.canvasLiveRegs, this.contextLiveRegs, this.canvas.style.color);
            this.initCols(3);
            this.drawText("CPU");
            this.drawText("Target");
            this.drawText("Current");
            this.skipLines();
            this.drawText(cpu.model);
            this.drawText(cpu.getSpeedTarget());
            this.drawText(cpu.getSpeedCurrent());
            this.skipLines(2);
            this.initCols(8);
            this.initNumberFormat(16, cpu.model < X86.MODEL_80386? 4 : 8);
            this.drawText("AX", cpu.regEAX, 2);
            this.drawText("DS", cpu.getDS(), 0, 1);
            this.drawText("DX", cpu.regEDX, 2);
            this.drawText("SI", cpu.regESI, 0, 1.5);
            this.drawText("BX", cpu.regEBX, 2);
            this.drawText("ES", cpu.getES(), 0, 1);
            this.drawText("CX", cpu.regECX, 2);
            this.drawText("DI", cpu.regEDI, 0, 1.5);
            this.drawText("CS", cpu.getCS(), 2);
            this.drawText("SS", cpu.getSS(), 0, 1);
            this.drawText("IP", cpu.getIP(), 2);
            this.drawText("SP", cpu.getSP(), 0, 1.5);
            let regPS;
            this.drawText("PS", regPS = cpu.getPS(), 2);
            this.drawText("BP", cpu.regEBP, 0, 1.5);
            if (cpu.model >= X86.MODEL_80386) {
                this.drawText("FS", cpu.getFS(), 2);
                this.drawText("CR0", cpu.regCR0, 0, 1);
                this.drawText("GS", cpu.getGS(), 2);
                this.drawText("CR3", cpu.regCR3, 0, 1.5);
            }
            this.initCols(9);
            this.drawText("V" + ((regPS & X86.PS.OF)? 1 : 0));
            this.drawText("D" + ((regPS & X86.PS.DF)? 1 : 0));
            this.drawText("I" + ((regPS & X86.PS.IF)? 1 : 0));
            this.drawText("T" + ((regPS & X86.PS.TF)? 1 : 0));
            this.drawText("S" + ((regPS & X86.PS.SF)? 1 : 0));
            this.drawText("Z" + ((regPS & X86.PS.ZF)? 1 : 0));
            this.drawText("A" + ((regPS & X86.PS.AF)? 1 : 0));
            this.drawText("P" + ((regPS & X86.PS.PF)? 1 : 0));
            this.drawText("C" + ((regPS & X86.PS.CF)? 1 : 0), 0, 2);

            this.dumpMemory(this.addrDumpLast);

            this.context.drawImage(this.canvasLiveRegs, x, y, cx, cy, this.xReg, this.yReg, this.cxReg, this.cyReg);
        }
    }

    /**
     * dumpMemory(addr, fDraw)
     *
     * @this {Panel}
     * @param {number} addr
     * @param {boolean} [fDraw]
     */
    dumpMemory(addr, fDraw)
    {
        if (this.context && this.canvasLiveRegs && this.contextLiveRegs) {

            let x = 0, y = Panel.LIVEREGS.CY - Panel.LIVEDUMP.CY, cx = this.canvasLiveRegs.width, cy = Panel.LIVEDUMP.CY;

            this.contextLiveRegs.fillStyle = Panel.LIVEREGS.COLOR;
            this.contextLiveRegs.fillRect(x, y, cx, cy);

            this.initPen(x + 10, y + Panel.LIVECANVAS.FONT.CY, this.canvasLiveRegs, this.contextLiveRegs, this.canvas.style.color);
            this.initCols(24);
            if (addr == null) {
                this.drawText("Mouse over memory to dump");
            } else {
                this.drawText(StrLib.toHexLong(addr), null, 0, 1);
                for (let iLine = 1; iLine <= 16; iLine++) {
                    let sChars = "";
                    for (let iCol = 1; iCol <= 8; iCol++) {
                        let b = this.bus.getByteDirect(addr++);
                        this.drawText(StrLib.toHex(b, 2), null, 1);
                        sChars += (b >= 32 && b < 128? String.fromCharCode(b) : ".");
                    }
                    this.drawText(sChars, null, 0, 1);
                }
            }

            if (fDraw) this.context.drawImage(this.canvasLiveRegs, x, y, cx, cy, this.xDump, this.yDump, this.cxDump, this.cyDump);
        }
    }

    /**
     * initPen(xLeft, yTop, canvas, context, color, cyFont, sFontFace)
     *
     * @this {Panel}
     * @param {number} xLeft
     * @param {number} yTop
     * @param {HTMLCanvasElement} [canvas]
     * @param {Object} [context]
     * @param {string} [color]
     * @param {number} [cyFont]
     * @param {string} [sFontFace]
     */
    initPen(xLeft, yTop, canvas, context, color, cyFont, sFontFace)
    {
        this.setPen(this.xLeftMargin = xLeft, yTop);
        this.heightText = this.heightDefault = cyFont || Panel.LIVECANVAS.FONT.CY;
        if (!sFontFace) sFontFace = this.fontDefault || (this.heightDefault + "px " + Panel.LIVECANVAS.FONT.FACE);
        this.fontText = this.fontDefault = sFontFace;
        if (canvas) {
            this.canvasText = canvas;
        }
        if (context) {
            this.contextText = context;
            this.colorText = color || "white";
        }
    }

    /**
     * setPen(x, y)
     *
     * @this {Panel}
     * @param {number} x
     * @param {number} y
     */
    setPen(x, y)
    {
        this.xText = x;
        this.yText = y;
    }

    /**
     * centerPen(rect)
     *
     * @this {Panel}
     * @param {Rectangle} rect
     */
    centerPen(rect)
    {
        this.fontText = this.fontDefault;
        this.heightText = this.heightDefault;
        let x = rect.x + (rect.cx >> 1);
        let y = rect.y + (rect.cy >> 1);
        let maxText = rect.cy;
        if (rect.cx < rect.cy) {
            maxText = rect.cx;
            this.fVerticalText = true;
            this.contextText.save();
            this.contextText.translate(x, y);
            this.contextText.rotate(-Math.PI/2);
            x = y = 0;
        }
        if (maxText < this.heightText) {
            this.heightText = maxText;
            this.fontText = this.heightText + "px " + Panel.LIVECANVAS.FONT.FACE;
        }
        this.setPen(x, y);
    }

    /**
     * initCols(nCols)
     *
     * @this {Panel}
     * @param {number} nCols
     */
    initCols(nCols)
    {
        this.cxColumn = (this.canvasText.width / nCols) | 0;
    }

    /**
     * skipCols(nCols)
     *
     * @this {Panel}
     * @param {number} nCols
     */
    skipCols(nCols)
    {
        this.xText += this.cxColumn * nCols;
    }

    /**
     * skipLines(nLines)
     *
     * @this {Panel}
     * @param {number} [nLines]
     */
    skipLines(nLines)
    {
        this.xText = this.xLeftMargin;
        this.yText += (this.heightText + 2) * (nLines || 1);
    }

    /**
     * initNumberFormat(nBase, nDigits)
     *
     * @this {Panel}
     * @param {number} nBase
     * @param {number} nDigits
     */
    initNumberFormat(nBase, nDigits)
    {
        this.nDefaultBase = nBase;
        this.nDefaultDigits = nDigits;
    }

    /**
     * drawText(sText)
     *
     * @this {Panel}
     * @param {string} sText
     * @param {number|null|*} [nValue]
     * @param {number} [nColsSkip]
     * @param {number} [nLinesSkip]
     */
    drawText(sText, nValue, nColsSkip, nLinesSkip)
    {
        this.contextText.font = this.fontText;
        this.contextText.fillStyle = this.colorText;
        this.contextText.fillText(sText, this.xText, this.yText);
        this.xText += this.cxColumn;
        if (nValue != null) {
            let sValue;
            if (this.nDefaultBase != 16) {
                sValue = nValue.toString();
            } else {
                sValue = this.nDefaultDigits < 8? "0x" : "";
                sValue += StrLib.toHex(nValue, this.nDefaultDigits);
            }
            this.contextText.fillText(sValue, this.xText, this.yText);
            this.xText += this.cxColumn;
        }
        if (nColsSkip) this.skipCols(nColsSkip);
        if (nLinesSkip) this.skipLines(nLinesSkip);
    }

    /**
     * centerText(sText)
     *
     * To center text within a given Rectangle:
     *
     *      centerPen(rect)
     *      centerText(sText)
     *
     * centerPen() sets xLeft and yTop to the center of the specified rectangle, and centerText() calculates
     * the width of the text, adjusting the horizontal centering by its width and the vertical centering by the
     * default font height.  Then it calls drawText().
     *
     * @this {Panel}
     * @param {string} sText
     */
    centerText(sText)
    {
        this.contextText.font = this.fontText;
        let tm = this.contextText.measureText(sText);
        this.xText -= tm.width >> 1;
        this.yText += (this.heightText >> 1) - 2;
        this.drawText(sText);
        if (this.fVerticalText) {
            this.contextText.restore();
            this.fVerticalText = false;
        }
    }

    /**
     * Panel.init()
     *
     * This function operates on every HTML element of class "panel", extracting the
     * JSON-encoded parameters for the Panel constructor from the element's "data-value"
     * attribute, invoking the constructor to create a Panel component, and then binding
     * any associated HTML controls to the new component.
     *
     * NOTE: Unlike most other component init() functions, this one is designed to be
     * called multiple times: once at load time, so that we can bind our print()
     * function to the panel's output control ASAP, and again when the Computer component
     * is verifying that all components are ready and invoking their powerUp() functions.
     *
     * Our powerUp() method gives us a second opportunity to notify any components that
     * that might care (eg, CPU, Keyboard, and Debugger) that we have some controls they
     * might want to use.
     */
    static init()
    {
        let fReady = false;
        let aePanels = Component.getElementsByClass(APPCLASS, "panel");
        for (let iPanel=0; iPanel < aePanels.length; iPanel++) {
            let ePanel = aePanels[iPanel];
            let parmsPanel = Component.getComponentParms(ePanel);
            let panel = Component.getComponentByID(parmsPanel['id'], false);
            if (!panel) {
                fReady = true;
                panel = new Panel(parmsPanel);
            }
            Component.bindComponentControls(panel, ePanel, APPCLASS);
            if (fReady) panel.setReady();
        }
        if (!fReady) {
            /**
             * If no panel was created for this invocation, then there must be a machine without
             * a panel; find it and give it a panel now.  Panels used to be optional, but now they
             * provide services to other components, so every machine gets one now, even if there
             * was no <panel> element and associated controls.
             */
            let aMachines = Component.getMachines();
            for (let i in aMachines) {
                let idPanel = aMachines[+i] + ".panel";
                let panel = Component.getComponentByType("Panel", idPanel);
                if (!panel) {
                    panel = new Panel({'id': idPanel});
                    panel.setReady();
                    break;
                }
            }
        }
    }
}

/**
 * Initialize every Panel module on the page.
 */
WebLib.onInit(Panel.init);

/**
 * @copyright https://www.pcjs.org/machines/pcx86/modules/v2/bus.js (C) 2012-2024 Jeff Parsons
 */

/** @typedef {{ cbTotal: number, cBlocks: number, aBlocks: Array.<number> }} */
let BusInfo;

/** @typedef {{ obj: Object, off: number, slot: number, refs: number }} */
let BackTrack;

/**
 * Think of this Controller class definition as an interface definition, implemented by the Video Card
 * class and the RAM CompaqController class.
 *
 * @class Controller
 * @unrestricted (allows the class to define properties, both dot and named, outside of the constructor)
 */
class Controller {
    /**
     * getMemoryAccess()
     *
     * @this {Controller}
     * @returns {Array.<function()>}
     */
    getMemoryAccess()
    {
        return [];
    }

    /**
     * getMemoryBuffer(addr)
     *
     * @this {Controller}
     * @param {number} addr
     * @returns {Array} containing the buffer (and an offset within that buffer)
     */
    getMemoryBuffer(addr)
    {
        return [];
    }
}

/**
 * @class Bus
 * @unrestricted (allows the class to define properties, both dot and named, outside of the constructor)
 */
class Busx86 extends Component {
    /**
     * BackTrack indexes are 31-bit values, where bits 0-8 store an object offset (0-511) and bits 16-30 store
     * an object number (1-32767).  Object number 0 is reserved for dynamic data (ie, data created independent
     * of any source); examples include zero values produced by instructions such as "SUB AX,AX" or "XOR AX,AX".
     * We must special-case instructions like that, because even though AX will almost certainly contain some source
     * data prior to the instruction, the result no longer has any connection to the source.  Similarly, "SBB AX,AX"
     * may produce 0 or -1, depending on carry, but since we don't track the source of individual bits (including the
     * carry flag), AX is now source-less.  TODO: This is an argument for maintaining source info on selected flags,
     * even though it would be rather expensive.
     *
     * The 7 middle bits (9-15) record type and access information, as follows:
     *
     *      bit 15: set to indicate a "data" byte, clear to indicate a "code" byte
     *
     * All bytes start out as "data" bytes; only once they've been executed do they become "code" bytes.  For code
     * bytes, the remaining 6 middle bits (9-14) represent an execution count that starts at 1 (on the byte's initial
     * transition from data to code) and tops out at 63.
     *
     * For data bytes, the remaining middle bits indicate any transformations the data has undergone; eg:
     *
     *      bit 14: ADD/SUB/INC/DEC
     *      bit 13: MUL/DIV
     *      bit 12: OR/AND/XOR/NOT
     *
     * We make no attempt to record the original data or the transformation data, only that the transformation occurred.
     *
     * Other middle bits indicate whether the data was ever read and/or written:
     *
     *      bit 11: READ
     *      bit 10: WRITE
     *
     * Bit 9 is reserved for now.
     */
    static BTINFO = {
        SLOT_MAX:       32768,
        SLOT_SHIFT:     16,
        TYPE_DATA:      0x8000,
        TYPE_ADDSUB:    0x4000,
        TYPE_MULDIV:    0x2000,
        TYPE_LOGICAL:   0x1000,
        TYPE_READ:      0x0800,
        TYPE_WRITE:     0x0400,
        TYPE_COUNT_INC: 0x0200,
        TYPE_COUNT_MAX: 0x7E00,
        TYPE_MASK:      0xFE00,
        TYPE_SHIFT:     9,
        OFF_MAX:        512,
        OFF_MASK:       0x1FF
    };

    static ERROR = {
        ADD_MEM_INUSE:      1,
        ADD_MEM_BADRANGE:   2,
        SET_MEM_NOCTRL:     3,
        SET_MEM_BADRANGE:   4,
        REM_MEM_BADRANGE:   5
    };

    /**
     * This defines the BlockInfo bit fields used by scanMemory() when it creates the aBlocks array.
     */
    static BlockInfo = UsrLib.defineBitFields({num:20, count:8, btmod:1, type:3});

    /**
     * Busx86(cpu, dbg)
     *
     * The Busx86 component manages physical memory and I/O address spaces.
     *
     * The Busx86 component has no UI elements, so it does not require an init() handler,
     * but it still inherits from the Component class and must be allocated like any
     * other device component.  It's currently allocated by the Computer's init() handler,
     * which then calls the initBus() method of all the other components.
     *
     * When initMemory() initializes the entire address space, it also passes aMemBlocks
     * to the CPU object, so that the CPU can perform its own address-to-block calculations
     * (essential, for example, when the CPU enables paging).
     *
     * For memory beyond the simple needs of the ROM and RAM components (ie, memory-mapped
     * devices), the address space must still be allocated through the Busx86 component via
     * addMemory().  If the component needs something more than simple read/write storage,
     * it must provide a controller with getMemoryBuffer() and getMemoryAccess() methods.
     *
     * All port (I/O) operations are defined by external handlers; they register with us,
     * and we manage those registrations and provide support for I/O breakpoints, but the
     * only default I/O behavior we provide is ignoring writes to any unregistered output
     * ports and returning 0xff from any unregistered input ports.
     *
     * @this {Busx86}
     * @param {Object} parmsBus
     * @param {CPUx86} cpu
     * @param {Debuggerx86} dbg
     */
    constructor(parmsBus, cpu, dbg)
    {
        super("Busx86", parmsBus);

        this.cpu = cpu;
        this.dbg = dbg;

        this.nBusWidth = +parmsBus['busWidth'] || 20;

        /**
         * Compute all Bus memory block parameters, based on the width of the bus.
         *
         * Regarding blockTotal, we want to avoid using block overflow expressions like:
         *
         *      iBlock < this.nBlockTotal? iBlock : 0
         *
         * As long as we know that blockTotal is a power of two (eg, 256 or 0x100, in the case of
         * nBusWidth == 20 and blockSize == 4096), we can define blockMask as (blockTotal - 1) and
         * rewrite the previous expression as:
         *
         *      iBlock & this.nBlockMask
         *
         * Similarly, we mask addresses with busMask to enforce "A20 wrap" on 20-bit buses.
         * For larger buses, A20 wrap can be simulated by either clearing bit 20 of busMask or by
         * changing all the block entries for the 2nd megabyte to match those in the 1st megabyte.
         *
         *      Bus Property        Old hard-coded values (when nBusWidth was always 20)
         *      ------------        ----------------------------------------------------
         *      this.nBusLimit      0xfffff
         *      this.nBusMask       [same as busLimit]
         *      this.nBlockSize     4096
         *      this.nBlockLen      (this.nBlockSize >> 2)
         *      this.nBlockShift    12
         *      this.nBlockLimit    0xfff
         *      this.nBlockTotal    ((this.nBusLimit + this.nBlockSize) / this.nBlockSize) | 0
         *      this.nBlockMask     (this.nBlockTotal - 1) [ie, 0xff]
         *
         * Note that we choose a nBlockShift value (and thus a physical memory block size) based on "buswidth":
         *
         *      Bus Width                       Block Shift     Block Size
         *      ---------                       -----------     ----------
         *      20 bits (1Mb address space):    12              4Kb (256 maximum blocks)
         *      24 bits (16Mb address space):   14              16Kb (1K maximum blocks)
         *      32 bits (4Gb address space);    15              32Kb (128K maximum blocks)
         *
         * The coarser block granularities (ie, 16Kb and 32Kb) may cause problems for certain RAM and/or ROM
         * allocations that are contiguous but are allocated out of order, or that have different controller
         * requirements.  Your choices, for the moment, are either to ensure the allocations are performed in
         * order, or to choose smaller nBlockShift values (at the expense of a generating a larger block array).
         *
         * UPDATE: The above is mostly historical thinking, because the new default block size is 4K (assuming
         * PAGEBLOCKS is set, which it always is now).  We really need the lower granularity for all machines,
         * because the original IBM MDA video card needs to be able to do 4K-granular aliasing.
         */
        this.addrTotal = Math.pow(2, this.nBusWidth);
        this.nBusLimit = this.nBusMask = (this.addrTotal - 1) | 0;
        this.nBlockShift = (PAGEBLOCKS /* && this.nBusWidth == 32 */ || this.nBusWidth <= 20)? 12 : (this.nBusWidth <= 24? 14 : 15);
        this.nBlockSize = 1 << this.nBlockShift;
        this.nBlockLen = this.nBlockSize >> 2;
        this.nBlockLimit = this.nBlockSize - 1;
        this.nBlockTotal = (this.addrTotal / this.nBlockSize) | 0;
        this.nBlockMask = this.nBlockTotal - 1;


        /**
         * Lists of I/O notification functions: aPortInputNotify and aPortOutputNotify are arrays, indexed by
         * port, of sub-arrays which contain:
         *
         *      [0]: registered function to call for every I/O access
         *
         * The registered function is called with the port address, and if the access was triggered by the CPU,
         * the linear instruction pointer (LIP) at the point of access.
         *
         * WARNING: Unlike the (old) read and write memory notification functions, these support only one
         * pair of input/output functions per port.  A more sophisticated architecture could support a list
         * of chained functions across multiple components, but I doubt that will be necessary here.
         *
         * UPDATE: The Debugger now piggy-backs on these arrays to indicate ports for which it wants notification
         * of I/O.  In those cases, the registered component/function elements may or may not be set, but the
         * following additional element will be set:
         *
         *      [1]: true to break on I/O, false to ignore I/O
         *
         * The false case is important if fPortInputBreakAll and/or fPortOutputBreakAll is set, because it allows the
         * Debugger to selectively ignore specific ports.
         */
        this.aPortInputNotify = [];
        this.aPortOutputNotify = [];
        this.fPortInputBreakAll = this.fPortOutputBreakAll = false;

        /**
         * By default, all I/O ports are 1 byte wide; ports that are wider must add themselves to one or both of
         * these lists, using addPortInputWidth() and/or addPortOutputWidth().
         */
        this.aPortInputWidth = [];
        this.aPortOutputWidth = [];

        /**
         * Allocate empty Memory blocks to span the entire physical address space.
         */
        this.initMemory();

        if (BACKTRACK) {
            this.abtObjects = [];
            this.cbtDeletions = 0;
            this.ibtLastAlloc = -1;
            this.ibtLastDelete = 0;
        }

        this.setReady();
    }

    /**
     * initMemory()
     *
     * Allocate enough (empty) Memory blocks to span the entire physical address space.
     *
     * @this {Busx86}
     */
    initMemory()
    {
        let block = new Memoryx86();
        block.copyBreakpoints(this.dbg);
        this.aMemBlocks = new Array(this.nBlockTotal);
        for (let iBlock = 0; iBlock < this.nBlockTotal; iBlock++) {
            this.aMemBlocks[iBlock] = block;
        }
        this.cpu.initMemory(this.aMemBlocks, this.nBlockShift);
        this.cpu.setAddressMask(this.nBusMask);
    }

    /**
     * reset()
     *
     * @this {Busx86}
     */
    reset()
    {
        this.setA20(true);
        if (BACKTRACK) this.ibtLastDelete = 0;
    }

    /**
     * powerUp(data, fRepower)
     *
     * We don't need a powerDown() handler, because for largely historical reasons, our state (including the A20 state)
     * is saved by saveMemory(), which called by the CPU.
     *
     * However, we do need a powerUp() handler, because on resumable machines, the Computer's onReset() function calls
     * everyone's powerUp() handler rather than their reset() handler.
     *
     * TODO: Perhaps Computer should be smarter: if there's no powerUp() handler, then fallback to the reset() handler.
     * In that case, however, we'd either need to remove the powerUp() stub in Component, or detect the existence of the stub.
     *
     * @this {Busx86}
     * @param {Object|null} data (always null because we supply no powerDown() handler)
     * @param {boolean} [fRepower]
     * @returns {boolean} true if successful, false if failure
     */
    powerUp(data, fRepower)
    {
        if (!fRepower) this.reset();
        return true;
    }

    /**
     * addMemory(addr, size, type, controller)
     *
     * Adds new Memory blocks to the specified address range.  Any Memory blocks previously
     * added to that range must first be removed via removeMemory(); otherwise, you'll get
     * an allocation conflict error.  This helps prevent address calculation errors, redundant
     * allocations, etc.
     *
     * We've relaxed some of the original requirements (ie, that addresses must start at a
     * block-granular address, or that sizes must be equal to exactly one or more blocks),
     * because machines with large block sizes can make it impossible to load certain ROMs at
     * their required addresses.  Every allocation still allocates a whole number of blocks.
     *
     * Even so, Bus memory management does NOT provide a general-purpose heap.  Most memory
     * allocations occur during machine initialization and never change.  In particular, there
     * is NO support for removing partial-block allocations.  Typically, the only region that
     * changes post-initialization is the Video buffer, and only in the EGA/VGA implementation.
     *
     * Each Memory block keeps track of a start address (addr) and length (used), indicating
     * the used space within the block; any free space that precedes or follows that used space
     * can be allocated later, by simply extending the beginning or ending of the previously used
     * space.  However, any holes that might have existed between the original allocation and an
     * extension are subsumed by the extension.
     *
     * @this {Busx86}
     * @param {number} addr is the starting physical address of the request
     * @param {number} size of the request, in bytes
     * @param {number} type is one of the Memoryx86.TYPE constants
     * @param {Controller} [controller] is an optional memory controller component
     * @returns {boolean} true if successful, false if not
     */
    addMemory(addr, size, type, controller)
    {
        let addrNext = addr;
        let sizeLeft = size;
        let iBlock = addrNext >>> this.nBlockShift;

        while (sizeLeft > 0 && iBlock < this.aMemBlocks.length) {

            let block = this.aMemBlocks[iBlock];
            let addrBlock = iBlock * this.nBlockSize;
            let sizeBlock = this.nBlockSize - (addrNext - addrBlock);
            if (sizeBlock > sizeLeft) sizeBlock = sizeLeft;

            if (block && block.size) {
                if (block.type == type && block.controller == controller) {
                    /**
                     * Where there is already a similar block with a non-zero size, we allow the allocation only if:
                     *
                     *   1) addrNext + sizeLeft <= block.addr (the request precedes the used portion of the current block), or
                     *   2) addrNext >= block.addr + block.used (the request follows the used portion of the current block)
                     */
                    if (addrNext + sizeLeft <= block.addr) {
                        block.used += (block.addr - addrNext);
                        block.addr = addrNext;
                        return true;
                    }
                    if (addrNext >= block.addr + block.used) {
                        let sizeAvail = block.size - (addrNext - addrBlock);
                        if (sizeAvail > sizeLeft) sizeAvail = sizeLeft;
                        block.used = addrNext - block.addr + sizeAvail;
                        addrNext = addrBlock + this.nBlockSize;
                        sizeLeft -= sizeAvail;
                        iBlock++;
                        continue;
                    }
                }
                return this.reportError(Busx86.ERROR.ADD_MEM_INUSE, addrNext, sizeLeft);
            }

            let blockNew = new Memoryx86(addrNext, sizeBlock, this.nBlockSize, type, controller);
            blockNew.copyBreakpoints(this.dbg, block);
            this.aMemBlocks[iBlock++] = blockNew;

            addrNext = addrBlock + this.nBlockSize;
            sizeLeft -= sizeBlock;
        }
        if (sizeLeft <= 0) {
            /**
             * If all addMemory() calls happened ONLY during device initialization, the following code would not
             * be necessary; unfortunately, the Video component can add and remove physical memory blocks during video
             * mode changes, so we have to kick out any PAGED blocks that could have references to those physical memory
             * blocks.  If paging isn't enabled (or supported by the current the CPU), this call has no effect.
             *
             * We could handle this case with a little more, um, precision, but Video mode changes aren't frequent enough
             * to warrant it.
             */
            this.cpu.flushPageBlocks();
            if (!this.cpu.isRunning()) {        // allocation messages at "run time" are bit too much
                let kb = Math.round(size / 1024);
                let sb = kb? (kb + "Kb") : (size + " bytes");
                this.printf(MESSAGE.STATUS, "%s %s at 0x%X\n", sb, Memoryx86.TYPE.NAMES[type], addr);
            }
            return true;
        }
        return this.reportError(Busx86.ERROR.ADD_MEM_BADRANGE, addr, size);
    }

    /**
     * cleanMemory(addr, size, fScrub)
     *
     * @this {Busx86}
     * @param {number} addr
     * @param {number} size
     * @param {boolean} [fScrub] (true to "scrub" blocks as well)
     * @returns {boolean} (true if all blocks were clean, false otherwise)
     */
    cleanMemory(addr, size, fScrub)
    {
        let fClean = true;
        let iBlock = addr >>> this.nBlockShift;
        let sizeBlock = this.nBlockSize - (addr & this.nBlockLimit);
        while (size > 0 && iBlock < this.aMemBlocks.length) {
            if (!this.aMemBlocks[iBlock].clean(fScrub)) {
                fClean = false;
            }
            size -= sizeBlock;
            sizeBlock = this.nBlockSize;
            iBlock++;
        }
        return fClean;
    }

    /**
     * scanMemory(info, addr, size)
     *
     * Returns a BusInfo object for the specified address range.
     *
     * @this {Busx86}
     * @param {Object} [info] previous BusInfo, if any
     * @param {number} [addr] starting address of range (0 if none provided)
     * @param {number} [size] size of range, in bytes (up to end of address space if none provided)
     * @returns {Object} updated info (or new info if no previous info provided)
     */
    scanMemory(info, addr, size)
    {
        if (addr == null) addr = 0;
        if (size == null) size = (this.addrTotal - addr) | 0;
        if (info == null) info = {cbTotal: 0, cBlocks: 0, aBlocks: []};

        let iBlock = addr >>> this.nBlockShift;
        let iBlockMax = ((addr + size - 1) >>> this.nBlockShift);

        info.cbTotal = 0;
        info.cBlocks = 0;
        while (iBlock <= iBlockMax) {
            let block = this.aMemBlocks[iBlock];
            info.cbTotal += block.size;
            if (block.size) {
                let btmod = (BACKTRACK && block.modBackTrack(false)? 1 : 0);
                info.aBlocks.push(UsrLib.initBitFields(/** @type {BitFields} */ (Busx86.BlockInfo), iBlock, 0, btmod, block.type));
                info.cBlocks++;
            }
            iBlock++;
        }
        return info;
    }

    /**
     * getA20()
     *
     * @this {Busx86}
     * @returns {boolean} true if enabled, false if disabled
     */
    getA20()
    {
        return !this.aBlocks2Mb && this.nBusLimit == this.nBusMask;
    }

    /**
     * setA20(fEnable)
     *
     * On 32-bit bus machines, I've adopted the approach that COMPAQ took with DeskPro 386 machines,
     * which is to map the 1st Mb to the 2nd Mb whenever A20 is disabled, rather than blindly masking
     * the A20 address bit from all addresses; in fact, this is what the DeskPro 386 ROM BIOS requires.
     *
     * For 24-bit bus machines, we take the same approach that most if not all 80286 systems took, which
     * is simply masking the A20 address bit.  A lot of 32-bit machines probably took the same approach.
     *
     * TODO: On machines with a 32-bit bus, look into whether we can eliminate address masking altogether,
     * which seems feasible, provided all incoming addresses are already pre-truncated to 32 bits.  Also,
     * confirm that DeskPro 386 machines mapped the ENTIRE 1st Mb to the 2nd, and not simply the first 64Kb,
     * which is technically all that 8086 address wrap-around compatibility would require.
     *
     * @this {Busx86}
     * @param {boolean} fEnable is true to enable A20 (default), false to disable
     */
    setA20(fEnable)
    {
        if (this.nBusWidth == 32) {
            if (fEnable) {
                if (this.aBlocks2Mb) {
                    this.setMemoryBlocks(0x100000, 0x100000, this.aBlocks2Mb);
                    this.aBlocks2Mb = null;
                }
            } else {
                if (!this.aBlocks2Mb) {
                    this.aBlocks2Mb = this.getMemoryBlocks(0x100000, 0x100000);
                    this.setMemoryBlocks(0x100000, 0x100000, this.getMemoryBlocks(0x0, 0x100000));
                }
            }
        }
        else if (this.nBusWidth > 20) {
            let addrMask = (this.nBusMask & ~0x100000) | (fEnable? 0x100000 : 0);
            if (addrMask != this.nBusMask) {
                this.nBusMask = addrMask;
                if (this.cpu) this.cpu.setAddressMask(addrMask);
            }
        }
    }

    /**
     * getWidth()
     *
     * @this {Busx86}
     * @returns {number}
     */
    getWidth()
    {
        return this.nBusWidth;
    }

    /**
     * setMemoryAccess(addr, size, afn, fQuiet)
     *
     * Updates the access functions in every block of the specified address range.  Since the only components
     * that should be dynamically modifying the memory access functions are those that use addMemory() with a custom
     * memory controller, we require that the block(s) being updated do in fact have a controller.
     *
     * @this {Busx86}
     * @param {number} addr
     * @param {number} size
     * @param {Array.<function()>} [afn]
     * @param {boolean} [fQuiet] (true if any error should be quietly logged)
     * @returns {boolean} true if successful, false if not
     */
    setMemoryAccess(addr, size, afn, fQuiet)
    {
        if (!(addr & this.nBlockLimit) && size && !(size & this.nBlockLimit)) {
            let iBlock = addr >>> this.nBlockShift;
            while (size > 0) {
                let block = this.aMemBlocks[iBlock];
                if (!block.controller) {
                    return this.reportError(Busx86.ERROR.SET_MEM_NOCTRL, addr, size, fQuiet);
                }
                block.setAccess(afn, true);
                size -= this.nBlockSize;
                iBlock++;
            }
            return true;
        }
        return this.reportError(Busx86.ERROR.SET_MEM_BADRANGE, addr, size);
    }

    /**
     * removeMemory(addr, size)
     *
     * Replaces every block in the specified address range with empty Memory blocks that ignore all reads/writes.
     *
     * TODO: Update the removeMemory() interface to reflect the relaxed requirements of the addMemory() interface.
     *
     * @this {Busx86}
     * @param {number} addr
     * @param {number} size
     * @returns {boolean} true if successful, false if not
     */
    removeMemory(addr, size)
    {
        if (!(addr & this.nBlockLimit) && size && !(size & this.nBlockLimit)) {
            let iBlock = addr >>> this.nBlockShift;
            while (size > 0) {
                let blockOld = this.aMemBlocks[iBlock];
                let blockNew = new Memoryx86(addr);
                blockNew.copyBreakpoints(this.dbg, blockOld);
                this.aMemBlocks[iBlock++] = blockNew;
                addr = iBlock * this.nBlockSize;
                size -= this.nBlockSize;
            }
            /**
             * If all removeMemory() calls happened ONLY during device initialization, the following code would not
             * be necessary; unfortunately, the Video component can add and remove physical memory blocks during video
             * mode changes, so we have to kick out any PAGED blocks that could have references to those physical memory
             * blocks.  If paging isn't enabled (or supported by the current the CPU), this call has no effect.
             *
             * We could handle this case with a little more, um, precision, but Video mode changes aren't frequent enough
             * to warrant it.
             */
            this.cpu.flushPageBlocks();
            return true;
        }
        return this.reportError(Busx86.ERROR.REM_MEM_BADRANGE, addr, size);
    }

    /**
     * getMemoryBlocks(addr, size)
     *
     * @this {Busx86}
     * @param {number} addr is the starting physical address
     * @param {number} size of the request, in bytes
     * @returns {Array} of Memory blocks
     */
    getMemoryBlocks(addr, size)
    {
        let aBlocks = [];
        let iBlock = addr >>> this.nBlockShift;
        while (size > 0 && iBlock < this.aMemBlocks.length) {
            aBlocks.push(this.aMemBlocks[iBlock++]);
            size -= this.nBlockSize;
        }
        return aBlocks;
    }

    /**
     * setMemoryBlocks(addr, size, aBlocks, type)
     *
     * If no type is specified, then specified address range uses all the provided blocks as-is;
     * this form of setMemoryBlocks() is used for complete physical aliases.
     *
     * Otherwise, new blocks are allocated with the specified type; the underlying memory from the
     * provided blocks is still used, but the new blocks may have different access to that memory.
     *
     * @this {Busx86}
     * @param {number} addr is the starting physical address
     * @param {number} size of the request, in bytes
     * @param {Array} aBlocks as returned by getMemoryBlocks()
     * @param {number} [type] is one of the Memoryx86.TYPE constants
     */
    setMemoryBlocks(addr, size, aBlocks, type)
    {
        let i = 0;
        let iBlock = addr >>> this.nBlockShift;
        while (size > 0 && iBlock < this.aMemBlocks.length) {
            let block = aBlocks[i++];

            if (!block) break;
            if (type !== undefined) {
                let blockNew = new Memoryx86(addr);
                blockNew.clone(block, type, this.dbg);
                block = blockNew;
            }
            this.aMemBlocks[iBlock++] = block;
            size -= this.nBlockSize;
        }
    }

    /**
     * getByte(addr)
     *
     * For physical addresses only; for linear addresses, use cpu.getByte().
     *
     * @this {Busx86}
     * @param {number} addr is a physical address
     * @returns {number} byte (8-bit) value at that address
     */
    getByte(addr)
    {
        return this.aMemBlocks[(addr & this.nBusMask) >>> this.nBlockShift].readByte(addr & this.nBlockLimit, addr);
    }

    /**
     * getByteDirect(addr)
     *
     * This is useful for the Debugger and other components that want to bypass getByte() breakpoint detection.
     *
     * @this {Busx86}
     * @param {number} addr is a physical address
     * @returns {number} byte (8-bit) value at that address
     */
    getByteDirect(addr)
    {
        return this.aMemBlocks[(addr & this.nBusMask) >>> this.nBlockShift].readByteDirect(addr & this.nBlockLimit, addr);
    }

    /**
     * getShort(addr)
     *
     * For physical addresses only; for linear addresses, use cpu.getShort().
     *
     * @this {Busx86}
     * @param {number} addr is a physical address
     * @returns {number} word (16-bit) value at that address
     */
    getShort(addr)
    {
        let off = addr & this.nBlockLimit;
        let iBlock = (addr & this.nBusMask) >>> this.nBlockShift;
        if (off != this.nBlockLimit) {
            return this.aMemBlocks[iBlock].readShort(off, addr);
        }
        return this.aMemBlocks[iBlock++].readByte(off, addr) | (this.aMemBlocks[iBlock & this.nBlockMask].readByte(0, addr + 1) << 8);
    }

    /**
     * getShortDirect(addr)
     *
     * This is useful for the Debugger and other components that want to bypass getShort() breakpoint detection.
     *
     * @this {Busx86}
     * @param {number} addr is a physical address
     * @returns {number} word (16-bit) value at that address
     */
    getShortDirect(addr)
    {
        let off = addr & this.nBlockLimit;
        let iBlock = (addr & this.nBusMask) >>> this.nBlockShift;
        if (off != this.nBlockLimit) {
            return this.aMemBlocks[iBlock].readShortDirect(off, addr);
        }
        return this.aMemBlocks[iBlock++].readByteDirect(off, addr) | (this.aMemBlocks[iBlock & this.nBlockMask].readByteDirect(0, addr + 1) << 8);
    }

    /**
     * getLong(addr)
     *
     * For physical addresses only; for linear addresses, use cpu.getLong().
     *
     * @this {Busx86}
     * @param {number} addr is a physical address
     * @returns {number} long (32-bit) value at that address
     */
    getLong(addr)
    {
        let off = addr & this.nBlockLimit;
        let iBlock = (addr & this.nBusMask) >>> this.nBlockShift;
        if (off < this.nBlockLimit - 2) {
            return this.aMemBlocks[iBlock].readLong(off, addr);
        }
        /**
         * I think the previous version of this function tried to be too clever (ie, reading the last
         * long in the current block and the first long in the next block and masking/combining the results),
         * which may have also created some undesirable side-effects for custom memory controllers.
         * This simpler (and probably more reliable) approach is to simply read the long as individual bytes.
         */
        let l = 0;
        let cb = 4, nShift = 0;
        let cbBlock = 4 - (off & 0x3);    // (off & 0x3) will be 1, 2 or 3, so cbBlock will be 3, 2, or 1
        while (cb--) {
            l |= (this.aMemBlocks[iBlock].readByte(off++, addr++) << nShift);
            if (!--cbBlock) {
                iBlock = (iBlock + 1) & this.nBlockMask;
                off = 0;
            }
            nShift += 8;
        }
        return l;
    }

    /**
     * setByte(addr, b)
     *
     * For physical addresses only; for linear addresses, use cpu.setByte().
     *
     * @this {Busx86}
     * @param {number} addr is a physical address
     * @param {number} b is the byte (8-bit) value to write (we truncate it to 8 bits to be safe)
     */
    setByte(addr, b)
    {
        this.aMemBlocks[(addr & this.nBusMask) >>> this.nBlockShift].writeByte(addr & this.nBlockLimit, b & 0xff, addr);
    }

    /**
     * setByteDirect(addr, b)
     *
     * This is useful for the Debugger and other components that want to bypass breakpoint detection AND read-only
     * memory protection (for example, this is an interface the ROM component could use to initialize ROM contents).
     *
     * @this {Busx86}
     * @param {number} addr is a physical address
     * @param {number} b is the byte (8-bit) value to write (we truncate it to 8 bits to be safe)
     */
    setByteDirect(addr, b)
    {
        this.aMemBlocks[(addr & this.nBusMask) >>> this.nBlockShift].writeByteDirect(addr & this.nBlockLimit, b & 0xff, addr);
    }

    /**
     * setShort(addr, w)
     *
     * For physical addresses only; for linear addresses, use cpu.setShort().
     *
     * @this {Busx86}
     * @param {number} addr is a physical address
     * @param {number} w is the word (16-bit) value to write (we truncate it to 16 bits to be safe)
     */
    setShort(addr, w)
    {
        let off = addr & this.nBlockLimit;
        let iBlock = (addr & this.nBusMask) >>> this.nBlockShift;
        if (off != this.nBlockLimit) {
            this.aMemBlocks[iBlock].writeShort(off, w & 0xffff, addr);
            return;
        }
        this.aMemBlocks[iBlock++].writeByte(off, w & 0xff, addr);
        this.aMemBlocks[iBlock & this.nBlockMask].writeByte(0, (w >> 8) & 0xff, addr + 1);
    }

    /**
     * setShortDirect(addr, w)
     *
     * This is useful for the Debugger and other components that want to bypass breakpoint detection AND read-only
     * memory protection (for example, this is an interface the ROM component could use to initialize ROM contents).
     *
     * @this {Busx86}
     * @param {number} addr is a physical address
     * @param {number} w is the word (16-bit) value to write (we truncate it to 16 bits to be safe)
     */
    setShortDirect(addr, w)
    {
        let off = addr & this.nBlockLimit;
        let iBlock = (addr & this.nBusMask) >>> this.nBlockShift;
        if (off != this.nBlockLimit) {
            this.aMemBlocks[iBlock].writeShortDirect(off, w & 0xffff, addr);
            return;
        }
        this.aMemBlocks[iBlock++].writeByteDirect(off, w & 0xff, addr);
        this.aMemBlocks[iBlock & this.nBlockMask].writeByteDirect(0, (w >> 8) & 0xff, addr + 1);
    }

    /**
     * setLong(addr, l)
     *
     * For physical addresses only; for linear addresses, use cpu.setLong().
     *
     * @this {Busx86}
     * @param {number} addr is a physical address
     * @param {number} l is the long (32-bit) value to write
     */
    setLong(addr, l)
    {
        let off = addr & this.nBlockLimit;
        let iBlock = (addr & this.nBusMask) >>> this.nBlockShift;
        if (off < this.nBlockLimit - 2) {
            this.aMemBlocks[iBlock].writeLong(off, l);
            return;
        }
        /**
         * I think the previous version of this function tried to be too clever (ie, reading and rewriting
         * the last long in the current block, and then reading and rewriting the first long in the next
         * block), which may have also created some undesirable side-effects for custom memory controllers.
         * This simpler (and probably more reliable) approach is to simply write the long as individual bytes.
         */
        let cb = 4;
        let cbBlock = 4 - (off & 0x3);    // (off & 0x3) will be 1, 2 or 3, so cbBlock will be 3, 2, or 1
        while (cb--) {
            this.aMemBlocks[iBlock].writeByte(off++, l & 0xff, addr++);
            if (!--cbBlock) {
                iBlock = (iBlock + 1) & this.nBlockMask;
                off = 0;
            }
            l >>>= 8;
        }
    }

    /**
     * addBackTrackObject(obj, bto, off)
     *
     * If bto is null, then we create bto (ie, an object that wraps obj and records off).
     *
     * If bto is NOT null, then we verify that off is within the given bto's range; if not,
     * then we must create a new bto and return that instead.
     *
     * @this {Busx86}
     * @param {Object} obj
     * @param {BackTrack|null} bto
     * @param {number} off (the offset within obj that this wrapper object is relative to)
     * @returns {BackTrack|null}
     */
    addBackTrackObject(obj, bto, off)
    {
        if (BACKTRACK && obj) {
            let cbtObjects = this.abtObjects.length;
            if (!bto) {
                /**
                 * Try the most recently created bto, on the off-chance it's what the caller needs
                 */
                if (this.ibtLastAlloc >= 0) bto = this.abtObjects[this.ibtLastAlloc];
            }
            if (!bto || bto.obj != obj || off < bto.off || off >= bto.off + Busx86.BTINFO.OFF_MAX) {

                bto = {obj: obj, off: off, slot: 0, refs: 0};

                let slot;
                if (!this.cbtDeletions) {
                    slot = cbtObjects;
                } else {
                    for (slot = this.ibtLastDelete; slot < cbtObjects; slot++) {
                        let btoTest = this.abtObjects[slot];
                        if (!btoTest || !btoTest.refs && !this.isBackTrackWeak(slot << Busx86.BTINFO.SLOT_SHIFT)) {
                            this.ibtLastDelete = slot + 1;
                            this.cbtDeletions--;
                            break;
                        }
                    }
                    /**
                     * There's no longer any guarantee that simply because cbtDeletions was non-zero that there WILL
                     * be an available (existing) slot, because cbtDeletions also counts weak references that may still
                     * be weak.
                     *
                     *
                     */
                }
                /**
                 *  I hit the following error after running in a machine with lots of disk activity:
                 *
                 *      Error: assertion failure in deskpro386.bus
                 *      at Busx86.Component.assert (http://localhost:8088/machines/modules/v2/component.js:732:31)
                 *      at Busx86.addBackTrackObject (http://localhost:8088/machines/pcx86/modules/v2/bus.js:980:18)
                 *      at onATCReadData (http://localhost:8088/machines/pcx86/modules/v2/hdc.js:1410:35)
                 *      at HDC.readData (http://localhost:8088/machines/pcx86/modules/v2/hdc.js:2573:23)
                 *      at HDC.inATCByte (http://localhost:8088/machines/pcx86/modules/v2/hdc.js:1398:20)
                 *      at HDC.inATCData (http://localhost:8088/machines/pcx86/modules/v2/hdc.js:1487:17)
                 *      at Busx86.checkPortInputNotify (http://localhost:8088/machines/pcx86/modules/v2/bus.js:1457:38)
                 *      at CPUx86.INSw (http://localhost:8088/machines/pcx86/modules/v2/x86ops.js:1640:26)
                 *      at CPUx86.stepCPU (http://localhost:8088/machines/pcx86/modules/v2/cpux86.js:4637:37)
                 *      at CPUx86.CPU.runCPU (http://localhost:8088/machines/pcx86/modules/v2/cpu.js:1014:22)
                 *
                 * TODO: Investigate.  For now, disable BACKTRACK if you run into this or other problems.
                 */

                this.ibtLastAlloc = slot;
                bto.slot = slot + 1;
                if (slot == cbtObjects) {
                    this.abtObjects.push(bto);
                } else {
                    this.abtObjects[slot] = bto;
                }
            }
            return bto;
        }
        return null;
    }

    /**
     * getBackTrackIndex(bto, off)
     *
     * @this {Busx86}
     * @param {BackTrack|null} bto
     * @param {number} off
     * @returns {number}
     */
    getBackTrackIndex(bto, off)
    {
        let bti = 0;
        if (BACKTRACK && bto) {
            bti = (bto.slot << Busx86.BTINFO.SLOT_SHIFT) | Busx86.BTINFO.TYPE_DATA | (off - bto.off);
        }
        return bti;
    }

    /**
     * writeBackTrackObject(addr, bto, off)
     *
     * @this {Busx86}
     * @param {number} addr is a physical address
     * @param {BackTrack|null} bto
     * @param {number} off
     */
    writeBackTrackObject(addr, bto, off)
    {
        if (BACKTRACK && bto) {

            let bti = (bto.slot << Busx86.BTINFO.SLOT_SHIFT) | Busx86.BTINFO.TYPE_DATA | (off - bto.off);
            this.writeBackTrack(addr, bti);
        }
    }

    /**
     * readBackTrack(addr)
     *
     * @this {Busx86}
     * @param {number} addr is a physical address
     * @returns {number}
     */
    readBackTrack(addr)
    {
        if (BACKTRACK) {
            return this.aMemBlocks[(addr & this.nBusMask) >>> this.nBlockShift].readBackTrack(addr & this.nBlockLimit);
        }
        return 0;
    }

    /**
     * writeBackTrack(addr, bti)
     *
     * @this {Busx86}
     * @param {number} addr is a physical address
     * @param {number} bti
     */
    writeBackTrack(addr, bti)
    {
        if (BACKTRACK) {
            let slot = bti >>> Busx86.BTINFO.SLOT_SHIFT;
            let iBlock = (addr & this.nBusMask) >>> this.nBlockShift;
            let btiPrev = this.aMemBlocks[iBlock].writeBackTrack(addr & this.nBlockLimit, bti);
            let slotPrev = btiPrev >>> Busx86.BTINFO.SLOT_SHIFT;
            if (slot != slotPrev) {
                this.aMemBlocks[iBlock].modBackTrack(true);
                if (btiPrev && slotPrev) {
                    let btoPrev = this.abtObjects[slotPrev-1];
                    if (!btoPrev) {
                        this.printf(MESSAGE.DEBUG + MESSAGE.WARNING, "writeBackTrack(%%%x,%x): previous index (%x) refers to empty slot (%d)\n", addr, bti, btiPrev, slotPrev);
                    }
                    else if (btoPrev.refs <= 0) {
                        this.printf(MESSAGE.DEBUG + MESSAGE.WARNING, "writeBackTrack(%%%x,%x): previous index (%x) refers to object with bad ref count (%d)\n", addr, bti, btiPrev, btoPrev.refs);
                        /**
                         * We used to just slam a null into the previous slot and consider it gone, but there may still
                         * be "weak references" to that slot (ie, it may still be associated with a register bti).
                         *
                         * The easiest way to handle weak references is to leave the slot allocated, with the object's ref
                         * count sitting at zero, and change addBackTrackObject() to look for both empty slots AND non-empty
                         * slots with a ref count of zero; in the latter case, it should again check for weak references,
                         * after which we can re-use the slot if all its weak references are now gone.
                         */
                        if (!this.isBackTrackWeak(btiPrev)) this.abtObjects[slotPrev-1] = null;
                        /**
                         * TODO: Consider what the appropriate trigger should be for resetting ibtLastDelete to zero;
                         * if we don't OCCASIONALLY set it to zero, we may never clear out obsolete weak references,
                         * whereas if we ALWAYS set it to zero, we may be forcing addBackTrackObject() to scan the entire
                         * table too often.
                         *
                         * I'd prefer to do something like this:
                         *
                         *      if (this.ibtLastDelete > slotPrev-1) this.ibtLastDelete = slotPrev-1;
                         *
                         * or even this:
                         *
                         *      if (this.ibtLastDelete > slotPrev-1) this.ibtLastDelete = 0;
                         *
                         * But neither one of those guarantees that we will at least occasionally scan the entire table.
                         */
                        this.ibtLastDelete = 0;
                        this.cbtDeletions++;
                    }
                }
                if (bti && slot) {
                    let bto = this.abtObjects[slot-1];
                    if (bto) {

                        bto.refs++;
                    }
                }
            }
        }
    }

    /**
     * isBackTrackWeak(bti)
     *
     * @param {number} bti
     * @returns {boolean} true if the given bti is still referenced by a register, false if not
     */
    isBackTrackWeak(bti)
    {
        let bt = this.cpu.backTrack;
        let slot = bti >> Busx86.BTINFO.SLOT_SHIFT;
        return (bt.btiAL   >> Busx86.BTINFO.SLOT_SHIFT == slot ||
                bt.btiAH   >> Busx86.BTINFO.SLOT_SHIFT == slot ||
                bt.btiBL   >> Busx86.BTINFO.SLOT_SHIFT == slot ||
                bt.btiBH   >> Busx86.BTINFO.SLOT_SHIFT == slot ||
                bt.btiCL   >> Busx86.BTINFO.SLOT_SHIFT == slot ||
                bt.btiCH   >> Busx86.BTINFO.SLOT_SHIFT == slot ||
                bt.btiDL   >> Busx86.BTINFO.SLOT_SHIFT == slot ||
                bt.btiDH   >> Busx86.BTINFO.SLOT_SHIFT == slot ||
                bt.btiBPLo >> Busx86.BTINFO.SLOT_SHIFT == slot ||
                bt.btiBPHi >> Busx86.BTINFO.SLOT_SHIFT == slot ||
                bt.btiSILo >> Busx86.BTINFO.SLOT_SHIFT == slot ||
                bt.btiSIHi >> Busx86.BTINFO.SLOT_SHIFT == slot ||
                bt.btiDILo >> Busx86.BTINFO.SLOT_SHIFT == slot ||
                bt.btiDIHi >> Busx86.BTINFO.SLOT_SHIFT == slot
        );
    }

    /**
     * updateBackTrackCode(addr, bti)
     *
     * @this {Busx86}
     * @param {number} addr is a physical address
     * @param {number} bti
     */
    updateBackTrackCode(addr, bti)
    {
        if (BACKTRACK) {
            if (bti & Busx86.BTINFO.TYPE_DATA) {
                bti = (bti & ~Busx86.BTINFO.TYPE_MASK) | Busx86.BTINFO.TYPE_COUNT_INC;
            } else if ((bti & Busx86.BTINFO.TYPE_MASK) < Busx86.BTINFO.TYPE_COUNT_MAX) {
                bti += Busx86.BTINFO.TYPE_COUNT_INC;
            } else {
                return;
            }
            this.aMemBlocks[(addr & this.nBusMask) >>> this.nBlockShift].writeBackTrack(addr & this.nBlockLimit, bti);
        }
    }

    /**
     * getBackTrackObject(bti)
     *
     * @this {Busx86}
     * @param {number} bti
     * @returns {Object|null}
     */
    getBackTrackObject(bti)
    {
        if (BACKTRACK) {
            let slot = bti >>> Busx86.BTINFO.SLOT_SHIFT;
            if (slot) return this.abtObjects[slot-1];
        }
        return null;
    }

    /**
     * getBackTrackInfo(bti, fSymbol, fNearest)
     *
     * @this {Busx86}
     * @param {number} bti
     * @param {boolean} [fSymbol] (true to return only symbol)
     * @param {boolean} [fNearest] (true to return nearest symbol)
     * @returns {string|null}
     */
    getBackTrackInfo(bti, fSymbol, fNearest)
    {
        if (BACKTRACK) {
            let bto = this.getBackTrackObject(bti);
            if (bto) {
                let off = bti & Busx86.BTINFO.OFF_MASK;
                let file = bto.obj.file;
                if (file) {

                    return file.getSymbol(bto.obj.offFile + off, fNearest);
                }
                if (!fSymbol || fNearest) {
                    if (bto.obj.idComponent) {
                        return bto.obj.idComponent + '+' + StrLib.toHex(bto.off + off, 0, true);
                    }
                }
            }
        }
        return null;
    }

    /**
     * getSymbol(addr, fNearest)
     *
     * @this {Busx86}
     * @param {number} addr
     * @param {boolean} [fNearest] (true to return nearest symbol)
     * @returns {string|null}
     */
    getSymbol(addr, fNearest)
    {
        return BACKTRACK? this.getBackTrackInfo(this.readBackTrack(addr), true, fNearest) : null;
    }

    /**
     * saveMemory(fAll)
     *
     * All blocks will be stored in a single array, as pairs of block numbers and data arrays, like so:
     *
     *      [iBlock0, [dw0, dw1, ...], iBlock1, [dw0, dw1, ...], ...]
     *
     * In a normal 4Kb block, there will be 1K DWORD values in the data array.  Remember that each DWORD is a signed 32-bit
     * integer (because they are formed using bitwise operator rather than floating-point math operators), so don't be
     * surprised to see negative numbers in the data.
     *
     * The above example assumes "uncompressed" data arrays.  If we choose to use "compressed" data arrays, the data arrays
     * will look like:
     *
     *      [count0, dw0, count1, dw1, ...]
     *
     * where each count indicates how many times the following DWORD value occurs.  A data array length less than 1K indicates
     * that it's compressed, since we'll only store them in compressed form if they actually shrank, and we'll use State
     * helper methods compress() and decompress() to create and expand the compressed data arrays.
     *
     * @this {Busx86}
     * @param {boolean} [fAll] (true to save all non-ROM memory blocks, regardless of their modified() state)
     * @returns {Array} a
     */
    saveMemory(fAll = true)
    {
        /**
         * A quick-and-dirty work-around for 32-bit bus machines, to ensure that all blocks in the 2nd Mb are
         * mapped in before we save.  We do this by forcing A20 on, and then turning it off again before we leave.
         */
        let fA20 = this.getA20();
        if (!fA20) this.setA20(true);

        let i = 0, a = [];
        for (let iBlock = 0; iBlock < this.nBlockTotal; iBlock++) {
            let block = this.aMemBlocks[iBlock];
            if (block.size) {
                if (fAll && block.type != Memoryx86.TYPE.ROM || block.modified()) {
                    let adw = block.save();
                    if (adw) {
                        a[i++] = iBlock;
                        a[i++] = State.compress(adw);
                    }
                }
            }
        }
        if (!fA20) this.setA20(false);
        a[i] = fA20;
        return a;
    }

    /**
     * restoreMemory(a)
     *
     * This restores the contents of all Memory blocks; called by CPUx86.restore().
     *
     * In theory, we ONLY have to save/restore block contents.  Other block attributes,
     * like the type, the memory controller (if any), and the active memory access functions,
     * should already be restored, since every component (re)allocates all the memory blocks
     * it was using when it's restored.  And since the CPU is guaranteed to be the last
     * component to be restored, all those blocks (and their attributes) should be in place now.
     *
     * See saveMemory() for more information on how the memory block contents are saved.
     *
     * @this {Busx86}
     * @param {Array} a
     * @returns {boolean} true if successful, false if not
     */
    restoreMemory(a)
    {
        let i, scale = 1;
        for (i = 0; i < a.length - 1; i += 2) {
            let iBlock = a[i] * scale, adw = a[i+1];
            /**
             * One wrinkle here is dealing with blocks that were saved when the machine was using an
             * older (larger) block size (eg, 16K or 32K), because now I ALWAYS use a block size of 4K.
             *
             * Detecting that situation is a little tricky, because our memory states don't include the
             * block size that was in effect, and the blocks themselves could be compressed; in a worst
             * case scenario, the very first block of a machine using 16K blocks might have been compressed
             * to exactly 4K, and we'd have no idea if that block should be decompressed or used as-is.
             *
             * So, if the length of the block is less than our default length, we know we must decompress,
             * but furthermore, if the length is not a power-of-two, that's another clue.  Checking for
             * a power-of-two is a simple matter of AND'ing the value with one less than the value; if
             * the result is non-zero, it's not a power-of-two.
             */
            if (adw) {
                if (adw.length < this.nBlockLen * scale || (adw.length & (adw.length - 1))) {
                    adw = State.decompress(adw);
                }
                let nBlocks = (adw.length / this.nBlockLen)|0;
                if (nBlocks && scale == 1) scale = nBlocks;
                while (nBlocks > 0) {
                    let adwBlock = nBlocks > 1? adw.splice(0, this.nBlockLen) : adw;
                    let block = this.aMemBlocks[iBlock];
                    if (!block || !block.restore(adwBlock)) {
                        /**
                         * Either the block to restore hasn't been allocated, indicating a change in the machine
                         * configuration since it was last saved (the most likely explanation) or there's some internal
                         * inconsistency (eg, the block size is wrong).
                         */
                        Component.error("Unable to restore memory block " + iBlock);
                        return false;
                    }
                    nBlocks--;
                    iBlock++;
                }
            }
        }
        if (a[i] !== undefined) this.setA20(a[i]);
        return true;
    }

    /**
     * addPortInputBreak(port)
     *
     * @this {Busx86}
     * @param {number|null} [port]
     * @returns {boolean} true if break on port input enabled, false if disabled
     */
    addPortInputBreak(port)
    {
        if (port == null) {
            this.fPortInputBreakAll = !this.fPortInputBreakAll;
            return this.fPortInputBreakAll;
        }
        if (this.aPortInputNotify[port] === undefined) {
            this.aPortInputNotify[port] = [null, false];
        }
        this.aPortInputNotify[port][1] = !this.aPortInputNotify[port][1];
        return this.aPortInputNotify[port][1];
    }

    /**
     * addPortInputNotify(start, end, fn)
     *
     * Add a port input-notification handler to the list of such handlers.
     *
     * @this {Busx86}
     * @param {number} start port address
     * @param {number} end port address
     * @param {function(number,number)} fn is called with the port and LIP values at the time of the input
     */
    addPortInputNotify(start, end, fn)
    {
        if (fn !== undefined) {
            for (let port = start; port <= end; port++) {
                if (this.aPortInputNotify[port] !== undefined) {
                    Component.warning("input port " + StrLib.toHexWord(port) + " already registered");
                    continue;
                }
                this.aPortInputNotify[port] = [fn, false];
                if (MAXDEBUG) this.printf(MESSAGE.LOG, "addPortInputNotify(%#06x)\n", port);
            }
        }
    }

    /**
     * addPortInputTable(component, table, offset)
     *
     * Add port input-notification handlers from the specified table (a batch version of addPortInputNotify)
     *
     * @this {Busx86}
     * @param {Component} component
     * @param {Object} table
     * @param {number} [offset] is an optional port offset
     */
    addPortInputTable(component, table, offset)
    {
        if (offset === undefined) offset = 0;
        for (let port in table) {
            this.addPortInputNotify(+port + offset, +port + offset, table[port].bind(component));
        }
    }

    /**
     * addPortInputWidth(port, size)
     *
     * By default, all input ports are 1 byte wide; ports that are wider must call this function.
     *
     * @this {Busx86}
     * @param {number} port
     * @param {number} size (1, 2 or 4)
     */
    addPortInputWidth(port, size)
    {
        this.aPortInputWidth[port] = size;
    }

    /**
     * checkPortInputNotify(port, size, addrLIP)
     *
     * @this {Busx86}
     * @param {number} port
     * @param {number} size (1, 2 or 4)
     * @param {number} [addrLIP] is the LIP value at the time of the input
     * @returns {number} simulated port data
     *
     * NOTE: It seems that parts of the ROM BIOS (like the RS-232 probes around F000:E5D7 in the 5150 BIOS)
     * assume that ports for non-existent hardware return 0xff rather than 0x00, hence my new default (0xff) below.
     */
    checkPortInputNotify(port, size, addrLIP)
    {
        let data = 0, shift = 0;

        while (size > 0) {

            let aNotify = this.aPortInputNotify[port];
            let sizePort = this.aPortInputWidth[port] || 1;
            let maskPort = (sizePort == 1? 0xff : (sizePort == 2? 0xffff : -1));
            let dataPort = maskPort;

            /**
             * TODO: We need to decide what to do about 8-bit I/O to a 16-bit port (ditto for 16-bit I/O
             * to a 32-bit port).  We probably should pass the size through to the aNotify[0] handler,
             * and let it decide what to do, but I don't feel like changing all the I/O handlers right now.
             * The good news, at least, is that the 8-bit handlers would not have to do anything special.
             * This assert will warn us if this is a pressing need.
             */


            if (BACKTRACK) {
                this.cpu.backTrack.btiIO = 0;
            }

            if (aNotify !== undefined) {
                if (aNotify[0]) {
                    dataPort = aNotify[0](port, addrLIP);
                    if (dataPort == null) {
                        dataPort = maskPort;
                    } else {
                        dataPort &= maskPort;
                    }
                }
                if (DEBUGGER && this.dbg && this.fPortInputBreakAll != aNotify[1]) {
                    this.dbg.checkPortInput(port, size, dataPort);
                }
            }
            else {
                if (DEBUGGER && this.dbg) {
                    this.dbg.messageIO(this, port, undefined, addrLIP);
                    if (this.fPortInputBreakAll) this.dbg.checkPortInput(port, size, dataPort);
                }
            }

            data |= dataPort << shift;
            shift += (sizePort << 3);
            port += sizePort;
            size -= sizePort;
        }


        return data;
    }

    /**
     * addPortOutputBreak(port)
     *
     * @this {Busx86}
     * @param {number|null} [port]
     * @returns {boolean} true if break on port output enabled, false if disabled
     */
    addPortOutputBreak(port)
    {
        if (port == null) {
            this.fPortOutputBreakAll = !this.fPortOutputBreakAll;
            return this.fPortOutputBreakAll;
        }
        if (this.aPortOutputNotify[port] === undefined) {
            this.aPortOutputNotify[port] = [null, false];
        }
        this.aPortOutputNotify[port][1] = !this.aPortOutputNotify[port][1];
        return this.aPortOutputNotify[port][1];
    }

    /**
     * addPortOutputNotify(start, end, fn)
     *
     * Add a port output-notification handler to the list of such handlers.
     *
     * @this {Busx86}
     * @param {number} start port address
     * @param {number} end port address
     * @param {function(number,number)} fn is called with the port and LIP values at the time of the output
     */
    addPortOutputNotify(start, end, fn)
    {
        if (fn !== undefined) {
            for (let port = start; port <= end; port++) {
                if (this.aPortOutputNotify[port] !== undefined) {
                    Component.warning("output port " + StrLib.toHexWord(port) + " already registered");
                    continue;
                }
                this.aPortOutputNotify[port] = [fn, false];
                if (MAXDEBUG) this.printf(MESSAGE.LOG, "addPortOutputNotify(%#06x)\n", port);
            }
        }
    }

    /**
     * addPortOutputTable(component, table, offset)
     *
     * Add port output-notification handlers from the specified table (a batch version of addPortOutputNotify)
     *
     * @this {Busx86}
     * @param {Component} component
     * @param {Object} table
     * @param {number} [offset] is an optional port offset
     */
    addPortOutputTable(component, table, offset)
    {
        if (offset === undefined) offset = 0;
        for (let port in table) {
            this.addPortOutputNotify(+port + offset, +port + offset, table[port].bind(component));
        }
    }

    /**
     * addPortOutputWidth(port, size)
     *
     * By default, all output ports are 1 byte wide; ports that are wider must call this function.
     *
     * @this {Busx86}
     * @param {number} port
     * @param {number} size (1, 2 or 4)
     */
    addPortOutputWidth(port, size)
    {
        this.aPortOutputWidth[port] = size;
    }

    /**
     * checkPortOutputNotify(port, size, data, addrLIP)
     *
     * @this {Busx86}
     * @param {number} port
     * @param {number} size
     * @param {number} data
     * @param {number} [addrLIP] is the LIP value at the time of the output
     */
    checkPortOutputNotify(port, size, data, addrLIP)
    {
        let shift = 0;

        while (size > 0) {

            let aNotify = this.aPortOutputNotify[port];
            let sizePort = this.aPortOutputWidth[port] || 1;
            let maskPort = (sizePort == 1? 0xff : (sizePort == 2? 0xffff : -1));
            let dataPort = (data >>>= shift) & maskPort;

            /**
             * TODO: We need to decide what to do about 8-bit I/O to a 16-bit port (ditto for 16-bit I/O
             * to a 32-bit port).  We probably should pass the size through to the aNotify[0] handler,
             * and let it decide what to do, but I don't feel like changing all the I/O handlers right now.
             * The good news, at least, is that the 8-bit handlers would not have to do anything special.
             * This assert will warn us if this is a pressing need.
             */


            if (aNotify !== undefined) {
                if (aNotify[0]) {
                    aNotify[0](port, dataPort, addrLIP);
                }
                if (DEBUGGER && this.dbg && this.fPortOutputBreakAll != aNotify[1]) {
                    this.dbg.checkPortOutput(port, size, dataPort);
                }
            }
            else {
                if (DEBUGGER && this.dbg) {
                    this.dbg.messageIO(this, port, dataPort, addrLIP);
                    if (this.fPortOutputBreakAll) this.dbg.checkPortOutput(port, size, dataPort);
                }
            }

            shift += (sizePort << 3);
            port += sizePort;
            size -= sizePort;
        }

    }

    /**
     * reportError(op, addr, size, fQuiet)
     *
     * @this {Busx86}
     * @param {number} op
     * @param {number} addr
     * @param {number} size
     * @param {boolean} [fQuiet] (true if any error should be quietly logged)
     * @returns {boolean} false
     */
    reportError(op, addr, size, fQuiet)
    {
        this.printf(fQuiet? MESSAGE.DEBUG : MESSAGE.NONE, "Memory block error (%d: %x,%x)\n", op, addr, size);
        return false;
    }

    /**
     * getLongDirect(addr)
     *
     * This is useful for the Debugger and other components that want to bypass getLong() breakpoint detection.
     *
     * @this {Busx86}
     * @param {number} addr is a physical address
     * @returns {number} long (32-bit) value at that address
     *
     getLongDirect(addr)
     {
         let off = addr & this.nBlockLimit;
         let iBlock = (addr & this.nBusMask) >>> this.nBlockShift;
         if (off < this.nBlockLimit - 2) {
             return this.aMemBlocks[iBlock].readLongDirect(off, addr);
         }
         //
         // I think the previous version of this function tried to be too clever (ie, reading the last
         // long in the current block and the first long in the next block and masking/combining the results),
         // which may have also created some undesirable side-effects for custom memory controllers.
         // This simpler (and probably more reliable) approach is to simply read the long as individual bytes.
         //
         let l = 0;
         let cb = 4, nShift = 0;
         let cbBlock = 4 - (off & 0x3);    // (off & 0x3) will be 1, 2 or 3, so cbBlock will be 3, 2, or 1
         while (cb--) {
             l |= (this.aMemBlocks[iBlock].readByteDirect(off++, addr++) << nShift);
             if (!--cbBlock) {
                 iBlock = (iBlock + 1) & this.nBlockMask;
                 off = 0;
             }
             nShift += 8;
         }
         return l;
     }
     */

    /**
     * setLongDirect(addr, l)
     *
     * This is useful for the Debugger and other components that want to bypass breakpoint detection AND read-only
     * memory protection (for example, this is an interface the ROM component could use to initialize ROM contents).
     *
     * @this {Busx86}
     * @param {number} addr is a physical address
     * @param {number} l is the long (32-bit) value to write
     *
     setLongDirect(addr, l)
     {
         let off = addr & this.nBlockLimit;
         let iBlock = (addr & this.nBusMask) >>> this.nBlockShift;
         if (off < this.nBlockLimit - 2) {
             this.aMemBlocks[iBlock].writeLongDirect(off, l, addr);
             return;
         }
         //
         // I think the previous version of this function tried to be too clever (ie, reading and rewriting
         // the last long in the current block, and then reading and rewriting the first long in the next
         // block), which may have also created some undesirable side-effects for custom memory controllers.
         // This simpler (and probably more reliable) approach is to simply write the long as individual bytes.
         //
         let cb = 4;
         let cbBlock = 4 - (off & 0x3);    // (off & 0x3) will be 1, 2 or 3, so cbBlock will be 3, 2, or 1
         while (cb--) {
             this.aMemBlocks[iBlock].writeByteDirect(off++, l & 0xff, addr++);
             if (!--cbBlock) {
                 iBlock = (iBlock + 1) & this.nBlockMask;
                 off = 0;
             }
             l >>>= 8;
         }
     }
     */

    /**
     * getBackTrackObjectFromAddr(addr)
     *
     * @this {Busx86}
     * @param {number} addr
     * @returns {Object|null}
     *
     getBackTrackObjectFromAddr(addr)
     {
         return BACKTRACK? this.getBackTrackObject(this.readBackTrack(addr)) : null;
     }
     */

    /**
     * getBackTrackInfoFromAddr(addr)
     *
     * @this {Busx86}
     * @param {number} addr
     * @returns {string|null}
     *
     getBackTrackInfoFromAddr(addr)
     {
         return BACKTRACK? this.getBackTrackInfo(this.readBackTrack(addr)) : null;
     }
     */

    /**
     * removePortInputNotify(start, end)
     *
     * Remove port input-notification handler(s) (to be ENABLED later if needed)
     *
     * @this {Busx86}
     * @param {number} start address
     * @param {number} end address
     *
     removePortInputNotify(start, end)
     {
         for (let port = start; port < end; port++) {
             if (this.aPortInputNotify[port]) {
                 delete this.aPortInputNotify[port];
             }
         }
     }
     */

    /**
     * removePortOutputNotify(start, end)
     *
     * Remove port output-notification handler(s) (to be ENABLED later if needed)
     *
     * @this {Busx86}
     * @param {number} start address
     * @param {number} end address
     *
     removePortOutputNotify(start, end)
     {
         for (let port = start; port < end; port++) {
             if (this.aPortOutputNotify[port]) {
                 delete this.aPortOutputNotify[port];
             }
         }
     }
     */
}

/**
 * @copyright https://www.pcjs.org/machines/pcx86/modules/v2/memory.js (C) 2012-2024 Jeff Parsons
 */

/**
 * @class DataView
 * @property {function(number,boolean):number} getUint8
 * @property {function(number,number,boolean)} setUint8
 * @property {function(number,boolean):number} getUint16
 * @property {function(number,number,boolean)} setUint16
 * @property {function(number,boolean):number} getInt32
 * @property {function(number,number,boolean)} setInt32
 */

var littleEndian = (TYPEDARRAYS? (function() {
    let buffer = new ArrayBuffer(2);
    new DataView(buffer).setUint16(0, 256, true);
    return new Uint16Array(buffer)[0] === 256;
})() : false);

/**
 * @class Memoryx86
 * @unrestricted (allows the class to define properties, both dot and named, outside of the constructor)
 */
class Memoryx86 {
    /**
     * Last used block ID (used for debugging only)
     */
    static idBlock = 0;

    /**
     * Basic memory types
     *
     * RAM is the most conventional memory type, providing full read/write capability to x86-compatible (ie,
     * 'little endian") storage.  ROM is equally conventional, except that the fReadOnly property is set,
     * disabling writes.  VIDEO is treated exactly like RAM, unless a controller is provided.  Both RAM and
     * VIDEO memory are always considered writable, and even ROM can be written using the Bus setByteDirect()
     * interface (which in turn uses the Memory writeByteDirect() interface), allowing the ROM component to
     * initialize its own memory.  The CTRL type is used to identify memory-mapped devices that do not need
     * any default storage and always provide their own controller.
     *
     * UNPAGED and PAGED blocks are created by the CPU when paging is enabled; the role of an UNPAGED block
     * is simply to perform page translation and replace itself with a PAGED block, which redirects read/write
     * requests to the physical page located during translation.  UNPAGED and PAGED blocks are considered
     * "logical" blocks that don't contain any storage of their own; all other block types represent "physical"
     * memory (or a memory-mapped device).
     *
     * Unallocated regions of the address space contain a special memory block of type NONE that contains
     * no storage.  Mapping every addressable location to a memory block allows all accesses to be routed in
     * exactly the same manner, without resorting to any range or processor checks.
     *
     * Originally, the Debugger always went through the Bus interfaces, and could therefore modify ROMs as well,
     * but with the introduction of protected mode memory segmentation (and later paging), where logical and
     * physical addresses were no longer the same, that is no longer true.  For coherency, all Debugger memory
     * accesses now go through Segx86 and CPUx86 memory interfaces, so that the user sees the same segment
     * and page translation that the CPU sees.  However, the Debugger uses a special probeAddr() interface to
     * read memory, along with a special "fSuppress" flag to mapPageBlock(), to prevent its memory accesses
     * from triggering segment and/or page faults when invalid or not-present segments or pages are accessed.
     *
     * These types are not mutually exclusive.  For example, VIDEO memory could be allocated as RAM, with or
     * without a custom controller (the original Monochrome and CGA video cards used read/write storage that
     * was indistinguishable from RAM), and CTRL memory could be allocated as an empty block of any type, with
     * a custom controller.  A few types are required for certain features (eg, ROM is required if you want
     * read-only memory), but the larger purpose of these types is to help document the caller's intent and to
     * provide the Control Panel with the ability to highlight memory regions accordingly.
     */
    static TYPE = {
        NONE:       0,
        RAM:        1,
        ROM:        2,
        VIDEO:      3,
        CTRL:       4,
        UNPAGED:    5,
        PAGED:      6,
        COLORS:     ["black", "blue", "green", "cyan"],
        NAMES:      ["NONE",  "RAM",  "ROM",   "VIDEO", "H/W", "UNPAGED", "PAGED"]
    };

    static FLAGS = {
        CLEAN:      0x0,
        DIRTY:      0x1,
        MODIFIED:   0x2
    };

    /**
     * Memory(addr, used, size, type, controller)
     *
     * The Bus component allocates Memory objects so that each has a memory buffer with a
     * block-granular starting address and an address range equal to bus.nBlockSize; however,
     * the size of any given Memory object's underlying buffer can be either zero or bus.nBlockSize;
     * memory read/write functions for empty (buffer-less) blocks are mapped to readNone/writeNone.
     *
     * The Bus allocates empty blocks for the entire address space during initialization, so that
     * any reads/writes to undefined addresses will have no effect.  Later, the ROM and RAM
     * components will ask the Bus to allocate memory for specific ranges, and the Bus will allocate
     * as many new blockSize Memory objects as the ranges require.  Partial Memory blocks could
     * also be supported in theory, but in practice, they're not.
     *
     * Because Memory blocks now allow us to have a "sparse" address space, we could choose to
     * take the memory hit of allocating 4K arrays per block, where each element stores only one byte,
     * instead of the more frugal but slightly slower approach of allocating arrays of 32-bit dwords
     * (LONGARRAYS) and shifting/masking bytes/words to/from dwords; in theory, byte accesses would
     * be faster and word accesses somewhat less faster.
     *
     * However, preliminary testing of that feature (BYTEARRAYS) did not yield significantly faster
     * performance, so it is OFF by default to minimize our memory consumption.  Using TYPEDARRAYS
     * would seem best, but as discussed in defines.js, it's off by default, because it doesn't perform
     * as well as LONGARRAYS; the other advantage of TYPEDARRAYS is that it should theoretically use
     * about 1/2 the memory of LONGARRAYS (32-bit elements vs 64-bit numbers), but I value speed over
     * size at this point.  Also, not all JavaScript implementations support TYPEDARRAYS (IE9 is probably
     * the only real outlier: it lacks typed arrays but otherwise has all the necessary HTML5 support).
     *
     * WARNING: Since Memory blocks are low-level objects that have no UI requirements, they
     * do not inherit from the Component class, so if you want to use any Component class methods,
     * such as Component.assert(), use the corresponding Debugger methods instead (assuming a debugger
     * is available).
     *
     * @this {Memoryx86}
     * @param {number} [addr] of lowest used address in block
     * @param {number} [used] portion of block in bytes (0 for none); must be a multiple of 4
     * @param {number} [size] of block's buffer in bytes (0 for none); must be a multiple of 4
     * @param {number} [type] is one of the Memoryx86.TYPE constants (default is Memoryx86.TYPE.NONE)
     * @param {Controller} [controller] is an optional memory controller component
     * @param {CPUx86} [cpu] is required for UNPAGED memory blocks, so that the CPU can map it to a PAGED block
     */
    constructor(addr, used, size, type, controller, cpu)
    {
        let i;
        this.id = (Memoryx86.idBlock += 2);
        this.adw = null;
        this.offset = 0;
        this.addr = addr;
        this.used = used;
        this.size = size || 0;
        this.type = type || Memoryx86.TYPE.NONE;
        this.fReadOnly = (type == Memoryx86.TYPE.ROM);
        this.controller = null;
        this.cpu = cpu;             // if a CPU reference is provided, then this must be an UNPAGED Memory block allocation
        this.copyBreakpoints();     // initialize the block's Debugger info (eg, breakpoint totals); the caller will reinitialize

        /**
         * Dirty block tracking is now controller-specific.  As noted in the paged block handlers (eg, writeBytePLE),
         * the original purposes were to allow saveMemory() to save only dirty blocks and to enable the Video component
         * to quickly detect changes to the video buffer.  But saveMemory() has since been changed to save (and compress)
         * all memory blocks by default, and the Video component now uses a custom memory controller for all video modes,
         * which performs its own dirty block tracking, so general-purpose memory blocks no longer need to pay this
         * penalty.
         */
        this.flags = Memoryx86.FLAGS.CLEAN;

        if (BACKTRACK) {
            if (!size || controller) {
                this.fModBackTrack = false;
                this.readBackTrack = this.readBackTrackNone;
                this.writeBackTrack = this.writeBackTrackNone;
                this.modBackTrack = this.modBackTrackNone;
            } else {
                this.fModBackTrack = true;
                this.readBackTrack = this.readBackTrackIndex;
                this.writeBackTrack = this.writeBackTrackIndex;
                this.modBackTrack = this.modBackTrackIndex;
                this.abtIndexes = new Array(size);
                for (i = 0; i < size; i++) this.abtIndexes[i] = 0;
            }
        }

        /**
         * For empty memory blocks, all we need to do is ensure all access functions
         * are mapped to "none" handlers (or "unpaged" handlers if paging is enabled).
         */
        if (!size) {
            this.setAccess();
            return;
        }

        /**
         * When a controller is specified, the controller must provide a buffer,
         * via getMemoryBuffer(), and memory access functions, via getMemoryAccess().
         */
        if (controller) {
            this.controller = controller;
            let a = controller.getMemoryBuffer(addr|0);
            this.adw = a[0];
            this.offset = a[1];
            this.setAccess(controller.getMemoryAccess());
            return;
        }

        /**
         * This is the normal case: allocate a buffer that provides 8 bits of data per address;
         * no controller is required because our default memory access functions (see afnMemory)
         * know how to deal with this simple 1-1 mapping of addresses to bytes and words.
         *
         * TODO: Consider initializing the memory array to random (or pseudo-random) values in DEBUG
         * mode; pseudo-random might be best, to help make any bugs reproducible.
         */
        if (TYPEDARRAYS) {
            this.buffer = new ArrayBuffer(size);
            this.dv = new DataView(this.buffer, 0, size);
            /**
             * If littleEndian is true, we can use ab[], aw[] and adw[] directly; well, we can use them
             * whenever the offset is a multiple of 1, 2 or 4, respectively.  Otherwise, we must fallback to
             * dv.getUint8()/dv.setUint8(), dv.getUint16()/dv.setUint16() and dv.getInt32()/dv.setInt32().
             */
            this.ab = new Uint8Array(this.buffer, 0, size);
            this.aw = new Uint16Array(this.buffer, 0, size >> 1);
            this.adw = new Int32Array(this.buffer, 0, size >> 2);
            this.setAccess(littleEndian? Memoryx86.afnArrayLE : Memoryx86.afnArrayBE);
        } else {
            if (BYTEARRAYS) {
                this.ab = new Array(size);
            } else {
                /**
                 * NOTE: This is the default mode of operation (!TYPEDARRAYS && !BYTEARRAYS), because it
                 * seems to provide the best performance; and although in theory, that performance might
                 * come at twice the overhead of TYPEDARRAYS, it's increasingly likely that the JavaScript
                 * runtime will notice that all we ever store are 32-bit values, and optimize accordingly.
                 */
                this.adw = new Array(size >> 2);
                for (i = 0; i < this.adw.length; i++) this.adw[i] = 0;
            }
            this.setAccess(Memoryx86.afnMemory);
        }
    }

    /**
     * init(addr)
     *
     * Quick reinitializer when reusing a Memory block.
     *
     * @this {Memoryx86}
     * @param {number} addr
     */
    init(addr)
    {
        this.addr = addr;
    }

    /**
     * clean(fScrub)
     *
     * @this {Memoryx86}
     * @param {boolean} [fScrub]
     * @returns {boolean} (true if block is not dirty, false otherwise)
     */
    clean(fScrub)
    {
        if (this.flags & Memoryx86.FLAGS.DIRTY) {
            if (fScrub) {
                this.flags = (this.flags & ~Memoryx86.FLAGS.DIRTY) | Memoryx86.FLAGS.MODIFIED;
            }
            return false;
        }
        return true;
    }

    /**
     * modified()
     *
     * @this {Memoryx86}
     * @returns {boolean} (true if block is dirty and/or modified, false otherwise)
     */
    modified()
    {
        return (this.flags & (Memoryx86.FLAGS.DIRTY | Memoryx86.FLAGS.MODIFIED)) != 0;
    }

    /**
     * clone(mem, type)
     *
     * Converts the current Memory block (this) into a clone of the given Memory block (mem),
     * and optionally overrides the current block's type with the specified type.
     *
     * @this {Memoryx86}
     * @param {Memoryx86} mem
     * @param {number} [type]
     * @param {Debuggerx86} [dbg]
     */
    clone(mem, type, dbg)
    {
        /**
         * Original memory block IDs are even; cloned memory block IDs are odd;
         * the original ID of the current block is lost, but that's OK, since it was presumably
         * produced merely to become a clone.
         */
        this.id = mem.id | 0x1;
        this.used = mem.used;
        this.size = mem.size;
        if (type) {
            this.type = type;
            this.fReadOnly = (type == Memoryx86.TYPE.ROM);
        }
        if (TYPEDARRAYS) {
            this.buffer = mem.buffer;
            this.dv = mem.dv;
            this.ab = mem.ab;
            this.aw = mem.aw;
            this.adw = mem.adw;
            this.setAccess(littleEndian? Memoryx86.afnArrayLE : Memoryx86.afnArrayBE);
        } else {
            if (BYTEARRAYS) {
                this.ab = mem.ab;
            } else {
                this.adw = mem.adw;
            }
            this.setAccess(Memoryx86.afnMemory);
        }
        this.copyBreakpoints(dbg, mem);
    }

    /**
     * save()
     *
     * This gets the contents of a Memory block as an array of 32-bit values; used by Bus.saveMemory(),
     * which in turn is called by CPUx86.save().
     *
     * Memory blocks with custom memory controllers do NOT save their contents; that's the responsibility
     * of the controller component.
     *
     * @this {Memoryx86}
     * @returns {Array|Int32Array|null}
     */
    save()
    {
        let adw, i;
        if (this.controller) {
            adw = null;
        }
        else if (BYTEARRAYS) {
            adw = new Array(this.size >> 2);
            let off = 0;
            for (i = 0; i < adw.length; i++) {
                adw[i] = this.ab[off] | (this.ab[off + 1] << 8) | (this.ab[off + 2] << 16) | (this.ab[off + 3] << 24);
                off += 4;
            }
        }
        else if (TYPEDARRAYS) {
            /**
             * It might be tempting to just return a copy of Int32Array(this.buffer, 0, this.size >> 2),
             * but we can't be sure of the "endianness" of an Int32Array -- which would be OK if the array
             * was always saved/restored on the same machine, but there's no guarantee of that, either.
             * So we use getInt32() and require little-endian values.
             *
             * Moreover, an Int32Array isn't treated by JSON.stringify() and JSON.parse() exactly like
             * a normal array; it's serialized as an Object rather than an Array, so it lacks a "length"
             * property and causes problems for State.store() and State.parse().
             */
            adw = new Array(this.size >> 2);
            for (i = 0; i < adw.length; i++) {
                adw[i] = this.dv.getInt32(i << 2, true);
            }
        }
        else {
            adw = this.adw;
        }
        return adw;
    }

    /**
     * restore(adw)
     *
     * This restores the contents of a Memory block from an array of 32-bit values; used by
     * Bus.restoreMemory(), which is called by CPUx86.restore(), after all other components have been
     * restored and thus all Memory blocks have been allocated by their respective components.
     *
     * @this {Memoryx86}
     * @param {Array} adw
     * @returns {boolean} true if successful, false if block size mismatch
     */
    restore(adw)
    {
        /**
         * If this block has its own controller, then that controller is responsible for performing the
         * restore, since we don't know the underlying memory format.  However, we no longer blow off these
         * restore calls, because old machine states may still try to restore video memory blocks for MDA
         * and CGA video buffers (and in those cases, the memory formats should be compatible).
         */
        let i;
        let off;
        if (this.controller) {
            if (this.adw) {
                /**
                 * If the controller memory buffer appears to be for either an MDA using 2048 16-bit values
                 * or a CGA using 8192 16-bit values, then split up the saved 32-bit values accordingly.
                 * Otherwise, do a 1-for-1 restore and hope for the best.
                 */
                if (this.adw.length == 2048 || this.adw.length == 8192) {
                    off = (this.offset >> 1);
                    for (i = 0; i < adw.length; i++) {
                        if (off >= this.adw.length) break;
                        this.adw[off++] = adw[i] & 0xffff;
                        this.adw[off++] = (adw[i] >> 16) & 0xffff;
                    }
                }
                else {
                    off = (this.offset >> 2);
                    for (i = 0; i < adw.length; i++) {
                        if (off >= this.adw.length) break;
                        this.adw[off++] = adw[i];
                    }
                }
                this.flags |= Memoryx86.FLAGS.DIRTY;
            }
            return true;
        }
        if (this.size == adw.length << 2) {
            if (BYTEARRAYS) {
                off = 0;
                for (i = 0; i < adw.length; i++) {
                    this.ab[off] = adw[i] & 0xff;
                    this.ab[off + 1] = (adw[i] >> 8) & 0xff;
                    this.ab[off + 2] = (adw[i] >> 16) & 0xff;
                    this.ab[off + 3] = (adw[i] >> 24) & 0xff;
                    off += 4;
                }
            } else if (TYPEDARRAYS) {
                for (i = 0; i < adw.length; i++) {
                    this.dv.setInt32(i << 2, adw[i], true);
                }
            } else {
                this.adw = adw;
            }
            this.flags |= Memoryx86.FLAGS.DIRTY;
            return true;
        }
        return false;
    }

    /**
     * setAccess(afn, fDirect)
     *
     * The afn parameter should be a 6-entry function table containing two byte handlers, two
     * short handlers, and two long handlers.  See the static afnMemory table for an example.
     *
     * If no function table is specified, a default is selected based on the Memory type;
     * similarly, any undefined entries in the table are filled with default handlers that fall
     * back to the byte handlers, and if one or both byte handlers are undefined, they default
     * to handlers that simply ignore the access.
     *
     * fDirect indicates that both the default AND the direct handlers should be updated.  Direct
     * handlers normally match the default handlers, except when "checked" handlers are installed;
     * this allows "checked" handlers to know where to dispatch the call after performing checks.
     * Examples of checks are read/write breakpoints, but it's really up to the Debugger to decide
     * what the check consists of.
     *
     * @this {Memoryx86}
     * @param {Array.<function()>} [afn] function table
     * @param {boolean} [fDirect] (true to update direct access functions as well; default is true)
     */
    setAccess(afn, fDirect)
    {
        if (!afn) {
            if (this.type == Memoryx86.TYPE.UNPAGED) {
                afn = Memoryx86.afnUnpaged;
            }
            else if (this.type == Memoryx86.TYPE.PAGED) {
                afn = Memoryx86.afnPaged;
            } else {

                afn = Memoryx86.afnNone;
            }
        }
        this.setReadAccess(afn, fDirect);
        this.setWriteAccess(afn, fDirect);
    }

    /**
     * setReadAccess(afn, fDirect)
     *
     * @this {Memoryx86}
     * @param {Array.<function()>} afn
     * @param {boolean} [fDirect]
     */
    setReadAccess(afn, fDirect)
    {
        if (!fDirect || !this.cReadBreakpoints) {
            this.readByte = afn[0] || this.readNone;
            this.readShort = afn[2] || this.readShortDefault;
            this.readLong = afn[4] || this.readLongDefault;
        }
        if (fDirect || fDirect === undefined) {
            this.readByteDirect = afn[0] || this.readNone;
            this.readShortDirect = afn[2] || this.readShortDefault;
            this.readLongDirect = afn[4] || this.readLongDefault;
        }
    }

    /**
     * setWriteAccess(afn, fDirect)
     *
     * @this {Memoryx86}
     * @param {Array.<function()>} afn
     * @param {boolean} [fDirect]
     */
    setWriteAccess(afn, fDirect)
    {
        if (!fDirect || !this.cWriteBreakpoints) {
            this.writeByte = !this.fReadOnly && afn[1] || this.writeNone;
            this.writeShort = !this.fReadOnly && afn[3] || this.writeShortDefault;
            this.writeLong = !this.fReadOnly && afn[5] || this.writeLongDefault;
        }
        if (fDirect || fDirect === undefined) {
            this.writeByteDirect = afn[1] || this.writeNone;
            this.writeShortDirect = afn[3] || this.writeShortDefault;
            this.writeLongDirect = afn[5] || this.writeLongDefault;
        }
    }

    /**
     * resetReadAccess()
     *
     * @this {Memoryx86}
     */
    resetReadAccess()
    {
        this.readByte = this.readByteDirect;
        this.readShort = this.readShortDirect;
        this.readLong = this.readLongDirect;
    }

    /**
     * resetWriteAccess()
     *
     * @this {Memoryx86}
     */
    resetWriteAccess()
    {
        this.writeByte = this.fReadOnly? this.writeNone : this.writeByteDirect;
        this.writeShort = this.fReadOnly? this.writeShortDefault : this.writeShortDirect;
        this.writeLong = this.fReadOnly? this.writeLongDefault : this.writeLongDirect;
    }

    /**
     * getPageBlock(addr, fWrite)
     *
     * Called for UNPAGED Memory blocks only.
     *
     * @this {Memoryx86}
     * @param {number} addr
     * @param {boolean} fWrite (true if called for a write, false if for a read)
     * @returns {Memoryx86}
     */
    getPageBlock(addr, fWrite)
    {
        /**
         * Even when mapPageBlock() fails (ie, when the page is not present or has insufficient privileges), it
         * will trigger a fault (since we don't set fSuppress), but it will still return a block (ie, an empty block).
         */
        return this.cpu.mapPageBlock(addr, fWrite);
    }

    /**
     * setPhysBlock(blockPhys, blockPDE, offPDE, blockPTE, offPTE)
     *
     * @this {Memoryx86}
     * @param {Memoryx86} blockPhys
     * @param {Memoryx86} blockPDE
     * @param {number} offPDE
     * @param {Memoryx86} blockPTE
     * @param {number} offPTE
     */
    setPhysBlock(blockPhys, blockPDE, offPDE, blockPTE, offPTE)
    {
        this.blockPhys = blockPhys;
        this.blockPDE = blockPDE;
        this.iPDE = offPDE >> 2;    // convert offPDE into iPDE (an adw index)
        this.blockPTE = blockPTE;
        this.iPTE = offPTE >> 2;    // convert offPTE into iPTE (an adw index)
        /**
         * This is an optimization for "normal" pages, installing paged memory handlers that mimic
         * normal memory but also know how to update page tables.  If any of the criteria are not met
         * for these special handlers, we fall back to the slower default "paged" memory handlers.
         */
        if (TYPEDARRAYS && littleEndian && blockPhys.adw && !blockPhys.controller && !blockPhys.cReadBreakpoints && !blockPhys.cWriteBreakpoints) {
            this.ab = blockPhys.ab;
            this.aw = blockPhys.aw;
            this.adw = blockPhys.adw;
            this.setAccess(Memoryx86.afnPagedLE);
        } else {
            this.bitPTEAccessed = blockPhys? Memoryx86.adjustEndian(X86.PTE.ACCESSED) : 0;
            this.bitPTEDirty = blockPhys? Memoryx86.adjustEndian(X86.PTE.ACCESSED | X86.PTE.DIRTY) : 0;
            this.setAccess(Memoryx86.afnPaged);
        }
    }

    /**
     * printAddr(sMessage)
     *
     * @this {Memoryx86}
     * @param {string} sMessage
     */
    printAddr(sMessage)
    {
        if (DEBUG && this.dbg) {
            this.dbg.printf(MESSAGE.MEM, "%s %%%x #%s\n", this.addr, this.id);
        }
    }

    /**
     * addBreakpoint(off, fWrite, cpu)
     *
     * NOTE: Some Memory blocks already require access to the CPU (eg, UNPAGED blocks that need to call cpu.mapPageBlock()),
     * while others require access only if the CPU has set a read or write breakpoint in one of its Debug registers; the latter
     * case is handled here by virtue of the CPU parameter.
     *
     * @this {Memoryx86}
     * @param {number} off
     * @param {boolean} fWrite
     * @param {CPUx86} [cpu] (required for breakpoints set by the CPU, as opposed to the Debugger)
     */
    addBreakpoint(off, fWrite, cpu)
    {
        if (!fWrite) {
            if (this.cReadBreakpoints++ === 0) {
                if (cpu) this.cpu = cpu;
                this.setReadAccess(Memoryx86.afnChecked, false);
            }
            if (DEBUG) this.printAddr("read breakpoint added to memory block");
        }
        else {
            if (this.cWriteBreakpoints++ === 0) {
                if (cpu) this.cpu = cpu;
                this.setWriteAccess(Memoryx86.afnChecked, false);
            }
            if (DEBUG) this.printAddr("write breakpoint added to memory block");
        }
    }

    /**
     * removeBreakpoint(off, fWrite)
     *
     * NOTE: If this Memory block is not an UNPAGED block that might need to call cpu.mapPageBlock()), and it no
     * longer has any read or write breakpoints associated with it, then it no longer needs a CPU reference.  The
     * existence of a CPU reference only impacts the performance of the "checked" memory access functions, so it's
     * not critical to eliminate it.
     *
     * TODO: Another option would be to count CPU references separately from Debugger references, so that when
     * the former goes to zero, we can unconditionally remove the CPU reference; UNPAGED blocks would automatically
     * increment that reference count, so their CPU reference would never go away.
     *
     * @this {Memoryx86}
     * @param {number} off
     * @param {boolean} fWrite
     */
    removeBreakpoint(off, fWrite)
    {
        if (!fWrite) {
            if (--this.cReadBreakpoints === 0) {
                this.resetReadAccess();
                if (DEBUG) this.printAddr("all read breakpoints removed from memory block");
            }

        }
        else {
            if (--this.cWriteBreakpoints === 0) {
                this.resetWriteAccess();
                if (DEBUG) this.printAddr("all write breakpoints removed from memory block");
            }

        }
    }

    /**
     * copyBreakpoints(dbg, mem)
     *
     * @this {Memoryx86}
     * @param {Debuggerx86} [dbg]
     * @param {Memoryx86} [mem] (outgoing Memory block to copy breakpoints from, if any)
     */
    copyBreakpoints(dbg, mem)
    {
        this.dbg = dbg;
        this.cReadBreakpoints = this.cWriteBreakpoints = 0;
        if (mem) {
            if (mem.cpu) this.cpu = mem.cpu;
            if ((this.cReadBreakpoints = mem.cReadBreakpoints)) {
                this.setReadAccess(Memoryx86.afnChecked, false);
            }
            if ((this.cWriteBreakpoints = mem.cWriteBreakpoints)) {
                this.setWriteAccess(Memoryx86.afnChecked, false);
            }
        }
    }

    /**
     * readNone(off)
     *
     * Previously, this always returned 0x00, but the initial memory probe by the COMPAQ DeskPro 386 ROM BIOS
     * writes 0x0000 to the first word of every 64Kb block in the nearly 16Mb address space it supports, and
     * if it reads back 0x0000, it will initially think that LOTS of RAM exists, only to be disappointed later
     * when it performs a more exhaustive memory test, generating unwanted error messages in the process.
     *
     * TODO: Determine if we should have separate readByteNone(), readShortNone() and readLongNone() functions
     * to return 0xff, 0xffff and 0xffffffff|0, respectively.  This seems sufficient for now, as it seems unlikely
     * that a system would require nonexistent memory locations to return ALL bits set.
     *
     * Also, I'm reluctant to address that potential issue by simply returning -1, because to date, the above
     * Memory interfaces have always returned values that are properly masked to 8, 16 or 32 bits, respectively.
     *
     * @this {Memoryx86}
     * @param {number} off
     * @param {number} addr
     * @returns {number}
     */
    readNone(off, addr)
    {
        if (DEBUGGER && this.dbg) {
            this.dbg.printf(MESSAGE.CPU + MESSAGE.MEM, "attempt to read invalid block %%%x\n", addr);
        }
        return 0xff;
    }

    /**
     * writeNone(off, v, addr)
     *
     * @this {Memoryx86}
     * @param {number} off
     * @param {number} v (could be either a byte or word value, since we use the same handler for both kinds of accesses)
     * @param {number} addr
     */
    writeNone(off, v, addr)
    {
        if (DEBUGGER && this.dbg) {
            this.dbg.printf(MESSAGE.CPU + MESSAGE.MEM, "attempt to write %#06x to invalid block %%%x\n", v, addr);
        }
    }

    /**
     * readShortDefault(off, addr)
     *
     * @this {Memoryx86}
     * @param {number} off
     * @param {number} addr
     * @returns {number}
     */
    readShortDefault(off, addr)
    {
        return this.readByte(off++, addr++) | (this.readByte(off, addr) << 8);
    }

    /**
     * readLongDefault(off, addr)
     *
     * @this {Memoryx86}
     * @param {number} off
     * @param {number} addr
     * @returns {number}
     */
    readLongDefault(off, addr)
    {
        return this.readByte(off++, addr++) | (this.readByte(off++, addr++) << 8) | (this.readByte(off++, addr++) << 16) | (this.readByte(off, addr) << 24);
    }

    /**
     * writeShortDefault(off, w, addr)
     *
     * @this {Memoryx86}
     * @param {number} off
     * @param {number} w
     * @param {number} addr
     */
    writeShortDefault(off, w, addr)
    {
        this.writeByte(off++, w & 0xff, addr++);
        this.writeByte(off, w >> 8, addr);
    }

    /**
     * writeLongDefault(off, w, addr)
     *
     * @this {Memoryx86}
     * @param {number} off
     * @param {number} w
     * @param {number} addr
     */
    writeLongDefault(off, w, addr)
    {
        this.writeByte(off++, w & 0xff, addr++);
        this.writeByte(off++, (w >> 8) & 0xff, addr++);
        this.writeByte(off++, (w >> 16) & 0xff, addr++);
        this.writeByte(off, (w >>> 24), addr);
    }

    /**
     * readByteMemory(off, addr)
     *
     * @this {Memoryx86}
     * @param {number} off
     * @param {number} addr
     * @returns {number}
     */
    readByteMemory(off, addr)
    {
        if (BYTEARRAYS) {
            return this.ab[off];
        }
        return ((this.adw[off >> 2] >>> ((off & 0x3) << 3)) & 0xff);
    }

    /**
     * readShortMemory(off, addr)
     *
     * @this {Memoryx86}
     * @param {number} off
     * @param {number} addr
     * @returns {number}
     */
    readShortMemory(off, addr)
    {
        if (BYTEARRAYS) {
            return this.ab[off] | (this.ab[off + 1] << 8);
        }
        let w;
        let idw = off >> 2;
        let nShift = (off & 0x3) << 3;
        let dw = (this.adw[idw] >> nShift);
        if (nShift < 24) {
            w = dw & 0xffff;
        } else {
            w = (dw & 0xff) | ((this.adw[idw + 1] & 0xff) << 8);
        }
        return w;
    }

    /**
     * readLongMemory(off, addr)
     *
     * @this {Memoryx86}
     * @param {number} off
     * @param {number} addr
     * @returns {number}
     */
    readLongMemory(off, addr)
    {
        if (BYTEARRAYS) {
            return this.ab[off] | (this.ab[off + 1] << 8) | (this.ab[off + 2] << 16) | (this.ab[off + 3] << 24);
        }
        let idw = off >> 2;
        let nShift = (off & 0x3) << 3;
        let l = this.adw[idw];
        if (nShift) {
            l >>>= nShift;
            l |= this.adw[idw + 1] << (32 - nShift);
        }
        return l;
    }

    /**
     * writeByteMemory(off, b, addr)
     *
     * @this {Memoryx86}
     * @param {number} off
     * @param {number} b
     * @param {number} addr
     */
    writeByteMemory(off, b, addr)
    {
        if (BYTEARRAYS) {
            this.ab[off] = b;
        } else {
            let idw = off >> 2;
            let nShift = (off & 0x3) << 3;
            this.adw[idw] = (this.adw[idw] & ~(0xff << nShift)) | (b << nShift);
        }
        // this.flags |= Memoryx86.FLAGS.DIRTY;
    }

    /**
     * writeShortMemory(off, w, addr)
     *
     * @this {Memoryx86}
     * @param {number} off
     * @param {number} w
     * @param {number} addr
     */
    writeShortMemory(off, w, addr)
    {
        if (BYTEARRAYS) {
            this.ab[off] = (w & 0xff);
            this.ab[off + 1] = (w >> 8);
        } else {
            let idw = off >> 2;
            let nShift = (off & 0x3) << 3;
            if (nShift < 24) {
                this.adw[idw] = (this.adw[idw] & ~(0xffff << nShift)) | (w << nShift);
            } else {
                this.adw[idw] = (this.adw[idw] & 0x00ffffff) | (w << 24);
                idw++;
                this.adw[idw] = (this.adw[idw] & (0xffffff00|0)) | (w >> 8);
            }
        }
        // this.flags |= Memoryx86.FLAGS.DIRTY;
    }

    /**
     * writeLongMemory(off, l, addr)
     *
     * @this {Memoryx86}
     * @param {number} off
     * @param {number} l
     * @param {number} addr
     */
    writeLongMemory(off, l, addr)
    {
        if (BYTEARRAYS) {
            this.ab[off] = (l & 0xff);
            this.ab[off + 1] = (l >> 8) & 0xff;
            this.ab[off + 2] = (l >> 16) & 0xff;
            this.ab[off + 3] = (l >> 24) & 0xff;
        } else {
            let idw = off >> 2;
            let nShift = (off & 0x3) << 3;
            if (!nShift) {
                this.adw[idw] = l;
            } else {
                let mask = (0xffffffff|0) << nShift;
                this.adw[idw] = (this.adw[idw] & ~mask) | (l << nShift);
                idw++;
                this.adw[idw] = (this.adw[idw] & mask) | (l >>> (32 - nShift));
            }
        }
        // this.flags |= Memoryx86.FLAGS.DIRTY;
    }

    /**
     * readByteChecked(off, addr)
     *
     * NOTE: When we're called in the context of a PAGED block (eg, with one or more DEBUGGER breakpoints set),
     * the checkMemory functions need "this.addr + off" rather than "addr", because the former will be the physical
     * address rather than the linear address.
     *
     * @this {Memoryx86}
     * @param {number} off
     * @param {number} addr
     * @returns {number}
     */
    readByteChecked(off, addr)
    {
        if (!DEBUGGER || !this.dbg || this.addr == null || !this.dbg.checkMemoryRead(this.addr + off)) {
            if (I386 && this.cpu) this.cpu.checkMemoryException(addr, 1, false);
        }
        return this.readByteDirect(off, addr);
    }

    /**
     * readShortChecked(off, addr)
     *
     * @this {Memoryx86}
     * @param {number} off
     * @param {number} addr
     * @returns {number}
     */
    readShortChecked(off, addr)
    {
        if (!DEBUGGER || !this.dbg || this.addr == null || !this.dbg.checkMemoryRead(this.addr + off, 2)) {
            if (I386 && this.cpu) this.cpu.checkMemoryException(addr, 2, false);
        }
        return this.readShortDirect(off, addr);
    }

    /**
     * readLongChecked(off, addr)
     *
     * @this {Memoryx86}
     * @param {number} off
     * @param {number} addr
     * @returns {number}
     */
    readLongChecked(off, addr)
    {
        if (!DEBUGGER || !this.dbg || this.addr == null || !this.dbg.checkMemoryRead(this.addr + off, 4)) {
            if (I386 && this.cpu) this.cpu.checkMemoryException(addr, 4, false);
        }
        return this.readLongDirect(off, addr);
    }

    /**
     * writeByteChecked(off, b, addr)
     *
     * @this {Memoryx86}
     * @param {number} off
     * @param {number} addr
     * @param {number} b
     */
    writeByteChecked(off, b, addr)
    {
        if (!DEBUGGER || !this.dbg || this.addr == null || !this.dbg.checkMemoryWrite(this.addr + off)) {
            if (I386 && this.cpu) this.cpu.checkMemoryException(addr, 1, true);
        }
        if (this.fReadOnly) this.writeNone(off, b, addr); else this.writeByteDirect(off, b, addr);
    }

    /**
     * writeShortChecked(off, w, addr)
     *
     * @this {Memoryx86}
     * @param {number} off
     * @param {number} addr
     * @param {number} w
     */
    writeShortChecked(off, w, addr)
    {
        if (!DEBUGGER || !this.dbg || this.addr == null || !this.dbg.checkMemoryWrite(this.addr + off, 2)) {
            if (I386 && this.cpu) this.cpu.checkMemoryException(addr, 2, true);
        }
        if (this.fReadOnly) this.writeNone(off, w, addr); else this.writeShortDirect(off, w, addr);
    }

    /**
     * writeLongChecked(off, l, addr)
     *
     * @this {Memoryx86}
     * @param {number} off
     * @param {number} l
     * @param {number} addr
     */
    writeLongChecked(off, l, addr)
    {
        if (!DEBUGGER || !this.dbg || this.addr == null || !this.dbg.checkMemoryWrite(this.addr + off, 4)) {
            if (I386 && this.cpu) this.cpu.checkMemoryException(addr, 4, true);
        }
        if (this.fReadOnly) this.writeNone(off, l, addr); else this.writeLongDirect(off, l, addr);
    }

    /**
     * readBytePaged(off, addr)
     *
     * @this {Memoryx86}
     * @param {number} off
     * @param {number} addr
     * @returns {number}
     */
    readBytePaged(off, addr)
    {
        this.blockPDE.adw[this.iPDE] |= this.bitPTEAccessed;
        this.blockPTE.adw[this.iPTE] |= this.bitPTEAccessed;
        return this.blockPhys.readByte(off, addr);
    }

    /**
     * readShortPaged(off, addr)
     *
     * @this {Memoryx86}
     * @param {number} off
     * @param {number} addr
     * @returns {number}
     */
    readShortPaged(off, addr)
    {
        this.blockPDE.adw[this.iPDE] |= this.bitPTEAccessed;
        this.blockPTE.adw[this.iPTE] |= this.bitPTEAccessed;
        return this.blockPhys.readShort(off, addr);
    }

    /**
     * readLongPaged(off, addr)
     *
     * @this {Memoryx86}
     * @param {number} off
     * @param {number} addr
     * @returns {number}
     */
    readLongPaged(off, addr)
    {
        this.blockPDE.adw[this.iPDE] |= this.bitPTEAccessed;
        this.blockPTE.adw[this.iPTE] |= this.bitPTEAccessed;
        return this.blockPhys.readLong(off, addr);
    }

    /**
     * writeBytePaged(off, b, addr)
     *
     * @this {Memoryx86}
     * @param {number} off
     * @param {number} b
     * @param {number} addr
     */
    writeBytePaged(off, b, addr)
    {
        this.blockPDE.adw[this.iPDE] |= this.bitPTEAccessed;
        this.blockPTE.adw[this.iPTE] |= this.bitPTEDirty;
        this.blockPhys.writeByte(off, b, addr);
    }

    /**
     * writeShortPaged(off, w, addr)
     *
     * @this {Memoryx86}
     * @param {number} off
     * @param {number} w
     * @param {number} addr
     */
    writeShortPaged(off, w, addr)
    {
        this.blockPDE.adw[this.iPDE] |= this.bitPTEAccessed;
        this.blockPTE.adw[this.iPTE] |= this.bitPTEDirty;
        this.blockPhys.writeShort(off, w, addr);
    }

    /**
     * writeLongPaged(off, l, addr)
     *
     * @this {Memoryx86}
     * @param {number} off
     * @param {number} l
     * @param {number} addr
     */
    writeLongPaged(off, l, addr)
    {
        this.blockPDE.adw[this.iPDE] |= this.bitPTEAccessed;
        this.blockPTE.adw[this.iPTE] |= this.bitPTEDirty;
        this.blockPhys.writeLong(off, l, addr);
    }

    /**
     * readByteUnpaged(off, addr)
     *
     * @this {Memoryx86}
     * @param {number} off
     * @param {number} addr
     * @returns {number}
     */
    readByteUnpaged(off, addr)
    {
        return this.getPageBlock(addr, false).readByte(off, addr);
    }

    /**
     * readShortUnpaged(off, addr)
     *
     * @this {Memoryx86}
     * @param {number} off
     * @param {number} addr
     * @returns {number}
     */
    readShortUnpaged(off, addr)
    {
        return this.getPageBlock(addr, false).readShort(off, addr);
    }

    /**
     * readLongUnpaged(off, addr)
     *
     * @this {Memoryx86}
     * @param {number} off
     * @param {number} addr
     * @returns {number}
     */
    readLongUnpaged(off, addr)
    {
        return this.getPageBlock(addr, false).readLong(off, addr);
    }

    /**
     * writeByteUnpaged(off, b, addr)
     *
     * @this {Memoryx86}
     * @param {number} off
     * @param {number} b
     * @param {number} addr
     */
    writeByteUnpaged(off, b, addr)
    {
        this.getPageBlock(addr, true).writeByte(off, b, addr);
    }

    /**
     * writeShortUnpaged(off, w, addr)
     *
     * @this {Memoryx86}
     * @param {number} off
     * @param {number} w
     * @param {number} addr
     */
    writeShortUnpaged(off, w, addr)
    {
        this.getPageBlock(addr, true).writeShort(off, w, addr);
    }

    /**
     * writeLongUnpaged(off, l, addr)
     *
     * @this {Memoryx86}
     * @param {number} off
     * @param {number} l
     * @param {number} addr
     */
    writeLongUnpaged(off, l, addr)
    {
        this.getPageBlock(addr, true).writeLong(off, l, addr);
    }

    /**
     * readByteBE(off, addr)
     *
     * @this {Memoryx86}
     * @param {number} off
     * @param {number} addr
     * @returns {number}
     */
    readByteBE(off, addr)
    {
        return this.ab[off];
    }

    /**
     * readByteLE(off, addr)
     *
     * @this {Memoryx86}
     * @param {number} off
     * @param {number} addr
     * @returns {number}
     */
    readByteLE(off, addr)
    {
        return this.ab[off];
    }

    /**
     * readBytePLE(off, addr)
     *
     * @this {Memoryx86}
     * @param {number} off
     * @param {number} addr
     * @returns {number}
     */
    readBytePLE(off, addr)
    {
        this.blockPDE.adw[this.iPDE] |= X86.PTE.ACCESSED;
        this.blockPTE.adw[this.iPTE] |= X86.PTE.ACCESSED;
        /**
         * TODO: Review this performance hack.  Basically, after the first read of a page,
         * we redirect the default read handler to a faster handler.  However, if operating
         * systems clear the PDE/PTE bits without reloading CR3, they won't get set again.
         *
         * We should look into creating special write handlers for pages containing PDE/PTE
         * entries, and whenever those entries are written, reset the read/write handlers
         * for the corresponding pages.
         */
        this.readByte = this.readByteLE;
        return this.ab[off];
    }

    /**
     * readShortBE(off, addr)
     *
     * @this {Memoryx86}
     * @param {number} off
     * @param {number} addr
     * @returns {number}
     */
    readShortBE(off, addr)
    {
        return this.dv.getUint16(off, true);
    }

    /**
     * readShortLE(off, addr)
     *
     * @this {Memoryx86}
     * @param {number} off
     * @param {number} addr
     * @returns {number}
     */
    readShortLE(off, addr)
    {
        /**
         * TODO: It remains to be seen if there's any advantage to checking the offset for an aligned read
         * vs. always reading the bytes separately; it seems a safe bet for longs, but it's less clear for shorts.
         */
        return (off & 0x1)? (this.ab[off] | (this.ab[off+1] << 8)) : this.aw[off >> 1];
    }

    /**
     * readShortPLE(off, addr)
     *
     * @this {Memoryx86}
     * @param {number} off
     * @param {number} addr
     * @returns {number}
     */
    readShortPLE(off, addr)
    {
        /**
         * TODO: It remains to be seen if there's any advantage to checking the offset for an aligned read
         * vs. always reading the bytes separately; it seems a safe bet for longs, but it's less clear for shorts.
         */
        this.blockPDE.adw[this.iPDE] |= X86.PTE.ACCESSED;
        this.blockPTE.adw[this.iPTE] |= X86.PTE.ACCESSED;
        /**
         * TODO: Review this performance hack.  Basically, after the first read of a page,
         * we redirect the default read handler to a faster handler.  However, if operating
         * systems clear the PDE/PTE bits without reloading CR3, they won't get set again.
         *
         * We should look into creating special write handlers for pages containing PDE/PTE
         * entries, and whenever those entries are written, reset the read/write handlers
         * for the corresponding pages.
         */
        this.readShort = this.readShortLE;
        return (off & 0x1)? (this.ab[off] | (this.ab[off+1] << 8)) : this.aw[off >> 1];
    }

    /**
     * readLongBE(off, addr)
     *
     * @this {Memoryx86}
     * @param {number} off
     * @param {number} addr
     * @returns {number}
     */
    readLongBE(off, addr)
    {
        return this.dv.getInt32(off, true);
    }

    /**
     * readLongLE(off, addr)
     *
     * @this {Memoryx86}
     * @param {number} off
     * @param {number} addr
     * @returns {number}
     */
    readLongLE(off, addr)
    {
        /**
         * TODO: It remains to be seen if there's any advantage to checking the offset for an aligned read
         * vs. always reading the bytes separately; it seems a safe bet for longs, but it's less clear for shorts.
         */
        return (off & 0x3)? (this.ab[off] | (this.ab[off+1] << 8) | (this.ab[off+2] << 16) | (this.ab[off+3] << 24)) : this.adw[off >> 2];
    }

    /**
     * readLongPLE(off, addr)
     *
     * @this {Memoryx86}
     * @param {number} off
     * @param {number} addr
     * @returns {number}
     */
    readLongPLE(off, addr)
    {
        /**
         * TODO: It remains to be seen if there's any advantage to checking the offset for an aligned read
         * vs. always reading the bytes separately; it seems a safe bet for longs, but it's less clear for shorts.
         */
        this.blockPDE.adw[this.iPDE] |= X86.PTE.ACCESSED;
        this.blockPTE.adw[this.iPTE] |= X86.PTE.ACCESSED;
        /**
         * TODO: Review this performance hack.  Basically, after the first read of a page, we redirect the default
         * read handler to a faster handler.  However, if operating systems clear the PDE/PTE bits without reloading
         * CR3, they won't get set again.
         *
         * We should look into creating special write handlers for pages containing PDE/PTE entries, and whenever
         * those entries are written, reset the read/write handlers for the corresponding pages.
         */
        this.readLong = this.readLongLE;
        return (off & 0x3)? (this.ab[off] | (this.ab[off+1] << 8) | (this.ab[off+2] << 16) | (this.ab[off+3] << 24)) : this.adw[off >> 2];
    }

    /**
     * writeByteBE(off, b, addr)
     *
     * @this {Memoryx86}
     * @param {number} off
     * @param {number} b
     * @param {number} addr
     */
    writeByteBE(off, b, addr)
    {
        this.ab[off] = b;
        // this.flags |= Memoryx86.FLAGS.DIRTY;
    }

    /**
     * writeByteLE(off, b, addr)
     *
     * @this {Memoryx86}
     * @param {number} off
     * @param {number} addr
     * @param {number} b
     */
    writeByteLE(off, b, addr)
    {
        this.ab[off] = b;
        // this.flags |= Memoryx86.FLAGS.DIRTY;
    }

    /**
     * writeBytePLE(off, b, addr)
     *
     * @this {Memoryx86}
     * @param {number} off
     * @param {number} addr
     * @param {number} b
     */
    writeBytePLE(off, b, addr)
    {
        this.ab[off] = b;
        this.blockPDE.adw[this.iPDE] |= X86.PTE.ACCESSED;
        this.blockPTE.adw[this.iPTE] |= X86.PTE.ACCESSED | X86.PTE.DIRTY;
        /**
         * TODO: Review this performance hack.  Basically, after the first write of a page, we redirect the default
         * write handler to a faster handler.  However, if operating systems clear the PDE/PTE bits without reloading
         * CR3, they won't get set again.
         *
         * We should look into creating special write handlers for pages containing PDE/PTE entries, and whenever
         * those entries are written, reset the read/write handlers for the corresponding pages.
         */
        this.writeByte = this.writeByteLE;
        /**
         * NOTE: Technically, we should be setting the DIRTY flag on blockPDE and blockPTE as well, but let's consider
         * the two sole uses of DIRTY.  First, we have cleanMemory(), which is currently used only by the Video component,
         * and video memory should never contain page directories or page tables, so no worries there.  Second, we have
         * saveMemory(), but the CPU now asks that function to save all physical memory blocks whenever paging is enabled,
         * so no worries there either.
         */
        // this.blockPhys.flags |= Memoryx86.FLAGS.DIRTY;
    }

    /**
     * writeShortBE(off, w, addr)
     *
     * @this {Memoryx86}
     * @param {number} off
     * @param {number} addr
     * @param {number} w
     */
    writeShortBE(off, w, addr)
    {
        this.dv.setUint16(off, w, true);
        // this.flags |= Memoryx86.FLAGS.DIRTY;
    }

    /**
     * writeShortLE(off, w, addr)
     *
     * @this {Memoryx86}
     * @param {number} off
     * @param {number} addr
     * @param {number} w
     */
    writeShortLE(off, w, addr)
    {
        /**
         * TODO: It remains to be seen if there's any advantage to checking the offset for an aligned write
         * vs. always writing the bytes separately; it seems a safe bet for longs, but it's less clear for shorts.
         */
        if (off & 0x1) {
            this.ab[off] = w;
            this.ab[off+1] = w >> 8;
        } else {
            this.aw[off >> 1] = w;
        }
        // this.flags |= Memoryx86.FLAGS.DIRTY;
    }

    /**
     * writeShortPLE(off, w, addr)
     *
     * @this {Memoryx86}
     * @param {number} off
     * @param {number} addr
     * @param {number} w
     */
    writeShortPLE(off, w, addr)
    {
        /**
         * TODO: It remains to be seen if there's any advantage to checking the offset for an aligned write
         * vs. always writing the bytes separately; it seems a safe bet for longs, but it's less clear for shorts.
         */
        if (off & 0x1) {
            this.ab[off] = w;
            this.ab[off+1] = w >> 8;
        } else {
            this.aw[off >> 1] = w;
        }
        this.blockPDE.adw[this.iPDE] |= X86.PTE.ACCESSED;
        this.blockPTE.adw[this.iPTE] |= X86.PTE.ACCESSED | X86.PTE.DIRTY;
        /**
         * TODO: Review this performance hack.  Basically, after the first write of a page,
         * we redirect the default write handler to a faster handler.  However, if operating
         * systems clear the PDE/PTE bits without reloading CR3, they won't get set again.
         *
         * We should look into creating special write handlers for pages containing PDE/PTE
         * entries, and whenever those entries are written, reset the read/write handlers
         * for the corresponding pages.
         */
        this.writeShort = this.writeShortLE;
        /**
         * NOTE: Technically, we should be setting the DIRTY flag on blockPDE and blockPTE as well, but let's
         * consider the two sole uses of DIRTY.  First, we have cleanMemory(), which is currently used only by
         * the Video component, and video memory should never contain page directories or page tables, so no
         * worries there.  Second, we have saveMemory(), but the CPU now asks that function to save all physical
         * memory blocks whenever paging is enabled, so no worries there either.
         */
        // this.blockPhys.flags |= Memoryx86.FLAGS.DIRTY;
    }

    /**
     * writeLongBE(off, l, addr)
     *
     * @this {Memoryx86}
     * @param {number} off
     * @param {number} l
     * @param {number} addr
     */
    writeLongBE(off, l, addr)
    {
        this.dv.setInt32(off, l, true);
        // this.flags |= Memoryx86.FLAGS.DIRTY;
    }

    /**
     * writeLongLE(off, l, addr)
     *
     * @this {Memoryx86}
     * @param {number} off
     * @param {number} l
     * @param {number} addr
     */
    writeLongLE(off, l, addr)
    {
        /**
         * TODO: It remains to be seen if there's any advantage to checking the offset for an aligned write
         * vs. always writing the bytes separately; it seems a safe bet for longs, but it's less clear for shorts.
         */
        if (off & 0x3) {
            this.ab[off] = l;
            this.ab[off+1] = (l >> 8);
            this.ab[off+2] = (l >> 16);
            this.ab[off+3] = (l >> 24);
        } else {
            this.adw[off >> 2] = l;
        }
        // this.flags |= Memoryx86.FLAGS.DIRTY;
    }

    /**
     * writeLongPLE(off, l, addr)
     *
     * @this {Memoryx86}
     * @param {number} off
     * @param {number} l
     * @param {number} addr
     */
    writeLongPLE(off, l, addr)
    {
        /**
         * TODO: It remains to be seen if there's any advantage to checking the offset for an aligned write
         * vs. always writing the bytes separately; it seems a safe bet for longs, but it's less clear for shorts.
         */
        if (off & 0x3) {
            this.ab[off] = l;
            this.ab[off+1] = (l >> 8);
            this.ab[off+2] = (l >> 16);
            this.ab[off+3] = (l >> 24);
        } else {
            this.adw[off >> 2] = l;
        }
        this.blockPDE.adw[this.iPDE] |= X86.PTE.ACCESSED;
        this.blockPTE.adw[this.iPTE] |= X86.PTE.ACCESSED | X86.PTE.DIRTY;
        /**
         * TODO: Review this performance hack.  Basically, after the first write of a page,
         * we redirect the default write handler to a faster handler.  However, if operating
         * systems clear the PDE/PTE bits without reloading CR3, they won't get set again.
         *
         * We should look into creating special write handlers for pages containing PDE/PTE
         * entries, and whenever those entries are written, reset the read/write handlers
         * for the corresponding pages.
         */
        this.writeLong = this.writeLongLE;
        /**
         * NOTE: Technically, we should be setting the DIRTY flag on blockPDE and blockPTE as well, but let's
         * consider the two sole uses of DIRTY.  First, we have cleanMemory(), which is currently used only by
         * the Video component, and video memory should never contain page directories or page tables, so no
         * worries there.  Second, we have saveMemory(), but the CPU now asks that function to save all physical
         * memory blocks whenever paging is enabled, so no worries there either.
         */
        // this.blockPhys.flags |= Memoryx86.FLAGS.DIRTY;
    }

    /**
     * readBackTrackNone(off)
     *
     * @this {Memoryx86}
     * @param {number} off
     * @returns {number}
     */
    readBackTrackNone(off)
    {
        return 0;
    }

    /**
     * writeBackTrackNone(off, bti)
     *
     * @this {Memoryx86}
     * @param {number} off
     * @param {number} bti
     */
    writeBackTrackNone(off, bti)
    {
    }

    /**
     * modBackTrackNone(fMod)
     *
     * @this {Memoryx86}
     * @param {boolean} fMod
     */
    modBackTrackNone(fMod)
    {
        return false;
    }

    /**
     * readBackTrackIndex(off)
     *
     * @this {Memoryx86}
     * @param {number} off
     * @returns {number}
     */
    readBackTrackIndex(off)
    {
        return this.abtIndexes[off];
    }

    /**
     * writeBackTrackIndex(off, bti)
     *
     * @this {Memoryx86}
     * @param {number} off
     * @param {number} bti
     * @returns {number} previous bti (0 if none)
     */
    writeBackTrackIndex(off, bti)
    {
        let btiPrev;
        btiPrev = this.abtIndexes[off];
        this.abtIndexes[off] = bti;
        return btiPrev;
    }

    /**
     * modBackTrackIndex(fMod)
     *
     * @this {Memoryx86}
     * @param {boolean} fMod
     * @returns {boolean} previous value
     */
    modBackTrackIndex(fMod)
    {
        let fModPrev = this.fModBackTrack;
        this.fModBackTrack = fMod;
        return fModPrev;
    }

    /**
     * adjustEndian(dw)
     *
     * @param {number} dw
     * @returns {number}
     */
    static adjustEndian(dw)
    {
        if (TYPEDARRAYS && !littleEndian) {
            dw = (dw << 24) | ((dw << 8) & 0x00ff0000) | ((dw >> 8) & 0x0000ff00) | (dw >>> 24);
        }
        return dw;
    }
}

/**
 * This is the effective definition of afnNone, but we need not fully define it, because setAccess() uses these
 * defaults when any of the 6 handlers (ie, 2 byte handlers, 2 short handlers, and 2 long handlers) are undefined.
 *
Memoryx86.afnNone = [
    Memoryx86.prototype.readNone,
    Memoryx86.prototype.writeNone,
    Memoryx86.prototype.readShortDefault,
    Memoryx86.prototype.writeShortDefault,
    Memoryx86.prototype.readLongDefault,
    Memoryx86.prototype.writeLongDefault
];
 */
Memoryx86.afnNone = [];

Memoryx86.afnMemory = [
    Memoryx86.prototype.readByteMemory,
    Memoryx86.prototype.writeByteMemory,
    Memoryx86.prototype.readShortMemory,
    Memoryx86.prototype.writeShortMemory,
    Memoryx86.prototype.readLongMemory,
    Memoryx86.prototype.writeLongMemory
];

Memoryx86.afnChecked = [
    Memoryx86.prototype.readByteChecked,
    Memoryx86.prototype.writeByteChecked,
    Memoryx86.prototype.readShortChecked,
    Memoryx86.prototype.writeShortChecked,
    Memoryx86.prototype.readLongChecked,
    Memoryx86.prototype.writeLongChecked
];

if (PAGEBLOCKS) {
    Memoryx86.afnPaged = [
        Memoryx86.prototype.readBytePaged,
        Memoryx86.prototype.writeBytePaged,
        Memoryx86.prototype.readShortPaged,
        Memoryx86.prototype.writeShortPaged,
        Memoryx86.prototype.readLongPaged,
        Memoryx86.prototype.writeLongPaged
    ];

    Memoryx86.afnUnpaged = [
        Memoryx86.prototype.readByteUnpaged,
        Memoryx86.prototype.writeByteUnpaged,
        Memoryx86.prototype.readShortUnpaged,
        Memoryx86.prototype.writeShortUnpaged,
        Memoryx86.prototype.readLongUnpaged,
        Memoryx86.prototype.writeLongUnpaged
    ];
}

if (TYPEDARRAYS) {
    Memoryx86.afnArrayBE = [
        Memoryx86.prototype.readByteBE,
        Memoryx86.prototype.writeByteBE,
        Memoryx86.prototype.readShortBE,
        Memoryx86.prototype.writeShortBE,
        Memoryx86.prototype.readLongBE,
        Memoryx86.prototype.writeLongBE
    ];

    Memoryx86.afnArrayLE = [
        Memoryx86.prototype.readByteLE,
        Memoryx86.prototype.writeByteLE,
        Memoryx86.prototype.readShortLE,
        Memoryx86.prototype.writeShortLE,
        Memoryx86.prototype.readLongLE,
        Memoryx86.prototype.writeLongLE
    ];

    Memoryx86.afnPagedLE = [
        Memoryx86.prototype.readBytePLE,
        Memoryx86.prototype.writeBytePLE,
        Memoryx86.prototype.readShortPLE,
        Memoryx86.prototype.writeShortPLE,
        Memoryx86.prototype.readLongPLE,
        Memoryx86.prototype.writeLongPLE
    ];
}

/**
 * @copyright https://www.pcjs.org/machines/pcx86/modules/v2/cpu.js (C) 2012-2024 Jeff Parsons
 */

/** @typedef {{ nCycles: number, nCyclesTotal: number, msDuration: number, msLag: number, msBegin: number }} */
let TimeLog;

/**
 * @class CPU
 * @unrestricted (allows the class to define properties, both dot and named, outside of the constructor)
 */
class CPU extends Component {

    static YIELDS_PER_SECOND = 60;

    static BUTTONS = ["power", "reset"];

    /**
     * CPU(parmsCPU, nCyclesDefault)
     *
     * The CPU class supports the following (parmsCPU) properties:
     *
     *      cycles: the machine's base cycles per second; the CPUx86 constructor will provide us with a default
     *      (based on the CPU model) to use as a fallback.
     *
     *      multiplier: base cycle multiplier; default is 1.
     *
     *      autoStart: true to automatically start, false to not, or null if "it depends"; null is the default,
     *      which means autostart UNLESS there is a Debugger present.
     *
     *      csStart: the number of cycles that runCPU() must wait before generating checksum records;
     *      -1 if disabled.  checksum records are a diagnostic aid used to help compare one CPU run to another.
     *
     *      csInterval: the number of cycles that runCPU() must execute before generating a checksum record;
     *      -1 if disabled.
     *
     *      csStop: the number of cycles to stop generating checksum records.
     *
     * This component is primarily responsible for interfacing the CPU with the outside world (eg, Panel and Debugger
     * components), and managing overall CPU operation.
     *
     * It is extended by the CPUx86 component, where all the x86-specific logic resides.
     *
     * @this {CPU}
     * @param {Object} parmsCPU
     * @param {number} nCyclesDefault
     */
    constructor(parmsCPU, nCyclesDefault)
    {
        super("CPU", parmsCPU, MESSAGE.CPU);

        let nCycles = parmsCPU['cycles'] || nCyclesDefault;

        let nMultiplier = parmsCPU['multiplier'] || 1;

        if (DEBUG) this.aTimeLogs = [null, null];
        this.nBaseCyclesPerSecond = nCycles;
        this.msPerYield = Math.round(1000 / CPU.YIELDS_PER_SECOND);

        /**
         * nTargetMultiplier replaces the old "speed" variable (0, 1, 2) and eliminates the need for
         * the constants (SPEED_SLOW, SPEED_FAST and SPEED_MAX).  The UI simply doubles the target multiplier
         * until we've exceeded the host's speed limit (ie, the current value is unable to reach the target),
         * at which point we reset the target back to the default.
         */
        this.nBaseMultiplier = this.nCurrentMultiplier = this.nTargetMultiplier = nMultiplier;
        this.mhzBase = Math.round(this.nBaseCyclesPerSecond / 10000) / 100;
        this.mhzCurrent = this.mhzTarget = this.mhzBase * this.nTargetMultiplier;

        /**
         * We add a number of flags to those initialized by Component.
         */
        this.flags.starting = this.flags.running = this.flags.yield = false;
        this.flags.autoStart = parmsCPU['autoStart'];

        /**
         * TODO: Add some UI for displayLiveRegs (either an XML property, or a UI checkbox, or both)
         */
        this.flags.displayLiveRegs = false;

        /**
         * Get checksum parameters, if any. runCPU() behavior is not affected until fChecksum
         * is true, which won't happen until resetChecksum() is called with nCyclesChecksumInterval
         * ("csInterval") set to a positive value.
         *
         * As above, any of these parameters can also be set with the Debugger's execution options
         * command ("x"); for example, "x cs int 5000" will set nCyclesChecksumInterval to 5000
         * and call resetChecksum().
         */
        this.flags.checksum = false;
        this.nChecksum = this.nCyclesChecksumNext = 0;
        this.nCyclesChecksumStart = parmsCPU["csStart"];
        this.nCyclesChecksumInterval = parmsCPU["csInterval"];
        this.nCyclesChecksumStop = parmsCPU["csStop"];

        /**
         * Array of countdown timers managed by addTimer() and setTimer().
         *
         * See also: getMSCycles(), getBurstCycles(), saveTimers(), restoreTimers(), and updateTimers()
         */
        this.aTimers = [];

        this.idRunTimeout = 0;
        this.onRunTimeout = this.runCPU.bind(this); // function onRunTimeout() { cpu.runCPU(); };
    }

    /**
     * addTimeLog(nCycles, nCyclesTotal, msBegin, msDuration)
     *
     * @this {CPU}
     * @param {number} nCycles
     * @param {number} nCyclesTotal
     * @param {number} msBegin
     * @param {number} msDuration
     */
    addTimeLog(nCycles, nCyclesTotal, msBegin, msDuration)
    {
        if (DEBUG) {
            let msLag = 0;
            if (nCycles) {
                if (!this.aTimeLogs[0]) {
                    this.aTimeLogs[0] = {nCycles, msDuration, msLag, msBegin};
                } else {
                    this.aTimeLogs[0].nCycles += nCycles;
                    this.aTimeLogs[0].msDuration += msDuration;
                }
            }
            if (!this.aTimeLogs[1]) {
                this.aTimeLogs[1] = {nCycles, msDuration, msLag, msBegin};
            } else {
                this.aTimeLogs[1].nCycles += nCycles;
                this.aTimeLogs[1].msDuration += msDuration;
            }
            if (this.aTimeLogs.length > 2) {
                let prevLog = this.aTimeLogs[this.aTimeLogs.length-1];
                let msEndPrev = prevLog.msBegin + prevLog.msDuration;
                //
                msLag = msBegin - msEndPrev;
            }
            this.aTimeLogs.push({nCycles, msDuration, msLag, msBegin});
            if (this.aTimeLogs.length > 600 + 2) {
                this.aTimeLogs.splice(2, 1);
            }
        }
    }

    /**
     * initBus(cmp, bus, cpu, dbg)
     *
     * @this {CPU}
     * @param {Computer} cmp
     * @param {Busx86} bus
     * @param {CPU} cpu
     * @param {Debuggerx86} dbg
     */
    initBus(cmp, bus, cpu, dbg)
    {
        this.cmp = cmp;
        this.bus = bus;
        this.dbg = dbg;

        for (let i = 0; i < CPU.BUTTONS.length; i++) {
            let control = this.bindings[CPU.BUTTONS[i]];
            if (control) this.cmp.setBinding("", CPU.BUTTONS[i], control);
        }

        this.fpuActive = null;
        this.fpu = cmp.getMachineComponent("FPU", false);

        /**
         * Attach the ChipSet component to the CPU so that it can obtain the IDT vector number
         * of pending hardware interrupts in response to the ChipSet's updateINTR() notifications.
         *
         * We must also call chipset.updateAllTimers() periodically; stepCPU() takes care of that.
         */
        this.chipset = cmp.getMachineComponent("ChipSet");

        /**
         * We've already saved the parmsCPU 'autoStart' setting, but there may be a machine (or URL) override.
         */
        this.flags.autoStart = cmp.getMachineBoolean('autoStart', this.flags.autoStart);

        let nMultiplier = cmp.getMachineParm('multiplier');
        if (nMultiplier) this.nBaseMultiplier = +nMultiplier;

        this.timerYield = cpu.addTimer(this.id, function yieldTimer() {
            cpu.flags.yield = true;
        }, this.msPerYield);

        this.setReady();
    }

    /**
     * reset()
     *
     * This is a placeholder for reset (overridden by the CPUx86 component).
     *
     * @this {CPU}
     */
    reset()
    {
    }

    /**
     * save(fRunning)
     *
     * This is a placeholder for save support (overridden by the CPUx86 component).
     *
     * @this {CPU}
     * @param {boolean} [fRunning]
     * @returns {Object|null}
     */
    save(fRunning)
    {
        return null;
    }

    /**
     * restore(data)
     *
     * This is a placeholder for restore support (overridden by the CPUx86 component).
     *
     * @this {CPU}
     * @param {Object} data
     * @returns {boolean} true if restore successful, false if not
     */
    restore(data)
    {
        return false;
    }

    /**
     * powerUp(data, fRepower)
     *
     * @this {CPU}
     * @param {Object|null} data
     * @param {boolean} [fRepower]
     * @returns {boolean} true if successful, false if failure
     */
    powerUp(data, fRepower)
    {
        if (!fRepower) {
            if (!data || !this.restore) {
                this.reset();
            } else {
                this.resetCycles();
                if (!this.restore(data)) return false;
                this.resetChecksum();
            }
            /**
             * Give the Debugger a chance to do/print something once we've powered up
             */
            if (DEBUGGER && this.dbg) {
                this.dbg.init();
            } else {
                this.printf(MESSAGE.NONE, "No debugger detected\n");
            }
        }
        /**
         * The Computer component (which is responsible for all powerDown and powerUp notifications)
         * is now responsible for managing a component's fPowered flag, not us.
         *
         *      this.flags.powered = true;
         */
        this.updateCPU(false);
        return true;
    }

    /**
     * powerDown(fSave, fShutdown)
     *
     * @this {CPU}
     * @param {boolean} [fSave]
     * @param {boolean} [fShutdown]
     * @returns {Object|boolean} component state if fSave; otherwise, true if successful, false if failure
     */
    powerDown(fSave, fShutdown)
    {
        /**
         * The Computer component (which is responsible for all powerDown and powerUp notifications)
         * is now responsible for managing a component's fPowered flag, not us.
         *
         *      this.flags.powered = false;
         */
        let fRunning = this.flags.running;
        if (fShutdown) this.stopCPU();
        return fSave? this.save(fRunning) : true;
    }

    /**
     * autoStart()
     *
     * @this {CPU}
     * @returns {boolean} true if started, false if not
     */
    autoStart()
    {
        if (this.flags.running) {
            return true;
        }
        /**
         * Start running automatically on power-up, assuming there's no Debugger.
         */
        if (this.flags.autoStart || this.flags.autoStart == null && !this.dbg) {
            return this.startCPU(true);
        }
        return false;
    }

    /**
     * isPowered()
     *
     * @this {CPU}
     * @returns {boolean}
     */
    isPowered()
    {
        if (!this.flags.powered) {
            this.printf(MESSAGE.NONE, "%s not powered\n", this.toString());
            return false;
        }
        return true;
    }

    /**
     * isRunning()
     *
     * @this {CPU}
     * @returns {boolean}
     */
    isRunning()
    {
        return this.flags.running;
    }

    /**
     * getChecksum()
     *
     * This will be implemented by the CPUx86 component.
     *
     * @this {CPU}
     * @returns {number} a 32-bit summation of key elements of the current CPU state (used by the CPU checksum code)
     */
    getChecksum()
    {
        return 0;
    }

    /**
     * resetChecksum()
     *
     * If checksum generation is enabled (fChecksum is true), this resets the running 32-bit checksum and the
     * cycle counter that will trigger the next displayChecksum(); called by resetCycles(), which is called whenever
     * the CPU is reset or restored.
     *
     * @this {CPU}
     * @returns {boolean} true if checksum generation enabled, false if not
     */
    resetChecksum()
    {
        if (this.nCyclesChecksumStart === undefined) this.nCyclesChecksumStart = 0;
        if (this.nCyclesChecksumInterval === undefined) this.nCyclesChecksumInterval = -1;
        if (this.nCyclesChecksumStop === undefined) this.nCyclesChecksumStop = -1;
        this.flags.checksum = (this.nCyclesChecksumStart >= 0 && this.nCyclesChecksumInterval > 0);
        if (this.flags.checksum) {
            this.nChecksum = 0;
            this.nCyclesChecksumNext = this.nCyclesChecksumStart - this.nTotalCycles;
            /**
             *  this.nCyclesChecksumNext = this.nCyclesChecksumStart + this.nCyclesChecksumInterval -
             *      (this.nTotalCycles % this.nCyclesChecksumInterval);
             */
            return true;
        }
        return false;
    }

    /**
     * updateChecksum(nCycles)
     *
     * When checksum generation is enabled (fChecksum is true), runCPU() asks stepCPU() to execute a minimum
     * number of cycles (1), effectively limiting execution to a single instruction, and then we're called with
     * the exact number cycles that were actually executed.  This should give us instruction-granular checksums
     * at precise intervals that are 100% repeatable.
     *
     * @this {CPU}
     * @param {number} nCycles
     */
    updateChecksum(nCycles)
    {
        if (this.flags.checksum) {
            /**
             * Get a 32-bit summation of the current CPU state and add it to our running 32-bit checksum
             */
            let fDisplay = false;
            this.nChecksum = (this.nChecksum + this.getChecksum())|0;
            this.nCyclesChecksumNext -= nCycles;
            if (this.nCyclesChecksumNext <= 0) {
                this.nCyclesChecksumNext += this.nCyclesChecksumInterval;
                fDisplay = true;
            }
            if (this.nCyclesChecksumStop >= 0) {
                if (this.nCyclesChecksumStop <= this.getCycles()) {
                    this.nCyclesChecksumInterval = this.nCyclesChecksumStop = -1;
                    this.resetChecksum();
                    this.stopCPU();
                    fDisplay = true;
                }
            }
            if (fDisplay) this.displayChecksum();
        }
    }

    /**
     * displayChecksum()
     *
     * When checksum generation is enabled (fChecksum is true), this is called to provide a crude log of all
     * checksums generated at the specified cycle intervals, as specified by the "csStart" and "csInterval" parmsCPU
     * properties).
     *
     * @this {CPU}
     */
    displayChecksum()
    {
        this.printf("%d cycles: checksum=%x\n", this.getCycles(), this.nChecksum);
    }

    /**
     * displayValue(sLabel, nValue, cch)
     *
     * This is principally for displaying register values, but in reality, it can be used to display any
     * numeric (hex) value bound to the given label.
     *
     * @this {CPU}
     * @param {string} sLabel
     * @param {number} nValue
     * @param {number} cch
     */
    displayValue(sLabel, nValue, cch)
    {
        if (this.bindings[sLabel]) {
            if (nValue === undefined) {
                this.setError("Value for " + sLabel + " is invalid");
                this.stopCPU();
            }
            let sVal;
            if (!this.flags.running || this.flags.displayLiveRegs) {
                sVal = StrLib.toHex(nValue, cch);
            } else {
                sVal = "--------".substr(0, cch);
            }
            /**
             * TODO: Determine if this test actually avoids any redrawing when a register hasn't changed, and/or if
             * we should maintain our own (numeric) cache of displayed register values (to avoid creating these temporary
             * string values that will have to garbage-collected), and/or if this is actually slower, and/or if I'm being
             * too obsessive.
             */
            if (this.bindings[sLabel].textContent != sVal) this.bindings[sLabel].textContent = sVal;
        }
    }

    /**
     * setBinding(sHTMLType, sBinding, control, sValue)
     *
     * @this {CPU}
     * @param {string} sHTMLType is the type of the HTML control (eg, "button", "list", "text", "submit", "textarea", "canvas")
     * @param {string} sBinding is the value of the 'binding' parameter stored in the HTML control's "data-value" attribute (eg, "run")
     * @param {HTMLElement} control is the HTML control DOM object (eg, HTMLButtonElement)
     * @param {string} [sValue] optional data value
     * @returns {boolean} true if binding was successful, false if unrecognized binding request
     */
    setBinding(sHTMLType, sBinding, control, sValue)
    {
        let cpu = this;
        let fBound = false;

        switch (sBinding) {
        case "power":
        case "reset":
            /**
             * The "power" and "reset" buttons are functions of the entire computer, not just the CPU,
             * but it's not always convenient to stick a power button in the Computer component definition,
             * so we record those bindings here and pass them on to the Computer component in initBus().
             */
            this.bindings[sBinding] = control;
            fBound = true;
            break;

        case "run":
            this.bindings[sBinding] = control;
            control.onclick = function onClickRun() {
                let fRunning = cpu.flags.running;
                if (!cpu.cmp || !cpu.cmp.checkPower()) return;
                /**
                 * We snapped the CPU's running flag before calling checkPower() because there are rare (REPOWER)
                 * situations where checkPower() will have started the CPU as well.  So toggle the CPU state ONLY
                 * if the running flag remains unchanged.
                 */
                if (fRunning == cpu.flags.running) {
                    if (!cpu.flags.running) {
                        cpu.startCPU(true);
                    } else {
                        cpu.stopCPU(true);
                    }
                }
            };
            fBound = true;
            break;

        case "speed":
            this.bindings[sBinding] = control;
            fBound = true;
            break;

        case "setSpeed":
            this.bindings[sBinding] = control;
            control.onclick = function onClickSetSpeed() {
                cpu.setSpeed(cpu.nTargetMultiplier << 1, true);
            };
            control.textContent = this.getSpeedTarget();
            fBound = true;
            break;

        default:
            break;
        }
        return fBound;
    }

    /**
     * setBurstCycles(nCycles)
     *
     * This function is used by the ChipSet component whenever (for example) a very low timer count is set.
     *
     * @this {CPU}
     * @param {number} nCycles (the target number of cycles to drop the current burst)
     * @returns {boolean}
     */
    setBurstCycles(nCycles)
    {
        if (this.flags.running) {
            let delta = this.nStepCycles - nCycles;
            if (delta > 0) {
                /**
                 * NOTE: If the delta is negative, we would actually be increasing nStepCycles and nBurstCycles.
                 * Which used to be OK, but now that we have CPU timers that calculate and rely upon maximum bursts,
                 * this can no longer be allowed.  TODO: Determine if there are any, um, negative side-effects on
                 * ChipSet timers if we don't allow negative deltas.
                 */
                this.nStepCycles -= delta;
                this.nBurstCycles -= delta;
                return true;
            }
        }
        return false;
    }

    /**
     * addCycles(nCycles, fEndStep)
     *
     * @this {CPU}
     * @param {number} nCycles
     * @param {boolean} [fEndStep]
     */
    addCycles(nCycles, fEndStep)
    {
        this.nTotalCycles += nCycles;
        if (fEndStep) {
            this.nBurstCycles = this.nStepCycles = 0;
        }
    }

    /**
     * calcCycles()
     *
     * Calculate the maximum number of cycles we should attempt to process before the next yield.
     *
     * @this {CPU}
     * @returns {boolean} (true if there was a change to the multiplier, false if not)
     */
    calcCycles()
    {
        let nMultiplier = this.mhzCurrent / this.mhzBase;
        if (!nMultiplier || nMultiplier > this.nTargetMultiplier) {
            nMultiplier = this.nTargetMultiplier;
        } else if (nMultiplier < 1) {
            nMultiplier = 1;
        }
        this.nCyclesPerYield = Math.floor(this.nBaseCyclesPerSecond / CPU.YIELDS_PER_SECOND * nMultiplier);
        if (this.nCurrentMultiplier !== nMultiplier) {
            this.nCurrentMultiplier = nMultiplier;
            return true;
        }
        return false;
    }

    /**
     * getCycles(fScaled)
     *
     * getCycles() returns the number of cycles executed so far.  Note that we can be called after
     * runCPU() OR during runCPU(), perhaps from a handler triggered during the current run's stepCPU(),
     * so nRunCycles must always be adjusted by number of cycles stepCPU() was asked to run (nBurstCycles),
     * less the number of cycles it has yet to run (nStepCycles).
     *
     * nRunCycles is zeroed whenever the CPU is halted or the CPU speed is changed, which is why we also
     * have nTotalCycles, which accumulates all nRunCycles before we zero it.  However, nRunCycles and
     * nTotalCycles eventually get reset by calcSpeed(), to avoid overflow, so components that rely on
     * getCycles() returning steadily increasing values should also be prepared for a reset at any time.
     *
     * @this {CPU}
     * @param {boolean} [fScaled] is true if the caller wants a cycle count relative to a multiplier of 1
     * @returns {number}
     */
    getCycles(fScaled)
    {
        let nCycles = this.nTotalCycles + this.nRunCycles + this.nBurstCycles - this.nStepCycles;
        if (fScaled && this.nTargetMultiplier > 1 && this.mhzCurrent > this.mhzBase) {
            /**
             * We could scale the current cycle count by the current speed (this.mhzCurrent); eg:
             *
             *      nCycles = Math.round(nCycles / (this.mhzCurrent / this.mhzBase));
             *
             * but that speed will fluctuate somewhat: large fluctuations at first, but increasingly smaller
             * fluctuations after each burst of instructions that runCPU() executes.
             *
             * Alternatively, we can scale the cycle count by the multiplier, which is good in that the
             * multiplier doesn't vary once the user changes it, but a potential downside is that the
             * multiplier might be set too high, resulting in a target speed that's higher than the effective
             * speed is able to reach.
             *
             * Also, if multipliers were always limited to a power-of-two, then this could be calculated
             * with a simple shift.  However, only the "setSpeed" UI binding limits it that way; the Debugger
             * interface allows any value, as does the CPU "multiplier" parmsCPU property (from the machine's
             * XML file).
             */
            nCycles = Math.round(nCycles / this.nTargetMultiplier);
        }
        return nCycles;
    }

    /**
     * getBaseCyclesPerSecond()
     *
     * This returns the CPU's base speed (ie, the original cycles per second defined for the machine)
     *
     * @this {CPU}
     * @returns {number}
     */
    getBaseCyclesPerSecond()
    {
        return this.nBaseCyclesPerSecond;
    }

    /**
     * getCurrentCyclesPerSecond()
     *
     * This returns the CPU's current speed (ie, the actual cycles per second, according the current multiplier)
     *
     * @this {CPU}
     * @returns {number}
     */
    getCurrentCyclesPerSecond()
    {
        return (this.nBaseCyclesPerSecond * this.nCurrentMultiplier)|0;
    }

    /**
     * resetCycles()
     *
     * Resets speed and cycle information as part of any reset() or restore(); this typically occurs during powerUp().
     * It's important that this be called BEFORE the actual restore() call, because restore() may want to call setSpeed(),
     * which in turn assumes that all the cycle counts have been initialized to sensible values.
     *
     * @this {CPU}
     */
    resetCycles()
    {
        this.nTotalCycles = this.nRunCycles = this.nBurstCycles = this.nStepCycles = 0;
        this.resetChecksum();
        this.setSpeed(this.nBaseMultiplier);
    }

    /**
     * getSpeed()
     *
     * @this {CPU}
     * @returns {number} the current speed multiplier
     */
    getSpeed()
    {
        return this.nTargetMultiplier;
    }

    /**
     * getSpeedCurrent()
     *
     * @this {CPU}
     * @returns {string} the current speed, in mhz, as a string formatted to two decimal places
     */
    getSpeedCurrent()
    {
        return ((this.flags.running && this.mhzCurrent)? (this.mhzCurrent.toFixed(2) + "Mhz") : "Stopped");
    }

    /**
     * getSpeedTarget()
     *
     * @this {CPU}
     * @returns {string} the target speed, in mhz, as a string formatted to two decimal places
     */
    getSpeedTarget()
    {
        return this.mhzTarget.toFixed(2) + "Mhz";
    }

    /**
     * setSpeed(nMultiplier, fUpdateFocus)
     *
     * @this {CPU}
     * @param {number} [nMultiplier] is the new proposed multiplier (reverts to default if target was too high)
     * @param {boolean} [fUpdateFocus] is true to update Computer focus
     * @returns {boolean} true if successful, false if not
     *
     * @desc Whenever the speed is changed, the running cycle count and corresponding start time must be reset,
     * so that the next effective speed calculation obtains sensible results.  In fact, when runCPU() initially calls
     * setSpeed() with no parameters, that's all this function does (it doesn't change the current speed setting).
     */
    setSpeed(nMultiplier, fUpdateFocus)
    {
        let fSuccess = true;
        if (nMultiplier !== undefined) {
            /**
             * If we haven't reached 90% (0.9) of the current target speed, revert to the default multiplier.
             */
            if (this.mhzCurrent > 0 && this.mhzCurrent < this.mhzTarget * 0.9) {
                nMultiplier = this.nBaseMultiplier;
                fSuccess = false;
            }
            this.mhzCurrent = 0;
            this.nTargetMultiplier = nMultiplier;
            let mhzTarget = this.mhzBase * this.nTargetMultiplier;
            if (this.mhzTarget != mhzTarget) {
                this.mhzTarget = mhzTarget;
                let sSpeed = this.getSpeedTarget();
                let controlSpeed = this.bindings["setSpeed"];
                if (controlSpeed) controlSpeed.textContent = sSpeed;
                this.printf(MESSAGE.NONE, "target speed: %s\n", sSpeed);
            }
            if (fUpdateFocus && this.cmp) this.cmp.updateFocus();
        }
        this.addCycles(this.nRunCycles);
        this.nRunCycles = 0;
        this.msStartRun = this.msEndThisRun = 0;
        if (this.calcCycles()) {    // if a new value was calculated for the current cycle multiplier
            this.resetTimers();     // then update all the fixed-period timers using the new cycle multiplier
        }
        return fSuccess;
    }

    /**
     * calcSpeed(nCycles, msElapsed)
     *
     * @this {CPU}
     * @param {number} nCycles
     * @param {number} msElapsed
     */
    calcSpeed(nCycles, msElapsed)
    {
        if (msElapsed) {
            this.mhzCurrent = Math.round(nCycles / (msElapsed * 10)) / 100;
            if (msElapsed >= 86400000) {
                this.nTotalCycles = 0;
                if (this.chipset) this.chipset.updateAllTimers(true);
                this.setSpeed();        // reset all counters once per day so that we never have to worry about overflow
            }
        }
    }

    /**
     * calcStartTime()
     *
     * @this {CPU}
     */
    calcStartTime()
    {
        this.calcCycles();

        this.nCyclesThisRun = 0;
        this.msDiscount = 0;
        this.msStartThisRun = Component.getTime();
        if (!this.msStartRun) {
            this.msStartRun = this.msStartThisRun;
        }

        /**
         * Try to detect situations where the browser may have throttled us, such as when the user switches
         * to a different tab; in those situations, Chrome and Safari may restrict setTimeout() callbacks
         * to roughly one per second.
         *
         * Another scenario: the user resizes the browser window.  setTimeout() callbacks are not throttled,
         * but there can still be enough of a lag between the callbacks that CPU speed will be noticeably
         * erratic if we don't compensate for it here.
         *
         * We can detect throttling/lagging by verifying that msEndThisRun (which was set at the end of the
         * previous run and includes any requested sleep time) is comparable to the current msStartThisRun;
         * if the delta is significant, we compensate by bumping msStartRun forward by that delta.
         *
         * This shouldn't be triggered when the Debugger halts the CPU, because setSpeed() -- which is called
         * whenever the CPU starts running again -- zeroes msEndThisRun.
         *
         * This also won't do anything about other internal delays; for example, Debugger message() calls.
         * By the time the message() function has called yieldCPU(), the cost of the message has already been
         * incurred, so it will be end up being charged against the instruction(s) that triggered it.
         *
         * TODO: Consider calling yieldCPU() sooner from message(), so that it can arrange for the msEndThisRun
         * "snapshot" to occur sooner; it's unclear, however, whether that will really improve the CPU's ability
         * to hit its target speed, since any instruction that displays a message is unavoidably slooooow.
         */
        let msDelta = 0;
        if (this.msEndThisRun) {
            msDelta = this.msStartThisRun - this.msEndThisRun;
            if (msDelta > this.msPerYield) {
                this.msStartRun += msDelta;
                /**
                 * Bumping msStartRun forward should NEVER cause it to exceed msStartThisRun; however, just
                 * in case, I make absolutely sure it cannot happen, since doing so could result in negative
                 * speed calculations.
                 */

                if (this.msStartRun > this.msStartThisRun) {
                    this.msStartRun = this.msStartThisRun;
                }
            }
        }
    }

    /**
     * calcRemainingTime()
     *
     * @this {CPU}
     * @returns {number}
     */
    calcRemainingTime()
    {
        this.msEndThisRun = Component.getTime();

        if (this.msDiscount) {
            this.msStartRun += this.msDiscount;
            this.msStartThisRun += this.msDiscount;
        }

        let msYield = this.msPerYield;
        if (this.nCyclesThisRun) {
            /**
             * Normally, we would assume we executed a full quota of work over msPerYield, but since the CPU
             * now has the option of calling yieldCPU(), that might not be true.  If nCyclesThisRun is correct, then
             * the ratio of nCyclesThisRun/nCyclesPerYield should represent the percentage of work we performed,
             * and so applying that percentage to msPerYield should give us a better estimate of work vs. time.
             */
            msYield = Math.round(msYield * this.nCyclesThisRun / this.nCyclesPerYield);
        }

        let msElapsedThisRun = this.msEndThisRun - this.msStartThisRun;
        let msRemainsThisRun = msYield - msElapsedThisRun;

        /**
         * We could pass only "this run" results to calcSpeed():
         *
         *      nCycles = this.nCyclesThisRun;
         *      msElapsed = msElapsedThisRun;
         *
         * but it seems preferable to use longer time periods and hopefully get a more accurate speed.
         */
        let nCycles = this.nRunCycles;
        let msElapsed = this.msEndThisRun - this.msStartRun;

        if (MAXDEBUG && msRemainsThisRun < 0 && this.nTargetMultiplier > 1) {
            this.printf("warning: updates @%dms (prefer %dms)\n", msElapsedThisRun, Math.round(msYield));
        }

        this.calcSpeed(nCycles, msElapsed);

        if (msRemainsThisRun < 0) {
            /**
             * Try "throwing out" the effects of large anomalies, by moving the overall run start time up;
             * ordinarily, this should only happen when the someone is using an external Debugger or some other
             * tool or feature that is interfering with our overall execution.
             */
            if (msRemainsThisRun < -1000) {
                this.msStartRun -= msRemainsThisRun;
            }
            /**
             * If the last burst took MORE time than we allotted (ie, it's taking more than 1 second to simulate
             * nBaseCyclesPerSecond), all we can do is yield for as little time as possible (ie, 0ms) and hope
             * that the simulation is at least usable.
             */
            msRemainsThisRun = 0;
        }
        else if (this.mhzCurrent < this.mhzTarget) {
            msRemainsThisRun = 0;
        }

        if (DEBUG) {
            /**
             * Every time the browser gives us another chance to run, we want to display our targets for that run
             * here, followed by what we accomplished in that run.
             */
            this.printf(MESSAGE.CPU, "%3dms run  %3dms wait  %6dcy  %6.2fmhz  %6dms total  %8dcy total  %6.2fmhz total",
                msElapsedThisRun,
                msRemainsThisRun,
                this.nCyclesThisRun,
                Math.round(this.nCyclesThisRun / (msElapsedThisRun * 10)) / 100,
                msElapsed,
                nCycles,
                this.mhzCurrent
            );
        }

        this.msEndThisRun += msRemainsThisRun;

        return msRemainsThisRun;
    }

    /**
     * addTimer(id, callBack, ms)
     *
     * Components that want to have timers that fire after some number of milliseconds call addTimer() to create
     * the timer, and then setTimer() when they want to arm it.  Alternatively, they can specify an automatic timeout
     * value (in milliseconds) to have the timer fire automatically at regular intervals.  There is currently
     * no removeTimer() because these are generally used for the entire lifetime of a component.
     *
     * Internally, each timer entry is a preallocated Array with the following entries:
     *
     *      [0]: timer ID
     *      [1]: countdown value, in cycles
     *      [2]: setTimer value: milliseconds if positive, cycles if negative, zero if not used
     *      [3]: callback function
     *
     * A timer is initially dormant; dormant timers have a countdown value of -1 (although any negative number
     * will suffice) and active timers have a non-negative value.
     *
     * Why not use JavaScript's setTimeout() instead?  Good question.  For a good answer, see setTimer() below.
     *
     * @this {CPU}
     * @param {string} id
     * @param {function()} callBack
     * @param {number} [ms] (setTimer value: milliseconds if positive, cycles if negative, zero if not used)
     * @returns {number} timer index
     */
    addTimer(id, callBack, ms = 0)
    {
        let iTimer = this.aTimers.length;
        this.aTimers.push([id, -1, ms, callBack]);
        if (ms) this.setTimer(iTimer, ms);
        return iTimer;
    }

    /**
     * clearTimer(iTimer)
     *
     * Using the timer index from a previous addTimer() call, this clears that timer.
     *
     * @this {CPU}
     * @param {number} iTimer
     * @returns {boolean}
     */
    clearTimer(iTimer)
    {
        if (iTimer >= 0 && iTimer < this.aTimers.length) {
            this.aTimers[iTimer][1] = -1;
            return true;
        }
        return false;
    }

    /**
     * findTimer(id)
     *
     * @this {CPU}
     * @param {string} id
     * @returns {Array|null}
     */
    findTimer(id)
    {
        for (let iTimer = 0; iTimer < this.aTimers.length; iTimer++) {
            let timer = this.aTimers[iTimer];
            if (timer[0] == id) return timer;
        }
        return null;
    }

    /**
     * isTimerSet(iTimer)
     *
     * @this {CPU}
     * @param {number} iTimer
     * @returns {boolean}
     */
    isTimerSet(iTimer)
    {
        if (iTimer >= 0 && iTimer < this.aTimers.length) {
            return this.aTimers[iTimer][1] >= 0;
        }
        return false;
    }

    /**
     * resetTimers()
     *
     * When the target CPU speed multiplier is altered, it's a good idea to run through all the timers that
     * have a fixed millisecond period and re-arm them, because the timers are using cycle counts that were based
     * on a previous multiplier.
     *
     * @this {CPU}
     */
    resetTimers()
    {
        for (let iTimer = this.aTimers.length - 1; iTimer >= 0; iTimer--) {
            let timer = this.aTimers[iTimer];
            if (timer[2]) this.setTimer(iTimer, timer[2], true);
        }
    }

    /**
     * restoreTimers(aTimerStates)
     *
     * @this {CPU}
     * @param {Array} aTimerStates
     */
    restoreTimers(aTimerStates)
    {
        for (let iTimerState = 0; iTimerState < aTimerStates.length; iTimerState++) {
            let state = aTimerStates[iTimerState];
            let timer = this.findTimer(state[0]);
            if (timer) {
                timer[1] = state[1];
                /**
                 * When restoring from a new state (ie, when state[3] is true), the theory was we could use
                 * state[2] as-is, but in reality, overriding a component's timeout value is problematic, especially
                 * if a component wants to start using a new value (ie, we don't want an old value trumping it).
                 */
                // if (state[3] || state[2] > 0) timer[2] = state[2];
            }
        }
    }

    /**
     * saveTimers()
     *
     * @this {CPU}
     * @returns {Array}
     */
    saveTimers()
    {
        let aTimerStates = [];
        for (let iTimer = 0; iTimer < this.aTimers.length; iTimer++) {
            let timer = this.aTimers[iTimer];
            /**
             * We now push a 4th element (true) to indicate that this is a new timer state, where timer[2] is
             * a tri-state value (positive for milliseconds, negative for cycles, zero for none); previously, it
             * was negative (-1) for none or else some number of milliseconds.
             */
            aTimerStates.push([timer[0], timer[1], timer[2], true]);
        }
        return aTimerStates;
    }

    /**
     * setTimer(iTimer, ms, fReset)
     *
     * Using the timer index from a previous addTimer() call, this sets that timer to fire after the
     * specified number of milliseconds.
     *
     * This is preferred over JavaScript's setTimeout(), because all our timers are effectively paused when
     * the CPU is paused (eg, when the Debugger halts execution).  Moreover, setTimeout() handlers only run after
     * runCPU() yields, which is far too granular for some components (eg, when the SerialPort tries to simulate
     * interrupts at 9600 baud).
     *
     * Ideally, the only function that would use setTimeout() is runCPU(), while the rest of the components
     * use setTimer(); however, due to legacy code (ie, code that predates these functions and/or laziness),
     * that may not be the case.
     *
     * @this {CPU}
     * @param {number} iTimer
     * @param {number} ms (number of milliseconds if positive, cycles otherwise)
     * @param {boolean} [fReset] (true if the timer should be reset even if already armed)
     * @returns {number} (number of cycles used to arm timer, or -1 if error)
     */
    setTimer(iTimer, ms, fReset)
    {
        let nCycles = -1;
        if (iTimer >= 0 && iTimer < this.aTimers.length) {
            let timer = this.aTimers[iTimer];
            if (fReset || timer[1] < 0) {
                nCycles = ms > 0? this.getMSCycles(ms) : -ms;
                /**
                 * If the CPU is currently executing a burst of cycles, the number of cycles it has executed in
                 * that burst so far must NOT be charged against the cycle timeout we're about to set.  The simplest
                 * way to resolve that is to immediately call endBurst() and bias the cycle timeout by the number
                 * of cycles that the burst executed.
                 */
                if (this.flags.running) {
                    nCycles += this.endBurst();
                }
                timer[1] = nCycles;
            }
        }
        return nCycles;
    }

    /**
     * updateTimers(nCycles)
     *
     * Used by runCPU() to reduce all active timer countdown values by the number of cycles just executed;
     * this is the function that actually "fires" any timer(s) whose countdown has reached (or dropped below)
     * zero, invoking their callback function.
     *
     * @this {CPU}
     * @param {number} nCycles (number of cycles actually executed)
     */
    updateTimers(nCycles)
    {
        for (let iTimer = this.aTimers.length - 1; iTimer >= 0; iTimer--) {
            let timer = this.aTimers[iTimer];

            if (timer[1] < 0) continue;
            timer[1] -= nCycles;
            if (timer[1] <= 0) {
                if (DEBUG) {
                    this.printf(MESSAGE.CPU + MESSAGE.TIMER, "updateTimer(%d): firing %s with only %d cycles left\n", nCycles, timer[0], (timer[1] + nCycles));
                }
                timer[1] = -1;      // zero is technically an "active" value, so ensure the timer is dormant now
                timer[3]();         // safe to invoke the callback function now
                if (timer[2]) {
                    this.setTimer(iTimer, timer[2]);
                    if (DEBUG) {
                        this.printf(MESSAGE.CPU + MESSAGE.TIMER, "updateTimer(%d): rearming %s for %dms (%d cycles)\n", nCycles, timer[0], timer[2], timer[1]);
                    }
                }
            }
        }
    }

    /**
     * getMSCycles(ms)
     *
     * @this {CPU}
     * @param {number} ms
     * @returns {number} number of corresponding cycles
     */
    getMSCycles(ms)
    {
        return ((this.nBaseCyclesPerSecond * this.nCurrentMultiplier) / 1000 * ms)|0;
    }

    /**
     * getBurstCycles(nCycles)
     *
     * @this {CPU}
     * @param {number} nCycles (maximum number of cycles to execute)
     * @returns {number}
     */
    getBurstCycles(nCycles)
    {
        for (let iTimer = this.aTimers.length - 1; iTimer >= 0; iTimer--) {
            let timer = this.aTimers[iTimer];

            if (timer[1] < 0) continue;
            if (nCycles > timer[1]) {
                nCycles = timer[1];
            }
        }
        return nCycles;
    }

    /**
     * endBurst()
     *
     * @this {CPU}
     * @returns {number} (number of cycles executed in the most recent burst)
     */
    endBurst()
    {
        let nCycles = this.nBurstCycles - this.nStepCycles;
        this.nBurstCycles = this.nStepCycles = 0;
        this.nCyclesThisRun += nCycles;
        this.nRunCycles += nCycles;
        return nCycles;
    }

    /**
     * runCPU()
     *
     * @this {CPU}
     */
    runCPU()
    {
        this.idRunTimeout = 0;
        if (!this.flags.running) return;

        let msRunStart = 0, msRunStop = 0, nRunCycles = 0;
        if (DEBUG) msRunStart = Component.getTime();

        /**
         *  calcStartTime() initializes the cycle counter and timestamp for this runCPU() invocation.
         */
        this.calcStartTime();

        try {
            this.flags.yield = false;
            do {
                /**
                 * getBurstCycles() tells us how many cycles to execute as a burst.  The answer will always
                 * be less than getCurrentCyclesPerSecond(), because at the very least, our own timer fires more than
                 * once per second.
                 */
                let nCycles = this.getBurstCycles(this.flags.checksum? 1 : this.getCurrentCyclesPerSecond());

                if (this.chipset) {
                    this.chipset.updateAllTimers();
                    nCycles = this.chipset.getTimerCycleLimit(0, nCycles);
                    nCycles = this.chipset.getRTCCycleLimit(nCycles);
                }
                /**
                 * Execute the burst.
                 */
                try {
                    this.stepCPU(nCycles);
                }
                catch(exception) {
                    if (typeof exception != "number") throw exception;
                    if (MAXDEBUG) this.printf("CPU exception %#04x\n", exception);
                    /**
                     * TODO: If we ever get into a situation where every single instruction is generating a fault
                     * (eg, if an 8088 executes opcode 0xFF 0xFF, which is incorrectly routed to helpFault() instead
                     * of fnGRPUndefined()), the browser may hang because we're failing to yield often enough.
                     * This is likely because the thrown exceptions are taking MUCH longer than normal instructions,
                     * throwing off our burst calculations.  We need to either adjust the burst or break out of the
                     * DO-WHILE loop on every exception.
                     */
                }

                /**
                 * Terminate the burst, returning the number of cycles that stepCPU() actually ran.  If this
                 * returns zero, then presumably someone already called endBurst(), such as stopCPU(), and already
                 * took care of all the timers.
                 */
                nCycles = this.endBurst();
                if (nCycles) {
                    nRunCycles += nCycles;
                    this.updateTimers(nCycles);
                    this.updateChecksum(nCycles);
                }
            } while (this.flags.running && !this.flags.yield);
        }
        catch (e) {
            this.stopCPU();
            this.updateCPU();
            if (this.cmp) this.cmp.stop(Component.getTime(), this.getCycles());
            this.setError(e.stack || e.message);
            return;
        }

        if (DEBUG) {
            msRunStop = Component.getTime();
            this.addTimeLog(nRunCycles, this.getCycles(), msRunStart, msRunStop - msRunStart);
        }

        if (this.flags.running) {

            let msTimeout = this.calcRemainingTime();
            if (DEBUG) this.addTimeLog(0, 0, msRunStop, msTimeout);
            this.idRunTimeout = setTimeout(this.onRunTimeout, msTimeout);
        }
    }

    /**
     * startCPU(fUpdateFocus)
     *
     * For use by any component that wants to start the CPU.
     *
     * @param {boolean} [fUpdateFocus]
     * @param {boolean} [fQuiet]
     * @returns {boolean}
     */
    startCPU(fUpdateFocus, fQuiet)
    {
        if (this.isError()) {
            return false;
        }
        if (this.flags.running) {
            if (!fQuiet) this.printf(MESSAGE.NONE, "%s busy\n", this.toString());
            return false;
        }
        if (this.idRunTimeout) {
            clearTimeout(this.idRunTimeout);
            this.idRunTimeout = 0;
        }
        /**
         *  setSpeed() without a speed parameter leaves the selected speed in place, but also resets the
         *  cycle counter and timestamp for the current series of runCPU() calls, and calculates the maximum number
         *  of cycles for each burst based on the last known effective CPU speed.
         */
        this.setSpeed();
        this.flags.running = true;
        this.flags.starting = true;
        if (this.chipset) this.chipset.start();
        let controlRun = this.bindings["run"];
        if (controlRun) controlRun.textContent = "Halt";
        if (this.cmp) {
            this.cmp.updateStatus(true);
            if (fUpdateFocus) this.cmp.updateFocus();
            this.cmp.start(Component.getTime(), this.getCycles());
        }

        this.idRunTimeout = setTimeout(this.onRunTimeout, 0);
        return true;
    }

    /**
     * stepCPU(nMinCycles)
     *
     * This will be implemented by the CPUx86 component.
     *
     * @this {CPU}
     * @param {number} nMinCycles (0 implies a single-step, and therefore breakpoints should be ignored)
     * @returns {number} of cycles executed; 0 indicates that the last instruction was not executed
     */
    stepCPU(nMinCycles)
    {
        return 0;
    }

    /**
     * stopCPU(fComplete)
     *
     * For use by any component that wants to stop the CPU.
     *
     * @this {CPU}
     * @param {boolean} [fComplete]
     * @returns {boolean} true if the CPU was stopped, false if it was already stopped
     */
    stopCPU(fComplete)
    {
        let fStopped = false;
        if (this.flags.running) {
            let nCycles = this.endBurst();
            if (nCycles) {
                this.updateTimers(nCycles);
                this.updateChecksum(nCycles);
            }
            this.addCycles(this.nRunCycles);
            this.nRunCycles = 0;
            this.flags.running = false;
            if (this.chipset) this.chipset.stop();
            let controlRun = this.bindings["run"];
            if (controlRun) controlRun.textContent = "Run";
            if (this.cmp) {
                this.cmp.stop(Component.getTime(), this.getCycles());
                this.cmp.updateStatus(true);
            }
            if (!this.dbg) this.printf(MESSAGE.STATUS, "Stopped\n");
            fStopped = true;
        }
        this.flags.complete = fComplete;
        return fStopped;
    }

    /**
     * nonCPU(fn)
     *
     * Use this function to perform any work outside the scope of the CPU (eg, DOM updates),
     * to prevent that work from disrupting our speed calculations.
     *
     * @this {CPU}
     * @param {function()} fn (should return true only if the function actually performed any work)
     * @returns {boolean}
     */
    nonCPU(fn)
    {
        let msStart = Component.getTime();
        if (fn()) {
            let msStop = Component.getTime();
            this.msDiscount += msStop - msStart;
            return true;
        }
        return false;
    }

    /**
     * updateCPU(fForce)
     *
     * This used to be performed at the end of every stepCPU(), but runCPU() -- which relies upon
     * stepCPU() -- needed to have more control over when these updates are performed.  However, for
     * other callers of stepCPU(), such as the Debugger, the combination of stepCPU() + updateCPU()
     * provides the old behavior.
     *
     * @this {CPU}
     * @param {boolean} [fForce] (true to force a Computer update; used by the Debugger)
     */
    updateCPU(fForce)
    {
        if (this.cmp) this.cmp.updateStatus(fForce);
    }

    /**
     * yieldCPU()
     *
     * Similar to stopCPU() with regard to how it resets various cycle countdown values, but the CPU
     * remains in a "running" state.
     *
     * @this {CPU}
     */
    yieldCPU()
    {
        this.flags.yield = true;
        /**
         * The Debugger calls yieldCPU() after every message() to ensure browser responsiveness, but it looks
         * odd for those messages to show CPU state changes but for the CPU's own status display to not (ditto
         * for the Video display), so I've added this call to try to keep things looking synchronized.
         */
        this.updateCPU();
    }
}

/**
 * @copyright https://www.pcjs.org/machines/pcx86/modules/v2/cpux86.js (C) 2012-2024 Jeff Parsons
 */

/**
 * @class CPUx86
 * @unrestricted (allows the class to define properties, both dot and named, outside of the constructor)
 */
class CPUx86 extends CPU {

    /**
     * NOTE: CPUx86.PFINFO.LENGTH must be set to a power of two, so that LENGTH - 1 will form a mask
     * (IP_MASK) we can use to create a sliding prefetch window of LENGTH bytes.  We also zero the low
     * 2 bits of IP_MASK so that the sliding window always starts on a 32-bit (long) boundary.  Finally,
     * instead of breaking all the longs we prefetch into bytes, we simply store the longs as-is into
     * every 4th element of the queue (the queue is a sparse array).
     */
    static PFLEN = 16;                  // 16 generates a 16-byte prefetch queue consisting of 4 32-bit entries
    static PFINFO = {
        LENGTH:     CPUx86.PFLEN,
        IP_MASK:    ((CPUx86.PFLEN - 1) & ~0x3)
    };

    static PAGEBLOCKS_CACHE = 512;      // TODO: This seems adequate for 4Mb of RAM, but it should be dynamically reconfigured

    /**
     * CPUx86(parmsCPU)
     *
     * The CPUx86 class uses the following (parmsCPU) properties:
     *
     *      model: a string (eg, "8088") that should match one of the X86.MODEL values (default is "8088")
     *      stepping: a string (eg, "B1") that should match one of the X86.STEPPING values (default is "")
     *
     * This extends the CPU class and passes any remaining parmsCPU properties to the CPU class
     * constructor, along with a default speed (cycles per second) based on the specified (or default)
     * CPU model number.
     *
     * The CPUx86 class was initially written to simulate a 8086/8088 microprocessor, although over time
     * it has evolved to support later microprocessors (eg, the 80186/80188 and the 80286, including
     * protected-mode support).
     *
     * This is a logical simulation, not a physical simulation, and performance is critical, second only
     * to the accuracy of the simulation when running real-world x86 software.  Consequently, it takes a
     * few liberties with the operation of the simulated hardware, especially with regard to timings,
     * little-used features, etc.  We do make an effort to maintain approximate instruction cycle counts,
     * but there are many other obstacles (eg, prefetch queue, wait states) to achieving accurate timings.
     *
     * For example, our 8237 DMA controller performs all DMA transfers immediately, since internally
     * they are all memory-to-memory, and attempting to interleave DMA cycles with instruction execution
     * cycles would hurt overall performance.  Similarly, 8254 timer counters are updated only on-demand.
     *
     * The 8237 and 8254, along with the 8259 interrupt controller and several other "chips", are combined
     * into a single ChipSet component, to keep the number of components we juggle to a minimum.
     *
     * All that being said, this does not change the overall goal: to produce as accurate a simulation as
     * possible, within the limits of what JavaScript allows and how precisely/predictably it behaves.
     *
     * @this {CPUx86}
     * @param {Object} parmsCPU
     */
    constructor(parmsCPU)
    {
        let nCyclesDefault;
        let model = +parmsCPU['model'] || X86.MODEL_8088;

        switch(model) {
        case X86.MODEL_8088:
        default:
            nCyclesDefault = 4772727;
            break;
        case X86.MODEL_80286:
            nCyclesDefault = 6000000;
            break;
        case X86.MODEL_80386:
            nCyclesDefault = 16000000;
            break;
        }

        super(parmsCPU, nCyclesDefault);

        this.model = model;

        /**
         * We take the 'stepping' value, convert it to a hex value, and then add that to the model to provide
         * a single value that's unique for any given CPU stepping.  If no stepping is provided, then stepping
         * is equal to model.
         */
        let stepping = parmsCPU['stepping'];
        this.stepping = model + (stepping? StrLib.parseInt(stepping, 16) : 0);

        /**
         * Initialize processor operation to match the requested model
         */
        this.initProcessor();

        /**
         * List of software interrupt notification functions: aIntNotify is an array, indexed by
         * interrupt number, where each element contains:
         *
         *      registered function to call for every software interrupt
         *
         * The registered function is called with the linear address (LIP) following the software interrupt;
         * if any function returns false, the software interrupt will be skipped (presumed to be emulated),
         * and no further notification functions will be called.
         *
         * NOTE: Registered functions are called only for INT N instructions -- *not* INT 0x03 or INTO or the
         * INT 0x00 generated by a divide-by-zero or any other kind of interrupt (nor any interrupt simulated
         * with PUSHF/CALLF).
         *
         * aIntReturn is a hash of return address notifications set up by software interrupt notification
         * functions that want to receive return notifications.  A software interrupt function must call
         * cpu.addIntReturn(fn).
         *
         * WARNING: There's no mechanism in place to insure that software interrupt return notifications don't
         * get "orphaned" if an interrupt handler bypasses the normal return path (INT 0x24 is one example of an
         * "evil" software interrupt).
         */
        this.aIntNotify = [];
        this.aIntReturn = [];

        /**
         * Since aReturnNotify is a "sparse array", this global count gives the CPU a quick way of knowing whether
         * or not RETF or IRET instructions need to bother calling checkIntReturn().
         */
        this.cIntReturn = 0;

        /**
         * A variety of stepCPU() state variables that don't strictly need to be initialized before the first
         * stepCPU() call, but it's good form to do so.
         */
        this.resetCycles();
        this.flags.complete = this.flags.debugCheck = false;

        /**
         * If there are no live registers to display, then updateStatus() can skip a bit....
         */
        this.cLiveRegs = 0;

        /**
         * We're just declaring aMemBlocks and associated Bus parameters here; they'll be initialized by initMemory()
         * when the Bus is initialized.
         */
        this.aBusBlocks = this.aMemBlocks = [];
        this.nBusMask = this.nMemMask = -1;
        this.nBlockShift = this.nBlockSize = this.nBlockLimit = this.nBlockTotal = this.nBlockMask = 0;

        if (PREFETCH) {
            this.cbPrefetch = 0;
            this.adwPrefetch = null;
        }

        /**
         * This initial resetRegs() call is important to create all the registers (eg, the Segx86 registers),
         * so that if/when we call restore(), it will have something to fill in.
         */
        this.resetRegs();
    }

    /**
     * initMemory(aMemBlocks, nBlockShift)
     *
     * Notification from Bus.initMemory(), giving us direct access to the entire memory space
     * (aMemBlocks).  Since the CPU must perform additional layers of address decoding depending
     * on the mode (real-mode, protected-mode, paging), it's best if the CPU can avoid going
     * through the Bus component for every memory access.
     *
     * We also initialize a 32-bit prefetch queue, containing dword-aligned values; the queue is
     * an array of dwords indexed by a masked regLIP; for example, a queue of 4 dwords is indexed
     * by "regLIP & 0xC"; we use a sparse array to avoid right-shifting the index, like so:
     *
     *      0:  [dword]
     *      4:  [dword]
     *      8:  [dword]
     *     12:  [dword]
     *
     * The actual regLIP mask is CPUx86.PFINFO.IP_MASK; ie, (CPUx86.PFINFO.LENGTH - 1) & ~0x3.
     *
     * On refilling, the queue is always filled to capacity, and cbPrefetch is set to its maximum
     * value (eg, a value from 16 to 13, depending on whether "regLIP & 0x3" is 0, 1, 2 or 3).
     *
     * When a byte is requested from the queue, the dword is extracted from index "regLIP & 0xC"
     * and then shifted by 0, 8, 16, or 24, depending on whether "regLIP & 0x3" is 0, 1, 2 or 3
     * (ie, "(regLIP & 0x3) << 3").
     *
     * TODO: Consider how/whether to simulate an effective prefetch queue size of 4 bytes for an 8088,
     * 6 bytes for an 8086, 12 for an 80386, etc.
     *
     * @this {CPUx86}
     * @param {Array} aMemBlocks
     * @param {number} nBlockShift
     */
    initMemory(aMemBlocks, nBlockShift)
    {
        /**
         * aBusBlocks preserves the Bus block array for the life of the machine, whereas aMemBlocks
         * will be altered if/when the CPU enables paging.  PAGEBLOCKS must be true when using Memory
         * blocks to simulate paging, ensuring that physical blocks and pages have the same size (4Kb).
         */
        this.aBusBlocks = this.aMemBlocks = aMemBlocks;
        this.nBlockShift = nBlockShift;
        this.nBlockSize = 1 << this.nBlockShift;
        this.nBlockLimit = this.nBlockSize - 1;
        this.nBlockTotal = aMemBlocks.length;
        this.nBlockMask = this.nBlockTotal - 1;
        if (PREFETCH) {
         // this.nBusCycles = 0;
            this.adwPrefetch = new Array(CPUx86.PFINFO.LENGTH);
        }
    }

    /**
     * setAddressMask(nBusMask)
     *
     * Notification from Bus.initMemory() and Bus.setA20(); the latter calls us whenever the physical
     * A20 line changes (note that on a 20-bit bus machine, address lines A20 and higher are always zero).
     *
     * For 32-bit bus machines (eg, 80386), nBusMask is never changed after the initial call, because A20
     * wrap-around is simulated by changing the physical memory map rather than altering the A20 bit in nBusMask.
     *
     * We maintain nMemMask separate from nBusMask, because when paging is enabled on the 80386, the CPU memory
     * functions are now dealing with linear addresses rather than physical addresses, so it would be incorrect
     * to apply nBusMask to those addresses; nMemMask must remain 0xffffffff (-1) for the duration.  If we change
     * how A20 is simulated on the 80386, then enablePageBlocks() and disablePageBlocks() will need to override
     * nMemMask appropriately.
     *
     * TODO: Ideally, we would eliminate masking altogether of 32-bit addresses, but that would require different
     * sets of memory access functions for different machines (ie, those with 20-bit or 24-bit buses).
     *
     * @this {CPUx86}
     * @param {number} nBusMask
     */
    setAddressMask(nBusMask)
    {
        this.nBusMask = this.nMemMask = nBusMask;
    }

    /**
     * addMemBreak(addr, fWrite, fPhysical)
     *
     * NOTE: addMemBreak() could be merged with addMemCheck(), but the new merged interface would
     * have to provide one additional parameter indicating whether the Debugger or the CPU is the client.
     *
     * For now, this is simply a DEBUGGER-only interface.
     *
     * @this {CPUx86}
     * @param {number} addr
     * @param {boolean} fWrite is true for a memory write breakpoint, false for a memory read breakpoint
     * @param {boolean} [fPhysical] (true for physical breakpoint, false for linear)
     * @returns {boolean}
     */
    addMemBreak(addr, fWrite, fPhysical)
    {
        if (DEBUGGER) {
            let iBlock = addr >>> this.nBlockShift;
            let aBlocks = (fPhysical? this.aBusBlocks : this.aMemBlocks);
            if (aBlocks[iBlock]) {
                aBlocks[iBlock].addBreakpoint(addr & this.nBlockLimit, fWrite);
                /**
                 * When a physical memory breakpoint is added, a fresh setPhysBlock() call is REQUIRED for any
                 * linear mappings to that address.  This is a bit of a sledgehammer solution, but at least it's a solution.
                 */
                if (fPhysical) this.flushPageBlocks();
                return true;
            }
        }
        return false;
    }

    /**
     * removeMemBreak(addr, fWrite, fPhysical)
     *
     * NOTE: removeMemBreak() could be merged with removeMemCheck(), but the new merged interface would
     * have to provide one additional parameter indicating whether the Debugger or the CPU is the client.
     *
     * For now, this is simply a DEBUGGER-only interface.
     *
     * @this {CPUx86}
     * @param {number} addr
     * @param {boolean} fWrite is true for a memory write breakpoint, false for a memory read breakpoint
     * @param {boolean} [fPhysical] (true for physical breakpoint, false for linear)
     */
    removeMemBreak(addr, fWrite, fPhysical)
    {
        if (DEBUGGER) {
            let iBlock = addr >>> this.nBlockShift;
            let aBlocks = (fPhysical? this.aBusBlocks : this.aMemBlocks);
            aBlocks[iBlock].removeBreakpoint(addr & this.nBlockLimit, fWrite);
            /**
             * When a physical memory breakpoint is removed, a fresh setPhysBlock() call is RECOMMENDED for any
             * linear mappings to that address.  This is a bit of a sledgehammer solution, but at least it's a solution.
             */
            if (fPhysical) this.flushPageBlocks();
        }
    }

    /**
     * addMemCheck(addr, fWrite)
     *
     * These functions provide Debug register functionality to the CPU by leveraging the same Memory block-based
     * breakpoint support originally created for our built-in Debugger.  Only minimal changes were required to the
     * Memory component, by adding additional checkMemoryException() call-outs from the "checked" Memory access
     * functions.
     *
     * Note that those call-outs occur only AFTER our own Debugger (if present) has checked the address and has
     * passed on it, because we want our own Debugger's breakpoints to take precedence over any breakpoints that
     * the emulated machine may have enabled.
     *
     * @this {CPUx86}
     * @param {number} addr
     * @param {boolean} fWrite is true for a memory write check, false for a memory read check
     */
    addMemCheck(addr, fWrite)
    {
        let iBlock = addr >>> this.nBlockShift;
        this.aMemBlocks[iBlock].addBreakpoint(addr & this.nBlockLimit, fWrite, this);
    }

    /**
     * removeMemCheck(addr, fWrite)
     *
     * @this {CPUx86}
     * @param {number} addr
     * @param {boolean} fWrite is true for a memory write check, false for a memory read check
     */
    removeMemCheck(addr, fWrite)
    {
        let iBlock = addr >>> this.nBlockShift;
        this.aMemBlocks[iBlock].removeBreakpoint(addr & this.nBlockLimit, fWrite);
    }

    /**
     * enablePageBlocks()
     *
     * Whenever the CPU turns on paging and/or updates CR3, this function is called to update our copy
     * of the Bus block array, to simulate paging.  Whenever the CPU turns paging off, disablePageBlocks()
     * must be called to restore our copy of the Bus block array to its original (physical) mapping.
     *
     * This also requires PAGEBLOCKS be enabled, to ensure the Bus is configured with a 4Kb block size.
     *
     * The first time this function is called, aMemBlocks and aBusBlocks are identical, so aMemBlocks is
     * reinitialized with special UNPAGED Memory blocks that know how to perform page directory/page table
     * lookup and replace themselves with special PAGED Memory blocks that reference memory from the
     * appropriate block in aBusBlocks.  A parallel array, aBlocksPaged, keeps track (by block number) of
     * which blocks have been PAGED, so that whenever CR3 is updated, those blocks can be quickly UNPAGED.
     *
     * @this {CPUx86}
     */
    enablePageBlocks()
    {
        if (!PAGEBLOCKS) {
            this.setError("PAGEBLOCKS support required");
            return;
        }
        let iBlock;
        if (this.aMemBlocks === this.aBusBlocks) {
            this.aMemBlocks = new Array(this.nBlockTotal);
            /**
             * TODO: Currently we allocate only one UNPAGED block for the entire linear address space;
             * only when a block is touched and becomes PAGED do we allocate a dedicated Memory block
             * for that slot.  One potential downside to using a single UNPAGED block, however, is that
             * it will accumulate all breakpoints for all UNPAGED blocks, requiring copyBreakpoints() to
             * do extra work to figure out which breakpoints should be copied (ie, removed) from the
             * outgoing block -- which it can't currently do, because blocks only keep track of the total
             * number of breakpoints, not the actual breakpoint addresses.
             *
             * So, Memory blocks either need to start maintaining their own breakpoint address lists,
             * or we need to allocate separate (empty) UNPAGED blocks for every slot.  I've not tackled
             * this yet, because it's largely just a debugging issue.
             *
             * Notice that when we call copyBreakpoints() here, it's merely to initialize the new block;
             * we make no attempt to copy any breakpoints from physical blocks to linear blocks, although
             * perhaps we should.  The plan for our Debugger is to maintain separate physical and linear
             * breakpoint address lists, but what about CPU Debug registers?  If the CPU sets the Debug
             * registers, then enables paging, do all the previous Debug register addresses automatically
             * become linear addresses?  I'm guessing they do.
             */
            this.blockUnpaged = new Memoryx86(undefined, 0, 0, Memoryx86.TYPE.UNPAGED, null, this);
            this.blockUnpaged.copyBreakpoints(this.dbg);
            for (iBlock = 0; iBlock < this.nBlockTotal; iBlock++) {
                this.aMemBlocks[iBlock] = this.blockUnpaged;
            }
            /**
             * We also use a special "empty" Memory block that mapPageBlock() can pass back to callers
             * whenever a valid block cannot be found for an UNPAGED block.  Under normal conditions,
             * an invalid block will trigger a fault, so memEmpty will never actually be returned, but
             * if the Debugger is suppressing faults or calling probeAddr(), returning memEmpty is helpful.
             */
            this.memEmpty = new Memoryx86();

            /**
             * Initialize our PAGEBLOCKS cache (see acquirePageBlock() and releasePageBlock()).
             */
            this.aCacheBlocks = new Array(CPUx86.PAGEBLOCKS_CACHE);
            this.iCacheBlocks = 0;
        } else {
            /**
             * Our equivalent of a TLB flush.  NOTE: We do not attempt to simulate an actual TLB; our
             * aMemBlocks array will "cache" as many pages (ie, allow as many PAGED block) as there are
             * entries in the array.  I'm assuming we won't run into any system software that relies on
             * a constrained TLB -- at least not from the 80386 era, which is all we're emulating.
             */
            for (let i = 0; i < this.aBlocksPaged.length; i++) {
                iBlock = this.aBlocksPaged[i];
                this.releasePageBlock(this.aMemBlocks[iBlock]);
                this.aMemBlocks[iBlock] = this.blockUnpaged;
            }
        }
        this.aBlocksPaged = [];
    }

    /**
     * flushPageBlocks()
     *
     * @this {CPUx86}
     */
    flushPageBlocks()
    {
        if (this.regCR0 & X86.CR0.PG) this.enablePageBlocks();
    }

    /**
     * acquirePageBlock(addr)
     *
     * This implements a simple paged memory block cache.  Candidates for caching must be released via
     * releasePageBlock().
     *
     * After acquiring a block from this cache, the caller MUST use setPhysBlock() to properly reinitialize
     * it for the new given linear address.
     *
     * @this {CPUx86}
     * @param {number} addr
     * @returns {Memoryx86}
     */
    acquirePageBlock(addr)
    {
        let block;
        if (this.iCacheBlocks > 0) {
            block = this.aCacheBlocks[--this.iCacheBlocks];
            /**
             * Paged memory blocks are all very generic and contain no memory of their own, so the fact
             * that we're not calling the Memory constructor to reinitialize it is OK.  setPhysBlock() is
             * what's critical, and the caller will take care of that.  However, to avoid any confusion,
             * especially when debugging, there are a few properties we should reinitialize, hence init().
             */
            block.init(addr);
        } else {
            block = new Memoryx86(addr, 0, 0, Memoryx86.TYPE.PAGED);
        }
        return block;
    }

    /**
     * releasePageBlock(block)
     *
     * Instead of simply tossing Memory blocks onto the garbage collector's heap, we'll retain a maximum
     * number (CPUx86.PAGEBLOCKS_CACHE) in aCacheBlocks, with iCacheBlocks pointing to the next free element.
     *
     * @this {CPUx86}
     * @param {Memoryx86} block
     */
    releasePageBlock(block)
    {

        if (this.iCacheBlocks < CPUx86.PAGEBLOCKS_CACHE) {
            this.aCacheBlocks[this.iCacheBlocks++] = block;
        }
    }

    /**
     * mapPageBlock(addr, fWrite, fSuppress)
     *
     * Locate the corresponding physical PDE, PTE and memory blocks for the given linear address, and then
     * upgrade the block from an UNPAGED Memory block to a new PAGED Memory block; all future accesses to
     * the current page will go directly to that block, instead of coming here through the UNPAGED block
     * handlers.
     *
     * Note that since the incoming address (addr) is a linear address, we never need to mask it with nBusMask,
     * but all the intermediate (PDE, PTE) and final physical addresses we calculate should still be masked.
     *
     * Granted, nBusMask on a 32-bit bus is generally going to be 0xffffffff (-1), so masking might seem like
     * a waste of time; however, if we decide to once again rely on nBusMask for emulating A20 wrap-around
     * (instead of changing the physical memory map to alias the 2nd Mb to the 1st Mb), then performing
     * consistent masking will be important.
     *
     * Also, addrPDE, addrPTE and addrPhys do not need any offsets added to them, because we immediately shift
     * the offset portion of those addresses out.  But for now, at least for debugging and documentation purposes,
     * my preference is to include the offset in the address calculations.
     *
     * Besides, this should not be a performance-critical function; it's normally called only once per UNPAGED
     * page.  Obviously, if CR3 is constantly being updated, that will trigger repeated calls to enablePageBlocks(),
     * which will perform our equivalent of a TLB flush (ie, resetting all PAGED blocks back to UNPAGED blocks).
     * That would hurt our performance, but it would hurt performance on a real machine as well, so presumably
     * CR3 updates will be minimal.
     *
     * @this {CPUx86}
     * @param {number} addr is a linear address
     * @param {boolean} fWrite (true if called for a write, false if for a read)
     * @param {boolean} [fSuppress] (true if any faults, remapping, etc should be suppressed)
     * @returns {Memoryx86}
     */
    mapPageBlock(addr, fWrite, fSuppress)
    {
        let offPDE = (addr & X86.LADDR.PDE.MASK) >>> X86.LADDR.PDE.SHIFT;
        let addrPDE = this.regCR3 + offPDE;

        /**
         * bus.getLong(addrPDE) would be simpler, but setPhysBlock() needs to know blockPDE and offPDE, too.
         * TODO: Since we're immediately shifting addrPDE by nBlockShift, then we could also skip adding offPDE.
         */
        let blockPDE = this.aBusBlocks[(addrPDE & this.nBusMask) >>> this.nBlockShift];
        let pde = blockPDE.readLong(offPDE);

        if (!(pde & X86.PTE.PRESENT)) {
            if (!fSuppress) X86.helpPageFault.call(this, addr, false, fWrite);
            return this.memEmpty;
        }

        if (!(pde & X86.PTE.USER) && this.nCPL == 3) {
            if (!fSuppress) X86.helpPageFault.call(this, addr, true, fWrite);
            return this.memEmpty;
        }

        let offPTE = (addr & X86.LADDR.PTE.MASK) >>> X86.LADDR.PTE.SHIFT;
        let addrPTE = (pde & X86.PTE.FRAME) + offPTE;

        /**
         * bus.getLong(addrPTE) would be simpler, but setPhysBlock() needs to know blockPTE and offPTE, too.
         * TODO: Since we're immediately shifting addrPDE by nBlockShift, then we could also skip adding offPTE.
         */
        let blockPTE = this.aBusBlocks[(addrPTE & this.nBusMask) >>> this.nBlockShift];
        let pte = blockPTE.readLong(offPTE);

        if (!(pte & X86.PTE.PRESENT)) {
            if (!fSuppress) X86.helpPageFault.call(this, addr, false, fWrite);
            return this.memEmpty;
        }

        if (!(pte & X86.PTE.USER) && this.nCPL == 3) {
            if (!fSuppress) X86.helpPageFault.call(this, addr, true, fWrite);
            return this.memEmpty;
        }

        let addrPhys = (pte & X86.PTE.FRAME) + (addr & X86.LADDR.OFFSET);
        /**
         * TODO: Since we're immediately shifting addrPhys by nBlockShift, we could also skip adding the addr's offset.
         */
        let blockPhys = this.aBusBlocks[(addrPhys & this.nBusMask) >>> this.nBlockShift];
        if (fSuppress) return blockPhys;

        let iBlock = addr >>> this.nBlockShift;
        let block = this.aMemBlocks[iBlock];

        /**
         * So we have the block containing the physical memory corresponding to the given linear address.
         *
         * Now we can create a new PAGED Memory block and record the physical block info using setPhysBlock().
         */
        let blockPage = this.acquirePageBlock(addr & ~X86.LADDR.OFFSET);
        blockPage.setPhysBlock(blockPhys, blockPDE, offPDE, blockPTE, offPTE);
        blockPage.copyBreakpoints(this.dbg, block);

        this.aMemBlocks[iBlock] = blockPage;
        this.aBlocksPaged.push(iBlock);

        return blockPage;
    }

    /**
     * disablePageBlocks()
     *
     * Whenever the CPU turns off paging, this function restores the CPU's original aMemBlocks.
     *
     * @this {CPUx86}
     */
    disablePageBlocks()
    {
        if (this.aMemBlocks !== this.aBusBlocks) {
            this.aMemBlocks = this.aBusBlocks;
            this.blockUnpaged = null;
            this.aBlocksPaged = null;
            this.memEmpty = null;
        }
    }

    /**
     * isPagingEnabled()
     *
     * @this {CPUx86}
     * @returns {boolean}
     */
    isPagingEnabled()
    {
        let fPaging = !!(this.regCR0 & X86.CR0.PG);

        return fPaging;
    }

    /**
     * initProcessor()
     *
     * This isolates 80186/80188/80286/80386 support, so that it can be selectively enabled/tested.
     *
     * Here's a summary of 80186/80188 differences according to "AP-186: Introduction to the 80186
     * Microprocessor, March 1983" (pp.55-56).  "The iAPX 86,88 and iAPX 186,188 User's Manual Programmer's
     * Reference", p.3-38, apparently contains the same information, but I've not seen that document.
     *
     * Undefined [Invalid] Opcodes:
     *
     *      When the opcodes 63H, 64H, 65H, 66H, 67H, F1H, FEH/xx111xxxB and FFH/xx111xxxB are executed,
     *      the 80186 will execute an illegal [invalid] instruction exception, interrupt 0x06.
     *      The 8086 will ignore the opcode.
     *
     * 0FH opcode:
     *
     *      When the opcode 0FH is encountered, the 8086 will execute a POP CS, while the 80186 will
     *      execute an illegal [invalid] instruction exception, interrupt 0x06.
     *
     * Word Write at Offset FFFFH:
     *
     *      When a word write is performed at offset FFFFH in a segment, the 8086 will write one byte
     *      at offset FFFFH, and the other at offset 0, while the 80186 will write one byte at offset
     *      FFFFH, and the other at offset 10000H (one byte beyond the end of the segment). One byte segment
     *      underflow will also occur (on the 80186) if a stack PUSH is executed and the Stack Pointer
     *      contains the value 1.
     *
     * Shift/Rotate by Value Greater Then [sic] 31:
     *
     *      Before the 80186 performs a shift or rotate by a value (either in the CL register, or by an
     *      immediate value) it ANDs the value with 1FH, limiting the number of bits rotated to less than 32.
     *      The 8086 does not do this.
     *
     * LOCK prefix:
     *
     *      The 8086 activates its LOCK signal immediately after executing the LOCK prefix. The 80186 does
     *      not activate the LOCK signal until the processor is ready to begin the data cycles associated
     *      with the LOCKed instruction.
     *
     * Interrupted String Move Instructions:
     *
     *      If an 8086 is interrupted during the execution of a repeated string move instruction, the return
     *      value it will push on the stack will point to the last prefix instruction before the string move
     *      instruction. If the instruction had more than one prefix (e.g., a segment override prefix in
     *      addition to the repeat prefix), it will not be re-executed upon returning from the interrupt.
     *      The 80186 will push the value of the first prefix to the repeated instruction, so long as prefixes
     *      are not repeated, allowing the string instruction to properly resume.
     *
     * Conditions causing divide error with an integer divide:
     *
     *      The 8086 will cause a divide error whenever the absolute value of the quotient is greater then
     *      [sic] 7FFFH (for word operations) or if the absolute value of the quotient is greater than 7FH
     *      (for byte operations). The 80186 has expanded the range of negative numbers allowed as a quotient
     *      by 1 to include 8000H and 80H. These numbers represent the most negative numbers representable
     *      using 2's complement arithmetic (equaling -32768 and -128 in decimal, respectively).
     *
     * ESC Opcode:
     *
     *      The 80186 may be programmed to cause an interrupt type 7 whenever an ESCape instruction (used for
     *      co-processors like the 8087) is executed. The 8086 has no such provision. Before the 80186 performs
     *      this trap, it must be programmed to do so. [The details of this "programming" are not included.]
     *
     * Here's a summary of 80286 differences according to "80286 and 80287 Programmer's Reference Manual",
     * Appendix C, p.C-1 (p.329):
     *
     *   1. Add Six Interrupt Vectors
     *
     *      The 80286 adds six interrupts which arise only if the 8086 program has a hidden bug. These interrupts
     *      occur only for instructions which were undefined on the 8086/8088 or if a segment wraparound is attempted.
     *      It is recommended that you add an interrupt handler to the 8086 software that is to be run on the 80286,
     *      which will treat these interrupts as invalid operations.
     *
     *      This additional software does not significantly effect [sic] the existing 8086 software because the interrupts
     *      do not normally occur and should not already have been used since they are in the interrupt group reserved
     *      by Intel. [NOTE: IBM ignored Intel's admonishments.]
     *
     *   2. Do not Rely on 8086/8088 Instruction Clock Counts
     *
     *      The 80286 takes fewer clocks for most instructions than the 8086/8088. The areas to look into are delays
     *      between I/0 operations, and assumed delays in 8086/8088 operating in parallel with an 8087.
     *
     *   3. Divide Exceptions Point at the DIV Instruction
     *
     *      Any interrupt on the 80286 will always leave the saved CS:IP value pointing at the beginning of the
     *      instruction that failed (including prefixes). On the 8086, the CS:IP value saved for a divide exception
     *      points at the next instruction.
     *
     *   4. Use Interrupt 16 (0x10) for Numeric Exceptions
     *
     *      Any 80287 system must use interrupt vector 16 for the numeric error interrupt. If an 8086/8087 or 8088/8087
     *      system uses another vector for the 8087 interrupt, both vectors should point at the numeric error interrupt
     *      handler.
     *
     *   5. Numeric Exception Handlers Should allow Prefixes
     *
     *      The saved CS:IP value in the NPX environment save area will point at any leading prefixes before an ESC
     *      instruction. On 8086/8088 systems, this value points only at the ESC instruction.
     *
     *   6. Do Not Attempt Undefined 8086/8088 Operations
     *
     *      Instructions like POP CS or MOV CS,op will either cause exception 6 (undefined [invalid] opcode) or perform
     *      a protection setup operation like LIDT on the 80286. Undefined bit encodings for bits 5-3 of the second byte
     *      of POP MEM or PUSH MEM will cause exception 13 on the 80286.
     *
     *   7. Place a Far JMP Instruction at FFFF0H
     *
     *      After reset, CS:IP = F000:FFF0 on the 80286 (versus FFFF:0000 on the 8086/8088). This change was made to allow
     *      sufficient code space to enter protected mode without reloading CS. Placing a far JMP instruction at FFFF0H
     *      will avoid this difference. Note that the BOOTSTRAP option of LOC86 will automatically generate this jump
     *      instruction.
     *
     *   8. Do not Rely on the Value Written by PUSH SP
     *
     *      The 80286 will push a different value on the stack for PUSH SP than the 8086/8088. If the value pushed is
     *      important [and when would it NOT be?], replace PUSH SP instructions with the following three instructions:
     *
     *          PUSH    BP
     *          MOV     BP,SP
     *          XCHG    BP,[BP]
     *
     *      This code functions as the 8086/8088 PUSH SP instruction on the 80286.
     *
     *   9. Do not Shift or Rotate by More than 31 Bits
     *
     *      The 80286 masks all shift/rotate counts to the low 5 bits. This MOD 32 operation limits the count to a maximum
     *      of 31 bits. With this change, the longest shift/rotate instruction is 39 clocks. Without this change, the longest
     *      shift/rotate instruction would be 264 clocks, which delays interrupt response until the instruction completes
     *      execution.
     *
     *  10. Do not Duplicate Prefixes
     *
     *      The 80286 sets an instruction length limit of 10 bytes. The only way to violate this limit is by duplicating
     *      a prefix two or more times before an instruction. Exception 6 occurs if the instruction length limit is violated.
     *      The 8086/8088 has no instruction length limit.
     *
     *  11. Do not Rely on Odd 8086/8088 LOCK Characteristics
     *
     *      The LOCK prefix and its corresponding output signal should only be used to prevent other bus masters from
     *      interrupting a data movement operation. The 80286 will always assert LOCK during an XCHG instruction with memory
     *      (even if the LOCK prefix was not used). LOCK should only be used with the XCHG, MOV, MOVS, INS, and OUTS instructions.
     *
     *      The 80286 LOCK signal will not go active during an instruction prefetch.
     *
     *  12. Do not Single Step External Interrupt Handlers
     *
     *      The priority of the 80286 single step interrupt is different from that of the 8086/8088. This change was made
     *      to prevent an external interrupt from being single-stepped if it occurs while single stepping through a program.
     *      The 80286 single step interrupt has higher priority than any external interrupt.
     *
     *      The 80286 will still single step through an interrupt handler invoked by INT instructions or an instruction
     *      exception.
     *
     *  13. Do not Rely on IDIV Exceptions for Quotients of 80H or 8000H
     *
     *      The 80286 can generate the largest negative number as a quotient for IDIV instructions. The 8086 will instead
     *      cause exception O.
     *
     *  14. Do not Rely on NMI Interrupting NMI Handlers
     *
     *      After an NMI is recognized, the NMI input and processor extension limit error interrupt is masked until the
     *      first IRET instruction is executed.
     *
     *  15. The NPX error signal does not pass through an interrupt controller (an 8087 INT signal does). Any interrupt
     *      controller-oriented instructions for the 8087 may have to be deleted.
     *
     *  16. If any real-mode program relies on address space wrap-around (e.g., FFF0:0400=0000:0300), then external hardware
     *      should be used to force the upper 4 addresses to zero during real mode.
     *
     *  17. Do not use I/O ports 00F8-00FFH. These are reserved for controlling 80287 and future processor extensions.
     *
     * @this {CPUx86}
     */
    initProcessor()
    {
        this.PS_SET = X86.PS_SET_8086;
        this.PS_DIRECT = X86.PS_DIRECT_8086;
        this.PS_CLEAR_RM = X86.PS.IOPL.MASK | X86.PS.NT;

        this.OPFLAG_NOINTR_8086 = X86.OPFLAG.NOINTR;
        this.nShiftCountMask = 0xff;            // on an 8086/8088, all shift counts are used as-is

        this.cycleCounts = (this.model >= X86.MODEL_80286? X86.CYCLES_80286 : X86.CYCLES_8088);

        this.aOps     = X86.aOps;
        this.aOpGrp4b = X86.aOpGrp4b;
        this.aOpGrp4w = X86.aOpGrp4w;
        this.aOpGrp6  = X86.aOpGrp6Real;        // setProtMode() will ensure that aOpGrp6 is switched

        if (this.model >= X86.MODEL_80186) {
            /**
             * I don't go out of my way to make 80186/80188 cycle times accurate, since I'm not aware of any
             * IBM PC models that used those processors; beyond the 8086, my next priorities are the 80286 and
             * 80386, but I might revisit the 80186 someday.
             *
             * Instruction handlers that contain "hard-coded" 80286 cycle times include: opINSb, opINSw, opOUTSb,
             * opOUTSw, opENTER, and opLEAVE.
             */
            this.aOps = X86.aOps.slice();       // make copies of opcode tables before modifying
            this.aOpGrp4b = X86.aOpGrp4b.slice();
            this.aOpGrp4w = X86.aOpGrp4w.slice();
            this.nShiftCountMask = 0x1f;        // on newer processors, all shift counts are MOD 32
            this.aOps[0x0F]                 = X86.opInvalid;
            this.aOps[X86.OPCODE.PUSHA]     = X86.opPUSHA;      // 0x60
            this.aOps[X86.OPCODE.POPA]      = X86.opPOPA;       // 0x61
            this.aOps[X86.OPCODE.BOUND]     = X86.opBOUND;      // 0x62
            this.aOps[X86.OPCODE.ARPL]      = X86.opInvalid;    // 0x63
            this.aOps[X86.OPCODE.FS]        = X86.opInvalid;    // 0x64
            this.aOps[X86.OPCODE.GS]        = X86.opInvalid;    // 0x65
            this.aOps[X86.OPCODE.OS]        = X86.opInvalid;    // 0x66
            this.aOps[X86.OPCODE.AS]        = X86.opInvalid;    // 0x67
            this.aOps[X86.OPCODE.PUSHN]     = X86.opPUSHn;      // 0x68
            this.aOps[X86.OPCODE.IMULN]     = X86.opIMULn;      // 0x69
            this.aOps[X86.OPCODE.PUSH8]     = X86.opPUSH8;      // 0x6A
            this.aOps[X86.OPCODE.IMUL8]     = X86.opIMUL8;      // 0x6B
            this.aOps[X86.OPCODE.INSB]      = X86.opINSb;       // 0x6C
            this.aOps[X86.OPCODE.INSW]      = X86.opINSw;       // 0x6D
            this.aOps[X86.OPCODE.OUTSB]     = X86.opOUTSb;      // 0x6E
            this.aOps[X86.OPCODE.OUTSW]     = X86.opOUTSw;      // 0x6F
            this.aOps[0xC0]                 = X86.opGRP2bn;     // 0xC0
            this.aOps[0xC1]                 = X86.opGRP2wn;     // 0xC1
            this.aOps[X86.OPCODE.ENTER]     = X86.opENTER;      // 0xC8
            this.aOps[X86.OPCODE.LEAVE]     = X86.opLEAVE;      // 0xC9
            this.aOps[X86.OPCODE.INT1]      = X86.opUndefined;  // 0xF1
            this.aOpGrp4b[0x07]             = X86.fnGRPInvalid;
            this.aOpGrp4w[0x07]             = X86.fnGRPInvalid;

            if (this.model >= X86.MODEL_80286) {

                let i;
                this.PS_SET = X86.PS.BIT1;      // on the 80286, only BIT1 of Processor Status (flags) is always set
                this.PS_DIRECT |= X86.PS.IOPL.MASK | X86.PS.NT;

                this.OPFLAG_NOINTR_8086 = 0;    // for instructions that do *not* set NOINTR on an 80286 (eg, non-SS segment loads)

                this.aOps[0x0F] = X86.op0F;
                this.aOps0F = X86.aOps0F.slice();
                for (i = 0; i < this.aOps0F.length; i++) {
                    if (!this.aOps0F[i]) this.aOps0F[i] = X86.opUndefined;
                }
                this.aOps[X86.OPCODE.PUSHSP] = X86.opPUSHSP;    // 0x54
                this.aOps[X86.OPCODE.ARPL]   = X86.opARPL;      // 0x63

                if (I386) {
                    if (this.model >= X86.MODEL_80386) {
                        let bOpcode;
                        this.PS_CLEAR_RM = 0;   // NOTE: This allows the 80386 to modify X86.PS.NT in real-mode (which is presumably OK)
                        this.PS_DIRECT |= X86.PS.RF | X86.PS.VM;
                        this.aOps[X86.OPCODE.FS]    = X86.opFS;     // 0x64
                        this.aOps[X86.OPCODE.GS]    = X86.opGS;     // 0x65
                        this.aOps[X86.OPCODE.OS]    = X86.opOS;     // 0x66
                        this.aOps[X86.OPCODE.AS]    = X86.opAS;     // 0x67
                        this.aOps[X86.OPCODE.INT1]  = X86.opINT1;   // 0xF1
                        for (bOpcode in X86.aOps0F386) {
                            this.aOps0F[+bOpcode] = X86.aOps0F386[+bOpcode];
                        }
                        if (this.stepping >= X86.STEPPING_80386_A0 && this.stepping <= X86.STEPPING_80386_B0) {
                            this.aOps0F[0xA6] = X86.opXBTS;
                            this.aOps0F[0xA7] = X86.opIBTS;
                        }
                    } else {
                        /**
                         * Let's make any "undefined" 80286 0x0F opcode handler "invalid" instead IFF the opcode
                         * is defined on the 80386.  Whereas if someone is using an opcode that isn't defined on ANY
                         * of these processors, then I want to know about it; ie, leave it set to opUndefined().
                         */
                        for (i = 0; i < X86.aOps0F386.length; i++) {
                            if (X86.aOps0F386[i] && this.aOps0F[i] == X86.opUndefined) this.aOps0F[i] = X86.opInvalid;
                        }
                    }
                }
            }
        }
    }

    /**
     * reset()
     *
     * @this {CPUx86}
     */
    reset()
    {
        this.resetFPU();
        this.resetRegs();
        this.resetCycles();
        this.clearError();      // clear any fatal error/exception that setError() may have flagged
    }

    /**
     * resetFPU()
     *
     * @this {CPUx86}
     */
    resetFPU()
    {
        if (this.chipset) {
            if (this.chipset.getDIPCoprocessor()) {
                this.fpuActive = this.fpu;
            } else {
                this.fpuActive = null;
            }
        }
    }

    /**
     * getReg(i)
     *
     * @this {CPUx86}
     * @param {number} i (0-7)
     * @returns {number}
     */
    getReg(i)
    {
        let reg;
        switch(i) {
        case 0x0:
            reg = this.regEAX;
            break;
        case 0x1:
            reg = this.regECX;
            break;
        case 0x2:
            reg = this.regEDX;
            break;
        case 0x3:
            reg = this.regEBX;
            break;
        case 0x4:
            reg = this.getSP();
            break;
        case 0x5:
            reg = this.regEBP;
            break;
        case 0x6:
            reg = this.regESI;
            break;
        case 0x7:
            reg = this.regEDI;
            break;
        }
        return reg;
    }

    /**
     * setReg(i, reg)
     *
     * @this {CPUx86}
     * @param {number} i (0-7)
     * @param {number} reg
     */
    setReg(i, reg)
    {
        switch(i) {
        case 0x0:
            this.regEAX = reg;
            break;
        case 0x1:
            this.regECX = reg;
            break;
        case 0x2:
            this.regEDX = reg;
            break;
        case 0x3:
            this.regEBX = reg;
            break;
        case 0x4:
            this.setSP(reg);
            break;
        case 0x5:
            this.regEBP = reg;
            break;
        case 0x6:
            this.regESI = reg;
            break;
        case 0x7:
            this.regEDI = reg;
            break;
        }
    }

    /**
     * resetRegs()
     *
     * According to "The 8086 Book", p.7-5, a RESET signal initializes the following registers:
     *
     *      PS          =   0x0000 (which has the important side-effect of disabling interrupts and traps)
     *      IP          =   0x0000
     *      CS          =   0xFFFF
     *      DS/ES/SS    =   0x0000
     *
     * It is silent as to whether the remaining registers are initialized to any particular values.
     *
     * According to the "80286 and 80287 Programmer's Reference Manual", these 80286 registers are reset:
     *
     *      PS          =   0x0002
     *      MSW         =   0xFFF0
     *      IP          =   0xFFF0
     *      CS Selector =   0xF000      DS/ES/SS Selector =   0x0000
     *      CS Base     = 0xFF0000      DS/ES/SS Base     = 0x000000        IDT Base  = 0x000000
     *      CS Limit    =   0xFFFF      DS/ES/SS Limit    =   0xFFFF        IDT Limit =   0x03FF
     *
     * And from the "INTEL 80386 PROGRAMMER'S REFERENCE MANUAL 1986", section 10.1:
     *
     *      The contents of EAX depend upon the results of the power-up self test. The self-test may be requested
     *      externally by assertion of BUSY# at the end of RESET. The EAX register holds zero if the 80386 passed
     *      the test. A nonzero value in EAX after self-test indicates that the particular 80386 unit is faulty.
     *      If the self-test is not requested, the contents of EAX after RESET is undefined.
     *
     *      DX holds a component identifier and revision number after RESET as Figure 10-1 illustrates. DH contains
     *      3, which indicates an 80386 component. DL contains a unique identifier of the revision level.
     *
     *      EFLAGS      =   0x00000002
     *      IP          =   0x0000FFF0
     *      CS selector =   0xF000 (base of 0xFFFF0000 and limit of 0xFFFF)
     *      DS selector =   0x0000
     *      ES selector =   0x0000
     *      SS selector =   0x0000
     *      FS selector =   0x0000
     *      GS selector =   0x0000
     *      IDTR        =   base of 0 and limit of 0x3FF
     *
     * All other 80386 registers are undefined after a reset (ie, Intel did not document how or if they are set).
     *
     * We've elected to set DX to 0x0308 on a reset, the highest known 80386 revision, since we have no desire to
     * try to emulate all the bugs in older (eg, B1) steppings -- at least not initially.  We leave stepping-accurate
     * emulation for another day.  It's also known that the B1 (and possibly B0) reported 0x0303 in DX, and that
     * the D0 stepping reported 0x0305; beyond that, it's not known exactly what revision numbers Intel used for all
     * 80386 revisions.
     *
     * We define some additional "registers", such as regLIP, which mirrors the linear address corresponding to
     * CS:IP (the address of the next opcode byte).  In fact, regLIP functions as our internal IP register, so any
     * code that needs the real IP must call getIP().  This, in turn, means that whenever CS or IP must be modified,
     * regLIP must be recalculated, so you must use either setCSIP(), which takes both an offset and a segment,
     * or setIP(), whichever is appropriate; in unusual cases where only segCS is changing (eg, undocumented 8086
     * opcodes), use setCS().
     *
     * Similarly, regLSP mirrors the linear address corresponding to SS:SP, and therefore you must rely on getSP()
     * to read the current SP, and setSP() and setSS() to update SP and SS.
     *
     * The other segment registers, such as segDS and segES, have similar getters and setters, but we do not mirror
     * any other segment:offset values in the same way that regLIP mirrors CS:IP, or that regLSP mirrors SS:SP.
     *
     * @this {CPUx86}
     */
    resetRegs()
    {
        this.regEAX = 0;
        this.regEBX = 0;
        this.regECX = 0;
        this.regEDX = 0;
        this.regESP = 0;            // this isn't needed in a 16-bit environment, but is required for I386
        this.regEBP = 0;
        this.regESI = 0;
        this.regEDI = 0;

        /**
         * The following are internal "registers" used to capture intermediate values inside selected helper
         * functions and use them if they've been modified (or are known to change); for example, the MUL and DIV
         * instructions perform calculations that must be propagated to specific registers (eg, AX and/or DX), which
         * the ModRM decoder functions don't know about.  We initialize them here mainly for documentation purposes.
         */
        this.fMDSet = false;        // regMDHi and/or regMDLo are invalid unless fMDSet is true
        this.regMDLo = this.regMDHi = 0;
        this.r64Div = [0, 0];
        this.r64Rem = [0, 0];
        this.regXX = 0;             // for internal use only (eg, assists with ModRM helper functions)

        /**
         * This internal "register" is set in selected opcode handlers to record the original opcode; ordinarily,
         * we dispatch on the opcode but never save it, because it's rarely needed.
         */
        this.bOpcode = 0;

        /**
         * Another internal "register" we occasionally need is an interim copy of bModRM, set inside selected opcode
         * handlers so that the helper function can have access to the instruction's bModRM without resorting to a
         * closure (which, in the Chrome V8 engine, for example, may cause constant recompilation).
         */
        this.bModRM = 0;

        /**
         * NOTE: Even though the 8086 doesn't have CR0 (aka MSW) and IDTR, we initialize them for ALL CPUs, so
         * that functions like X86.helpINT() can use the same code for both.  The 8086/8088 have no direct way
         * of accessing or changing them, so this is an implementation detail those processors are unaware of.
         */
        this.regCR0 = X86.CR0.MSW.ON;
        this.addrIDT = 0;
        this.addrIDTLimit = 0x03FF;
        this.regPS = this.nIOPL = 0;// these should be set before the first setPS() call

        /**
         * Define all the result registers that can be used to "cache" arithmetic and logical flags.
         *
         * In addition, setPS() will initialize resultType, which keeps track of which flags are cached,
         * and resultSize, which maintains the size of the last result; initially, no flags are cached.
         */
        this.resultDst = this.resultSrc = this.resultArith = this.resultLogic = 0;

        /**
         * nFault is set by helpFault() and reset (to -1) by resetRegs() and opIRET().  Its initial purpose was to
         * help helpFault() determine when a nested fault should be converted into either a double-fault (DF_FAULT)
         * or a triple-fault (ie, a processor reset).
         *
         * It has since evolved into another important role: helping segCS.loadIDT() know when an exception
         * is occurring, as opposed to a software interrupt (eg, INT3, INT n or INTO).  The former must set nFault
         * to the corresponding fault #, whereas the latter must set it to -1, so that if the IDT contains a gate
         * whose DPL < CPL, a GP fault will be generated instead.
         *
         * The former always call helpFault(), and the latter call helpTrap(), so nFault is updated automatically.
         * However, there are also intermediate cases, like hardware interrupts, which call helpINT() after manually
         * setting nFault to the IDT #.  TODO: Review all those "intermediate" cases.
         */
        this.nFault = -1;

        /**
         * These are used to snapshot regLIP and regLSP, to help make instructions restartable;
         * currently opLIP is updated prior to every instruction, but opLSP is updated only for instructions
         * that modify the stack pointer (eg, RETF) and should otherwise remain set to X86.ADDR_INVALID.
         *
         * More recently, opCS was added to selectively snapshot an instruction's original CS in case an
         * exception occurs accessing the stack after a new CS has been loaded, allowing the exception handler
         * to recover the old CS and make instructions like CALLF restartable; otherwise, opCS should remain -1.
         *
         * Ditto for opSS and the SS register.
         */
        this.opCS = this.opSS = -1;
        this.opLIP = this.opLSP = X86.ADDR_INVALID;

        /**
         * Segment registers used to be defined as separate selector and base variables (eg, regCS and regCS0),
         * but now they are defined as Segx86 objects.
         */
        this.segCS     = new Segx86(this, Segx86.ID.CODE,  "CS");
        this.segDS     = new Segx86(this, Segx86.ID.DATA,  "DS");
        this.segES     = new Segx86(this, Segx86.ID.DATA,  "ES");
        this.segSS     = new Segx86(this, Segx86.ID.STACK, "SS");
        this.setSP(0);
        this.setSS(0);

        if (I386 && this.model >= X86.MODEL_80386) {
            /**
             * As explained above, EAX depends upon the results of the CPU's power-up self-test; however, the only
             * documented value is zero, which indicates that the 80386 passed.  Additionally, DH is set to the CPU
             * identifier (3) and DL is set to the revision level (stepping).
             */
            switch(this.stepping) {
            case X86.STEPPING_80386_B0:
            case X86.STEPPING_80386_B1:
                this.regEDX = 0x0303;
                break;
            case X86.STEPPING_80386_C0:
                this.regEDX = 0x0304;
                break;
            case X86.STEPPING_80386_D0:
                this.regEDX = 0x0305;
                break;
            case X86.STEPPING_80386_D1:
            case X86.STEPPING_80386_D2:
                this.regEDX = 0x0308;
                break;
            default:
                this.regEDX = 0x0300;       // in the absence of a specific stepping, set revision (DL) to zero
                break;
            }
            this.regCR0 = X86.CR0.ON | X86.CR0.ET;
            this.regCR1 = 0;                // reserved
            this.regCR2 = 0;                // page fault linear address (PFLA)
            this.regCR3 = 0;                // page directory base register (PDBR)
            this.regDR  = [0,0,0,0,null,null,0,0];              // Debug Registers DR0-DR7 (DR4-DR5 are undefined)
            this.regTR  = [null,null,null,null,null,null,0,0];  // Test Registers TR0-TR7 (TR0-TR5 are undefined)
            this.segFS = new Segx86(this, Segx86.ID.DATA,  "FS");
            this.segGS = new Segx86(this, Segx86.ID.DATA,  "GS");
            /**
             * Synchronize the fact that paging is initially disabled with our PAGEBLOCKS functions
             */
            this.disablePageBlocks();
        }

        this.segNULL = new Segx86(this, Segx86.ID.NULL,  "NULL");

        /**
         * The next few initializations mirror what we must do prior to each instruction (ie, inside the stepCPU() function);
         * note that opPrefixes, along with segData and segStack, are reset only after we've executed a non-prefix instruction.
         */
        this.segData = this.segDS;
        this.segStack = this.segSS;
        this.opFlags = this.opPrefixes = 0;
        this.regEA = this.regEAWrite = X86.ADDR_INVALID;

        this.segEA = this.segNULL;

        /**
         * intFlags contains some internal states we use to indicate whether a hardware interrupt (INTFLAG.INTR) or
         * Trap software interrupt (INTR.TRAP) has been requested, as well as when we're in a "HLT" state (INTFLAG.HALT)
         * that requires us to wait for a hardware interrupt (INTFLAG.INTR) before continuing execution.
         *
         * intFlags must be cleared only by checkINTR(), whereas opFlags must be cleared prior to every CPU operation.
         */
        this.intFlags = X86.INTFLAG.NONE;

        if (BACKTRACK) {
            /**
             * Initialize the backtrack indexes for all registers to zero.  And while, yes, it IS possible
             * for raw data to flow through segment registers as well, it's not common enough in real-mode
             * (and too difficult in protected-mode) to merit the overhead.  Ditto for SP, which can't really
             * be considered a general-purpose register.
             *
             * Every time getByte() is called, btiMem0 is filled with the matching backtrack info; similarly,
             * every time getWord() is called, btiMem0 and btiMem1 are filled with the matching backtrack info
             * for the low and high bytes, respectively.
             */
            this.backTrack = {
                btiAL:      0,
                btiAH:      0,
                btiBL:      0,
                btiBH:      0,
                btiCL:      0,
                btiCH:      0,
                btiDL:      0,
                btiDH:      0,
                btiBPLo:    0,
                btiBPHi:    0,
                btiSILo:    0,
                btiSIHi:    0,
                btiDILo:    0,
                btiDIHi:    0,
                btiMem0:    0,
                btiMem1:    0,
                btiMem2:    0,
                btiMem3:    0,
                btiEALo:    0,
                btiEAHi:    0,
                btiIO:      0
            };
        }

        /**
         * Set the initial CS:IP appropriate for the processor; this should be done before the first setPS() call,
         * in part so that CPL will be set properly.
         */
        if (this.model < X86.MODEL_80286) {
            this.setCSIP(0, 0xffff);
        } else {
            /**
             * Assorted 80286-specific registers.  The GDTR and IDTR registers are stored as the following pieces:
             *
             *      GDTR:   addrGDT (24 bits) and addrGDTLimit (24 bits)
             *      IDTR:   addrIDT (24 bits) and addrIDTLimit (24 bits)
             *
             * while the LDTR and TR are stored as special segment registers: segLDT and segTSS.
             *
             * So, yes, our GDTR and IDTR "registers" differ from other segment registers in that we do NOT record
             * the 16-bit limit specified by the LGDT or LIDT instructions; instead, we immediately calculate the limiting
             * address, and record that instead.
             *
             * In addition to different CS:IP reset values, the CS base address must be set to the top of the 16Mb
             * address space rather than the top of the first 1Mb (which is why the MODEL_5170 ROM must be addressable
             * at both 0x0F0000 and 0xFF0000; see the ROM component's "alias" parameter).
             *
             * TODO: Verify what the 80286 actually sets addrGDT and addrGDTLimit to on reset (or if it leaves them alone).
             */
            this.addrGDT = 0; this.addrGDTLimit = 0xffff;                   // GDTR
            this.segLDT = new Segx86(this, Segx86.ID.LDT, "LDT", true);     // LDTR
            this.segTSS = new Segx86(this, Segx86.ID.TSS, "TSS", true);     // TR
            this.segVER = new Segx86(this, Segx86.ID.VER, "VER", true);     // a scratch segment register for VERR and VERW instructions
            this.setCSIP(0xfff0, 0xf000);                   // on an 80286 or 80386, the default CS:IP is 0xF000:0xFFF0 instead of 0xFFFF:0x0000
            this.setCSBase(0xffff0000|0);                   // on an 80286 or 80386, all CS base address bits above bit 15 must be set
        }

        /**
         * This resets the Processor Status flags (regPS), along with all the internal "result registers";
         * we've taken care to ensure that both CPL and IOPL are initialized before this first setPS() call.
         */
        this.setPS(0);

        /**
         * Now that all the segment registers have been created, it's safe to set the current addressing mode.
         */
        this.setProtMode();
    }

    /**
     * updateAddrSize()
     *
     * Select the appropriate ModRM dispatch tables, based on the current ADDRESS size (addrSize), which
     * is based foremost on segCS.sizeAddr, but can also be overridden by an ADDRESS size instruction prefix.
     *
     * There used to be six primary ModRM dispatch table pointers:
     *
     *      aOpModRegByte
     *      aOpModMemByte
     *      aOpModGrpByte
     *      aOpModRegWord
     *      aOpModMemWord
     *      aOpModGrpWord
     *
     * However, when support for the 80386 was added, the number of dispatch tables doubled, and since each entry
     * in the table was a discrete function, decoding was fast, but it also required a LOT of code.
     *
     * So we have now replaced the above table pointers with function pointers:
     *
     *      decodeModRegByte (set to one of: modRegByte16, modRegByte32)
     *      decodeModMemByte (set to one of: modMemByte16, modMemByte32)
     *      decodeModGrpByte (set to one of: modGrpByte16, modGrpByte32)
     *      decodeModRegWord (set to one of: modRegShort16, modRegLong16, modRegShort32, modRegLong32)
     *      decodeModMemWord (set to one of: modMemShort16, modMemLong16, modMemShort32, modMemLong32)
     *      decodeModGrpWord (set to one of: modGrpShort16, modGrpLong16, modGrpShort32, modGrpLong32)
     *
     * So opcode handlers that used to do this:
     *
     *      this.aOpModMemByte[b].call(this, X86.fnADDb);
     *
     * now do this:
     *
     *      this.decodeModMemByte.call(this, X86.fnADDb);
     *
     * Decoding of ModRM bytes is now slightly slower, but the previous code is still in the repository
     * (look for x86modb.js and x86modw.js for the pre-80386 dispatch tables, and x86modb16.js, x86modb32.js,
     * x86modw16.js, x86modw32.js, and x86modsib.js for the post-80386 dispatch tables).
     *
     * @this {CPUx86}
     */
    updateAddrSize()
    {
        if (!I386) {
            this.getAddr = (PREFETCH? this.getShortPrefetch : this.getShort);
            this.decodeModRegByte = X86.modRegByte16;
            this.decodeModMemByte = X86.modMemByte16;
            this.decodeModGrpByte = X86.modGrpByte16;
            this.decodeModRegWord = X86.modRegShort16;
            this.decodeModMemWord = X86.modMemShort16;
            this.decodeModGrpWord = X86.modGrpShort16;
        } else {
            if (this.sizeAddr == 2) {
                this.getAddr = (PREFETCH? this.getShortPrefetch : this.getShort);
                this.decodeModRegByte = X86.modRegByte16;
                this.decodeModMemByte = X86.modMemByte16;
                this.decodeModGrpByte = X86.modGrpByte16;
                if (this.sizeData == 2) {
                    this.decodeModRegWord = X86.modRegShort16;
                    this.decodeModMemWord = X86.modMemShort16;
                    this.decodeModGrpWord = X86.modGrpShort16;
                } else {
                    this.decodeModRegWord = X86.modRegLong16;
                    this.decodeModMemWord = X86.modMemLong16;
                    this.decodeModGrpWord = X86.modGrpLong16;
                }
            } else {
                this.getAddr = (PREFETCH? this.getLongPrefetch : this.getLong);
                this.decodeModRegByte = X86.modRegByte32;
                this.decodeModMemByte = X86.modMemByte32;
                this.decodeModGrpByte = X86.modGrpByte32;
                if (this.sizeData == 2) {
                    this.decodeModRegWord = X86.modRegShort32;
                    this.decodeModMemWord = X86.modMemShort32;
                    this.decodeModGrpWord = X86.modGrpShort32;
                } else {
                    this.decodeModRegWord = X86.modRegLong32;
                    this.decodeModMemWord = X86.modMemLong32;
                    this.decodeModGrpWord = X86.modGrpLong32;
                }
            }
        }
    }

    /**
     * setDataSize(size)
     *
     * This is used by opcodes that require a particular OPERAND size, which we enforce by internally
     * simulating an OPERAND size override, if needed.
     *
     * @this {CPUx86}
     * @param {number} size (2 for 2-byte/16-bit operands, or 4 for 4-byte/32-bit operands)
     */
    setDataSize(size)
    {
        if (this.sizeData != size) {
            this.opPrefixes |= X86.OPFLAG.DATASIZE;
            this.sizeData = size;
            this.maskData = (size == 2? 0xffff : (0xffffffff|0));
            this.updateDataSize();
        }
    }

    /**
     * updateDataSize()
     *
     * @this {CPUx86}
     */
    updateDataSize()
    {
        if (this.sizeData == 2) {
            this.typeData = X86.RESULT.WORD;
            this.getWord = this.getShort;
            this.setWord = this.setShort;
            if (this.sizeAddr == 2) {
                this.decodeModRegWord = X86.modRegShort16;
                this.decodeModMemWord = X86.modMemShort16;
                this.decodeModGrpWord = X86.modGrpShort16;
            } else {
                this.decodeModRegWord = X86.modRegShort32;
                this.decodeModMemWord = X86.modMemShort32;
                this.decodeModGrpWord = X86.modGrpShort32;
            }
        } else {
            this.typeData = X86.RESULT.DWORD;
            this.getWord = this.getLong;
            this.setWord = this.setLong;
            if (this.sizeAddr == 2) {
                this.decodeModRegWord = X86.modRegLong16;
                this.decodeModMemWord = X86.modMemLong16;
                this.decodeModGrpWord = X86.modGrpLong16;
            } else {
                this.decodeModRegWord = X86.modRegLong32;
                this.decodeModMemWord = X86.modMemLong32;
                this.decodeModGrpWord = X86.modGrpLong32;
            }
        }
    }

    /**
     * resetSizes()
     *
     * @this {CPUx86}
     */
    resetSizes()
    {
        /**
         * The following contain the (default) ADDRESS size (2 for 16 bits, 4 for 32 bits), and the corresponding
         * masks for isolating the (src) bits of an address and clearing the (dst) bits of an address.  Like the
         * OPERAND size properties, these are reset to their segCS counterparts at the start of every new instruction.
         */
        if (this.sizeAddr != this.segCS.sizeAddr) {
            this.sizeAddr = this.segCS.sizeAddr;
            this.maskAddr = this.segCS.maskAddr;

            /**
             * It's also worth noting that instructions that implicitly use the stack also rely on STACK size,
             * which is based on the BIG bit of the last descriptor loaded into SS; use the following segSS properties:
             *
             *      segSS.sizeAddr      (2 or 4)
             *      segSS.maskAddr      (0xffff or 0xffffffff)
             *
             * As there is no STACK size instruction prefix override, there's no need to propagate these segSS properties
             * to separate CPUx86 properties, as we do for the OPERAND size and ADDRESS size properties.
             */
            this.updateAddrSize();
        }

        /**
         * The following contain the (default) OPERAND size (2 for 16 bits, 4 for 32 bits), and the corresponding masks
         * for isolating the (src) bits of an OPERAND and clearing the (dst) bits of an OPERAND.  These are reset to
         * their segCS counterparts at the start of every new instruction, but are also set here for documentation purposes.
         */
        if (this.sizeData != this.segCS.sizeData) {
            this.sizeData = this.segCS.sizeData;
            this.maskData = this.segCS.maskData;

            this.updateDataSize();
        }

        this.opPrefixes &= ~(X86.OPFLAG.ADDRSIZE | X86.OPFLAG.DATASIZE);
    }

    /**
     * getChecksum()
     *
     * @this {CPUx86}
     * @returns {number} a 32-bit summation of key elements of the current CPU state (used by the CPU checksum code)
     */
    getChecksum()
    {
        let sum = (this.regEAX + this.regEBX + this.regECX + this.regEDX + this.getSP() + this.regEBP + this.regESI + this.regEDI)|0;
        sum = (sum + this.getIP() + this.getCS() + this.getDS() + this.getSS() + this.getES() + this.getPS())|0;
        return sum;
    }

    /**
     * addIntNotify(nInt, fn)
     *
     * Add a software interrupt notification handler to the CPU's list of such handlers.
     *
     * TODO: Consider adding removeIntNotify().  Example use case: if the Debugger's intWindowsDebugger() function
     * detects that an INT 0x41 client is loaded, it would be quite happy to uninstall itself.
     *
     * @this {CPUx86}
     * @param {number} nInt
     * @param {function(number)} fn is called with the LIP value following the software interrupt
     */
    addIntNotify(nInt, fn)
    {

        if (this.aIntNotify[nInt] === undefined) {
            this.aIntNotify[nInt] = [];
        }
        this.aIntNotify[nInt].push(fn);
    }

    /**
     * checkIntNotify(nInt)
     *
     * NOTE: This is called ONLY for "INT N" instructions -- not "INTO" or breakpoint or single-step interrupts
     * or divide exception interrupts, or hardware interrupts, or any simulation of an interrupt (eg, "PUSHF/CALLF").
     *
     * @this {CPUx86}
     * @param {number} nInt
     * @returns {boolean} true if software interrupt may proceed, false if software interrupt should be skipped
     */
    checkIntNotify(nInt)
    {
        let aNotify = this.aIntNotify[nInt];
        if (aNotify !== undefined) {
            for (let i = 0; i < aNotify.length; i++) {
                if (!aNotify[i](this.regLIP)) {
                    return false;
                }
            }
        }
        /**
         * The enabling of INT messages is one of the criteria that's also included in the Debugger's checksEnabled()
         * function, and therefore included in debugCheck, so for maximum speed, we check debugCheck first.
         *
         * NOTE: We've added MAXDEBUG to the test below, because onIntReturn() generates a lot of noise, via
         * dbg.messageIntReturn(), and because there's no way to be sure we'll catch the return (or for some interrupts,
         * *whether* they will return), so it's safer to disable this feature unless you really want it.
         *
         * For most purposes, just having dbg.messageInt(), and the Debugger's ability to selectively turn categories
         * of messages on and off, is good enough.
         */
        if (DEBUGGER && this.flags.debugCheck) {
            if (this.messageEnabled(MESSAGE.INT) && this.dbg.messageInt(nInt, this.regLIP) && MAXDEBUG) {
                this.addIntReturn(this.regLIP, function(cpu, nCycles) {
                    return function onIntReturn(nLevel) {
                        cpu.dbg.messageIntReturn(nInt, nLevel, cpu.getCycles() - nCycles);
                    };
                }(this, this.getCycles()));
            }
        }
        return true;
    }

    /**
     * addIntReturn(addr, fn)
     *
     * Add a return notification handler to the CPU's list of such handlers.
     *
     * When fn(n) is called, it's passed a "software interrupt level", which will normally be 0,
     * unless it's a return from a nested software interrupt (eg, return from INT 0x10 Video BIOS
     * call issued inside another INT 0x10 Video BIOS call).
     *
     * Note that the nesting could be due to a completely different software interrupt that
     * another interrupt notification function is intercepting, so use it as an advisory value only.
     *
     * @this {CPUx86}
     * @param {number} addr is a linear address
     * @param {function(number)} fn is an interrupt-return notification function
     */
    addIntReturn(addr, fn)
    {
        if (fn !== undefined) {
            if (this.aIntReturn[addr] == null) {
                this.cIntReturn++;
            }
            this.aIntReturn[addr] = fn;
        }
    }

    /**
     * checkIntReturn(addr)
     *
     * We check for possible "INT n" software interrupt returns in the cases of "IRET" (helpIRET), "RETF 2"
     * (helpRETF) and "JMPF [DWORD]" (fnJMPFdw).
     *
     * "JMPF [DWORD]" is an unfortunate choice that newer versions of DOS (as of at least 3.20, and probably
     * earlier) employed in their INT 0x13 hooks; I would have preferred not making this call for that opcode.
     *
     * It is expected (though not required) that callers will check cIntReturn and avoid calling this function
     * if the count is zero, for maximum performance.
     *
     * @this {CPUx86}
     * @param {number} addr is a linear address
     */
    checkIntReturn(addr)
    {
        let fn = this.aIntReturn[addr];
        if (fn != null) {
            fn(--this.cIntReturn);
            delete this.aIntReturn[addr];
        }
    }

    /**
     * checkDebugRegisters(fEnable)
     *
     * opMOVdr() simplifies its life by doing work ONLY if the contents of a Debug register is actually changing.
     *
     * Whenever a single register is about to change, it calls this function with fEnable set to false to REMOVE any
     * active checks, then updates the Debug register, then calls us again with fEnable set to true to (re)ADD active
     * checks.
     *
     * @this {CPUx86}
     * @param {boolean} fEnable
     */
    checkDebugRegisters(fEnable)
    {
        /**
         * We use a constant mask for the enable bits (X86.DR7.L0 | X86.DR7.G0) and shift our copy of regDR7
         * right 2 bits after each Debug register check.
         *
         * Similarly, we make a copy of regDR7 in bitsDR7 and shift the latter right 4 bits at a time, so that
         * the RW and LEN bits for the next Debug register are always in positions 1-0 and 3-2, respectively.
         */
        let regDR7 = this.regDR[7];
        let bitsDR7 = regDR7 >> 16;

        for (let i = 0; i < 4; i++) {
            if (regDR7 & (X86.DR7.L0 | X86.DR7.G0)) {
                /**
                 * We look only to the low bit of the RW field to determine if we should be watching for a write.
                 * FYI, if the low bit is clear but the high bit is set, that's "undefined"; we treat it as a read.
                 */
                let fWrite = !!(bitsDR7 & 0x1);
                /**
                 * The address in regDR[i] should already be masked with ~0x1 for 2-byte accesses (LEN == 0x1) or
                 * with ~0x3 for 4-byte accesses (LEN == 0x3), but if the client forgets, the hardware supposedly
                 * enforces it, so that's what we do here, too.
                 *
                 * FYI, if LEN is set to the "undefined" value of (0x2), we still apply a mask to the address, albeit
                 * a nonsensical mask of ~0x2 or 0xfffffffd.  That's how we define that particular "undefined" LEN.
                 */
                let addr = this.regDR[i];
                let len = ((bitsDR7 >> 2) & 0x3);
                addr &= ~len;       // NOTE: if LEN == 0x0, we don't need to mask, but ~0x0 is equivalent to no mask
                if (fEnable) {
                    this.addMemCheck(addr, fWrite);
                } else {
                    this.removeMemCheck(addr, fWrite);
                }
            }
            regDR7 >>= 2; bitsDR7 >>= 4;
        }
    }

    /**
     * checkMemoryException(addr, nb, fWrite)
     *
     * This "check" function is called by a Memory block to inform us that a memory read or write is occurring,
     * giving us the opportunity look for a matching "read" or "write" breakpoint enabled in one of the DRn registers.
     *
     * TODO: This currently does not discriminate between data reads and execution reads.  When we switch to a true
     * "prefetch" model, that would also be a good time to include a signal to this function indicating which "read"
     * accesses are are actually "exec" accesses.
     *
     * @this {CPUx86}
     * @param {number} addr
     * @param {number} nb (# of bytes)
     * @param {boolean|null} [fWrite] (false if read, true if write, null if exec)
     */
    checkMemoryException(addr, nb, fWrite)
    {
        /**
         * NOTE: We're preventing redundant X86.EXCEPTION.DB_EXC exceptions for a single instruction by checking
         * X86.OPFLAG.DBEXC.  I decided not to rely on the generic X86.OPFLAG.FAULT, because if an instruction
         * first triggers a DIFFERENT exception which then triggers a DEBUG exception (eg, because a Debug register
         * was set on the IDT entry of the first exception), then presumably we'd like to see that DEBUG exception,
         * as opposed to, say, a double fault.  TODO: Determine whether that SHOULD generate a double-fault.
         */
        if (!(this.opFlags & X86.OPFLAG.DBEXC) && (this.regDR[7] & X86.DR7.ENABLE)) {
            nb--;
            /**
             * We use a constant mask for the enable bits (X86.DR7.L0 | X86.DR7.G0) and shift our copy of regDR7
             * right 2 bits after each Debug register check.
             *
             * Similarly, we make a copy of regDR7 in bitsDR7 and shift the latter right 4 bits at a time, so that
             * the RW and LEN bits for the next Debug register are always in positions 1-0 and 3-2, respectively.
             */
            let regDR7 = this.regDR[7];
            let bitsDR7 = regDR7 >> 16;

            let bitsRWMask = X86.DR7.RW0 >> 16;
            let bitsRWRequired = (fWrite? 0x1 : (fWrite == false? 0x3 : 0x0));

            for (let i = 0; i < 4; i++) {
                if ((regDR7 & (X86.DR7.L0 | X86.DR7.G0)) && (bitsDR7 & bitsRWMask) == bitsRWRequired) {
                    /**
                     * NOTE: We reduced nb from 1-4 to 0-3 above, so we don't need to add 1 to len either.
                     */
                    let len = (bitsDR7 >> 2);
                    /**
                     * Time to determine if addr through addr + nb overlaps regDR[i] through regDR[i] + len.
                     */
                    if (addr + nb >= this.regDR[i] && addr <= this.regDR[i] + len) {
                        this.regDR[6] |= (1 << i);
                        /**
                         * Data access breakpoints are not faults; they must generate a trap at the end of the
                         * instruction, so we use the X86.INTFLAG.TRAP flag to generate the X86.EXCEPTION.DB_EXC trap.
                         *
                         *      X86.helpFault.call(this, X86.EXCEPTION.DB_EXC);
                         */
                        this.intFlags |= X86.INTFLAG.TRAP;
                        return;
                    }
                }
                regDR7 >>= 2; bitsDR7 >>= 4;
            }
        }
    }

    /**
     * isProtMode()
     *
     * @this {CPUx86}
     * @returns {boolean} true if protected-mode, false if not
     */
    isProtMode()
    {
        return !!(this.regCR0 & X86.CR0.MSW.PE);
    }

    /**
     * isV86Mode()
     *
     * @this {CPUx86}
     * @returns {boolean} true if V86-mode, false if not
     */
    isV86Mode()
    {
        return !!(this.regPS & X86.PS.VM);
    }

    /**
     * setProtMode(fProt, fV86)
     *
     * Update any opcode handlers that operate significantly differently in real-mode vs. protected-mode, and
     * notify all the segment registers about the mode change as well -- but only those that are "bi-modal"; internal
     * segment registers like segLDT and segTSS do not need to be notified, because they cannot be accessed in real-mode
     * (ie, LLDT, LTR, SLDT, STR are invalid instructions in real-mode, and are among the opcode handlers that we
     * update here).
     *
     * NOTE: Ideally, this function would do its work ONLY on mode *transitions*, but we assume calls to setProtMode()
     * are sufficiently infrequent that it doesn't really matter.
     *
     * @this {CPUx86}
     * @param {boolean} [fProt] (use the current MSW PE bit if not specified)
     * @param {boolean} [fV86] true if the X86.PS.VM (V86-mode) flag is set (or is about to be)
     */
    setProtMode(fProt, fV86)
    {
        if (fProt === undefined) {
            fProt = this.isProtMode();
        }
        if (fV86 === undefined) {
            fV86 = this.isV86Mode();
        }
        if (DEBUG && (fProt != this.isProtMode() || fV86 != this.isV86Mode())) {
            this.printf(MESSAGE.ADDR, "CPU switching to %s-mode\n", (fProt? (fV86? "v86" : "protected") : "real"));
        }
        this.aOpGrp6 = (fProt && !fV86? X86.aOpGrp6Prot : X86.aOpGrp6Real);
        this.segCS.updateMode(false, fProt, fV86);
        this.segDS.updateMode(false, fProt, fV86);
        this.segSS.updateMode(false, fProt, fV86);
        this.segES.updateMode(false, fProt, fV86);
        if (I386 && this.model >= X86.MODEL_80386) {
            this.segFS.updateMode(false, fProt, fV86);
            this.segGS.updateMode(false, fProt, fV86);
        }
        /**
         * This function used to be called only when I386 is true, but it's probably best if we ALWAYS call it, even
         * for 16-bit-only CPUs like the 8086 and 80286; this allows us to write opcode logic by either checking I386
         * and using appropriate hard-coded sizes, or NOT checking I386 and simply using the "soft-coded" sizes in
         * sizeData and sizeAddr.
         */
        this.resetSizes();
    }

    /**
     * saveProtMode()
     *
     * Save CPU state related to protected-mode, for save()
     *
     * @this {CPUx86}
     * @returns {Array}
     */
    saveProtMode()
    {
        if (this.addrGDT != null) {
            let a = [
                this.regCR0,
                this.addrGDT,
                this.addrGDTLimit,
                this.addrIDT,
                this.addrIDTLimit,
                this.segLDT.save(),
                this.segTSS.save(),
                this.nIOPL
            ];
            if (I386 && this.model >= X86.MODEL_80386) {
                a.push(this.regCR1);
                a.push(this.regCR2);
                a.push(this.regCR3);
                a.push(this.regDR);
                a.push(this.regTR);
            }
            return a;
        }
        return null;
    }

    /**
     * restoreProtMode()
     *
     * Restore CPU state related to protected-mode, for restore()
     *
     * @this {CPUx86}
     * @param {Array} a
     */
    restoreProtMode(a)
    {
        if (a && a.length) {
            this.regCR0 = a[0];
            this.addrGDT = a[1];
            this.addrGDTLimit = a[2];
            this.addrIDT = a[3];
            this.addrIDTLimit = a[4];
            this.segLDT.restore(a[5]);
            this.segTSS.restore(a[6]);
            this.nIOPL = a[7];
            if (I386 && this.model >= X86.MODEL_80386) {
                this.regCR1 = a[8];
                this.regCR2 = a[9];
                this.regCR3 = a[10];
                this.regDR  = a[11];
                this.regTR  = a[12];
            }
            this.setProtMode();
        }
    }

    /**
     * save(fRunning)
     *
     * This implements save support for the X86 component.
     *
     * NOTE: When the Computer starts issuing powerDown() calls, it always calls the CPU first, and the CPU's
     * powerDown() handler has the added responsibility of:
     *
     *      1) recording whether or not the CPU is currently running
     *      2) stopping the CPU if the powerDown is part of a shutDown
     *      3) passing the original running state to us
     *
     * UPDATES: The current speed multiplier from getSpeed() is now saved in group #3, so that your speed is preserved.
     *
     * @this {CPUx86}
     * @param {boolean} [fRunning]
     * @returns {Object|null}
     */
    save(fRunning)
    {
        let state = new State(this);
        state.set(0, [this.regEAX, this.regEBX, this.regECX, this.regEDX, this.getSP(), this.regEBP, this.regESI, this.regEDI]);
        let a = [this.getIP(), this.segCS.save(), this.segDS.save(), this.segSS.save(), this.segES.save(), this.saveProtMode(), this.getPS()];
        if (I386 && this.model >= X86.MODEL_80386) {
            a.push(this.segFS.save());
            a.push(this.segGS.save());
        }
        state.set(1, a);
        state.set(2, [this.segData.sName, this.segStack.sName, this.opFlags, this.opPrefixes, this.intFlags, this.regEA, this.regEAWrite]);
        state.set(3, [0, this.nTotalCycles, this.getSpeed(), fRunning, this.saveTimers()]);
        state.set(4, this.bus.saveMemory());
        return state.data();
    }

    /**
     * restore(data)
     *
     * This implements restore support for the X86 component.
     *
     * @this {CPUx86}
     * @param {Object} data
     * @returns {boolean} true if restore successful, false if not
     */
    restore(data)
    {
        let a = data[0];
        this.regEAX = a[0];
        this.regEBX = a[1];
        this.regECX = a[2];
        this.regEDX = a[3];
        let regESP = a[4];
        this.regEBP = a[5];
        this.regESI = a[6];
        this.regEDI = a[7];

        a = data[1];
        this.segCS.restore(a[1]);
        this.segDS.restore(a[2]);
        this.segSS.restore(a[3]);
        this.segES.restore(a[4]);
        this.restoreProtMode(a[5]);
        this.setPS(a[6]);

        /**
         * The introduction of protected-mode requires us to restore memory contents sooner than we used to
         * (ie, before we load any segment registers).
         */
        let fRestored = false;

        if (this.bus.restoreMemory(data[4])) {
            /**
             * It's important to call setCSIP(), both to ensure that the CPU's linear IP register (regLIP) is updated
             * properly AND to ensure the CPU's default ADDRESS and OPERAND sizes are set properly.
             */
            this.setCSIP(a[0], this.segCS.sel);

            /**
             * It's also important to call setSP(), so that the linear SP register (regLSP) will be updated properly;
             * we also need to call setSS(), to ensure that the lower and upper stack limits are properly initialized.
             */
            this.setSP(regESP);
            this.setSS(this.segSS.sel);

            if (I386 && this.model >= X86.MODEL_80386) {
                this.segFS.restore(a[7]);
                this.segGS.restore(a[8]);
            }
            fRestored = true;
        }

        a = data[2];
        this.segData  = a[0] != null && this.getSeg(a[0]) || this.segDS;
        this.segStack = a[1] != null && this.getSeg(a[1]) || this.segSS;
        this.opFlags = a[2];
        this.opPrefixes = a[3];
        this.intFlags = a[4];
        this.regEA = a[5];          // save/restore of last EA calculation(s) isn't strictly necessary,
        this.regEAWrite = a[6];     // but they may be of some interest to, say, the Debugger

        a = data[3];
        this.nTotalCycles = a[1];   // a[0] was previously nBurstDivisor (no longer used)
        this.setSpeed(a[2]);        // old states didn't contain a value from getSpeed(), but setSpeed() checks
        /**
         * autoStart is normally either true, false, or null (the latter depends on the presence of a debugger),
         * but there are special circumstances where it can be a number (ie, zero) if someone has decided that the
         * machine should NOT be auto-started regardless.
         */
        if (a[3] != null && this.flags.autoStart !== 0) {   // less old states didn't preserve the original running state
            this.flags.autoStart = a[3] || null;            // prefer null over false, because false is a firm no-autoStart
        }
        if (a[4] != null) {
            this.restoreTimers(a[4]);
        }
        /**
         * Making sure the ROM BIOS timer values are synced with the RTC (if any) is something the ChipSet component
         * would take care of automatically, but alas, it is initialized long before RAM is restored, so we have to make
         * this callback.
         */
        if (this.chipset) this.chipset.syncRTCTime();
        return fRestored;
    }

    /**
     * getSeg(sName)
     *
     * @param {string} sName
     * @returns {Segx86|Array}
     */
    getSeg(sName)
    {
        switch(sName) {
        case "CS":
            return this.segCS;
        case "DS":
            return this.segDS;
        case "SS":
            return this.segSS;
        case "ES":
            return this.segES;
        case "NULL":
            return this.segNULL;
        default:
            /**
             * HACK: We return a fake segment register object in which only the base linear address is valid,
             * because that's all the caller provided (ie, we must be restoring from an older state).
             */

            return [0, sName, 0, 0, ""];
        }
    }

    /**
     * getCS()
     *
     * @this {CPUx86}
     * @returns {number}
     */
    getCS()
    {
        return this.segCS.sel;
    }

    /**
     * setCS(sel)
     *
     * NOTE: This is used ONLY by those few undocumented 8086/8088/80186/80188 instructions that "MOV" or "POP" a value
     * into CS, which we assume have the same behavior as any other instruction that moves or pops a segment register
     * (ie, suppresses h/w interrupts for one instruction).  Instructions that "JMP" or "CALL" or "INT" or "IRET" a new
     * value into CS are always accompanied by a new IP value, so they use setCSIP() instead, which does NOT suppress
     * h/w interrupts.
     *
     * @this {CPUx86}
     * @param {number} sel
     * @returns {boolean}
     */
    setCS(sel)
    {
        if (this.setCSIP(this.getIP(), sel) != null) {
            if (!BUGS_8086) this.opFlags |= this.OPFLAG_NOINTR_8086;
            return true;
        }
        return false;
    }

    /**
     * getDS()
     *
     * @this {CPUx86}
     * @returns {number}
     */
    getDS()
    {
        return this.segDS.sel;
    }

    /**
     * setDS(sel)
     *
     * @this {CPUx86}
     * @param {number} sel
     */
    setDS(sel)
    {
        if (this.segDS.load(sel) !== X86.ADDR_INVALID) {
            if (!BUGS_8086) this.opFlags |= this.OPFLAG_NOINTR_8086;
            return true;
        }
        return false;
    }

    /**
     * getSS()
     *
     * @this {CPUx86}
     * @returns {number}
     */
    getSS()
    {
        return this.segSS.sel;
    }

    /**
     * setSS(sel)
     *
     * @this {CPUx86}
     * @param {number} sel
     * @param {boolean} [fInterruptable]
     * @returns {boolean}
     */
    setSS(sel, fInterruptable)
    {
        let regESP = this.getSP();
        let regLSP = this.segSS.load(sel);
        if (regLSP !== X86.ADDR_INVALID) {
            /**
             * The safest way to update regLSP after a potential change to segSS.base is to call setSP() with the
             * original stack pointer retrieved above via getSP().  When I tried to be clever and do this instead:
             *
             *      this.regLSP = (regLSP + regESP)|0;
             *
             * 16-bit stacks began inadvertently using ESP instead of SP.  The moral: don't be needlessly clever.
             */
            this.setSP(regESP);

            /**
             * The desire to use a linear stack pointer (regLSP) for internal stack operations has some pitfalls;
             * one involves these upper and lower limit calculations.  Example: Xenix 386 creates a (non-expand-down)
             * 32-bit data segment for all of DS, ES, and SS, which uses a limit of "-1"; ie:
             *
             *      SS=0018[ED800000,FFFFFFFF] DS=0018[ED800000,FFFFFFFF] ES=0018[ED800000,FFFFFFFF]
             *
             * so we end up calculating an upper limit of 0xED7FFFFF, which is lower than the lower limit of 0xED800000.
             *
             * For now, these "limit wrap-around" situations are resolved by using unsigned values and then applying
             * a linear address ceiling.  TODO: Come up with a simple solution for properly dealing with limit wrap-around.
             */
            if (this.segSS.fExpDown) {
                this.regLSPLimit = (this.segSS.base >>> 0) + (this.segSS.maskAddr >>> 0);
                this.regLSPLimitLow = (this.segSS.base >>> 0) + (this.segSS.limit >>> 0);
            } else {
                this.regLSPLimit = (this.segSS.base >>> 0) + (this.segSS.limit >>> 0);
                this.regLSPLimitLow = (this.segSS.base >>> 0);
            }

            this.regLSPLimit = Math.min(this.regLSPLimit, this.nMemMask >>> 0);
            this.regLSPLimitLow = Math.min(this.regLSPLimitLow, this.nMemMask >>> 0);

            if (!BUGS_8086 && !fInterruptable) this.opFlags |= X86.OPFLAG.NOINTR;
            return true;
        }
        return false;
    }

    /**
     * getES()
     *
     * @this {CPUx86}
     * @returns {number}
     */
    getES()
    {
        return this.segES.sel;
    }

    /**
     * setES(sel)
     *
     * @this {CPUx86}
     * @param {number} sel
     * @returns {boolean}
     */
    setES(sel)
    {
        if (this.segES.load(sel) !== X86.ADDR_INVALID) {
            if (!BUGS_8086) this.opFlags |= this.OPFLAG_NOINTR_8086;
            return true;
        }
        return false;
    }

    /**
     * getFS()
     *
     * NOTE: segFS is defined for I386 only.
     *
     * @this {CPUx86}
     * @returns {number}
     */
    getFS()
    {
        return this.segFS.sel;
    }

    /**
     * setFS(sel)
     *
     * NOTE: segFS is defined for I386 only.
     *
     * @this {CPUx86}
     * @param {number} sel
     * @returns {boolean}
     */
    setFS(sel)
    {
        return this.segFS.load(sel) !== X86.ADDR_INVALID;
    }

    /**
     * getGS()
     *
     * NOTE: segGS is defined for I386 only.
     *
     * @this {CPUx86}
     * @returns {number}
     */
    getGS()
    {
        return this.segGS.sel;
    }

    /**
     * setGS(sel)
     *
     * NOTE: segGS is defined for I386 only.
     *
     * @this {CPUx86}
     * @param {number} sel
     * @returns {boolean}
     */
    setGS(sel)
    {
        return this.segGS.load(sel) !== X86.ADDR_INVALID;
    }

    /**
     * getIP()
     *
     * @this {CPUx86}
     * @returns {number}
     */
    getIP()
    {
        return (this.regLIP - this.segCS.base)|0;
    }

    /**
     * setIP(off)
     *
     * @this {CPUx86}
     * @param {number} off
     */
    setIP(off)
    {
        this.regLIP = (this.segCS.base + (off & (I386? this.maskData : 0xffff)))|0;
        if (PREFETCH) this.refillPrefetch();
    }

    /**
     * setLIP(addr)
     *
     * @this {CPUx86}
     * @param {number} addr
     */
    setLIP(addr)
    {
        this.regLIP = addr;
        this.regLIPMax = (this.segCS.base >>> 0) + (this.segCS.limit >>> 0) + 1;

        /**
         * TODO: Verify the proper source for CPL.  Should it come from segCS.cpl or segCS.dpl?
         * Note that LOADALL386 wants it to come from segSS.dpl.
         */
        this.nCPL = this.segCS.cpl;             // cache the current CPL where it's more convenient

        if (I386 && this.model >= X86.MODEL_80386) {
            this.resetSizes();
        }

        /**
         * Here, we need to additionally test whether the prefetch buffer (adwPrefetch) has been allocated yet,
         * because when resetRegs() is first called, the Bus hasn't been initialized yet, so there's nothing to fetch.
         *
         * We'll allocate the prefetch buffer when the Bus calls initMemory().
         */
        if (PREFETCH && this.adwPrefetch) this.refillPrefetch();
    }

    /**
     * setCSIP(off, sel, fCall)
     *
     * This function is a little different from the other segment setters, only because it turns out that CS is
     * never set without an accompanying IP (well, except for a few undocumented instructions, like POP CS, which
     * were available ONLY on the 8086/8088/80186/80188; see setCS() for details).
     *
     * And even though this function is called setCSIP(), please note the order of the parameters is [IP,CS],
     * which matches the order that CS:IP values are normally stored in memory, allowing us to make calls like this:
     *
     *      this.setCSIP(this.popWord(), this.popWord());
     *
     * @this {CPUx86}
     * @param {number} off
     * @param {number} sel
     * @param {boolean} [fCall] is true if CALLF in progress, false if RETF/IRET in progress, undefined otherwise
     * @returns {boolean|null} true if a stack switch occurred; the only operation that needs to pay attention is opRETFn()
     */
    setCSIP(off, sel, fCall)
    {
        /**
         * Setting IP needs to occur AFTER loadCode(), because it may differ from the given IP if sel refers to a gate.
         */
        let base = this.segCS.loadCode(off, sel, fCall);
        if (base !== X86.ADDR_INVALID) {
            this.setLIP(base + (this.segCS.offIP & (I386? this.segCS.maskData : 0xffff)));
            return this.segCS.fStackSwitch;
        }
        return null;
    }

    /**
     * setCSBase(addr)
     *
     * Since the CPU must maintain regLIP as the sum of the CS base and the current IP, all calls to setBase()
     * for segCS need to go through here.
     *
     * @param {number} addr
     */
    setCSBase(addr)
    {
        let regIP = this.getIP();
        addr = this.segCS.setBase(addr);
        this.regLIP = (addr + regIP)|0;
        this.regLIPMax = (addr >>> 0) + (this.segCS.limit >>> 0) + 1;
    }

    /**
     * checkIP(inc)
     *
     * TODO: If we didn't care about compatibility, we could just return:
     *
     *      (this.regLIP + inc)|0
     *
     * and be done with it, because there probably isn't any "good" code that triggers the
     * "newLIP > this.regLIPMax" condition.  This check costs us about 2Mhz performance on an 80386.
     *
     * Turning PREFETCH on tends to offset this performance hit, but PREFETCH *without* this hit would
     * probably perform even better.
     *
     * @this {CPUx86}
     * @param {number} inc (positive)
     * @returns {number} new LIP
     */
    checkIP(inc)
    {
        let newLIP = (this.regLIP >>> 0) + inc;
        if (newLIP > this.regLIPMax) {
            /**
             * There's no such thing as a GP fault on the 8086/8088, and I'm now assuming that,
             * on newer processors, all attempts to fetch opcodes beyond the limit trigger a fault.
             */
            if (this.model <= X86.MODEL_8088 /* || this.segCS.limit == this.segCS.maskAddr */) {
                newLIP = this.segCS.base + ((newLIP - this.regLIPMax) & (I386? this.maskData : 0xffff));
                if (inc == 2) this.opFlags |= X86.OPFLAG.WRAP;
            } else {
                X86.helpFault.call(this, X86.EXCEPTION.GP_FAULT, 0);
            }
        }
        return newLIP|0;
    }

    /**
     * resetIP()
     *
     * @this {CPUx86}
     */
    resetIP()
    {
        if (PREFETCH) {
            this.cbPrefetch += this.regLIP - this.opLIP;
            this.regLIP = this.opLIP;
            /**
             * If the reset produces a prefetch total greater than the allocated amount, then we must have
             * refilled the queue somewhere in the middle of the rewound instruction, so we need to refill the
             * queue all over again; otherwise, the next repetition may fetch future data instead of past data.
             *
             * That's the bad news; the good news is that this extra refill should only hurt performance of the
             * first repetition.
             */
            if (this.cbPrefetch > CPUx86.PFINFO.LENGTH) this.refillPrefetch();
        } else {
            this.regLIP = this.opLIP;
        }
    }

    /**
     * rewindIP(fCheckSeg)
     *
     * This "rewinds" IP to the beginning of the current instruction (ie, the REP prefix of a string instruction).
     *
     * @this {CPUx86}
     * @param {boolean} [fCheckSeg]
     */
    rewindIP(fCheckSeg = false)
    {
        if (fCheckSeg && (this.opPrefixes & X86.OPFLAG.SEG)) {
            /**
             * This instruction has both REP and SEG overrides, so if we IRET'ed to it with interrupts enabled,
             * don't repeat it; this helps simulate the 8086/8088's failure to properly restart such an instruction
             * after a hardware interrupt (which became known as a "feature", hence not part of BUGS_8086).
             */
            if (this.model <= X86.MODEL_8088 && (this.opPrefixes & X86.OPFLAG.IRET) && (this.regPS & X86.PS.IF)) {
                return;
            }
        }
        this.opFlags |= X86.OPFLAG.REPEAT;
        this.resetIP();
    }

    /**
     * getSP()
     *
     * @this {CPUx86}
     * @returns {number}
     */
    getSP()
    {
        if (I386) {
            // assert(!((this.regLSP - this.segSS.base) & ~this.segSS.maskAddr));
            return (this.regESP & ~this.segSS.maskAddr) | (this.regLSP - this.segSS.base);
        }
        return (this.regLSP - this.segSS.base)|0;
    }

    /**
     * setSP(off)
     *
     * @this {CPUx86}
     * @param {number} off
     */
    setSP(off)
    {
        if (I386) {
            this.regESP = off;
            this.regLSP = (this.segSS.base + (off & this.segSS.maskAddr))|0;
        } else {
            this.regLSP = (this.segSS.base + off)|0;
        }
    }

    /**
     * setArithResult(dst, src, value, type, fSubtract)
     *
     * Updates the flags for arithmetic instructions; use setLogicResult() for logical instructions.
     *
     * The type parameter indicates both the size of the result (BYTE, WORD or DWORD) and which of the
     * flags should now be considered "cached" by the new result variables.  If the previous resultType
     * specifies any flags not contained in the new type parameter, then those flags must be immediately
     * calculated and written to the appropriate bit(s) in regPS.
     *
     * The default assumes an "addition" (eg, ADD, ADC, INC), where value = dst + src. The fSubtract
     * parameter is used to indicate a "subtraction" (eg, CMP, DEC, SUB, SBB), where value = dst - src;
     * We can transform a subtraction into an addition, since it's also true that dst = value + src,
     * by swapping swap dst and value -- which is exactly what we do below.  This allows all downstream
     * flag calculations (eg, getCF(), getOF()) to remain the same.
     *
     * @this {CPUx86}
     * @param {number} dst
     * @param {number} src
     * @param {number} value
     * @param {number} type
     * @param {boolean} [fSubtract]
     */
    setArithResult(dst, src, value, type, fSubtract)
    {
        if ((type & X86.RESULT.ALL) != X86.RESULT.ALL && type != this.resultType) {
            let diff = ((type ^ this.resultType) & this.resultType);
            if (diff) {
                if (diff & X86.RESULT.CF) this.getCF();
                if (diff & X86.RESULT.PF) this.getPF();
                if (diff & X86.RESULT.AF) this.getAF();
                if (diff & X86.RESULT.ZF) this.getZF();
                if (diff & X86.RESULT.SF) this.getSF();
                if (diff & X86.RESULT.OF) this.getOF();
            }
        }
        if (!fSubtract) {
            this.resultDst = dst;
            this.resultArith = value;
        } else {
            this.resultDst = value;
            this.resultArith = dst;
        }
        this.resultSrc = src;
        this.resultLogic = value;
        this.resultType = type;
    }

    /**
     * setLogicResult(value, type, carry, overflow)
     *
     * Updates the flags for logical instructions (eg, AND, OR, TEST, XOR); ie, instructions
     * that update PF, ZF, and SF, while clearing CF and OF (although CF and OF can be explicitly
     * set via the carry and overflow parameters as needed).  AF is always considered undefined.
     *
     * TODO: We should observe the behavior of AF on real CPUs, and determine if there is a
     * well-defined behavior, even though none is documented.  Ditto for OF on shift instructions
     * when the shift count > 1.
     *
     * @this {CPUx86}
     * @param {number} value
     * @param {number} type
     * @param {number} [carry]
     * @param {number} [overflow]
     * @returns {number} value
     */
    setLogicResult(value, type, carry, overflow)
    {
        this.resultType = type | X86.RESULT.LOGIC;
        this.resultLogic = value;
        if (carry) this.setCF(); else this.clearCF();
        if (overflow) this.setOF(); else this.clearOF();
        /**
         * Limited testing on actual hardware (the Intel Core i5 in my Mac Mini) as well as test
         * results from another user (https://github.com/jeffpar/pcjs/issues/81) suggest that AF is
         * cleared by logic ops (at least AND/OR/TEST/XOR; see https://sandpile.org/x86/flags.htm).
         *
         * The official Intel stance on AF in these circumstances is that it's "undefined", but we all
         * know that's just code for "we don't want to document how it ACTUALLY behaves".  Clearing AF
         * seems, um, "clearly" better than just letting it float, but that's all we can say for now.
         *
         * In particular, real-world tests with shift and rotate instructions are needed, because unlike
         * AND/OR/TEST/XOR, those alter carry in very specific ways, so why not "auxiliary carry" as well?
         *
         * In other words, clearAF() is not the end of the story; the original TODO above is still
         * very much a "to do".
         */
        this.clearAF();
        return value;
    }

    /**
     * setRotateResult(result, carry, size)
     *
     * Used by all rotate instructions (ie, RCL, RCR, ROL, ROR) to update CF and OF.
     *
     * TODO: We should observe the behavior of OF on real CPUs whenever the rotate count > 1,
     * and determine if there is a well-defined behavior, even though none is documented.
     *
     * @this {CPUx86}
     * @param {number} result
     * @param {number} carry
     * @param {number} size
     */
    setRotateResult(result, carry, size)
    {
        if (carry & size) this.setCF(); else this.clearCF();
        if ((result ^ carry) & size) this.setOF(); else this.clearOF();
    }

    /**
     * getCarry()
     *
     * @this {CPUx86}
     * @returns {number} 0 or 1, depending on whether CF is clear or set
     */
    getCarry()
    {
        return this.getCF()? 1 : 0;
    }

    /**
     * getCF()
     *
     * The following table summarizes bit 31 of the dst (D) and src (S) operands, bit 31 of the
     * addition (A), along with the expected carry bit (C):
     *
     *      D   S   A   C
     *      -   -   -   -
     *      0   0   0   0       no
     *      0   0   1   0       no (there must have been a carry out of bit 30, but it was "absorbed")
     *      0   1   0   1       yes (there must have been a carry out of bit 30, but it was NOT "absorbed")
     *      0   1   1   0       no
     *      1   0   0   1       yes (same as the preceding "yes" case)
     *      1   0   1   0       no
     *      1   1   0   1       yes (since the addition of two ones must always produce a carry)
     *      1   1   1   1       yes (since the addition of two ones must always produce a carry)
     *
     * So, we use the following calculation:
     *
     *      (resultDst ^ ((resultDst ^ resultSrc) & (resultSrc ^ resultArith))) & resultType
     *
     * NOTE: The above table assumes that the resultDst (D) and resultSrc (S) operands were ADDED to
     * produce resultArith (A); if they were SUBTRACTED instead (D - S), then D and A must be swapped
     * after the subtraction, so that the above truth table still applies; see setArithResult().
     *
     * @this {CPUx86}
     * @returns {number} 0 or X86.PS.CF
     */
    getCF()
    {
        if (this.resultType & X86.RESULT.CF) {
            this.regPS &= ~X86.PS.CF;
            if ((this.resultDst ^ ((this.resultDst ^ this.resultSrc) & (this.resultSrc ^ this.resultArith))) & (this.resultType & X86.RESULT.TYPE)) {
                this.regPS |= X86.PS.CF;
            }
            this.resultType &= ~X86.RESULT.CF;
        }
        return this.regPS & X86.PS.CF;
    }

    /**
     * getPF()
     *
     * From http://graphics.stanford.edu/~seander/bithacks.html#ParityParallel:
     *
     *      unsigned int v;  // word value to compute the parity of
     *      v ^= v >> 16;
     *      v ^= v >> 8;
     *      v ^= v >> 4;
     *      v &= 0xf;
     *      return (0x6996 >> v) & 1;
     *
     *      The method above takes around 9 operations, and works for 32-bit words.  It may be optimized to work just on
     *      bytes in 5 operations by removing the two lines immediately following "unsigned int v;".  The method first shifts
     *      and XORs the eight nibbles of the 32-bit value together, leaving the result in the lowest nibble of v.  Next,
     *      the binary number 0110 1001 1001 0110 (0x6996 in hex) is shifted to the right by the value represented in the
     *      lowest nibble of v.  This number is like a miniature 16-bit parity-table indexed by the low four bits in v.
     *      The result has the parity of v in bit 1, which is masked and returned.
     *
     * The x86 parity flag (PF) is based exclusively on the low 8 bits of resultParitySign, so our calculation is bit
     * simpler.  Note that PF must be SET if that byte has EVEN parity, and CLEAR if it has ODD parity.
     *
     * @this {CPUx86}
     * @returns {number} 0 or X86.PS.PF
     */
    getPF()
    {
        if (this.resultType & X86.RESULT.PF) {
            this.regPS &= ~X86.PS.PF;
            if ((0x9669 >> ((this.resultLogic ^ (this.resultLogic >> 4)) & 0xf)) & 1) {
                this.regPS |= X86.PS.PF;
            }
            this.resultType &= ~X86.RESULT.PF;
        }
        return this.regPS & X86.PS.PF;
    }

    /**
     * getAF()
     *
     * To determine if there's been a carry out of the low 4 bits of an arithmetic operation,
     * we look at all the possible inputs for bit 4, and calculate AF = A^(D^S).
     *
     *      D   S   A   D^S AF
     *      -   -   -   --- --
     *      0   0   0   0   0
     *      0   0   1   0   1
     *      0   1   0   1   1
     *      0   1   1   1   0
     *      1   0   0   1   1
     *      1   0   1   1   0
     *      1   1   0   0   0
     *      1   1   1   0   1
     *
     * The final calculation looks like:
     *
     *      (resultArith ^ (resultDst ^ resultSrc)) & 0x0010
     *
     * @this {CPUx86}
     * @returns {number} 0 or X86.PS.AF
     */
    getAF()
    {
        if (this.resultType & X86.RESULT.AF) {
            this.regPS &= ~X86.PS.AF;
            if ((this.resultArith ^ (this.resultDst ^ this.resultSrc)) & 0x0010) {
                this.regPS |= X86.PS.AF;
            }
            this.resultType &= ~X86.RESULT.AF;
        }
        return this.regPS & X86.PS.AF;
    }

    /**
     * getZF()
     *
     * @this {CPUx86}
     * @returns {number} 0 or X86.PS.ZF
     */
    getZF()
    {
        if (this.resultType & X86.RESULT.ZF) {
            this.regPS &= ~X86.PS.ZF;
            if (!(this.resultLogic & (((this.resultType & X86.RESULT.TYPE) - 1) | (this.resultType & X86.RESULT.TYPE)))) {
                this.regPS |= X86.PS.ZF;
            }
            this.resultType &= ~X86.RESULT.ZF;
        }
        return this.regPS & X86.PS.ZF;
    }

    /**
     * getSF()
     *
     * @this {CPUx86}
     * @returns {number} 0 or X86.PS.SF
     */
    getSF()
    {
        if (this.resultType & X86.RESULT.SF) {
            this.regPS &= ~X86.PS.SF;
            if (this.resultLogic & (this.resultType & X86.RESULT.TYPE)) {
                this.regPS |= X86.PS.SF;
            }
            this.resultType &= ~X86.RESULT.SF;
        }
        return this.regPS & X86.PS.SF;
    }

    /**
     * getOF()
     *
     * Overflow was originally calculated as:
     *
     *      (resultParitySign ^ resultAuxOverflow ^ (resultParitySign >> 1)) & (resultSize >> 1)
     *
     * but as you can see, that calculation depends on the carry out of the 8/16/32-bit result in
     * resultParitySign, which we don't have access to for 32-bit results.  So we fall-back to the
     * following:
     *
     *      ((resultDst ^ resultArith) & (resultSrc ^ resultArith)) & resultType
     *
     * which you can verify from the following table of sign bits, where x1 is resultDst ^ resultArith,
     * and x2 is resultSrc ^ resultArith:
     *
     *      D   S   A   x1  x2  OF
     *      -   -   -   --  --  --
     *      0   0   0   0   0   0
     *      0   0   1   1   1   1 (adding two positive values yielded a negative value)
     *      0   1   0   0   1   0
     *      0   1   1   1   0   0
     *      1   0   0   1   0   0
     *      1   0   1   0   1   0
     *      1   1   0   1   1   1 (adding two negative values yielded a positive value)
     *      1   1   1   0   0   0
     *
     * NOTE: The above table assumes that the resultDst (D) and resultSrc (S) operands were ADDED to
     * produce resultArith (A); if they were SUBTRACTED instead (D - S), then D and A must be swapped
     * after the subtraction, so that the above truth table still applies; see setArithResult().
     *
     * @this {CPUx86}
     * @returns {number} 0 or X86.PS.OF
     */
    getOF()
    {
        if (this.resultType & X86.RESULT.OF) {
            this.regPS &= ~X86.PS.OF;
            if (((this.resultDst ^ this.resultArith) & (this.resultSrc ^ this.resultArith)) & (this.resultType & X86.RESULT.TYPE)) {
                this.regPS |= X86.PS.OF;
            }
            this.resultType &= ~X86.RESULT.OF;
        }
        return this.regPS & X86.PS.OF;
    }

    /**
     * getTF()
     *
     * @this {CPUx86}
     * @returns {number} 0 or X86.PS.TF
     */
    getTF()
    {
        return (this.regPS & X86.PS.TF);
    }

    /**
     * getIF()
     *
     * @this {CPUx86}
     * @returns {number} 0 or X86.PS.IF
     */
    getIF()
    {
        return (this.regPS & X86.PS.IF);
    }

    /**
     * getDF()
     *
     * @this {CPUx86}
     * @returns {number} 0 or X86.PS.DF
     */
    getDF()
    {
        return (this.regPS & X86.PS.DF);
    }

    /**
     * clearCF()
     *
     * @this {CPUx86}
     */
    clearCF()
    {
        this.resultType &= ~X86.RESULT.CF;
        this.regPS &= ~X86.PS.CF;
    }

    /**
     * clearPF()
     *
     * @this {CPUx86}
     */
    clearPF()
    {
        this.resultType &= ~X86.RESULT.PF;
        this.regPS &= ~X86.PS.PF;
    }

    /**
     * clearAF()
     *
     * @this {CPUx86}
     */
    clearAF()
    {
        this.resultType &= ~X86.RESULT.AF;
        this.regPS &= ~X86.PS.AF;
    }

    /**
     * clearZF()
     *
     * @this {CPUx86}
     */
    clearZF()
    {
        this.resultType &= ~X86.RESULT.ZF;
        this.regPS &= ~X86.PS.ZF;
    }

    /**
     * clearSF()
     *
     * @this {CPUx86}
     */
    clearSF()
    {
        this.resultType &= ~X86.RESULT.SF;
        this.regPS &= ~X86.PS.SF;
    }

    /**
     * clearIF()
     *
     * @this {CPUx86}
     */
    clearIF()
    {
        this.regPS &= ~X86.PS.IF;
    }

    /**
     * clearDF()
     *
     * @this {CPUx86}
     */
    clearDF()
    {
        this.regPS &= ~X86.PS.DF;
    }

    /**
     * clearOF()
     *
     * @this {CPUx86}
     */
    clearOF()
    {
        this.resultType &= ~X86.RESULT.OF;
        this.regPS &= ~X86.PS.OF;
    }

    /**
     * setCF()
     *
     * @this {CPUx86}
     */
    setCF()
    {
        this.resultType &= ~X86.RESULT.CF;
        this.regPS |= X86.PS.CF;
    }

    /**
     * setPF()
     *
     * @this {CPUx86}
     */
    setPF()
    {
        this.resultType &= ~X86.RESULT.PF;
        this.regPS |= X86.PS.PF;
    }

    /**
     * setAF()
     *
     * @this {CPUx86}
     */
    setAF()
    {
        this.resultType &= ~X86.RESULT.AF;
        this.regPS |= X86.PS.AF;
    }

    /**
     * setZF()
     *
     * @this {CPUx86}
     */
    setZF()
    {
        this.resultType &= ~X86.RESULT.ZF;
        this.regPS |= X86.PS.ZF;
    }

    /**
     * setSF()
     *
     * @this {CPUx86}
     */
    setSF()
    {
        this.resultType &= ~X86.RESULT.SF;
        this.regPS |= X86.PS.SF;
    }

    /**
     * setIF()
     *
     * @this {CPUx86}
     */
    setIF()
    {
        this.regPS |= X86.PS.IF;
    }

    /**
     * setDF()
     *
     * @this {CPUx86}
     */
    setDF()
    {
        this.regPS |= X86.PS.DF;
    }

    /**
     * setOF()
     *
     * @this {CPUx86}
     */
    setOF()
    {
        this.resultType &= ~X86.RESULT.OF;
        this.regPS |= X86.PS.OF;
    }

    /**
     * getPS()
     *
     * @this {CPUx86}
     * @returns {number}
     */
    getPS()
    {
        return (this.regPS & ~X86.PS_CACHED) | (this.getCF() | this.getPF() | this.getAF() | this.getZF() | this.getSF() | this.getOF());
    }

    /**
     * setMSW(w)
     *
     * Factored out of x86op0f.js, since both opLMSW and opLOADALL are capable of setting a new MSW.
     * The caller is responsible for assessing the appropriate cycle cost.
     *
     * @this {CPUx86}
     * @param {number} w
     */
    setMSW(w)
    {
        /**
         * This instruction is always allowed to set MSW.PE, but it cannot clear MSW.PE once set;
         * therefore, we always OR the previous value of MSW.PE into the new value before loading.
         */
        w |= (this.regCR0 & X86.CR0.MSW.PE) | X86.CR0.MSW.ON;
        this.regCR0 = (this.regCR0 & ~X86.CR0.MSW.MASK) | (w & X86.CR0.MSW.MASK);
        /**
         * Since the 80286 cannot return to real-mode via this instruction, the only transition we
         * must worry about is to protected-mode.  And there's no harm calling setProtMode() if the
         * CPU is already in protected-mode; we could certainly optimize out the call in that case,
         * but the instruction isn't used frequently enough to warrant it.
         */
        if (this.regCR0 & X86.CR0.MSW.PE) this.setProtMode(true);
    }

    /**
     * setPS(regPS)
     *
     * @this {CPUx86}
     * @param {number} regPS
     * @param {number} [cpl]
     */
    setPS(regPS, cpl)
    {
        /**
         * OS/2 1.0 discriminates between an 80286 and an 80386 based on whether an IRET in real-mode that
         * pops 0xF000 into the flags is able to set *any* of flag bits 12-15: if it can, then OS/2 declares
         * the CPU an 80386.
         *
         * So, if the CPU is an 80286, we clear incoming bits 12-14 in real-mode (bit 15 is never allowed to
         * be modified, so there's no need to mask it).  And if the CPU is an 80386, no bits are automatically
         * cleared in real-mode (PS_CLEAR_RM is zero); although that allows the IOPL bits to change, it doesn't
         * affect real-mode operation, since CPL is always zero, making IOPL irrelevant.
         */
        if (!(this.regCR0 & X86.CR0.MSW.PE)) regPS &= ~this.PS_CLEAR_RM;

        /**
         * There are some cases (eg, an IRET returning to a less privileged code segment) where the CPL
         * we compare against should come from the outgoing code segment, so if the caller provided it, use it.
         */
        if (cpl === undefined) cpl = this.nCPL;

        /**
         * Since PS.IOPL and PS.IF are part of PS_DIRECT, we need to take care of any 80286-specific behaviors
         * before setting the PS_DIRECT bits from the incoming regPS bits.
         *
         * Specifically, PS.IOPL is unchanged if CPL > 0, and PS.IF is unchanged if CPL > IOPL.
         */
        if (!cpl) {
            this.nIOPL = (regPS & X86.PS.IOPL.MASK) >> X86.PS.IOPL.SHIFT;           // IOPL allowed to change
        } else {
            regPS = (regPS & ~X86.PS.IOPL.MASK) | (this.regPS & X86.PS.IOPL.MASK);  // IOPL not allowed to change
        }

        if (cpl > this.nIOPL) {
            regPS = (regPS & ~X86.PS.IF) | (this.regPS & X86.PS.IF);                // IF not allowed to change
        }

        this.resultType = X86.RESULT.BYTE;
        this.regPS = (this.regPS & ~(this.PS_DIRECT|X86.PS_CACHED)) | (regPS & (this.PS_DIRECT|X86.PS_CACHED)) | this.PS_SET;

        if (this.regPS & X86.PS.TF) {
            this.intFlags |= X86.INTFLAG.TRAP;
            this.opFlags |= X86.OPFLAG.NOINTR;
        }
    }

    /**
     * checkIOPM(port, nPorts, fInput)
     *
     * @this {CPUx86}
     * @param {number} port (0x0000 to 0xffff)
     * @param {number} nPorts (1 to 4)
     * @param {boolean} [fInput] (true if input, false if output; output assumed if not specified)
     * @returns {boolean} true if allowed, false if not
     */
    checkIOPM(port, nPorts, fInput)
    {
        let bitsPorts = 0;
        if (I386 && (this.regCR0 & X86.CR0.MSW.PE) && (this.nCPL > this.nIOPL || (this.regPS & X86.PS.VM)) && this.segTSS.addrIOPM) {
            let offIOPM = port >>> 3;
            let addrIOPM = this.segTSS.addrIOPM + offIOPM;
            bitsPorts = ((1 << nPorts) - 1) << (port & 0x7);
            while (bitsPorts && addrIOPM <= this.segTSS.addrIOPMLimit) {
                let bits = this.getByte(addrIOPM);
                if (bits & bitsPorts) break;
                bitsPorts >>>= 8;
                addrIOPM++;
            }
        }
        if (bitsPorts) {
            this.printf(MESSAGE.IOPM + MESSAGE.ADDR, "checkIOPM(%#06x,%d,%s): trapped\n", port, nPorts, (fInput? "input" : "output"));
            X86.helpFault.call(this, X86.EXCEPTION.GP_FAULT, 0);
            return false;
        }
        return true;
    }

    /**
     * setBinding(sHTMLType, sBinding, control, sValue)
     *
     * @this {CPUx86}
     * @param {string} sHTMLType is the type of the HTML control (eg, "button", "list", "text", "submit", "textarea", "canvas")
     * @param {string} sBinding is the value of the 'binding' parameter stored in the HTML control's "data-value" attribute (eg, "AX")
     * @param {HTMLElement} control is the HTML control DOM object (eg, HTMLButtonElement)
     * @param {string} [sValue] optional data value
     * @returns {boolean} true if binding was successful, false if unrecognized binding request
     */
    setBinding(sHTMLType, sBinding, control, sValue)
    {
        let fBound = false;
        switch (sBinding) {
        case "EAX":
        case "EBX":
        case "ECX":
        case "EDX":
        case "ESP":
        case "EBP":
        case "ESI":
        case "EDI":
        case "EIP":
        case "AX":
        case "BX":
        case "CX":
        case "DX":
        case "SP":
        case "BP":
        case "SI":
        case "DI":
        case "IP":
        case "PC":      // deprecated as an alias for "IP" (still used by older XML files, like the one at http://tpoindex.github.io/crobots/)
        case "CS":
        case "DS":
        case "SS":
        case "ES":
        case "FS":
        case "GS":
        case "CR0":
        case "CR2":
        case "CR3":
        case "PS":      // this refers to "Processor Status", aka the 16-bit flags register (although DEBUG.COM refers to this as "PC", surprisingly)
        case "C":
        case "P":
        case "A":
        case "Z":
        case "S":
        case "T":
        case "I":
        case "D":
        case "V":
            this.bindings[sBinding] = control;
            this.cLiveRegs++;
            fBound = true;
            break;
        default:
            fBound = super.setBinding(sHTMLType, sBinding, control);
            break;
        }
        return fBound;
    }

    /**
     * probeAddr(addr, size, fPhysical)
     *
     * Used by the Debugger to probe addresses without risk of triggering a page fault, and by internal
     * functions, like helpCheckFault(), that must also avoid triggering faults, since they're not part of
     * standard CPU operation.
     *
     * Since originally written, I've also relaxed the requirement that the request be contained entirely
     * within a single block; this was never a problem for any size-aligned request, but unfortunately, it
     * was difficult for the Debugger to guarantee that every 2 or 4-byte request would be always be word or
     * dword-aligned.  So now requests that straddle blocks will be broken into smaller probeAddr() requests.
     *
     * @this {CPUx86}
     * @param {number} addr is a linear address
     * @param {number} [size] is a length (default is 1; if specified, must be 1, 2 or 4)
     * @param {boolean} [fPhysical] (true for physical probe, false for linear; linear is the default)
     * @returns {number|null} value at the specified address, or null if invalid
     */
    probeAddr(addr, size, fPhysical)
    {
        let aBlocks = (fPhysical? this.aBusBlocks : this.aMemBlocks);
        let block = aBlocks[(addr & this.nMemMask) >>> this.nBlockShift];
        if (block && block.type == Memoryx86.TYPE.UNPAGED) block = this.mapPageBlock(addr, false, true);

        if (block) {
            let off = addr & this.nBlockLimit;
            if (!size || size == 1) {
                return block.readByteDirect(off, addr);
            }
            if (size == 2) {
                if (off < this.nBlockLimit) {
                    return block.readShortDirect(off, addr);
                }
                return block.readByteDirect(off, addr) | (this.probeAddr(addr + 1, 1, fPhysical) << 8);
            }
            if (size == 4) {
                if (off < this.nBlockLimit - 2) {
                    return block.readLongDirect(off, addr);
                }
                if (off == this.nBlockLimit - 1) {
                    return block.readShortDirect(off, addr) | (this.probeAddr(addr + 2, 2, fPhysical) << 16);
                }
                return block.readByteDirect(off, addr) | (this.probeAddr(addr + 1, 1, fPhysical) << 8) | (this.probeAddr(addr + 2, 1, fPhysical) << 16) | (this.probeAddr(addr + 3, 1, fPhysical) << 24);
            }
        }

        /**
         * Since the Bus component initializes all unused portions of physical address space with an empty
         * block, we have also written mapPageBlock() to return an empty block (memEmpty) whenever there is
         * no valid mapping.  So if we ever end up here, this may represent a hole that needs plugging.
         *
         * It's also possible the caller passed a bogus parameter, such as an invalid size (must be 1, 2 or 4).
         */

        return null;
    }

    /**
     * getByte(addr)
     *
     * Use bus.getByte() for physical addresses, and cpu.getByte() for linear addresses; the latter takes care
     * of paging, cycle counts, and BACKTRACK states, if any.
     *
     * @this {CPUx86}
     * @param {number} addr is a linear address
     * @returns {number} byte (8-bit) value at that address
     */
    getByte(addr)
    {
        if (BACKTRACK) this.backTrack.btiMem0 = this.bus.readBackTrack(addr);
        return this.aMemBlocks[(addr & this.nMemMask) >>> this.nBlockShift].readByte(addr & this.nBlockLimit, addr);
    }

    /**
     * getShort(addr)
     *
     * Use bus.getShort() for physical addresses, and cpu.getShort() for linear addresses; the latter takes care
     * of paging, cycle counts, and BACKTRACK states, if any.
     *
     * @this {CPUx86}
     * @param {number} addr is a linear address
     * @returns {number} word (16-bit) value at that address
     */
    getShort(addr)
    {
        let off = addr & this.nBlockLimit;
        let iBlock = (addr & this.nMemMask) >>> this.nBlockShift;
        /**
         * On the 8088, it takes 4 cycles to read the additional byte REGARDLESS whether the address is odd or even.
         * TODO: For the 8086, the penalty is actually "(addr & 0x1) << 2" (4 additional cycles only when the address is odd).
         */
        this.nStepCycles -= this.cycleCounts.nWordCyclePenalty;

        if (BACKTRACK) {
            this.backTrack.btiMem0 = this.bus.readBackTrack(addr);
            this.backTrack.btiMem1 = this.bus.readBackTrack(addr + 1);
        }
        if (off < this.nBlockLimit) {
            return this.aMemBlocks[iBlock].readShort(off, addr);
        }
        let w = this.aMemBlocks[iBlock].readByte(off, addr);
        if (!(this.opFlags & X86.OPFLAG.FAULT)) {
            w |= this.aMemBlocks[(iBlock + 1) & this.nBlockMask].readByte(0, addr + 1) << 8;
        }
        return w;
    }

    /**
     * getLong(addr)
     *
     * Use bus.getLong() for physical addresses, and cpu.getLong() for linear addresses; the latter takes care
     * of paging, cycle counts, and BACKTRACK states, if any.
     *
     * @this {CPUx86}
     * @param {number} addr is a linear address
     * @returns {number} long (32-bit) value at that address
     */
    getLong(addr)
    {
        let off = addr & this.nBlockLimit;
        let iBlock = (addr & this.nMemMask) >>> this.nBlockShift;
        if (BACKTRACK) {
            this.backTrack.btiMem0 = this.bus.readBackTrack(addr);
            this.backTrack.btiMem1 = this.bus.readBackTrack(addr + 1);
            this.backTrack.btiMem2 = this.bus.readBackTrack(addr + 2);
            this.backTrack.btiMem3 = this.bus.readBackTrack(addr + 3);
        }
        if (off < this.nBlockLimit - 2) {
            return this.aMemBlocks[iBlock].readLong(off, addr);
        }
        /**
         * I think the previous version of this function tried to be too clever (ie, reading the last
         * long in the current block and the first long in the next block and masking/combining the results),
         * which may have also created some undesirable side-effects for custom memory controllers.
         * This simpler (and probably more reliable) approach is to simply read the long as individual bytes.
         */
        let l = 0;
        let cb = 4, nShift = 0;
        let cbBlock = 4 - (off & 0x3);    // (off & 0x3) will be 1, 2 or 3, so cbBlock will be 3, 2, or 1
        while (cb--) {
            l |= (this.aMemBlocks[iBlock].readByte(off++, addr++) << nShift);
            if (this.opFlags & X86.OPFLAG.FAULT) break;
            if (!--cbBlock) {
                iBlock = (iBlock + 1) & this.nBlockMask;
                off = 0;
            }
            nShift += 8;
        }
        return l;
    }

    /**
     * setByte(addr, b)
     *
     * Use bus.setByte() for physical addresses, and cpu.setByte() for linear addresses; the latter takes care
     * of paging, cycle counts, and BACKTRACK states, if any.
     *
     * @this {CPUx86}
     * @param {number} addr is a linear address
     * @param {number} b is the byte (8-bit) value to write (which we truncate to 8 bits; required by opSTOSb)
     */
    setByte(addr, b)
    {
        if (BACKTRACK) this.bus.writeBackTrack(addr, this.backTrack.btiMem0);
        this.aMemBlocks[(addr & this.nMemMask) >>> this.nBlockShift].writeByte(addr & this.nBlockLimit, b & 0xff, addr);
    }

    /**
     * setShort(addr, w)
     *
     * Use bus.setShort() for physical addresses, and cpu.setShort() for linear addresses; the latter takes care
     * of paging, cycle counts, and BACKTRACK states, if any.
     *
     * @this {CPUx86}
     * @param {number} addr is a linear address
     * @param {number} w is the word (16-bit) value to write (which we truncate to 16 bits to be safe)
     */
    setShort(addr, w)
    {
        let off = addr & this.nBlockLimit;
        let iBlock = (addr & this.nMemMask) >>> this.nBlockShift;
        /**
         * On the 8088, it takes 4 cycles to write the additional byte REGARDLESS whether the address is odd or even.
         * TODO: For the 8086, the penalty is actually "(addr & 0x1) << 2" (4 additional cycles only when the address is odd).
         */
        this.nStepCycles -= this.cycleCounts.nWordCyclePenalty;

        if (BACKTRACK) {
            this.bus.writeBackTrack(addr, this.backTrack.btiMem0);
            this.bus.writeBackTrack(addr + 1, this.backTrack.btiMem1);
        }
        if (off < this.nBlockLimit) {
            this.aMemBlocks[iBlock].writeShort(off, w & 0xffff, addr);
            return;
        }
        this.aMemBlocks[iBlock++].writeByte(off, w & 0xff, addr);
        if (this.opFlags & X86.OPFLAG.FAULT) return;
        this.aMemBlocks[iBlock & this.nBlockMask].writeByte(0, (w >> 8) & 0xff, addr + 1);
    }

    /**
     * setLong(addr, l)
     *
     * Use bus.setLong() for physical addresses, and cpu.setLong() for linear addresses; the latter takes care
     * of paging, cycle counts, and BACKTRACK states, if any.
     *
     * @this {CPUx86}
     * @param {number} addr is a linear address
     * @param {number} l is the long (32-bit) value to write
     */
    setLong(addr, l)
    {
        let off = addr & this.nBlockLimit;
        let iBlock = (addr & this.nMemMask) >>> this.nBlockShift;
        this.nStepCycles -= this.cycleCounts.nWordCyclePenalty;

        if (BACKTRACK) {
            this.bus.writeBackTrack(addr, this.backTrack.btiMem0);
            this.bus.writeBackTrack(addr + 1, this.backTrack.btiMem1);
            this.bus.writeBackTrack(addr + 2, this.backTrack.btiMem2);
            this.bus.writeBackTrack(addr + 3, this.backTrack.btiMem3);
        }
        if (off < this.nBlockLimit - 2) {
            this.aMemBlocks[iBlock].writeLong(off, l, addr);
            return;
        }
        /**
         * I think the previous version of this function tried to be too clever (ie, reading and rewriting
         * the last long in the current block, and then reading and rewriting the first long in the next
         * block), which may have also created some undesirable side-effects for custom memory controllers.
         * This simpler (and probably more reliable) approach is to simply write the long as individual bytes.
         */
        let cb = 4;
        let cbBlock = 4 - (off & 0x3);    // (off & 0x3) will be 1, 2 or 3, so cbBlock will be 3, 2, or 1
        while (cb--) {
            this.aMemBlocks[iBlock].writeByte(off++, l & 0xff, addr++);
            if (this.opFlags & X86.OPFLAG.FAULT) return;
            if (!--cbBlock) {
                iBlock = (iBlock + 1) & this.nBlockMask;
                off = 0;
            }
            l >>>= 8;
        }
    }

    /**
     * getEAByte(seg, off)
     *
     * @this {CPUx86}
     * @param {Segx86} seg register (eg, segDS)
     * @param {number} off is a segment-relative offset
     * @returns {number} byte (8-bit) value at that address
     */
    getEAByte(seg, off)
    {
        this.segEA = seg;
        this.offEA = off & (I386? this.maskAddr : 0xffff);
        this.regEA = seg.checkRead(this.offEA, 1);
        if (this.opFlags & X86.OPFLAG.NOREAD) return 0;
        let b = this.getByte(this.regEA);
        if (BACKTRACK) this.backTrack.btiEALo = this.backTrack.btiMem0;
        return b;
    }

    /**
     * getEAByteData(off)
     *
     * @this {CPUx86}
     * @param {number} off is a segment-relative offset
     * @returns {number} byte (8-bit) value at that address
     */
    getEAByteData(off)
    {
        return this.getEAByte(this.segData, off);
    }

    /**
     * getEAByteStack(off)
     *
     * @this {CPUx86}
     * @param {number} off is a segment-relative offset
     * @returns {number} byte (8-bit) value at that address
     */
    getEAByteStack(off)
    {
        return this.getEAByte(this.segStack, off);
    }

    /**
     * getEAWord(seg, off)
     *
     * @this {CPUx86}
     * @param {Segx86} seg register (eg, segDS)
     * @param {number} off is a segment-relative offset
     * @returns {number} word (16-bit or 32-bit) value at that address
     */
    getEAWord(seg, off)
    {
        let w;
        this.segEA = seg;
        this.offEA = off & (I386? this.maskAddr : 0xffff);
        this.regEA = seg.checkRead(this.offEA, (I386? this.sizeData : 2));
        if (this.opFlags & (X86.OPFLAG.NOREAD | X86.OPFLAG.WRAP)) {
            if (this.opFlags & X86.OPFLAG.NOREAD) return 0;
            /**
             * The WRAP flag must have been set by checkReadReal(), so we also know that we're dealing with
             * a 16-bit read, which allows us to make some simplifications here.
             */
            w = this.getByte(this.regEA) | (this.getByte(seg.checkRead(0, 1)) << 8);
        }
        else {
            w = this.getWord(this.regEA);
        }
        if (BACKTRACK) {
            this.backTrack.btiEALo = this.backTrack.btiMem0;
            this.backTrack.btiEAHi = this.backTrack.btiMem1;
        }
        return w;
    }

    /**
     * getEAShortData(off)
     *
     * @this {CPUx86}
     * @param {number} off is a segment-relative offset
     * @returns {number} short (16-bit) value at that address
     */
    getEAShortData(off)
    {
        let w;
        this.segEA = this.segData;
        this.offEA = off & (I386? this.maskAddr : 0xffff);
        this.regEA = this.segEA.checkRead(this.offEA, 2);
        if (this.opFlags & (X86.OPFLAG.NOREAD | X86.OPFLAG.WRAP)) {
            if (this.opFlags & X86.OPFLAG.NOREAD) return 0;
            /**
             * The WRAP flag must have been set by checkReadReal(), so we also know that we're dealing with
             * a 16-bit read, which allows us to make some simplifications here.
             */
            w = this.getByte(this.regEA) | (this.getByte(this.segEA.checkRead(0, 1)) << 8);
            this.opFlags &= ~X86.OPFLAG.WRAP;
        }
        else {
            w = this.getShort(this.regEA);
        }
        if (BACKTRACK) {
            this.backTrack.btiEALo = this.backTrack.btiMem0;
            this.backTrack.btiEAHi = this.backTrack.btiMem1;
        }
        return w;
    }

    /**
     * getEAShortStack(off)
     *
     * @this {CPUx86}
     * @param {number} off is a segment-relative offset
     * @returns {number} short (16-bit) value at that address
     */
    getEAShortStack(off)
    {
        let w;
        this.segEA = this.segStack;
        this.offEA = off & (I386? this.maskAddr : 0xffff);
        this.regEA = this.segEA.checkRead(this.offEA, 2);
        if (this.opFlags & (X86.OPFLAG.NOREAD | X86.OPFLAG.WRAP)) {
            if (this.opFlags & X86.OPFLAG.NOREAD) return 0;
            /**
             * The WRAP flag must have been set by checkReadReal(), so we also know that we're dealing with
             * a 16-bit read, which allows us to make some simplifications here.
             */
            w = this.getByte(this.regEA) | (this.getByte(this.segEA.checkRead(0, 1)) << 8);
            this.opFlags &= ~X86.OPFLAG.WRAP;
        }
        else {
            w = this.getShort(this.regEA);
        }
        if (BACKTRACK) {
            this.backTrack.btiEALo = this.backTrack.btiMem0;
            this.backTrack.btiEAHi = this.backTrack.btiMem1;
        }
        return w;
    }

    /**
     * getEALongData(off)
     *
     * @this {CPUx86}
     * @param {number} off is a segment-relative offset
     * @returns {number} long (32-bit) value at that address
     */
    getEALongData(off)
    {
        this.segEA = this.segData;
        this.offEA = off & (I386? this.maskAddr : 0xffff);
        this.regEA = this.segEA.checkRead(this.offEA, 4);
        if (this.opFlags & X86.OPFLAG.NOREAD) return 0;
        let w = this.getLong(this.regEA);
        if (BACKTRACK) {
            this.backTrack.btiEALo = this.backTrack.btiMem0;
            this.backTrack.btiEAHi = this.backTrack.btiMem1;
        }
        return w;
    }

    /**
     * getEALongDataWrite(off)
     *
     * @this {CPUx86}
     * @param {number} off is a segment-relative offset
     * @returns {number} long (32-bit) value at that address
     */
    getEALongDataWrite(off)
    {
        this.segEA = this.segData;
        this.offEA = off & (I386? this.maskAddr : 0xffff);
        this.regEAWrite = this.regEA = this.segEA.checkRead(this.offEA, 4);
        if (this.opFlags & X86.OPFLAG.NOREAD) return 0;
        let w = this.getLong(this.regEA);
        if (BACKTRACK) {
            this.backTrack.btiEALo = this.backTrack.btiMem0;
            this.backTrack.btiEAHi = this.backTrack.btiMem1;
        }
        return w;
    }

    /**
     * getEALongStack(off)
     *
     * @this {CPUx86}
     * @param {number} off is a segment-relative offset
     * @returns {number} long (32-bit) value at that address
     */
    getEALongStack(off)
    {
        this.segEA = this.segStack;
        this.offEA = off & (I386? this.maskAddr : 0xffff);
        this.regEA = this.segEA.checkRead(this.offEA, 4);
        if (this.opFlags & X86.OPFLAG.NOREAD) return 0;
        let w = this.getLong(this.regEA);
        if (BACKTRACK) {
            this.backTrack.btiEALo = this.backTrack.btiMem0;
            this.backTrack.btiEAHi = this.backTrack.btiMem1;
        }
        return w;
    }

    /**
     * getEALongStackWrite(off)
     *
     * @this {CPUx86}
     * @param {number} off is a segment-relative offset
     * @returns {number} long (32-bit) value at that address
     */
    getEALongStackWrite(off)
    {
        this.segEA = this.segStack;
        this.offEA = off & (I386? this.maskAddr : 0xffff);
        this.regEAWrite = this.regEA = this.segEA.checkRead(this.offEA, 4);
        if (this.opFlags & X86.OPFLAG.NOREAD) return 0;
        let w = this.getLong(this.regEA);
        if (BACKTRACK) {
            this.backTrack.btiEALo = this.backTrack.btiMem0;
            this.backTrack.btiEAHi = this.backTrack.btiMem1;
        }
        return w;
    }

    /**
     * setEAByte(b)
     *
     * @this {CPUx86}
     * @param {number} b is the byte (8-bit) value to write
     */
    setEAByte(b)
    {
        if (this.opFlags & X86.OPFLAG.NOWRITE) return;
        if (BACKTRACK) this.backTrack.btiMem0 = this.backTrack.btiEALo;
        this.setByte(this.segEA.checkWrite(this.offEA, 1), b);
    }

    /**
     * setEAShort(w)
     *
     * @this {CPUx86}
     * @param {number} w is the short (16-bit) value to write
     */
    setEAShort(w)
    {
        if (this.opFlags & X86.OPFLAG.NOWRITE) return;
        if (BACKTRACK) {
            this.backTrack.btiMem0 = this.backTrack.btiEALo;
            this.backTrack.btiMem1 = this.backTrack.btiEAHi;
        }
        let addr = this.segEA.checkWrite(this.offEA, 2);
        if (this.opFlags & X86.OPFLAG.WRAP) {
            /**
             * The WRAP flag must have been set by checkWriteReal(), so we also know that we're dealing with
             * a 16-bit write, which allows us to make some simplifications here.
             */
            this.setByte(addr, w);
            this.setByte(this.segEA.checkWrite(0, 1), w >> 8);
            this.opFlags &= ~X86.OPFLAG.WRAP;
        }
        else {
            this.setShort(addr, w);
        }
    }

    /**
     * setEALong(l)
     *
     * @this {CPUx86}
     * @param {number} l is the long (32-bit) value to write
     */
    setEALong(l)
    {
        if (this.opFlags & X86.OPFLAG.NOWRITE) return;
        if (BACKTRACK) {
            this.backTrack.btiMem0 = this.backTrack.btiEALo;
            this.backTrack.btiMem1 = this.backTrack.btiEAHi;
        }
        this.setLong(this.segEA.checkWrite(this.offEA, 4), l);
    }

    /**
     * setEAWord(w)
     *
     * @this {CPUx86}
     * @param {number} w is the word (16-bit or 32-bit) value to write
     */
    setEAWord(w)
    {
        if (this.opFlags & X86.OPFLAG.NOWRITE) return;
        if (BACKTRACK) {
            this.backTrack.btiMem0 = this.backTrack.btiEALo;
            this.backTrack.btiMem1 = this.backTrack.btiEAHi;
        }
        let addr = this.segEA.checkWrite(this.offEA, this.sizeData);
        if (this.opFlags & X86.OPFLAG.WRAP) {
            /**
             * The WRAP flag must have been set by checkWriteReal(), so we also know that we're dealing with
             * a 16-bit write, which allows us to make some simplifications here.
             */
            this.setByte(addr, w);
            this.setByte(this.segEA.checkWrite(0, 1), w >> 8);
            this.opFlags &= ~X86.OPFLAG.WRAP;
        }
        else {
            this.setWord(addr, w);
        }
    }

    /**
     * getSOByte(seg, off)
     *
     * This is like getEAByte(), but it does NOT update regEA.
     *
     * @this {CPUx86}
     * @param {Segx86} seg register (eg, segDS)
     * @param {number} off is a segment-relative offset
     * @returns {number} byte (8-bit) value at that address
     */
    getSOByte(seg, off)
    {
       return this.getByte(seg.checkRead(off, 1));
    }

    /**
     * getSOWord(seg, off)
     *
     * This is like getEAWord(), but it does NOT update regEA.
     *
     * @this {CPUx86}
     * @param {Segx86} seg register (eg, segDS)
     * @param {number} off is a segment-relative offset
     * @returns {number} word (16-bit) value at that address
     */
    getSOWord(seg, off)
    {
        let w;
        let addr = seg.checkRead(off, this.sizeData);
        if (this.opFlags & X86.OPFLAG.WRAP) {
            /**
             * The WRAP flag must have been set by checkReadReal(), so we also know that we're dealing with
             * a 16-bit read, which allows us to make some simplifications here.
             */
            w = this.getByte(addr) | (this.getByte(seg.checkRead(0, 1)) << 8);
            this.opFlags &= ~X86.OPFLAG.WRAP;
        }
        else {
            w = this.getWord(addr);
        }
        return w;
    }

    /**
     * setSOByte(seg, off, b)
     *
     * This is like setEAByte(), but it does NOT update regEAWrite.
     *
     * @this {CPUx86}
     * @param {Segx86} seg register (eg, segDS)
     * @param {number} off is a segment-relative offset
     * @param {number} b is the byte (8-bit) value to write
     */
    setSOByte(seg, off, b)
    {
        this.setByte(seg.checkWrite(off, 1), b);
    }

    /**
     * setSOWord(seg, off, w)
     *
     * This is like setEAWord(), but it does NOT update regEAWrite.
     *
     * @this {CPUx86}
     * @param {Segx86} seg register (eg, segDS)
     * @param {number} off is a segment-relative offset
     * @param {number} w is the word (16-bit) value to write
     */
    setSOWord(seg, off, w)
    {
        let addr = seg.checkWrite(off, this.sizeData);
        if (this.opFlags & X86.OPFLAG.WRAP) {
            /**
             * The WRAP flag must have been set by checkWriteReal(), so we also know that we're dealing with
             * a 16-bit write, which allows us to make some simplifications here.
             */
            this.setByte(addr, w);
            this.setByte(seg.checkWrite(0, 1), w >> 8);
            this.opFlags &= ~X86.OPFLAG.WRAP;
        }
        else {
            this.setWord(addr, w);
        }
    }

    /**
     * getBytePrefetch()
     *
     * @this {CPUx86}
     * @returns {number} byte (8-bit) value at regLIP
     */
    getBytePrefetch()
    {
        if (!this.cbPrefetch) {
            this.refillPrefetch();
            if (!this.cbPrefetch) return this.getByte(this.regLIP);
        }
        let b = (this.adwPrefetch[this.regLIP & CPUx86.PFINFO.IP_MASK] >> ((this.regLIP & 0x3) << 3)) & 0xff;

        this.cbPrefetch--;
        return b;
    }

    /**
     * getShortPrefetch()
     *
     * @this {CPUx86}
     * @returns {number} short (16-bit) value at regLIP
     */
    getShortPrefetch()
    {
        if (this.cbPrefetch < 2) {
            this.refillPrefetch();
            if (this.cbPrefetch < 2) {
                this.cbPrefetch = 0;
                return this.getShort(this.regLIP);
            }
        }
        let shift = (this.regLIP & 0x3) << 3;
        let w = (this.adwPrefetch[this.regLIP & CPUx86.PFINFO.IP_MASK] >>> shift) & 0xffff;
        if (shift > 16) w |= (this.adwPrefetch[(this.regLIP + 4) & CPUx86.PFINFO.IP_MASK] & 0xff) << 8;

        this.cbPrefetch -= 2;
        return w;
    }

    /**
     * getLongPrefetch()
     *
     * @this {CPUx86}
     * @returns {number} long (32-bit) value at regLIP
     */
    getLongPrefetch()
    {
        if (this.cbPrefetch < 4) {
            this.refillPrefetch();
            if (this.cbPrefetch < 4) {
                this.cbPrefetch = 0;
                return this.getLong(this.regLIP);
            }
        }
        let shift = (this.regLIP & 0x3) << 3;
        let l = (this.adwPrefetch[this.regLIP & CPUx86.PFINFO.IP_MASK] >>> shift)|0;
        if (shift) l |= this.adwPrefetch[(this.regLIP + 4) & CPUx86.PFINFO.IP_MASK] << (32 - shift);

        this.cbPrefetch -= 4;
        return l;
    }

    /**
     * getWordPrefetch()
     *
     * @this {CPUx86}
     * @returns {number} short (16-bit) or long (32-bit) value as appropriate
     */
    getWordPrefetch()
    {
        return (I386 && this.sizeData == 4? this.getLongPrefetch() : this.getShortPrefetch());
    }

    /**
     * refillPrefetch()
     *
     * This function is similar to probeAddr() in that must NOT trigger a fault, because prefetching
     * inherently runs the risk of fetching more bytes that may actually be executed.  Also, to keep it
     * simple, we limit prefetching to whatever bytes (if any) are available in the current page.  If the
     * page is not present, or there are insufficient bytes in the current page to completely fill the
     * queue, then the caller must request byte(s) "the old-fashioned way", to ensure proper fault handling.
     *
     * For example, if getShortPrefetch() finds there are only 0 or 1 bytes in the prefetch queue, and
     * if it is unable to obtain any more bytes via refillPrefetch(), then getShortPrefetch() must call
     * getShort(this.regLIP) (which is also what would be called if PREFETCH was disabled completely).
     *
     * @this {CPUx86}
     */
    refillPrefetch()
    {
        let aBlocks = this.aMemBlocks;
        let regLIP = this.regLIP & ~0x3;
        let block = aBlocks[(regLIP & this.nMemMask) >>> this.nBlockShift];
        if (block && block.type == Memoryx86.TYPE.UNPAGED) {
            block = this.mapPageBlock(regLIP, false, true);
            if (block === this.memEmpty) block = null;
        }
        if (block) {
            let i = 0;
            let off = regLIP & this.nBlockLimit;
            let cbMax = this.nBlockSize - off;
            if (cbMax > CPUx86.PFINFO.LENGTH) cbMax = CPUx86.PFINFO.LENGTH;
            for (; i < cbMax; i += 4) {
                this.adwPrefetch[regLIP & CPUx86.PFINFO.IP_MASK] = block.readLongDirect(off, regLIP);
                off += 4; regLIP += 4;
            }
            this.cbPrefetch = i - (this.regLIP & 0x3);
         // this.nBusCycles += 4;
        } else {
            this.cbPrefetch = 0;
        }
    }

    /**
     * getIPByte()
     *
     * @this {CPUx86}
     * @returns {number} byte at the current IP; IP advanced by 1
     */
    getIPByte()
    {
        let newLIP = this.checkIP(1);
        let b = (PREFETCH? this.getBytePrefetch() : this.getByte(this.regLIP));
        if (BACKTRACK) this.bus.updateBackTrackCode(this.regLIP, this.backTrack.btiMem0);
        /**
         * With the following cycle penalty (which really only affects 8086/8088 CPUs), PC Tools 4.30
         * correctly reports an IBM PC-relative speed of 100% (assuming you're using a 4.77Mhz configuration).
         *
         * Unfortunately, adding this penalty creates other side-effects, including a timing failure in
         * the VGA BIOS when using a VGA with an IBM PC.  So, we'll have to take a second look at how PC Tools
         * calculates the machine's speed.
         *
         *      this.nStepCycles -= this.cycleCounts.nWordCyclePenalty;
         */
        this.regLIP = newLIP;
        return b;
    }

    /**
     * getIPShort()
     *
     * @this {CPUx86}
     * @returns {number} short at the current IP; IP advanced by 2
     */
    getIPShort()
    {
        let w;
        let newLIP = this.checkIP(2);
        if (PREFETCH) {
            w = this.getShortPrefetch();
        } else if (!(this.opFlags & X86.OPFLAG.WRAP)) {
            w = this.getShort(this.regLIP);
        } else {
            /**
             * The WRAP flag must have been set by checkIP(2), so we also know that we're dealing with
             * a 16-bit read, which allows us to make some simplifications here.
             */
            w = this.getByte(this.regLIP) | (this.getByte(newLIP - 1) << 8);
            this.opFlags &= ~X86.OPFLAG.WRAP;
        }
        if (BACKTRACK) {
            this.bus.updateBackTrackCode(this.regLIP, this.backTrack.btiMem0);
            this.bus.updateBackTrackCode(this.regLIP + 1, this.backTrack.btiMem1);
        }
        this.regLIP = newLIP;
        return w;
    }

    /**
     * getIPAddr()
     *
     * @this {CPUx86}
     * @returns {number} word at the current IP; IP advanced by 2 or 4, depending on address size
     */
    getIPAddr()
    {
        let w;
        let newLIP = this.checkIP(this.sizeAddr);
        if (PREFETCH) {
            w = this.getAddr();
        } else if (!(this.opFlags & X86.OPFLAG.WRAP)) {
            w = this.getAddr(this.regLIP);
        } else {
            /**
             * The WRAP flag must have been set by checkIP(), so we also know that we're dealing with
             * a 16-bit read, which allows us to make some simplifications here.
             */
            w = this.getByte(this.regLIP) | (this.getByte(newLIP - 1) << 8);
            this.opFlags &= ~X86.OPFLAG.WRAP;
        }
        if (BACKTRACK) {
            this.bus.updateBackTrackCode(this.regLIP, this.backTrack.btiMem0);
            this.bus.updateBackTrackCode(this.regLIP + 1, this.backTrack.btiMem1);
        }
        this.regLIP = newLIP;
        return w;
    }

    /**
     * getIPWord()
     *
     * @this {CPUx86}
     * @returns {number} word at the current IP; IP advanced by 2 or 4, depending on operand size
     */
    getIPWord()
    {
        let w;
        let newLIP = this.checkIP(this.sizeData);
        if (PREFETCH) {
            w = this.getWordPrefetch();
        } else if (!(this.opFlags & X86.OPFLAG.WRAP)) {
            w = this.getWord(this.regLIP);
        } else {
            /**
             * The WRAP flag must have been set by checkIP(), so we also know that we're dealing with
             * a 16-bit read, which allows us to make some simplifications here.
             */
            w = this.getByte(this.regLIP) | (this.getByte(newLIP - 1) << 8);
            this.opFlags &= ~X86.OPFLAG.WRAP;
        }
        if (BACKTRACK) {
            this.bus.updateBackTrackCode(this.regLIP, this.backTrack.btiMem0);
            this.bus.updateBackTrackCode(this.regLIP + 1, this.backTrack.btiMem1);
        }
        this.regLIP = newLIP;
        return w;
    }

    /**
     * getIPDisp()
     *
     * @this {CPUx86}
     * @returns {number} sign-extended (32-bit) value from the byte at the current IP; IP advanced by 1
     */
    getIPDisp()
    {
        let newLIP = this.checkIP(1);
        let w = ((PREFETCH? this.getBytePrefetch() : this.getByte(this.regLIP)) << 24) >> 24;
        if (BACKTRACK) this.bus.updateBackTrackCode(this.regLIP, this.backTrack.btiMem0);
        this.regLIP = newLIP;
        return w;
    }

    /**
     * peekIPByte()
     *
     * @this {CPUx86}
     * @returns {number} byte at the current IP
     */
    peekIPByte()
    {
        return (PREFETCH? this.getBytePrefetch() : this.getByte(this.regLIP));
    }

    /**
     * popWord()
     *
     * @this {CPUx86}
     * @returns {number} word popped from the current SP; SP increased by 2 or 4
     */
    popWord()
    {
        let data = this.getWord(this.regLSP);
        let width = I386? this.sizeData : 2;
        this.regLSP = (this.regLSP + width)|0;

        let delta = this.regLSPLimit - (this.regLSP >>> 0);
        if (delta < 0) {
            /**
             * There's no such thing as an SS fault on the 8086/8088, and in fact, we have to support the
             * operation even when the address straddles the wrap boundary; other emulators tend to barf on
             * a wrap, usually because they're running in V86 mode instead of real mode.
             */
            if (this.model <= X86.MODEL_8088) {
                this.setSP((this.regLSP - this.segSS.base) & this.segSS.maskAddr);
                if (delta < -1) {
                    data = (data & 0xff) | (this.getByte(this.regLSP - 1) << 8);
                }
            }
            else {
                /**
                 * I'm assuming that, on newer processors, when the stack segment limit is set to the maximum,
                 * it's OK for the stack to wrap, unless the new address is straddling the wrap boundary (ie, when
                 * delta is < -1).
                 *
                 * NOTE: This combines the old 8088 address-wrap check with the new segment-limit check, even though
                 * the correct time to do the latter is immediately BEFORE the fetch, not AFTER.
                 */
                if (delta < -1) {
                    X86.helpFault.call(this, X86.EXCEPTION.SS_FAULT, 0);
                }
                else if (!this.segSS.fExpDown && this.segSS.limit == this.segSS.maskAddr || this.segSS.fExpDown && !this.segSS.limit) {
                    this.setSP((this.regLSP - this.segSS.base) & this.segSS.maskAddr);
                }
            }
        }
        return data;
    }

    /**
     * pushWord(w)
     *
     * NOTE: pushWord() used to do a simplified version of pushData(), and while that might have made the emulator
     * slightly faster, it was woefully duplicative.  Let's trust the combination of the Closure Compiler and the
     * JavaScript engines to automatically inline instead.
     *
     * @this {CPUx86}
     * @param {number} w is the word (16-bit) value to push at current SP; SP decreased by 2 or 4
     */
    pushWord(w)
    {
        this.pushData(w, I386? this.sizeData : 2);
    }

    /**
     * pushData(data, width, size)
     *
     * The size parameter serves two very limited purposes: 1) the ability to push data according to a previous
     * operand size, and 2) the ability to write fewer bytes than the width if necessary.
     *
     * The former occurs when a 32-bit code segment performs a 16:32 call to a 16-bit code segment; after the
     * new 16-bit code segment is loaded (and possible stack switch occurs), the return address (both segment
     * and offset) must still be pushed as 32-bit values.
     *
     * The latter occurs with segment register pushes.  When a 32-bit operand size is in effect (ie, width is 4),
     * only the low 16 bits should be written (size must be 2).
     *
     * For all other kinds of pushes, width and size are impliedly the same.
     *
     * @this {CPUx86}
     * @param {number} data is the data to push at current SP; SP decreased by size
     * @param {number} width is the width of the data to push, in bytes (must be either 2 or 4)
     * @param {number} [size] is the size of the data to push, in bytes (must be 1, 2, or 4, and <= width)
     */
    pushData(data, width, size = width)
    {


        let regLSP = (this.regLSP - width)|0;

        let delta = (regLSP >>> 0) - this.regLSPLimitLow;
        if (delta < 0) {
            /**
             * There's no such thing as an SS fault on the 8086/8088, and in fact, we have to support the
             * operation even when the address straddles the wrap boundary (ie, when delta is -1); other
             * emulators tend to barf on a wrap, usually because they're running in V86 mode instead of real mode.
             */
            if (this.model <= X86.MODEL_8088) {
                if (delta == -1) {
                    this.setByte(regLSP + 1, data >> 8);
                    this.setSP((regLSP - this.segSS.base) & this.segSS.maskAddr);
                    this.setByte(this.regLSP, data);
                    return;
                }

            }
            /**
             * I'm assuming that, on newer processors, when the stack segment limit is set to the maximum,
             * it's OK for the stack to wrap, unless the new address is straddling the wrap boundary (ie, when
             * delta is < 0 and > -width).
             */
            if (!this.segSS.fExpDown && this.segSS.limit == this.segSS.maskAddr || this.segSS.fExpDown && !this.segSS.limit) {
                if (delta > -width) {
                    X86.helpFault.call(this, X86.EXCEPTION.SS_FAULT, 0);
                    return;
                }
                this.setSP((regLSP - this.segSS.base) & this.segSS.maskAddr);
                regLSP = this.regLSP;
            } else {
                X86.helpFault.call(this, X86.EXCEPTION.SS_FAULT, 0);
                return;
            }
        }

        switch(size) {
        case 1:
            this.setByte(regLSP, data);
            break;
        case 2:
            this.setShort(regLSP, data);
            break;
        case 4:
            this.setLong(regLSP, data);
            break;
        default:

            break;
        }

        /**
         * We update this.regLSP at the end to make life simpler for opcode handlers that perform only one
         * pushWord() operation, relieving them from having to snapshot this.regLSP into this.opLSP needlessly.
         */
        this.regLSP = regLSP;
    }

    /**
     * checkINTR()
     *
     * This must only be called when intFlags (containing the simulated INTFLAG.INTR signal) is known to be set.
     * Note that it's perfectly possible that between the time updateINTR(true) was called and we request the
     * interrupt vector number below, the interrupt could have been cleared or masked, in which case getIRRVector()
     * will return -1 and we'll simply clear INTFLAG.INTR.
     *
     * intFlags has been overloaded with the INTFLAG.TRAP bit as well, since the acknowledgment of h/w interrupts
     * and the Trap flag are similar; they must both honor the NOINTR suppression flag, and stepCPU() shouldn't
     * have to check multiple variables when deciding whether to simulate an interrupt.
     *
     * This function also includes a check for the new async INTFLAG.DMA flag, which is triggered by a ChipSet call
     * to setDMA().  This DMA flag actually has nothing to do with interrupts; it's simply an expedient way to
     * piggy-back on the CPU's execution logic, to help drive async DMA requests.
     *
     * Originally, DMA requests (eg, FDC or HDC I/O operations) were all handled synchronously, since no actual
     * I/O was required to satisfy the request; from the CPU's perspective, this meant DMA operations were virtually
     * instantaneous.  However, with the introduction of remote disk connections, some actual I/O may now be required;
     * in practice, this means that the FIRST byte requested as part of a DMA operation may require a callback to
     * finish, while all remaining bytes will be retrieved during subsequent checkINTR() calls -- unless of course
     * additional remote I/O operations are required to complete the DMA operation.
     *
     * As a result, the CPU will run slightly slower while an async DMA request is in progress, but the slowdown
     * should be negligible.  One downside is that this slowdown will be in effect for the entire duration of the
     * I/O (ie, even while we're waiting for the remote I/O to finish), so the ChipSet component should avoid
     * calling setDMA() whenever possible.
     *
     * TODO: While comparing SYMDEB tracing in both PCx86 and VMware, I noticed that after single-stepping ANY
     * segment-load instruction, SYMDEB would get control immediately after that instruction in VMware, whereas
     * I delay acknowledgment of the Trap flag until the *following* instruction, so in PCx86, SYMDEB doesn't get
     * control until the following instruction.  I think PCx86 behavior is correct, at least for SS.
     *
     * ERRATA: Early revisions of the 8086/8088 failed to suppress hardware interrupts (and possibly also Trap
     * acknowledgements) after an SS load, but Intel corrected the problem at some point; however, I don't know when
     * that change was made or which IBM PC models may have been affected, if any.  TODO: More research required.
     *
     * WARNING: There is also a priority consideration here.  On the 8086/8088, hardware interrupts have higher
     * priority than Trap interrupts (which is why the code below is written the way it is).  A potentially
     * undesirable side-effect is that a hardware interrupt handler could end up being single-stepped if an
     * external interrupt occurs immediately after the Trap flag is set.  This is why some 8086 debuggers temporarily
     * mask all hardware interrupts during a single-step operation (although that doesn't help with NMIs generated
     * by a coprocessor).  As of the 80286, those priorities were inverted, giving the Trap interrupt higher priority
     * than external interrupts.
     *
     * TODO: Determine the priorities for the 80186.
     *
     * @this {CPUx86}
     * @returns {boolean} true if h/w interrupt (or trap) has just been acknowledged, false if not
     */
    checkINTR()
    {
        // DEBUG:

        if (!(this.opFlags & X86.OPFLAG.NOINTR)) {
            /**
             * As discussed above, the 8086/8088 give hardware interrupts higher priority than the TRAP interrupt,
             * whereas the 80286 and up give TRAPs higher priority.
             */
            let iPriority = (this.model < X86.MODEL_80286? 0 : 1);
            for (let cPriorities = 0; cPriorities < 2; cPriorities++) {
                switch(iPriority) {
                case 0:
                    if ((this.intFlags & X86.INTFLAG.INTR) && (this.regPS & X86.PS.IF)) {
                        let nIDT = this.chipset.getIRRVector();
                        if (nIDT >= -1) {
                            this.intFlags &= ~X86.INTFLAG.INTR;
                            if (nIDT >= 0) {
                                this.intFlags &= ~X86.INTFLAG.HALT;
                                X86.helpInterrupt.call(this, nIDT);
                                return true;
                            }
                        }
                    }
                    break;
                case 1:
                    if ((this.intFlags & X86.INTFLAG.TRAP)) {
                        this.intFlags &= ~X86.INTFLAG.TRAP;
                        if (I386 && this.model >= X86.MODEL_80386) this.regDR[6] |= X86.DR6.BS;
                        X86.helpInterrupt.call(this, X86.EXCEPTION.DB_EXC);
                        return true;
                    }
                    break;
                }
                iPriority = 1 - iPriority;
            }
        }
        /**
         * As long as the ChipSet component isn't calling setDMA(), we don't need to test INTFLAG.DMA...
         *
        if (this.intFlags & X86.INTFLAG.DMA) {
            if (!this.chipset.checkDMA()) {
                this.intFlags &= ~X86.INTFLAG.DMA;
            }
        }
         */
        return false;
    }

    /**
     * updateINTR(fRaise)
     *
     * This is called by the ChipSet component whenever a h/w interrupt needs to be simulated.
     * This is how the PIC component simulates raising the INTFLAG.INTR signal.  We will honor the request
     * only if we have a reference back to the ChipSet component.  The CPU will then "respond" by calling
     * checkINTR() and request the corresponding interrupt vector from the ChipSet.
     *
     * @this {CPUx86}
     * @param {boolean} fRaise is true to raise INTFLAG.INTR, false to lower
     */
    updateINTR(fRaise)
    {
        if (this.chipset) {
            if (fRaise) {
                this.intFlags |= X86.INTFLAG.INTR;
            } else {
                this.intFlags &= ~X86.INTFLAG.INTR;
            }
        }
    }

    /**
     * delayINTR()
     *
     * This is called by the ChipSet component whenever the IMR register is being unmasked, to avoid
     * interrupts being simulated too quickly. This works around a problem in the ROM BIOS "KBD_RESET"
     * (F000:E688) function, which is called with interrupts enabled by the "TST8" (F000:E30D) code.
     *
     * "KBD_RESET" appears to be written with the assumption that CLI is in effect, because it issues an
     * STI immediately after unmasking the keyboard IRQ.  And normally, the STI would delay INTFLAG.INTR
     * long enough to allow AH to be set to 0. But if interrupts are already enabled, an interrupt could
     * theoretically occur before the STI.  And since AH isn't initialized until after the STI, such an
     * interrupt would be missed.
     *
     * I'm assuming this never happens in practice because the PIC isn't that fast.  But for us to
     * guarantee that, we need to provide this function to the ChipSet component.
     *
     * @this {CPUx86}
     */
    delayINTR()
    {
        this.opFlags |= X86.OPFLAG.NOINTR;
    }

    /**
     * updateReg(sReg, nValue)
     *
     * This function helps updateStatus() by massaging the register names and values according to
     * CPU type before passing the call to displayValue(); in the "old days", updateStatus() called
     * displayValue() directly (although then it was called displayReg()).
     *
     * @this {CPUx86}
     * @param {string} sReg
     * @param {number} nValue
     */
    updateReg(sReg, nValue)
    {
        let cch = 4;
        if (sReg.length == 1) {
            cch = 1;
            nValue = nValue? 1 : 0;
        }
        if (this.model < 80386) {
            if (sReg.length > 2) {
                sReg = sReg.substr(1, 2);
            }
        } else {
            if (sReg == "PS" || sReg.length > 2) {
                cch = 8;
            }
        }
        this.displayValue(sReg, nValue, cch);
    }

    /**
     * updateStatus(fForce)
     *
     * This provides periodic Control Panel updates (eg, a few times per second; see Computer.UPDATES_PER_SECOND).
     * this is where we take care of any DOM updates (eg, register values) while the CPU is running.
     *
     * @this {CPUx86}
     * @param {boolean} [fForce] (true will display registers even if the CPU is running and "live" registers are not enabled)
     */
    updateStatus(fForce)
    {
        if (this.cLiveRegs) {
            if (fForce || !this.flags.running || this.flags.displayLiveRegs) {
                this.updateReg("EAX", this.regEAX);
                this.updateReg("EBX", this.regEBX);
                this.updateReg("ECX", this.regECX);
                this.updateReg("EDX", this.regEDX);
                this.updateReg("ESP", this.getSP());
                this.updateReg("EBP", this.regEBP);
                this.updateReg("ESI", this.regESI);
                this.updateReg("EDI", this.regEDI);
                this.updateReg("CS", this.getCS());
                this.updateReg("DS", this.getDS());
                this.updateReg("SS", this.getSS());
                this.updateReg("ES", this.getES());
                this.updateReg("EIP", this.getIP());
                let regPS = this.getPS();
                this.updateReg("PS", regPS);
                this.updateReg("V", (regPS & X86.PS.OF));
                this.updateReg("D", (regPS & X86.PS.DF));
                this.updateReg("I", (regPS & X86.PS.IF));
                this.updateReg("T", (regPS & X86.PS.TF));
                this.updateReg("S", (regPS & X86.PS.SF));
                this.updateReg("Z", (regPS & X86.PS.ZF));
                this.updateReg("A", (regPS & X86.PS.AF));
                this.updateReg("P", (regPS & X86.PS.PF));
                this.updateReg("C", (regPS & X86.PS.CF));
                if (this.model == X86.MODEL_80386) {
                    this.updateReg("FS", this.getFS());
                    this.updateReg("GS", this.getGS());
                    this.updateReg("CR0", this.regCR0);
                    this.updateReg("CR2", this.regCR2);
                    this.updateReg("CR3", this.regCR3);
                }
            }
        }

        let controlSpeed = this.bindings["speed"];
        if (controlSpeed) controlSpeed.textContent = this.getSpeedCurrent();
    }

    /**
     * setDebugCheck(fCheck)
     *
     * This interface has been added for the Debugger, for situations where the Debugger has altered
     * the debugCheck state but we don't necessarily want to stop the current instruction burst; ordinarily,
     * we update the X86.INTFLAG.DEBUGGER flag only when we're about to start a new instruction burst.
     *
     * @this {CPUx86}
     * @param {boolean} fCheck
     */
    setDebugCheck(fCheck)
    {
        this.flags.debugCheck = fCheck;
        if (fCheck) {
            this.intFlags |= X86.INTFLAG.DEBUGGER;
        } else {
            this.intFlags &= ~X86.INTFLAG.DEBUGGER;
        }
    }

    /**
     * stepCPU(nMinCycles)
     *
     * NOTE: Single-stepping should not be confused with the Trap flag; single-stepping is a Debugger
     * operation that's completely independent of Trap status.  The CPU can go in and out of Trap mode,
     * in and out of h/w interrupt service routines (ISRs), etc, but from the Debugger's perspective,
     * they're all one continuous stream of instructions that can be stepped or run at will.  Moreover,
     * stepping vs. running should never change the behavior of the simulation.
     *
     * Similarly, the Debugger's execution breakpoints have no involvement with the x86 breakpoint instruction
     * (0xCC); the Debugger monitors changes to the regLIP register to implement its own execution breakpoints.
     *
     * As a result, the Debugger's complete independence means you can run other 8086/8088 debuggers
     * (eg, DEBUG) inside the simulation without interference; you can even "debug" them with the Debugger.
     *
     * @this {CPUx86}
     * @param {number} nMinCycles (0 implies a single-step, and therefore breakpoints should be ignored)
     * @returns {number} of cycles executed; 0 indicates a pre-execution condition (ie, an execution breakpoint
     * was hit), -1 indicates a post-execution condition (eg, a read or write breakpoint was hit), and a positive
     * number indicates successful completion of that many cycles (which should always be >= nMinCycles).
     */
    stepCPU(nMinCycles)
    {
        /**
         * The Debugger uses fComplete to determine if the instruction completed (true) or was interrupted
         * by a breakpoint or some other exceptional condition (false).  NOTE: this does NOT include JavaScript
         * exceptions, which stepCPU() expects the caller to catch using its own exception handler.
         *
         * The CPU relies on the use of stopCPU() rather than fComplete, because the CPU never single-steps
         * (ie, nMinCycles is always some large number), whereas the Debugger does.  And conversely, when the
         * Debugger is single-stepping (even when performing multiple single-steps), fRunning is never set,
         * so stopCPU() would have no effect as far as the Debugger is concerned.
         */
        this.flags.complete = true;

        /**
         * debugCheck is true if we need to "check" every instruction with the Debugger.
         */
        this.setDebugCheck(DEBUGGER && this.dbg != undefined && this.dbg.checksEnabled());

        /**
         * nDebugState is checked only when debugCheck is true, and its sole purpose is to tell the first call
         * to checkInstruction() that it can skip breakpoint checks, and that will be true ONLY when fStarting is
         * true OR nMinCycles is zero (the latter means the Debugger is single-stepping).
         *
         * Once we snap fStarting, we clear it, because technically, we've moved beyond "starting" and have
         * officially "started" now.
         */
        let nDebugState = (!nMinCycles)? -1 : (this.flags.starting? 0 : 1);
        this.flags.starting = false;

        /**
         * We move the minimum cycle count to nStepCycles (the number of cycles left to step), so that other
         * functions have the ability to force that number to zero (eg, stopCPU()), and thus we don't have to check
         * any other criteria to determine whether we should continue stepping or not.
         */
        this.nBurstCycles = this.nStepCycles = nMinCycles;

        /**
         * NOTE: Even though runCPU() calls updateAllTimers(), we need an additional call here if we're being
         * called from the Debugger, so that single-stepping will update timers as well.  TODO: What about RTC?
         */
        if (this.chipset && !nMinCycles) this.chipset.updateAllTimers();

        /**
         * Let's also suppress h/w interrupts whenever the Debugger is single-stepping an instruction; I'm loathe
         * to allow Debugger interactions to affect the behavior of the virtual machine in ANY way, but I'm making
         * this small concession to avoid the occasional and sometimes unexpected Debugger command that ends up
         * stepping into a hardware interrupt service routine (ISR).
         *
         * Note that this is similar to the problem discussed in checkINTR() regarding the priority of external h/w
         * interrupts vs. Trap interrupts, but they require different solutions, because our Debugger operates
         * independently of the CPU.
         *
         * One exception I make here is when you've asked the Debugger to display PIC messages, the idea being that
         * if you're watching the PIC that closely, then you want to hardware interrupts to occur regardless.
         */
        if (!nMinCycles && !this.messageEnabled(MESSAGE.PIC)) this.opFlags |= X86.OPFLAG.NOINTR;

        do {
            let opPrefixes = this.opFlags & X86.OPFLAG_PREFIXES;
            if (opPrefixes) {
                this.opPrefixes |= opPrefixes;
            } else {
                /**
                 * opLIP is used, among other things, to help string instructions rewind to the first prefix
                 * byte whenever the instruction needs to be repeated.  Repeating string instructions in this
                 * manner (essentially restarting them) is a bit heavy-handed, but ultimately it's more compatible,
                 * because it allows hardware interrupts (as well as Trap processing and Debugger single-stepping)
                 * to occur at any point during the string operation, without any additional effort.
                 *
                 * NOTE: The way we restart string instructions actually fixes an 8086/8088 flaw, because string
                 * instructions with multiple prefixes (eg, a REP and a segment override) would not be restarted
                 * properly following a hardware interrupt.  The recommended workarounds were to either turn off
                 * interrupts or to follow the string instruction with a LOOPNZ back to the first prefix byte.
                 * To emulate the flawed behavior, turn on BUGS_8086.
                 */
                this.opLIP = this.regLIP;
                this.segData = this.segDS;
                this.segStack = this.segSS;
                this.regEA = this.regEAWrite = X86.ADDR_INVALID;

                if (I386 && (this.opPrefixes & (X86.OPFLAG.ADDRSIZE | X86.OPFLAG.DATASIZE))) {
                    this.resetSizes();
                }

                this.opPrefixes = this.opFlags & (X86.OPFLAG.REPEAT | X86.OPFLAG.IRET);

                if (this.intFlags) {
                    if (this.checkINTR()) {
                        if (!nMinCycles) {

                            if (DEBUGGER) {
                                this.printf("interrupt dispatched\n");
                                this.opFlags = 0;
                                break;
                            }
                        }
                    }
                    if (this.intFlags & X86.INTFLAG.HALT) {
                        /**
                         * As discussed in opHLT(), the CPU is never REALLY halted by a HLT instruction, because the
                         * entire machine relies on the steady advance of the overall cycle count, to ensure that timer
                         * updates, video updates, etc, all continue to occur at the expected rates.
                         *
                         * So opHLT() sets X86.INTFLAG.HALT, signalling that we should not execute any more instructions
                         * until checkINTR() detects a hardware interrupt and clears X86.INTFLAG.HALT.
                         *
                         * Ideally, we would also end the current burst; ie:
                         *
                         *      this.nStepCycles = 0;
                         *      this.opFlags = 0;
                         *      break;
                         *
                         * and save the browser a bunch of work, which would translate into power savings for the host
                         * operating system, just as HLT was intended to do for the guest operating system.  Unfortunately,
                         * that screws up up our dynamic speed recalculations, because it makes it appear that a single
                         * instruction (HLT) performed the work of many.
                         *
                         * We could certainly add more cycle bookkeeping to compensate for HLT's lack of work, but for now,
                         * it's simpler to re-execute the HLT as long as X86.INTFLAG.HALT is set.
                         */
                        X86.opHLT.call(this);
                        continue;
                    }
                    if (this.intFlags & X86.INTFLAG.DEBUGGER) {
                        if (this.dbg.checkInstruction(this.regLIP, nDebugState)) {
                            this.stopCPU();
                            break;
                        }
                        nDebugState = 1;
                    }
                }
            }

            this.opFlags = 0;

            /**
            if (DEBUG || PREFETCH) {
                this.nBusCycles = 0;
                this.nSnapCycles = this.nStepCycles;
            }
             */

            this.aOps[this.getIPByte()].call(this);

            /**
            if (PREFETCH) {
                let nSpareCycles = (this.nSnapCycles - this.nStepCycles) - this.nBusCycles;
                if (nSpareCycles >= 4) {
                    this.fillPrefetch(nSpareCycles >> 2);   // for every 4 spare cycles, fetch 1 instruction byte
                }
            }
             */

            /**
            if (MAXDEBUG) {
                //
                // Make sure that every instruction is assessing a cycle cost, and that the cost is a net positive.
                //
                if (this.flags.complete && this.nStepCycles >= this.nSnapCycles && !(this.opFlags & X86.OPFLAG_PREFIXES)) {
                    this.printf("cycle miscount: %d\n", (this.nSnapCycles - this.nStepCycles));
                    this.setIP(this.opLIP - this.segCS.base);
                    this.stopCPU();
                    break;
                }
            }
             */

        } while (this.nStepCycles > 0);

        return (this.flags.complete? this.nBurstCycles - this.nStepCycles : (this.flags.complete === undefined? 0 : -1));
    }

    /**
     * setDMA(fActive)
     *
     * This is called by the ChipSet component to update DMA status.
     *
     * @this {CPUx86}
     * @param {boolean} fActive is true to set INTFLAG.DMA, false to clear
     *
     setDMA(fActive)
     {
        if (this.chipset) {
            if (fActive) {
                this.intFlags |= X86.INTFLAG.DMA;
            } else {
                this.intFlags &= ~X86.INTFLAG.DMA;
            }
        }
    }
     */

    /**
     * CPUx86.init()
     *
     * This function operates on every HTML element of class "cpu", extracting the
     * JSON-encoded parameters for the CPUx86 constructor from the element's "data-value"
     * attribute, invoking the constructor (which in turn invokes the CPU constructor)
     * to create a CPUx86 component, and then binding any associated HTML controls to the
     * new component.
     */
    static init()
    {
        let aeCPUs = Component.getElementsByClass(APPCLASS, "cpu");
        for (let iCPU = 0; iCPU < aeCPUs.length; iCPU++) {
            let eCPU = aeCPUs[iCPU];
            let parmsCPU = Component.getComponentParms(eCPU);
            let cpu = new CPUx86(parmsCPU);
            Component.bindComponentControls(cpu, eCPU, APPCLASS);
        }
    }
}

/**
 * Initialize every CPU module on the page
 */
WebLib.onInit(CPUx86.init);

/**
 * @copyright https://www.pcjs.org/machines/pcx86/modules/v2/fpux86.js (C) 2012-2024 Jeff Parsons
 */

/**
 * Operand Type Reference
 *
 *      ST(0), ST           stack top; the register currently at the top of the stack
 *      ST(i)               register in the stack i (0<=i<=7) stack elements from the top
 *      SR (short-real)     short real (32 bits) number in memory; exponent bias is 127 (0x7f)
 *      LR (long-real)      long real (64 bits) number in memory; exponent bias is 1023 (0x3ff)
 *      TR (temp-real)      temporary real (80 bits) number in memory; exponent bias is 16383 (0x3fff)
 *      PD (packed-decimal) packed decimal integer (18 digits, 10 bytes) in memory
 *      WI (word-integer)   word binary integer (16 bits) in memory
 *      SI (short-integer)  short binary integer (32 bits) in memory
 *      LI (long-integer)   long binary integer (64 bits) in memory
 *      NN (nn-bytes)       memory area nn bytes long
 *
 * FPU Coprocessor Trivia
 *
 *      Microsoft C 4.00 libraries executed software interrupts in the range 0x34-0x3B immediately after
 *      FPU operations, to assist with floating-point emulation when no coprocessor was present, since
 *      processors prior to the 80286 had no mechanism for generating a fault when an unsupported FPU
 *      instruction was executed.
 *
 *      In short, INT 0x34 through INT 0x3B was used after ESC opcodes 0xD8 through 0xDF, INT 0x3C was
 *      used for FPU instructions containing a segment override, and INT 0x3D was used for FWAIT.
 *
 *      A sample piece of code is available in x86ops.js, because it also highlights the Microsoft C 4.00
 *      library's dependency on the 8086/8088 behavior of "PUSH SP" (see the opPUSHSP_8086() function).
 */

/**
 * @class FPUx86
 * @unrestricted (allows the class to define properties, both dot and named, outside of the constructor)
 */
class FPUx86 extends Component {
    /**
     * Class constants
     *
     * TODO: When loading any of the following 5 constants, the 80287XL and newer coprocessors apply rounding control.
     */

    /** @type {number} */
    static regL2T = Math.log(10) / Math.LN2;        // log2(10) (use Math.log2() if we ever switch to ES6)

    /** @type {number} */
    static regL2E = Math.LOG2E;                     // log2(e)

    /** @type {number} */
    static regPI  = Math.PI;                        // pi

    /** @type {number} */
    static regLG2 = Math.log(2) / Math.LN10;        // log10(2) (use Math.log10() if we ever switch to ES6)

    /** @type {number} */
    static regLN2 = Math.LN2;                       // log(2)

    /** @type {number} */
    static MAX_INT16 = 0x8000;

    /** @type {number} */
    static MAX_INT32 = 0x80000000;

    /** @type {number} */
    static MAX_INT64 = Math.pow(2, 63);

    /**
     * FPUx86(parmsFPU)
     *
     * The FPUx86 class uses the following (parmsFPU) properties:
     *
     *      model: a number (eg, 8087) that should match one of the X86.FPU.MODEL values (default is 8087)
     *      stepping: a string (eg, "B1") that should match one of the X86.FPU.STEPPING values (default is "")
     *
     * @this {FPUx86}
     * @param {Object} parmsFPU
     */
    constructor(parmsFPU)
    {
        super("FPU", parmsFPU);

        this.model = this.parms['model'] || X86.FPU.MODEL_8087;

        /**
         * We take the 'stepping' value, convert it to a hex value, and then add that to the model to provide
         * a single value that's unique for any given CPU stepping.  If no stepping is provided, then stepping
         * is equal to model.
         */
        let stepping = this.parms['stepping'];
        this.stepping = this.model + (stepping? StrLib.parseInt(stepping, 16) : 0);

        /**
         * Perform a one-time allocation of all floating-point registers.
         * NOTE: The FPU's internal registers are supposed to be 80-bit, but JavaScript gives us only 64-bit floats.
         */
        this.regStack = new Float64Array(8);
        this.intStack = new Int32Array(this.regStack.buffer);

        /**
         * Used for "short-real" (SR) 32-bit floating-point operations.
         */
        this.regTmpSR = new Float32Array(1);
        this.intTmpSR = new Int32Array(this.regTmpSR.buffer);

        /**
         * Used for "long-real" (LR) 64-bit floating-point operations.  We also use intTmpLR as temporary storage
         * for all "word-integer" (WI or INT16), "short-integer" (SI or INT32) and "long-integer" (LI or INT64) values,
         * since it's just large enough to accommodate all three integer sizes.
         */
        this.regTmpLR = new Float64Array(1);
        this.intTmpLR = new Int32Array(this.regTmpLR.buffer);

        /**
         * Used for conversion to/from the 80-bit "temp-real" (TR) format; used as three 32-bit integers,
         * where [0] contains TR bits 0-31, [1] contains TR bits 32-63, and [2] contains TR bits 64-79; the
         * upper 16 bits of [2] are not used and should remain zero.
         */
        this.intTmpTR = new Array(3);

        /**
         * Initialize other (non-floating-point) coprocessor registers that resetFPU() doesn't touch,
         * such as the "exception" registers: regCodeSel, regCodeOff, regDataSel, regDataOff, and regOpcode.
         *
         * Note that regCodeSel and regDataSel are NEVER set in real-mode and are ALWAYS set in protected-mode,
         * so we set them to -1 in their "unset" state; if those values ever show up in an exception block,
         * something may have gone amiss (it's not impossible though, because if an exception occurs before any
         * memory operands have been used, regDataSel may still be "unset").
         *
         * NOTE: iStack is the low 3 bits of the bModRM byte, for instructions that have an explicit stack operand.
         */
        this.regCodeSel = this.regDataSel = -1;
        this.regCodeOff = this.regDataOff = this.regOpcode = this.iStack = 0;

        /**
         * Initialize special floating-point constants, as if they were internal read-only registers;
         * all other simple (non-special) constants are "statically" initialized below, as class constants.
         */
        this.regIndefinite = new Float64Array(1);
        this.intIndefinite = new Int32Array(this.regIndefinite.buffer);
        this.intIndefinite[0] = 0x00000000; this.intIndefinite[1] = 0xFFF8000;

        /**
         * Initialize all other coprocessor registers (control word, tag word, status word, etc) by resetting them.
         */
        this.resetFPU();
        /**
         * setEAFromSR()
         *
         * Stores the (32-bit) "short-real" value in the internal regTmpSR register to the address in regEA.
         *
         * @this {FPUx86}
         */
        this.setEAFromSR = FPUx86.prototype.setEAFromSI;
        /**
         * setEAFromLR()
         *
         * Stores the (64-bit) "long-real" value in the internal regTmpLR register to the address in regEA.
         *
         * @this {FPUx86}
         */
        this.setEAFromLR = FPUx86.prototype.setEAFromLI;
    }

    /**
     * initBus(cmp, bus, cpu, dbg)
     *
     * @this {FPUx86}
     * @param {Computer} cmp
     * @param {Busx86} bus
     * @param {CPUx86} cpu
     * @param {Debuggerx86} dbg
     */
    initBus(cmp, bus, cpu, dbg)
    {
        this.cpu = cpu;
        this.chipset = cmp.getMachineComponent("ChipSet");
        this.setReady();
    }

    /**
     * clearBusy()
     *
     * The ChipSet calls us whenever an I/O operation that clears the coprocessor's "busy" state is performed.
     *
     * @this {FPUx86}
     */
    clearBusy()
    {
        /**
         * We're never "busy" as far as other components are concerned, because we perform all FPU operations
         * synchronously, so there's nothing to do here.
         */
    }

    /**
     * powerUp(data, fRepower)
     *
     * @this {FPUx86}
     * @param {Object|null} data
     * @param {boolean} [fRepower]
     * @returns {boolean} true if successful, false if failure
     */
    powerUp(data, fRepower)
    {
        if (!fRepower) {
            if (!data || !this.restore) {
                this.resetFPU();
            } else {
                if (!this.restore(data)) return false;
            }
        }
        return true;
    }

    /**
     * powerDown(fSave, fShutdown)
     *
     * @this {FPUx86}
     * @param {boolean} [fSave]
     * @param {boolean} [fShutdown]
     * @returns {Object|boolean} component state if fSave; otherwise, true if successful, false if failure
     */
    powerDown(fSave, fShutdown)
    {
        return fSave? this.save() : true;
    }

    /**
     * save()
     *
     * This implements save support for the FPUx86 component.
     *
     * @this {FPUx86}
     * @returns {Object}
     */
    save()
    {
        let state = new State(this);
        let a = [], i = 0;
        a[i++] = this.regControl;
        a[i++] = this.getStatus();
        a[i++] = this.getTags();
        /**
         * Note that, unlike the FSAVE() and FRSTOR() operations, we save the registers in regStack in their physical
         * order (0-7) rather than their logical order (ST0-ST7).  Moreover, FSAVE() and FRSTOR() use the "temp-real" (TR)
         * format, whereas we use the current native format -- which, sadly, is only a 64-bit "long-real" (LR) format.
         */
        for (let iReg = 0; iReg < this.regStack.length; iReg++) {
            a[i++] = this.regStack[iReg];
        }
        state.set(0, a);
        return state.data();
    }

    /**
     * restore(data)
     *
     * This implements restore support for the FPUx86 component.
     *
     * @this {FPUx86}
     * @param {Object} data
     * @returns {boolean} true if successful, false if failure
     */
    restore(data)
    {
        let a = data[0], i = 0;
        this.setControl(a[i++]);
        this.setStatus(a[i++]);
        this.setTags(a[i++]);
        for (let iReg = 0; iReg < this.regStack.length; iReg++) {
            this.regStack[iReg] = a[i++];
        }
        return true;
    }

    /**
     * resetFPU()
     *
     * Aside from calling this internally (eg, during initialization and FINIT operations), the ChipSet may also call
     * us whenever an I/O operation that resets the coprocessor is performed.  Only 80487 coprocessors and higher will
     * also clear the "exception" registers, but the 80487 is currently beyond my planned level of support.
     *
     * TODO: Add support for X86.FPU.CONTROL.PC (Precision Control) and X86.FPU.CONTROL.IC (Infinity Control)
     *
     * @this {FPUx86}
     */
    resetFPU()
    {
        this.regUsed = 0;           // bits 0-7 are set as regs 0-7 are used
        this.regControl = X86.FPU.CONTROL.INIT;
        this.regStatus = 0;         // contains all status register bits EXCEPT for ST
        this.iST = 0;               // the ST bits for regStatus are actually stored here
        if (DEBUG) {
            /**
             * All the registers were tagged "unused" above, which is all that would normally happen, but debugging is
             * a little easier if we zero all the registers as well.
             */
            for (let iReg = 0; iReg < this.regStack.length; iReg++) {
                this.regStack[iReg] = 0.0;
            }
        }
        if (this.chipset) this.chipset.clearFPUInterrupt();
    }

    /**
     * isModel(model)
     *
     * If the current model is equal to the specified model, then it's assumed the current operation
     * is supported, and we return true.
     *
     * @this {FPUx86}
     * @param {number} model
     * @returns {boolean}
     */
    isModel(model)
    {
        return this.model == model;
    }

    /**
     * isAtLeastModel(model)
     *
     * If the current model is greater than or equal to the specified model, then it's assumed that the
     * current operation is supported, and we return true.
     *
     * @this {FPUx86}
     * @param {number} model
     * @returns {boolean}
     */
    isAtLeastModel(model)
    {
        return this.model >= model;
    }

    /**
     * opStop(fError)
     *
     * Place this inside any opcode handler to stop the CPU from running the current instruction; eg:
     *
     *      if (this.opStop()) return;
     *
     * You can still use the Debugger to single-step over the instruction; opStop() will return false in that case.
     *
     * @this {FPUx86}
     * @param {boolean} [fError]
     * @returns {boolean} (true if there was an error or the CPU was running, false if not)
     */
    opStop(fError)
    {
        if (DEBUG) {
            let cpu = this.cpu;
            if (fError || cpu.isRunning()) {
                cpu.setIP(cpu.opLIP - cpu.segCS.base);
                cpu.stopCPU();
                return true;
            }
        }
        return false;
    }

    /**
     * opNone()
     *
     * Used for any coprocessor opcode that has no known operation for the given model.
     *
     * @this {FPUx86}
     */
    opNone()
    {
        if (DEBUG) this.printf("%s.opNone(%#04x,%#04x)\n", this.idComponent, this.cpu.bOpcode, this.cpu.bModRM);
        this.opStop(true);
    }

    /**
     * opObsolete()
     *
     * Used for any coprocessor opcodes that are redundant and potentially obsolete.
     *
     * @this {FPUx86}
     */
    opObsolete()
    {
        if (DEBUG) this.printf("%s.opObsolete(%#04x,%#04x)\n", this.idComponent, this.cpu.bOpcode, this.cpu.bModRM);
        this.opStop(true);
    }

    /**
     * opUnimplemented()
     *
     * Used for any coprocessor opcode that DOES have a known operation, we just haven't implemented it yet.
     *
     * @this {FPUx86}
     */
    opUnimplemented()
    {
        if (DEBUG) this.printf("%s.opUnimplemented(%#04x,%#04x)\n", this.idComponent, this.cpu.bOpcode, this.cpu.bModRM);
        this.opStop(true);
    }

    /**
     * checkException()
     *
     * @this {FPUx86}
     * @returns {boolean} (true if unmasked exception exists, false if not)
     */
    checkException()
    {
        this.regStatus &= ~X86.FPU.STATUS.ES;
        /**
         * NOTE: The "Stack Fault" (SF) status bit wasn't introduced until the 80387, so it triggers the pre-existing
         * "Invalid Operation" (IE) exception; there is no corresponding "Stack Fault" (SE) exception, and the matching
         * control bit is still reserved.  Consequently, X86.FPU.CONTROL.EXC is a *subset* of X86.FPU.STATUS.EXC (0x3F
         * instead of 0x7F).
         *
         * However, we shouldn't have to do anything special when SF is set, because any setException() call that sets
         * SF should ALSO set IE.
         */
        if (this.regStatus & (~this.regControl & X86.FPU.CONTROL.EXC)) {
            this.regStatus |= X86.FPU.STATUS.ES;    // set ES whenever one or more unmasked EXC bits are set
        }
        if ((this.regStatus & X86.FPU.STATUS.ES) && !(this.regControl & X86.FPU.CONTROL.IEM)) {
            this.chipset.setFPUInterrupt();
            return true;
        }
        this.chipset.clearFPUInterrupt();
        return false;
    }

    /**
     * setException(n)
     *
     * Sets one or more of the FPU.STATUS.ECX bits; ie:
     *
     *      IE (0x0001 bit 0: Invalid Operation)
     *      DE (0x0002 bit 1: Denormalized Operand)
     *      ZE (0x0004 bit 2: Zero Divide)
     *      OE (0x0008 bit 3: Overflow)
     *      UE (0x0010 bit 4: Underflow)
     *      PE (0x0020 bit 5: Precision)
     *      SF (0x0040 bit 6: Stack Fault; 80387 and later)
     *
     * Also, as noted in checkException(), any time you set the SF bit, you should also set the IE bit, because
     * Stack Fault is a subset of Invalid Operation.  TODO: We should include a test for that in the assertion below.
     *
     * @this {FPUx86}
     * @param {number} n (one or more of the above error status bits)
     * @returns {boolean} (true if unmasked exception exists, false if not)
     */
    setException(n)
    {
        if (DEBUG) this.printf("%s.setException(%#06x)\n", this.idComponent, n);

        if (!this.isAtLeastModel(X86.FPU.MODEL_80387)) {
            n &= ~X86.FPU.STATUS.SF;                // the SF bit didn't exist on pre-80387 coprocessors
        }

        this.regStatus |= n;
        return this.checkException();
    }

    /**
     * getControl()
     *
     * @this {FPUx86}
     * @returns {number}
     */
    getControl()
    {
        return this.regControl;
    }

    /**
     * setControl(n)
     *
     * NOTE: Be sure to use this function for all "wholesale" regControl updates, because it ensures that
     * unused bits cannot be set -- including bit 6, which could otherwise inadvertently mask the SF error
     * condition on 80387 and newer coprocessors.
     *
     * @this {FPUx86}
     * @param {number} n
     */
    setControl(n)
    {
        this.regControl = n & ~X86.FPU.CONTROL.UNUSED;
    }

    /**
     * clearStatus(n)
     *
     * @this {FPUx86}
     * @param {number} n
     */
    clearStatus(n)
    {
        this.regStatus &= ~n;
        this.checkException();
    }

    /**
     * getStatus()
     *
     * @this {FPUx86}
     * @returns {number} regStatus merged with iST
     */
    getStatus()
    {
        /**
         * As long as we never store any ST bits in regStatus, they should always be zero, so in
         * order to return the complete regStatus, all we need to do is shift and "or" the bits from iST.
         */
        return this.regStatus | (this.iST << X86.FPU.STATUS.ST_SHIFT);
    }

    /**
     * setStatus(n)
     *
     * NOTE: Be sure to use this function for all "wholesale" regStatus updates, because it ensures that
     * the ST bits get propagated to the internal iST register.  Setting individual EXC bits should be done
     * through the fault() interface, and clearing individual EXC or BUSY bits should be done through
     * clearStatus().  Both functions, including this function, call checkException() after updating regStatus.
     *
     * @this {FPUx86}
     * @param {number} n
     */
    setStatus(n)
    {
        this.regStatus = n & ~X86.FPU.STATUS.ST;
        this.iST = (n & X86.FPU.STATUS.ST) >> X86.FPU.STATUS.ST_SHIFT;
        this.checkException();
    }

    /**
     * checkOperand(v)
     *
     * @this {FPUx86}
     * @param {number|null} v
     * @returns {boolean} (true if no exception, false otherwise)
     */
    checkOperand(v)
    {
        return isNaN(v)? !this.setException(X86.FPU.STATUS.IE) : true;
    }

    /**
     * checkResult(v)
     *
     * @this {FPUx86}
     * @param {number} v
     * @returns {boolean} (true if no exception, false otherwise)
     */
    checkResult(v)
    {
        return !isFinite(v)? !this.setException(v === Infinity? X86.FPU.STATUS.OE : X86.FPU.STATUS.UE) : true;
    }

    /**
     * doAdd(operand1, operand2)
     *
     * @this {FPUx86}
     * @param {number|null} operand1
     * @param {number|null} operand2
     * @returns {number|null}
     */
    doAdd(operand1, operand2)
    {
        let result = null;
        if (operand1 != null && operand2 != null) {
            result = operand1 + operand2;
            if (!this.checkResult(result)) result = null;
        }
        return result;
    }

    /**
     * doSubtract(operand1, operand2)
     *
     * @this {FPUx86}
     * @param {number|null} operand1
     * @param {number|null} operand2
     * @returns {number|null}
     */
    doSubtract(operand1, operand2)
    {
        let result = null;
        if (operand1 != null && operand2 != null) {
            result = operand1 - operand2;
            if (!this.checkResult(result)) result = null;
        }
        return result;
    }

    /**
     * doMultiply(operand1, operand2)
     *
     * @this {FPUx86}
     * @param {number|null} operand1
     * @param {number|null} operand2
     * @returns {number|null}
     */
    doMultiply(operand1, operand2)
    {
        let result = null;
        if (operand1 != null && operand2 != null) {
            result = operand1 * operand2;
            if (!this.checkResult(result)) result = null;
        }
        return result;
    }

    /**
     * doDivide(dividend, divisor)
     *
     * TODO: IE exceptions: infinity / infinity, 0 / 0, 0 / pseudo-zero, or divisor is denormal or unnormal.
     *
     * @this {FPUx86}
     * @param {number|null} dividend
     * @param {number|null} divisor
     * @returns {number|null}
     */
    doDivide(dividend, divisor)
    {
        let quotient = null;
        if (dividend != null && divisor != null) {
            if (divisor || !this.setException(X86.FPU.STATUS.DE)) {
                quotient = dividend / divisor;
                if (!this.checkResult(quotient)) quotient = null;
            }
        }
        return quotient;
    }

    /**
     * doCompare(operand1, operand2)
     *
     * @this {FPUx86}
     * @param {number|null} operand1
     * @param {number|null} operand2
     * @returns {boolean}
     */
    doCompare(operand1, operand2)
    {
        if (operand1 != null && operand2 != null) {
            let cc = 0;             // default value used when result > 0
            if (!isNaN(operand1) && !isNaN(operand2)) {
                let result = operand1 - operand2;
                if (result < 0) {
                    cc = X86.FPU.STATUS.C0;
                } else if (result === 0) {
                    cc = X86.FPU.STATUS.C3;
                }
            } else {
                cc = X86.FPU.STATUS.C0 | X86.FPU.STATUS.C2 | X86.FPU.STATUS.C3;
            }
            this.regStatus = (this.regStatus & ~X86.FPU.STATUS.CC) | cc;
            return true;
        }
        return false;
    }

    /**
     * doSquareRoot(operand)
     *
     * @this {FPUx86}
     * @param {number|null} operand
     * @returns {number|null}
     */
    doSquareRoot(operand)
    {
        let result = null;
        /**
         * Happily, -0 is ALSO >= 0.  Also happily, Math.sqrt(-0) returns -0.
         */
        if (operand >= 0 || !this.setException(X86.FPU.STATUS.IE)) {
            result = Math.sqrt(operand);
            if (!this.checkResult(result)) result = null;
        }
        return result;
    }

    /**
     * roundValue(operand, max)
     *
     * NOTE: The max parameter is EXCLUSIVE, not inclusive (ie, the maximum positive value is < max).
     *
     * Also, callers that expect intTmpLR[] to be loaded with the result *must* also specify a max parameter;
     * callers performing internal rounding and using just the return value may omit max to skip loading intTmpLR[].
     *
     * @this {FPUx86}
     * @param {number|null} operand
     * @param {number} [max] (ie, 0x8000, 0x80000000, or 0x8000000000000000)
     * @returns {number|null} (rounded result, or null if there was an unmasked exception)
     */
    roundValue(operand, max)
    {
        if (operand == null) return null;

        let rc = (this.regControl & X86.FPU.CONTROL.RC.MASK), result;

        if (rc == X86.FPU.CONTROL.RC.NEAR) {
            result = Math.round(operand);
            if (result - operand === 0.5 && (result % 2)) result--;
        }
        else if (rc == X86.FPU.CONTROL.RC.DOWN || rc == X86.FPU.CONTROL.RC.CHOP && operand > 0) {
            result = Math.floor(operand);
        }
        else {  // X86.FPU.CONTROL.RC.UP or X86.FPU.CONTROL.RC.CHOP && operand <= 0
            result = Math.ceil(operand);
        }

        if (max) {
            if (result >= max) {
                if (this.setException(X86.FPU.STATUS.IE)) return null;
                result = -max;      // apparently, the masked response is to return the most negative integer (not max - 1)
            }
            else if (result < -max) {
                if (this.setException(X86.FPU.STATUS.IE)) return null;
                result = -max;
            }
            this.intTmpLR[0] = result|0;
            if (max > FPUx86.MAX_INT32) {
                this.intTmpLR[1] = (result / 0x100000000)|0;
                if (!this.intTmpLR[1] && result < 0) this.intTmpLR[1] = -1;
            }
        }
        return result;
    }

    /**
     * truncateValue(v)
     *
     * @this {FPUx86}
     * @param {number} v
     * @returns {number}
     */
    truncateValue(v)
    {
        return v > 0? Math.floor(v) : Math.ceil(v);
    }

    /**
     * getTag(iReg)
     *
     * @this {FPUx86}
     * @param {number} iReg (register index)
     * @returns {number} tag value for register
     */
    getTag(iReg)
    {
        let bitUsed = (1 << iReg);
        let tag = X86.FPU.TAGS.EMPTY;
        if (this.regUsed & bitUsed) {
            let f = this.regStack[iReg];
            tag = X86.FPU.TAGS.VALID;
            if (f === 0.0) {
                tag = X86.FPU.TAGS.ZERO;
            }
            else if (!isFinite(f)) {
                tag = X86.FPU.TAGS.SPECIAL;
            }
        }
        return tag;
    }

    /**
     * getTags()
     *
     * @this {FPUx86}
     * @returns {number} tag values for all registers
     */
    getTags()
    {
        let tags = 0;
        for (let iReg = this.regStack.length - 1; iReg >= 0; iReg--) {
            tags <<= 2;
            tags |= this.getTag(iReg);
        }
        return tags;
    }

    /**
     * setTag(iReg, tag)
     *
     * @this {FPUx86}
     * @param {number} iReg (register index)
     * @param {number} tag value for register (EMPTY is the only supported value)
     */
    setTag(iReg, tag)
    {

        this.regUsed &= ~(1 << iReg);
    }

    /**
     * setTags(n)
     *
     * All we need to update here are which physical registers are marked "empty"; the rest of the tags
     * are generated on the fly based on actual values in the registers.
     *
     * @this {FPUx86}
     * @param {number} n (16-bit tag word, containing 8 2-bit tags)
     */
    setTags(n)
    {
        this.regUsed = 0;
        for (let bitUsed = 0x1; bitUsed <= 0x80; bitUsed <<= 1) {
            let tag = n & X86.FPU.TAGS.MASK;
            if (tag != X86.FPU.TAGS.EMPTY) {
                this.regUsed |= bitUsed;
            }
            n >>= 2;
        }
    }

    /**
     * getWI(i)
     *
     * Gets a "word-integer" (WI aka INT16) from ST(i)
     *
     * @this {FPUx86}
     * @param {number} i (eg, 0 for top-of-stack)
     * @returns {boolean} true if intTmpLR was loaded, false if not
     */
    getWI(i)
    {
        return this.roundValue(this.getST(i), FPUx86.MAX_INT16) != null;
    }

    /**
     * getSI(i)
     *
     * Gets a "short-integer" (SI aka INT32) from ST(i)
     *
     * @this {FPUx86}
     * @param {number} i (eg, 0 for top-of-stack)
     * @returns {boolean} true if intTmpLR was loaded, false if not
     */
    getSI(i)
    {
        return this.roundValue(this.getST(i), FPUx86.MAX_INT32) != null;
    }

    /**
     * getLI(i)
     *
     * Gets a "long-integer" (LI aka INT64) from ST(i)
     *
     * @this {FPUx86}
     * @param {number} i (eg, 0 for top-of-stack)
     * @returns {boolean} true if intTmpLR was loaded, false if not
     */
    getLI(i)
    {
        return this.roundValue(this.getST(i), FPUx86.MAX_INT64) != null;
    }

    /**
     * getSR(i)
     *
     * @this {FPUx86}
     * @param {number} i (eg, 0 for top-of-stack)
     * @returns {boolean} true if regTmpSR was loaded, false if not
     */
    getSR(i)
    {
        let iReg = (this.iST + i) & 7;
        if (this.regUsed & (1 << iReg)) {
            this.regTmpSR[0] = this.regStack[iReg];
            return true;
        } else if (!this.setException(X86.FPU.STATUS.IE)) {
            this.regTmpSR[0] = this.regIndefinite[0];
            return true;
        }
        return false;
    }

    /**
     * getLR(i)
     *
     * @this {FPUx86}
     * @param {number} i (eg, 0 for top-of-stack)
     * @returns {boolean} true if regTmpLR was loaded, false if not
     */
    getLR(i)
    {
        let iReg = (this.iST + i) & 7;
        if (this.regUsed & (1 << iReg)) {
            this.regTmpLR[0] = this.regStack[iReg];
            return true;
        } else if (!this.setException(X86.FPU.STATUS.IE)) {
            this.regTmpLR[0] = this.regIndefinite[0];
            return true;
        }
        return false;
    }

    /**
     * getST(i)
     *
     * @this {FPUx86}
     * @param {number} i (eg, 0 for top-of-stack)
     * @returns {number|null} v
     */
    getST(i)
    {
        let v = null;
        let iReg = (this.iST + i) & 7;
        if (this.regUsed & (1 << iReg)) {
            v = this.regStack[iReg];
        } else if (!this.setException(X86.FPU.STATUS.IE)) {
            v = this.regIndefinite[0];
        }
        return v;
    }

    /**
     * getSTSign(i)
     *
     * Returns zero if sign bit clear, and non-zero (negative) if sign bit set.  This is safer
     * than comparing getST() to zero, because JavaScript comparisons involving NaNs are meaningless.
     *
     * For internal use only; ignores whether the register is empty, and performs no exception checks.
     *
     * @this {FPUx86}
     * @param {number} i (eg, 0 for top-of-stack)
     * @returns {number}
     */
    getSTSign(i)
    {
        let iInt = ((this.iST + i) & 7) << 1;
        return this.intStack[iInt + 1] & (0x80000000|0);
    }

    /**
     * setST(i, v)
     *
     * @this {FPUx86}
     * @param {number} i (eg, 0 for top-of-stack)
     * @param {number|null} v
     * @returns {boolean}
     */
    setST(i, v)
    {
        if (v != null && this.checkOperand(v)) {
            let iReg = (this.iST + i) & 7;
            this.regStack[iReg] = v;
            this.regUsed |= (1 << iReg);
            return true;
        }
        return false;
    }

    /**
     * getTR(i, fSafe)
     *
     * @this {FPUx86}
     * @param {number} i (stack index, 0-7)
     * @param {boolean} [fSafe] (true to ignore all exception criteria; used by FSAVE)
     * @returns {Array.<number>|null} ("temp-real" aka TR, as an array of three 32-bit integers)
     */
    getTR(i, fSafe)
    {
        let a = null;
        let iReg = (this.iST + i) & 7;
        if (fSafe || this.regUsed & (1 << iReg) || !this.setException(X86.FPU.STATUS.IE)) {
            let iInt = iReg << 1;
            a = this.getTRFromLR(this.intStack[iInt], this.intStack[iInt + 1]);
        }
        return a;
    }

    /**
     * setTR(i, a)
     *
     * Sets ST(i) to the TR ("long-real") in a[].
     *
     * @this {FPUx86}
     * @param {number} i (stack index, 0-7)
     * @param {Array.<number>|null} a
     */
    setTR(i, a)
    {
        if (a) this.setST(i, this.getLRFromTR(a));
    }

    /**
     * getWIFromEA()
     *
     * Returns the (16-bit) "word-integer" value located at regEA.
     *
     * @this {FPUx86}
     * @returns {number} v
     */
    getWIFromEA()
    {

        return (this.cpu.getShort(this.cpu.regEA) << 16) >> 16;
    }

    /**
     * getSIFromEA()
     *
     * Returns the (32-bit) "short-integer" value located at regEA.
     *
     * @this {FPUx86}
     * @returns {number} v
     */
    getSIFromEA()
    {

        return this.cpu.getLong(this.cpu.regEA);
    }

    /**
     * getLIFromEA()
     *
     * Returns the (64-bit) "long-integer" value located at regEA.
     *
     * @this {FPUx86}
     * @returns {number} v
     */
    getLIFromEA()
    {

        let lo = this.cpu.getLong(this.cpu.regEA);
        let hi = this.cpu.getLong(this.cpu.regEA + 4);
        return (hi * 0x100000000) + (lo >>> 0);
    }

    /**
     * getSRFromEA()
     *
     * Sets the internal regTmpSR register to the (32-bit) "short-real" value located at regEA.
     *
     * @this {FPUx86}
     * @returns {number} v
     */
    getSRFromEA()
    {

        this.intTmpSR[0] = this.cpu.getLong(this.cpu.regEA);
        return this.regTmpSR[0];
    }

    /**
     * getLRFromEA()
     *
     * Sets the internal regTmpLR register to the (64-bit) "long-real" value located at regEA.
     *
     * @this {FPUx86}
     * @returns {number} v
     */
    getLRFromEA()
    {

        this.intTmpLR[0] = this.cpu.getLong(this.cpu.regEA);
        this.intTmpLR[1] = this.cpu.getLong(this.cpu.regEA + 4);
        return this.regTmpLR[0];
    }

    /**
     * getTRFromEA()
     *
     * Sets the internal intTmpTR register to the (80-bit) "temp-real" value located at regEA.
     *
     * @this {FPUx86}
     * @returns {Array.<number>} intTmpTR
     */
    getTRFromEA()
    {

        this.intTmpTR[0] = this.cpu.getLong(this.cpu.regEA);
        this.intTmpTR[1] = this.cpu.getLong(this.cpu.regEA + 4);
        this.intTmpTR[2] = this.cpu.getShort(this.cpu.regEA + 8);
        return this.intTmpTR;
    }

    /**
     * setEAFromWI()
     *
     * Stores the (16-bit) "word-integer" value in the internal intTmpLR register to the address in regEA.
     *
     * @this {FPUx86}
     */
    setEAFromWI()
    {

        this.cpu.setShort(this.cpu.regEA, this.intTmpLR[0]);
    }

    /**
     * setEAFromSI()
     *
     * Stores the (32-bit) "short-integer" value in the internal intTmpLR register to the address in regEA.
     *
     * @this {FPUx86}
     */
    setEAFromSI()
    {

        this.cpu.setLong(this.cpu.regEA, this.intTmpLR[0]);
    }

    /**
     * setEAFromLI()
     *
     * Stores the (64-bit) "long-integer" value in the internal intTmpLR register to the address in regEA.
     *
     * @this {FPUx86}
     */
    setEAFromLI()
    {

        this.cpu.setLong(this.cpu.regEA, this.intTmpLR[0]);
        this.cpu.setLong(this.cpu.regEA + 4, this.intTmpLR[1]);
    }

    /**
     * setEAFromTR()
     *
     * Stores the (80-bit) "temp-real" value in the internal intTmpTR register to the address in regEA.
     *
     * @this {FPUx86}
     */
    setEAFromTR()
    {

        this.cpu.setLong(this.cpu.regEA, this.intTmpTR[0]);
        this.cpu.setLong(this.cpu.regEA + 4, this.intTmpTR[1]);
        this.cpu.setShort(this.cpu.regEA + 8, this.intTmpTR[2]);
    }

    /**
     * getLRFromTR(a)
     *
     * Since we must use the "long-real" (64-bit) format internally, rather than the "temp-real" (80-bit) format,
     * this function converts a 64-bit value to an 80-bit value.  The major differences: 1) the former uses a 52-bit
     * fraction and 11-bit exponent, while the latter uses a 64-bit fraction and 15-bit exponent; 2) the former
     * does NOT store a leading 1 with the fraction, whereas the latter does.
     *
     * @this {FPUx86}
     * @param {Array.<number>} a (eg, intTmpTR)
     * @returns {number} v
     */
    getLRFromTR(a)
    {
        let loTR = a[0], hiTR = a[1];
        let signLR = (a[2] & 0x8000) >> 4;
        let expLR = a[2] & 0x7fff;

        /**
         * We have no choice but to chop off the bottom 11 TR bits in order to fit in an LR....
         */
        let loLR = (loTR >>> 11) | (hiTR << 21);
        let hiLR = (hiTR >> 11) & 0xfffff;

        if (expLR == 0x7fff) {
            /**
             * Convert an TR NaN to a LR NaN.
             */
            expLR = 0x7ff;
        }
        else if (expLR) {
            /**
             * We have a normal (biased) TR exponent which we must now convert to a (biased) LR exponent;
             * subtract the TR bias (0x3fff) and add the LR bias (0x3ff); additionally, we have a problem
             * that getTRFromLR() did not: if the TR exponent is too large to fit in an LR exponent, then we
             * have convert the result to +/- infinity.
             */
            expLR += 0x3ff - 0x3fff;
            if (expLR <= 0) {
                expLR = 0x7ff;
                loLR = hiLR = 0;
            }
        }

        this.intTmpLR[0] = loLR;
        this.intTmpLR[1] = hiLR | ((signLR | expLR) << 20);
        return this.regTmpLR[0];
    }

    /**
     * getTRFromLR(loLR, hiLR)
     *
     * Since we must use the "long-real" (64-bit) format internally, rather than the "temp-real" (80-bit) format,
     * this function converts a 64-bit value to an 80-bit value.  The major differences: 1) the former uses a 52-bit
     * fraction and 11-bit exponent, while the latter uses a 64-bit fraction and 15-bit exponent; 2) the former
     * does NOT store a leading 1 with the fraction, whereas the latter does.
     *
     * @this {FPUx86}
     * @param {number} loLR
     * @param {number} hiLR
     * @returns {Array.<number>} (intTmpTR)
     */
    getTRFromLR(loLR, hiLR)
    {
        let expTR = (hiLR >> 20) & 0x07ff;
        let signTR = (hiLR >> 16) & 0x8000;
        let loTR = loLR << 11;
        let hiTR = 0x80000000 | ((hiLR & 0x000fffff) << 11) | (loLR >>> 21);

        if (expTR == 0x07ff) {
            /**
             * Convert an LR NaN to a TR NaN.  NaNs encompass +/- infinity, which in the LR
             * world are fractions of all zeros.  NaNs also encompass indefinite, which in the LR
             * world are negative numbers with only the high fraction bit set.  So, in both cases,
             * our default TR value (ie, with zeros shifted into the bottom 11 bits) should be fine;
             * we simply need to change the exponent to the maximum TR value.
             */
            expTR = 0x7fff;
        }
        else if (!expTR) {
            /**
             * An LR with an exponent of zero could be an actual +/- zero, if the fraction is zero,
             * or it could be a denormal, if the fraction is non-zero.  In both cases, the only
             * change we need to make the TR form is clearing the leading 1 bit.
             */
            hiTR &= 0x7fffffff;
        }
        else {
            /**
             * We have a normal (biased) LR exponent which we must now convert to a (biased) TR exponent;
             * subtract the LR bias (0x3ff) and add the TR bias (0x3fff).
             */
            expTR += 0x3fff - 0x3ff;
        }

        this.intTmpTR[0] = loTR;
        this.intTmpTR[1] = hiTR;
        this.intTmpTR[2] = signTR | expTR;
        return this.intTmpTR;
    }

    /**
     * decodeBCD()
     *
     * @this {FPUx86}
     * @param {number} i (32-bit integer containing n BCD digits)
     * @param {number} n (number of BCD digits to decode)
     * @returns {number} (binary value representing the specified number of BCD digits)
     */
    decodeBCD(i, n)
    {
        let v = 0, m = 1;

        while (n--) {
            let d = i & 0xf;

            v += d * m;
            m *= 10;
            i >>= 4;
        }
        return v;
    }

    /**
     * encodeBCD()
     *
     * @this {FPUx86}
     * @param {number} v (binary value from which to extract n BCD digits)
     * @param {number} n (number of BCD digits to extract)
     * @returns {number} (integer containing the requested number of BCD digits)
     */
    encodeBCD(v, n)
    {
        let i = 0, s = 0;

        while (n--) {
            i |= (v % 10) << s;
            v /= 10;
            s += 4;
        }
        return i;
    }

    /**
     * popValue()
     *
     * @this {FPUx86}
     * @returns {number|null} v
     */
    popValue()
    {
        let v = null;
        let bitUsed = (1 << this.iST);
        if (!(this.regUsed & bitUsed)) {
            this.regStatus &= ~X86.FPU.STATUS.C1;       // clear C1 to indicate stack underflow (80287XL and up)
            if (this.setException(X86.FPU.STATUS.SF | X86.FPU.STATUS.IE)) return v;
        }
        this.regUsed &= ~bitUsed;
        v = this.regStack[this.iST];
        this.iST = (this.iST + 1) & 7;
        return v;
    }

    /**
     * pushValue(v)
     *
     * @this {FPUx86}
     * @param {number|null} v
     */
    pushValue(v)
    {
        if (v == null) return;
        let iReg = (this.iST - 1) & 7;
        let bitUsed = (1 << iReg);
        if (this.regUsed & bitUsed) {
            this.regStatus |= X86.FPU.STATUS.C1;        // set C1 to indicate stack overflow (80287XL and up)
            if (this.setException(X86.FPU.STATUS.SF | X86.FPU.STATUS.IE)) return;
        }
        if (!this.checkOperand(v)) {
            if (this.setException(X86.FPU.STATUS.IE)) return;
            v = NaN;
        }
        this.regStack[this.iST = iReg] = v;
        this.regUsed |= bitUsed;
    }

    /**
     * loadEnv(addr)
     *
     * @this {FPUx86}
     * @param {number} addr
     * @returns {number} updated addr
     */
    loadEnv(addr)
    {
        let w;
        let cpu = this.cpu;

        this.setControl(cpu.getWord(addr));
        this.setStatus(cpu.getWord(addr += cpu.sizeData));
        this.setTags(cpu.getWord(addr += cpu.sizeData));

        if (!(cpu.regCR0 & X86.CR0.MSW.PE) || (cpu.regPS & X86.PS.VM)) {
            this.regCodeOff = cpu.getWord(addr += cpu.sizeData);
            w = cpu.getWord(addr += cpu.sizeData);
            this.regOpcode = w & 0x7ff;
            this.regCodeOff |= (w & ~0xfff) << 4;
            this.regCodeSel = -1;
            this.regDataOff = cpu.getWord(addr += cpu.sizeData);
            this.regDataOff |= (cpu.getWord(addr += cpu.sizeData) & ~0xfff) << 4;
            this.regDataSel = -1;
        } else {
            this.regCodeOff = cpu.getWord(addr += cpu.sizeData);
            w = cpu.getWord(addr += cpu.sizeData);
            this.regCodeSel = w & 0xffff;
            this.regOpcode = (w >> 16) & 0x7ff;
            this.regDataOff = cpu.getWord(addr += cpu.sizeData);
            this.regDataSel = cpu.getWord(addr += cpu.sizeData) & 0xffff;
        }
        return addr + cpu.sizeData;
    }

    /**
     * saveEnv(addr)
     *
     * @this {FPUx86}
     * @param {number} addr
     * @returns {number} updated addr
     */
    saveEnv(addr)
    {
        let cpu = this.cpu;

        cpu.setWord(addr, this.regControl);
        cpu.setWord(addr += cpu.sizeData, this.getStatus());
        cpu.setWord(addr += cpu.sizeData, this.getTags());

        if (!(cpu.regCR0 & X86.CR0.MSW.PE) || (cpu.regPS & X86.PS.VM)) {
            let off = (this.regCodeSel << 4) + this.regCodeOff;
            cpu.setWord(addr += cpu.sizeData, off);
            cpu.setWord(addr += cpu.sizeData, ((off >> 4) & ~0xfff) | this.regOpcode);
            off = (this.regDataSel << 4) + this.regDataOff;
            cpu.setWord(addr += cpu.sizeData, off);
            cpu.setWord(addr += cpu.sizeData, ((off >> 4) & ~0xfff));
        } else {
            cpu.setWord(addr += cpu.sizeData, this.regCodeOff);
            cpu.setWord(addr += cpu.sizeData, this.regCodeSel | (this.regOpcode << 16));
            cpu.setWord(addr += cpu.sizeData, this.regDataOff);
            cpu.setWord(addr += cpu.sizeData, this.regDataSel);
        }
        return addr + cpu.sizeData;
    }

    /**
     * opFPU(bOpcode, bModRM, dst, src)
     *
     * This is called by the CPU's ESC opcode handlers, after each instruction has been fully decoded.
     *
     * @this {FPUx86}
     * @param {number} bOpcode (0xD8-0xDF)
     * @param {number} bModRM
     * @param {number} dst
     * @param {number} src
     */
    opFPU(bOpcode, bModRM, dst, src)
    {
        let mod = (bModRM >> 6) & 3;
        let reg = (bModRM >> 3) & 7;
        this.iStack = (bModRM & 7);

        /**
         * Combine mod and reg into one decodable value: put mod in the high nibble
         * and reg in the low nibble, after first collapsing all mod values < 3 to zero.
         */
        let modReg = (mod < 3? 0 : 0x30) + reg;

        /**
         * All values >= 0x34 imply mod == 3 and reg >= 4, so now we shift reg into the high
         * nibble and iStack into the low, yielding values >= 0x40.
         */
        if ((bOpcode == X86.OPCODE.ESC1 || bOpcode == X86.OPCODE.ESC3) && modReg >= 0x34) {
            modReg = (reg << 4) | this.iStack;
        }

        let fnOp = FPUx86.aaOps[bOpcode][modReg];
        if (fnOp) {
            /**
             * A handful of FPU instructions must preserve (at least some of) the "exception" registers,
             * so if the current function is NOT one of those, then update all the "exception" registers.
             */
            if (FPUx86.afnPreserveExceptions.indexOf(fnOp) < 0) {
                let cpu = this.cpu;
                let off = cpu.opLIP;
                /**
                 * WARNING: opLIP points to any prefixes preceding the ESC instruction, but the 8087 always
                 * points to the ESC instruction.  Technically, that's a bug, but it's also a reality, so we
                 * check for preceding prefixes and bump the instruction pointer accordingly.  This isn't a
                 * perfect solution, because it doesn't account for multiple (redundant) prefixes, but it
                 * should be adequate.
                 */
                if (this.isModel(X86.FPU.MODEL_8087)) {
                    if (cpu.opPrefixes & X86.OPFLAG.SEG) off++;
                    if (cpu.opPrefixes & X86.OPFLAG.LOCK) off++;
                }
                this.regCodeSel = cpu.segCS.sel;
                this.regCodeOff = off - cpu.segCS.base;
                if (cpu.regEA !== X86.ADDR_INVALID) {
                    this.regDataSel = cpu.segEA.sel;
                    this.regDataOff = cpu.regEA - cpu.segEA.base;
                }
                this.regOpcode = ((bOpcode & 7) << 8) | bModRM;
            }
            /**
             * Finally, perform the FPU operation.
             */
            fnOp.call(this);
        }
        else {
            /**
             * This is a gray area, at least until aaOps has been filled in for all supported coprocessors;
             * but for now, we'll treat all unrecognized operations as "no operation", as opposed to unimplemented.
             */
            this.opNone();
        }
    }

    /**
     * opWAIT()
     *
     * This is called by the CPU's WAIT opcode handler, giving us the opportunity to synchronize the FPU with the CPU,
     * charge an appropriate number of cycles, and return true.  In this context, it's considered an FWAIT instruction,
     * but technically, it's the same opcode.
     *
     * If we choose to do nothing, then we must return false, so that the CPU can charge a default number of cycles.
     *
     * @this {FPUx86}
     * @returns {boolean} true if implemented, false if not
     */
    opWAIT()
    {
        return false;
    }

    /**
     * readFPUStack(i)
     *
     * Returns the following information for the requested FPU stack element, relative to ST:
     *
     *      a[0]: physical stack position (0-7)
     *      a[1]: corresponding tag value
     *      a[2]: 64-bit "long-real" (LR) value
     *      a[3]: bits 0-31 of 64-bit "long-real" (LR)
     *      a[4]: bits 32-63 of 64-bit "long-real" (LR)
     *      a[5]: bits 0-31 of 80-bit "temp-real" (TR)
     *      a[6]: bits 32-63 of 80-bit "temp-real" (TR)
     *      a[7]: bits 64-79 of 80-bit "temp-real" (TR) (in bits 0-15)
     *
     * Used by the Debugger for its floating-point register ("rfp") command.  For other FPU registers,
     * the Debugger calls getStatus() and getControl() directly.
     *
     * NOTE: The "temp-real" values are fake; we manufacture them on demand from 64-bit "long-real" values
     * actually stored in the stack; see getTRFromLR().
     *
     * @this {FPUx86}
     * @param {number} i (stack index, relative to ST)
     * @returns {Array.<number>|null} (an array of information as described above, or null if invalid element)
     */
    readFPUStack(i)
    {
        let a = null;
        if (i < this.regStack.length) {
            a = [];
            let iReg = (this.iST + i) & 7;
            a[0] = iReg;
            a[1] = this.getTag(iReg);
            a[2] = this.regStack[iReg];
            let iInt = iReg << 1;
            a[3] = this.intStack[iInt];
            a[4] = this.intStack[iInt + 1];
            let aTR = this.getTRFromLR(a[3], a[4]);
            a[5] = aTR[0]; a[6] = aTR[1]; a[7] = aTR[2];
        }
        return a;
    }

    /**
     * getRandomInt(min, max)
     *
     * Used with old test code to verify that any randomly-constructed "long-real" (REAL64) could be converted
     * to a "temp-real" (REAL80) and back again losslessly, otherwise a bug in either getTRFromLR() or getLRFromTR()
     * might exist.  That test code can be resurrected from the repo; this code is being retained for future tests.
     *
     * NOTE: If either min or max is a value containing 32 or more significant bits AND bit 31 is set AND it has passed
     * through some bitwise operation(s), then that value may end up being negative, so you may end up with an inverted
     * range, or a range that's smaller or larger than intended.
     *
     * @this {FPUx86}
     * @param {number} min (inclusive)
     * @param {number} max (inclusive)
     * @returns {number}
     *
     getRandomInt(min, max)
     {
         max -= min;
         if (max < 0) {      // compensate for inverted ranges (ie, where min > max)
             min += max;
             max = -max;
         }
         return Math.floor(Math.random() * (max + 1)) + min;
     }
     */

    /**
     * FPUx86.init()
     *
     * This function operates on every HTML element of class "fpu", extracting the
     * JSON-encoded parameters for the FPUx86 constructor from the element's "data-value"
     * attribute, invoking the constructor to create an FPUx86 component, and then binding
     * any associated HTML controls to the new component.
     */
    static init()
    {
        let aeFPUs = Component.getElementsByClass(APPCLASS, "fpu");
        for (let iFPU = 0; iFPU < aeFPUs.length; iFPU++) {
            let eFPU = aeFPUs[iFPU];
            let parmsFPU = Component.getComponentParms(eFPU);
            let fpu = new FPUx86(parmsFPU);
            Component.bindComponentControls(fpu, eFPU, APPCLASS);
        }
    }
}

/**
 * F2XM1()
 *
 * F2XM1 (2 to the x minus 1) calculates the function 2^x - 1 and returns the result to ST(0).
 *
 * On the 8087 and 80287, the value in ST(0) must satisfy the inequality 0 <= ST(0) <= 0.5.  On the 80287XL and
 * later coprocessors, the permissible range is greater, and ST(0) must satisfy the inequality -1 <= ST(0) <= 1.
 * If ST(0) is out of range, the result is undefined, even though no exception is raised.
 *
 * The F2XM1 instruction is designed to provide an accurate result even when x is close to zero. To obtain 2^x,
 * simply add 1.0 to the result returned by F2XM1.
 *
 * This instruction is useful in performing exponentiation of values other than 2 as shown in the following formulas:
 *
 *      10^x = 2^(x * log2(10))
 *      e^x = 2^(x * log2(e))
 *      y^x = 2^(x * log2(y))
 *
 * Note that the NPX has dedicated instructions for loading the constants log2(10) and log2(e).  The FYL2X instruction
 * may be used to calculate x * log2(y).
 *
 * See also: FYL2X, FLDL2T, FLDL2E.
 *
 * @this {FPUx86}
 */
FPUx86.F2XM1 = function()
{
    this.setST(0, Math.pow(2, this.getST(0)) - 1);
};

/**
 * FABS()
 *
 * @this {FPUx86}
 */
FPUx86.FABS = function()
{
    /**
     * TODO: This could be implemented more efficiently by simply clearing the sign bit of ST(0).
     */
    this.setST(0, Math.abs(this.getST(0)));
};

/**
 * FADDlr()
 *
 * @this {FPUx86}
 */
FPUx86.FADDlr = function()
{
    this.setST(0, this.doAdd(this.getST(0), this.getLRFromEA()));
};

/**
 * FADDsr()
 *
 * Encoding 0xD8,reg=0x00 ("FADD short-real"): ST(0) <- ST(0) + REAL32
 *
 * @this {FPUx86}
 */
FPUx86.FADDsr = function()
{
    this.setST(0, this.doAdd(this.getST(0), this.getSRFromEA()));
};

/**
 * FADDst()
 *
 * @this {FPUx86}
 */
FPUx86.FADDst = function()
{
    this.setST(0, this.doAdd(this.getST(0), this.getST(this.iStack)));
};

/**
 * FADDsti()
 *
 * @this {FPUx86}
 */
FPUx86.FADDsti = function()
{
    this.setST(this.iStack, this.doAdd(this.getST(this.iStack), this.getST(0)));
};

/**
 * FADDPsti()
 *
 * @this {FPUx86}
 */
FPUx86.FADDPsti = function()
{
    if (this.setST(this.iStack, this.doAdd(this.getST(this.iStack), this.getST(0)))) this.popValue();
};

/**
 * FBLDpd()
 *
 * @this {FPUx86}
 */
FPUx86.FBLDpd = function()
{
    let a = this.getTRFromEA();
    /**
     * a[0] contains the 8 least-significant BCD digits, a[1] contains the next 8, and a[2] contains
     * the next 2 (bit 15 of a[2] is the sign bit, and bits 8-14 of a[2] are unused).
     */
    let v = this.decodeBCD(a[0], 8) + this.decodeBCD(a[1], 8) * 100000000 + this.decodeBCD(a[2], 2) * 10000000000000000;
    if (a[2] & 0x8000) v = -v;
    this.pushValue(v);
};

/**
 * FBSTPpd()
 *
 * @this {FPUx86}
 */
FPUx86.FBSTPpd = function()
{
    /**
     * TODO: Verify the operation of FBSTP (eg, does it signal an exception if abs(value) >= 1000000000000000000?)
     */
    let v = this.roundValue(this.popValue());
    if (v != null) {
        /**
         * intTmpTR[0] will contain the 8 least-significant BCD digits, intTmpTR[1] will contain the next 8,
         * and intTmpTR[2] will contain the next 2 (bit 15 of intTmpTR[2] will be the sign bit, and bits 8-14 of
         * intTmpTR[2] will be unused).
         */
        this.intTmpTR[0] = this.encodeBCD(v, 8);
        this.intTmpTR[1] = this.encodeBCD(v / 100000000, 8);
        this.intTmpTR[2] = this.encodeBCD(v / 10000000000000000, 2);
        if (v < 0) this.intTmpTR[2] |= 0x8000;
        this.setEAFromTR();
    }
};

/**
 * FCHS()
 *
 * @this {FPUx86}
 */
FPUx86.FCHS = function()
{
    /**
     * TODO: This could be implemented more efficiently by simply inverting the sign bit of ST(0).
     */
    this.setST(0, -this.getST(0));
};

/**
 * FCLEX()
 *
 * NOTE: Although we explicitly clear the BUSY bit, there shouldn't be any code setting it, because
 * we're never "busy" (all floating-point operations are performed synchronously).  Conversely, there's
 * no need to explicitly clear the ES bit, because clearStatus() will call checkException(), which
 * updates ES and clears/sets FPU interrupt status as appropriate.
 *
 * @this {FPUx86}
 */
FPUx86.FCLEX = function()
{
    this.clearStatus(X86.FPU.STATUS.EXC | X86.FPU.STATUS.BUSY);
};

/**
 * FCOMlr()
 *
 * Encoding 0xDC,mod<3,reg=2 ("FCOM long-real"): Evaluate ST(0) - REAL64
 *
 * @this {FPUx86}
 */
FPUx86.FCOMlr = function()
{
    this.doCompare(this.getST(0), this.getLRFromEA());
};

/**
 * FCOMsr()
 *
 * Encoding 0xD8,mod<3,reg=2 ("FCOM short-real"): Evaluate ST(0) - REAL32
 *
 * @this {FPUx86}
 */
FPUx86.FCOMsr = function()
{
    this.doCompare(this.getST(0), this.getSRFromEA());
};

/**
 * FCOMst()
 *
 * Encoding 0xD8,mod=3,reg=2 ("FCOM ST(i)"): Evaluate ST(0) - ST(i)
 *
 * @this {FPUx86}
 */
FPUx86.FCOMst = function()
{
    this.doCompare(this.getST(0), this.getST(this.iStack));
};

/**
 * FCOM8087()
 *
 * NOTE: This is used with encoding(s) (0xDC,0xD0-0xD7) that were valid for the 8087 and 80287
 * but may no longer be valid as of the 80387.
 *
 * TODO: Determine if this form subtracted the operands in the same order, or if it requires an FCOMsti(),
 * which, like the other *sti() functions, uses ST(0) as the second operand rather than the first.
 *
 * @this {FPUx86}
 */
FPUx86.FCOM8087 = function()
{
    this.opObsolete();
    FPUx86.FCOMst.call(this);
};

/**
 * FCOMPlr()
 *
 * Encoding 0xDC,mod<3,reg=3 ("FCOM long-real"): Evaluate ST(0) - REAL64, POP
 *
 * @this {FPUx86}
 */
FPUx86.FCOMPlr = function()
{
    if (this.doCompare(this.getST(0), this.getLRFromEA())) this.popValue();
};

/**
 * FCOMPsr()
 *
 * Encoding 0xD8,mod<3,reg=3 ("FCOM short-real"): Evaluate ST(0) - REAL32, POP
 *
 * @this {FPUx86}
 */
FPUx86.FCOMPsr = function()
{
    if (this.doCompare(this.getST(0), this.getSRFromEA())) this.popValue();
};

/**
 * FCOMPst()
 *
 * Encoding 0xD8,mod=3,reg=3 ("FCOMP ST(i)"): Evaluate ST(0) - ST(i), POP
 *
 * @this {FPUx86}
 */
FPUx86.FCOMPst = function()
{
    if (this.doCompare(this.getST(0), this.getST(this.iStack))) this.popValue();
};

/**
 * FCOMP8087()
 *
 * NOTE: This is used with encodings (0xDC,0xD8-0xDF and 0xDE,0xD0-0xD7) that were valid for the 8087
 * and 80287 but may no longer be valid as of the 80387.
 *
 * TODO: Determine if this form subtracted the operands in the same order, or if it requires an FCOMPsti(),
 * which, like the other *sti() functions, uses ST(0) as the second operand rather than the first.
 *
 * @this {FPUx86}
 */
FPUx86.FCOMP8087 = function()
{
    this.opObsolete();
    FPUx86.FCOMPst.call(this);
};

/**
 * FCOMPP()
 *
 * @this {FPUx86}
 */
FPUx86.FCOMPP = function()
{
    if (this.doCompare(this.getST(0), this.getST(1)) && this.popValue() != null) this.popValue();
};

/**
 * FDECSTP()
 *
 * @this {FPUx86}
 */
FPUx86.FDECSTP = function()
{
    this.iST = (this.iST - 1) & 0x7;
    this.regStatus &= ~X86.FPU.STATUS.C1;
};

/**
 * FDISI8087()
 *
 * @this {FPUx86}
 */
FPUx86.FDISI8087 = function()
{
    if (this.isModel(X86.FPU.MODEL_8087)) {
        this.regControl |= X86.FPU.CONTROL.IEM;
    }
};

/**
 * FDIVlr()
 *
 * @this {FPUx86}
 */
FPUx86.FDIVlr = function()
{
    this.setST(0, this.doDivide(this.getST(0), this.getLRFromEA()));
};

/**
 * FDIVsr()
 *
 * @this {FPUx86}
 */
FPUx86.FDIVsr = function()
{
    this.setST(0, this.doDivide(this.getST(0), this.getSRFromEA()));
};

/**
 * FDIVst()
 *
 * Encoding 0xD8,0xF0-0xF7 ("FDIV ST,ST(i)"): ST(0) <- ST(0) / ST(i)
 *
 * @this {FPUx86}
 */
FPUx86.FDIVst = function()
{
    this.setST(0, this.doDivide(this.getST(0), this.getST(this.iStack)));
};

/**
 * FDIVsti()
 *
 * Encoding 0xDC,0xF8-0xFF ("FDIV ST(i),ST"): ST(i) <- ST(i) / ST(0)
 *
 * @this {FPUx86}
 */
FPUx86.FDIVsti = function()
{
    this.setST(this.iStack, this.doDivide(this.getST(this.iStack), this.getST(0)));
};

/**
 * FDIVPsti()
 *
 * Encoding 0xDE,0xF8-0xFF ("FDIVP ST(i),ST"): ST(i) <- ST(i) / ST(0), POP
 *
 * @this {FPUx86}
 */
FPUx86.FDIVPsti = function()
{
    if (this.setST(this.iStack, this.doDivide(this.getST(this.iStack), this.getST(0)))) this.popValue();
};

/**
 * FDIVRlr()
 *
 * @this {FPUx86}
 */
FPUx86.FDIVRlr = function()
{
    this.setST(0, this.doDivide(this.getLRFromEA(), this.getST(0)));
};

/**
 * FDIVRsr()
 *
 * @this {FPUx86}
 */
FPUx86.FDIVRsr = function()
{
    this.setST(0, this.doDivide(this.getSRFromEA(), this.getST(0)));
};

/**
 * FDIVRst()
 *
 * Encoding 0xD8,0xF8-0xFF ("FDIVR ST,ST(i)"): ST(0) <- ST(i) / ST(0)
 *
 * @this {FPUx86}
 */
FPUx86.FDIVRst = function()
{
    this.setST(0, this.doDivide(this.getST(this.iStack), this.getST(0)));
};

/**
 * FDIVRsti()
 *
 * Encoding 0xDC,0xF0-0xF7 ("FDIVR ST(i),ST"): ST(i) <- ST(0) / ST(i)
 *
 * @this {FPUx86}
 */
FPUx86.FDIVRsti = function()
{
    this.setST(this.iStack, this.doDivide(this.getST(0), this.getST(this.iStack)));
};

/**
 * FDIVRPsti()
 *
 * Encoding 0xDE,0xF0-0xE7 ("FDIVRP ST(i),ST"): ST(i) <- ST(0) / ST(i), POP
 *
 * @this {FPUx86}
 */
FPUx86.FDIVRPsti = function()
{
    if (this.setST(this.iStack, this.doDivide(this.getST(0), this.getST(this.iStack)))) this.popValue();
};

/**
 * FENI8087()
 *
 * @this {FPUx86}
 */
FPUx86.FENI8087 = function()
{
    if (this.isModel(X86.FPU.MODEL_8087)) {
        this.regControl &= ~X86.FPU.CONTROL.IEM;
    }
};

/**
 * FFREEsti()
 *
 * @this {FPUx86}
 */
FPUx86.FFREEsti = function()
{
    this.setTag(this.iST, X86.FPU.TAGS.EMPTY);
};

/**
 * FFREEP8087()
 *
 * NOTE: This is used with an encoding (0xDF,0xC0-0xC7) that was valid for the 8087 and 80287
 * but may no longer be valid as of the 80387.  Also, if the older documentation is to be believed,
 * this instruction has no modern counterpart, as FFREE doesn't pop the stack.
 *
 * @this {FPUx86}
 */
FPUx86.FFREEP8087 = function()
{
    this.opObsolete();
    FPUx86.FFREEsti.call(this);
    this.popValue();
};

/**
 * FIADD16()
 *
 * @this {FPUx86}
 */
FPUx86.FIADD16 = function()
{
    this.setST(0, this.doAdd(this.getST(0), this.getWIFromEA()));
};

/**
 * FIADD32()
 *
 * @this {FPUx86}
 */
FPUx86.FIADD32 = function()
{
    this.setST(0, this.doAdd(this.getST(0), this.getSIFromEA()));
};

/**
 * FICOM16()
 *
 * @this {FPUx86}
 */
FPUx86.FICOM16 = function()
{
    this.doCompare(this.getST(0), this.getWIFromEA());
};

/**
 * FICOM32()
 *
 * @this {FPUx86}
 */
FPUx86.FICOM32 = function()
{
    this.doCompare(this.getST(0), this.getSIFromEA());
};

/**
 * FICOMP16()
 *
 * @this {FPUx86}
 */
FPUx86.FICOMP16 = function()
{
    if (this.doCompare(this.getST(0), this.getWIFromEA())) this.popValue();
};

/**
 * FICOMP32()
 *
 * @this {FPUx86}
 */
FPUx86.FICOMP32 = function()
{
    if (this.doCompare(this.getST(0), this.getSIFromEA())) this.popValue();
};

/**
 * FIDIV16()
 *
 * @this {FPUx86}
 */
FPUx86.FIDIV16 = function()
{
    this.setST(0, this.doDivide(this.getST(0), this.getWIFromEA()));
};

/**
 * FIDIV32()
 *
 * @this {FPUx86}
 */
FPUx86.FIDIV32 = function()
{
    this.setST(0, this.doDivide(this.getST(0), this.getSIFromEA()));
};

/**
 * FIDIVR16()
 *
 * @this {FPUx86}
 */
FPUx86.FIDIVR16 = function()
{
    this.setST(0, this.doDivide(this.getWIFromEA(), this.getST(0)));
};

/**
 * FIDIVR32()
 *
 * @this {FPUx86}
 */
FPUx86.FIDIVR32 = function()
{
    this.setST(0, this.doDivide(this.getSIFromEA(), this.getST(0)));
};

/**
 * FILD16()
 *
 * @this {FPUx86}
 */
FPUx86.FILD16 = function()
{
    this.pushValue(this.getWIFromEA());
};

/**
 * FILD32()
 *
 * @this {FPUx86}
 */
FPUx86.FILD32 = function()
{
    this.pushValue(this.getSIFromEA());
};

/**
 * FILD64()
 *
 * @this {FPUx86}
 */
FPUx86.FILD64 = function()
{
    this.pushValue(this.getLIFromEA());
};

/**
 * FIMUL16()
 *
 * @this {FPUx86}
 */
FPUx86.FIMUL16 = function()
{
    this.setST(0, this.doMultiply(this.getST(0), this.getWIFromEA()));
};

/**
 * FIMUL32()
 *
 * @this {FPUx86}
 */
FPUx86.FIMUL32 = function()
{
    this.setST(0, this.doMultiply(this.getST(0), this.getSIFromEA()));
};

/**
 * FINCSTP()
 *
 * @this {FPUx86}
 */
FPUx86.FINCSTP = function()
{
    this.iST = (this.iST + 1) & 0x7;
    this.regStatus &= ~X86.FPU.STATUS.C1;
};

/**
 * FINIT()
 *
 * @this {FPUx86}
 */
FPUx86.FINIT = function()
{
    this.resetFPU();
};

/**
 * FIST16()
 *
 * @this {FPUx86}
 */
FPUx86.FIST16 = function()
{
    if (this.getWI(0)) this.setEAFromWI();
};

/**
 * FIST32()
 *
 * @this {FPUx86}
 */
FPUx86.FIST32 = function()
{
    if (this.getSI(0)) this.setEAFromSI();
};

/**
 * FISTP16()
 *
 * @this {FPUx86}
 */
FPUx86.FISTP16 = function()
{
    if (this.getWI(0)) {
        this.setEAFromWI();
        this.popValue();
    }
};

/**
 * FISTP32()
 *
 * @this {FPUx86}
 */
FPUx86.FISTP32 = function()
{
    if (this.getSI(0)) {
        this.setEAFromSI();
        this.popValue();
    }
};

/**
 * FISTP64()
 *
 * @this {FPUx86}
 */
FPUx86.FISTP64 = function()
{
    if (this.getLI(0)) {
        this.setEAFromLI();
        this.popValue();
    }
};

/**
 * FISUB16()
 *
 * @this {FPUx86}
 */
FPUx86.FISUB16 = function()
{
    this.setST(0, this.doSubtract(this.getST(0), this.getWIFromEA()));
};

/**
 * FISUB32()
 *
 * @this {FPUx86}
 */
FPUx86.FISUB32 = function()
{
    this.setST(0, this.doSubtract(this.getST(0), this.getSIFromEA()));
};

/**
 * FISUBR16()
 *
 * @this {FPUx86}
 */
FPUx86.FISUBR16 = function()
{
    this.setST(0, this.doSubtract(this.getWIFromEA(), this.getST(0)));
};

/**
 * FISUBR32()
 *
 * @this {FPUx86}
 */
FPUx86.FISUBR32 = function()
{
    this.setST(0, this.doSubtract(this.getSIFromEA(), this.getST(0)));
};

/**
 * FLDlr()
 *
 * The FLD instruction loads the source operand, converts it to temporary real format (if required),
 * and pushes the resulting value onto the floating-point stack.
 *
 * The load operation is accomplished by decrementing the top-of-stack pointer (TOP) and copying the
 * source operand to the new stack top. If the source operand is a float ing-point register, the index of
 * the register is taken before TOP is changed. The source operand may also be a short real, long real,
 * or temporary real memory operand. Short real and long real operands are converted automatically.
 *
 * Note that coding the instruction FLD ST(0) duplicates the value at the stack top.
 *
 * On the 8087 and 80287, the FLD real80 instruction will raise the denormal exception if the memory
 * operand is a denormal. The 80287XL and later coprocessors will not, since the operation is not arithmetic.
 *
 * On the 8087 and 80287, a denormal will be converted to an unnormal by FLD; on the 80287XL and later
 * coprocessors, the number will be converted to temporary real. If the next instruction is an FXTRACT or FXAM,
 * the 8087/80827 and 80287XL/80387/ 80486 results will be different.
 *
 * On the 8087 and 80287, the FLD real32 and FLD real64 instructions will not raise an exception when loading
 * a signaling NaN; on the 80287XL and later coprocessors, loading a signaling NaN raises the invalid operation
 * exception.
 *
 * @this {FPUx86}
 */
FPUx86.FLDlr = function()
{
    this.pushValue(this.getLRFromEA());
};

/**
 * FLDsr()
 *
 * @this {FPUx86}
 */
FPUx86.FLDsr = function()
{
    this.pushValue(this.getSRFromEA());
};

/**
 * FLDsti()
 *
 * @this {FPUx86}
 */
FPUx86.FLDsti = function()
{
    this.pushValue(this.getST(this.iStack));
};

/**
 * FLDtr()
 *
 * @this {FPUx86}
 */
FPUx86.FLDtr = function()
{
    this.pushValue(this.getLRFromTR(this.getTRFromEA()));
};

/**
 * FLDCW()
 *
 * @this {FPUx86}
 */
FPUx86.FLDCW = function()
{

    this.setControl(this.cpu.getShort(this.cpu.regEA));
};

/**
 * FLDENV()
 *
 * @this {FPUx86}
 */
FPUx86.FLDENV = function()
{

    this.loadEnv(this.cpu.regEA);
};

/**
 * FLD1()
 *
 * The FLD1 instruction loads the constant +1.0 from the NPX's constant ROM and pushes the value onto the
 * floating-point stack.
 *
 * The constant is stored internally in temporary real format and is simply moved to the stack.
 *
 * See also: FLDLG2, FLDLN2, FLDL2E, FLDL2T, FLDPI, and FLD1.
 *
 * @this {FPUx86}
 */
FPUx86.FLD1 = function()
{
    this.pushValue(1.0);
};

/**
 * FLDL2T()
 *
 * The FLDL2T instruction loads the constant log2(10) from the NPX's constant ROM and pushes the value onto the
 * floating-point stack.
 *
 * The constant is stored internally in temporary real format and is simply moved to the stack.
 *
 * On the 8087 and 80287, rounding control is not in effect for the loading of this constant.  On the 80287XL and
 * later coprocessors, rounding control is in effect.  If RC is set for chop (round toward 0), round down (toward
 * -infinity), or round to nearest or even, the result will be the same as on the 8087 and 80287.  If RC is set for
 * round up (toward +infinity), the result will differ by one in the least significant bit of the mantissa.
 *
 * See also: FLDLG2, FLDLN2, FLDL2E, FLDPI, FLD1, and FLDZ.
 *
 * @this {FPUx86}
 */
FPUx86.FLDL2T = function()
{
    this.pushValue(FPUx86.regL2T);
};

/**
 * FLDL2E()
 *
 * The FLDL2E instruction loads the constant log2(e) from the NPX's constant ROM and pushes the value onto the
 * floating-point stack.
 *
 * The constant is stored internally in temporary real format and is simply moved to the stack.
 *
 * On the 8087 and 80287, rounding control is not in effect for the loading of this constant.  On the 80287XL and
 * later coprocessors, rounding control is in effect.  If RC is set for chop (round toward 0) or round down (toward
 * -infinity), the result is the same as on the 8087 and 80827.  If RC is set for round to nearest or even, or round
 * up (toward +infinity), the result will differ by one in the least significant bit of the mantissa.
 *
 * See also: FLDLG2, FLDLN2, FLDL2T, FLDPI, FLD1, and FLDZ.
 *
 * @this {FPUx86}
 */
FPUx86.FLDL2E = function()
{
    this.pushValue(FPUx86.regL2E);
};

/**
 * FLDPI()
 *
 * The FLDPI instruction loads the constant Pi from the NPX's constant ROM and pushes the value onto the
 * floating-point stack.
 *
 * The constant is stored internally in temporary real format and is simply moved to the stack.
 *
 * On the 8087 and 80287, rounding control is not in effect for the loading of these constants.  On the 80287XL and
 * later coprocessors, rounding control is in effect.  If RC is set for chop (round toward 0) or round down (toward
 * -infinity), the result is the same as on the 8087 and 80827.  If RC is set for round to nearest or even, or round
 * up (toward +infinity), the result will differ by one in the least significant bit of the mantissa.
 *
 * See also: FLDLG2, FLDLN2, FLDL2E, FLDL2T, FLD1, and FLDZ.
 *
 * @this {FPUx86}
 */
FPUx86.FLDPI = function()
{
    this.pushValue(FPUx86.regPI);
};

/**
 * FLDLG2()
 *
 * The FLDLG2 instruction loads the constant log10(2) from the NPX's constant ROM and pushes the value onto the
 * floating-point stack.
 *
 * The constant is stored internally in temporary real format and is simply moved to the stack.
 *
 * On the 8087 and 80287, rounding control is not in effect for the loading of this constant.  On the 80287XL and
 * later coprocessors, rounding control is in effect.  If RC is set for chop (round toward 0) or round down (toward
 * -infinity), the result is the same as on the 8087 and 80827.  If RC is set for round to nearest or even, or round
 * up (toward +infinity), the result will differ by one in the least significant bit of the mantissa.
 *
 * See also: FLDLN2, FLDL2E, FLDL2T, FLDPI, FLD1, and FLDZ.
 *
 * @this {FPUx86}
 */
FPUx86.FLDLG2 = function()
{
    this.pushValue(FPUx86.regLG2);
};

/**
 * FLDLN2()
 *
 * The FLDLN2 instruction loads the constant loge(2) from the NPX's constant ROM and pushes the value onto the
 * floating-point stack.
 *
 * The constant is stored internally in temporary real format and is simply moved to the stack.
 *
 * On the 8087 and 80287, rounding control is not in effect for the loading of this constant.  On the 80287XL and
 * later coprocessors, rounding control is in effect.  If RC is set for chop (round toward 0) or round down (toward
 * -infinity), the result will be the same as on the 8087 and 80827.  If RC is set for round to nearest or even, or
 * round up (toward +infinity), the result will differ by one in the least significant bit of the mantissa.
 *
 * See also: FLDLG2, FLDL2E, FLDL2T, FLDPI, FLD1, and FLDZ.
 *
 * @this {FPUx86}
 */
FPUx86.FLDLN2 = function()
{
    this.pushValue(FPUx86.regLN2);
};

/**
 * FLDZ()
 *
 * The FLDZ instruction loads the constant +0.0 from the NPX's constant ROM and pushes the value onto the
 * floating-point stack.
 *
 * The constant is stored internally in temporary real format and is simply moved to the stack.
 *
 * See also: FLDLG2, FLDLN2, FLDL2E, FLDL2T, FLDPI, and FLD1.
 *
 * @this {FPUx86}
 */
FPUx86.FLDZ = function()
{
    this.pushValue(0.0);
};

/**
 * FMULlr()
 *
 * @this {FPUx86}
 */
FPUx86.FMULlr = function()
{
    this.setST(0, this.doMultiply(this.getST(0), this.getLRFromEA()));
};

/**
 * FMULsr()
 *
 * Encoding 0xD8,reg=0x01 ("FMUL short-real"): ST(0) <- ST(0) * REAL32
 *
 * @this {FPUx86}
 */
FPUx86.FMULsr = function()
{
    this.setST(0, this.doMultiply(this.getST(0), this.getSRFromEA()));
};

/**
 * FMULst()
 *
 * @this {FPUx86}
 */
FPUx86.FMULst = function()
{
    this.setST(0, this.doMultiply(this.getST(0), this.getST(this.iStack)));
};

/**
 * FMULsti()
 *
 * @this {FPUx86}
 */
FPUx86.FMULsti = function()
{
    this.setST(this.iStack, this.doMultiply(this.getST(this.iStack), this.getST(0)));
};

/**
 * FMULPsti()
 *
 * @this {FPUx86}
 */
FPUx86.FMULPsti = function()
{
    if (this.setST(this.iStack, this.doMultiply(this.getST(this.iStack), this.getST(0)))) this.popValue();
};

/**
 * FNOP()
 *
 * @this {FPUx86}
 */
FPUx86.FNOP = function()
{
};

/**
 * FPATAN()
 *
 * FPATAN calculates the partial arctangent of ST(0) divided by ST(1):
 *
 *      ST(1) = tan^-1( ST(1) / ST(0) )
 *
 * On the 8087 and 80287, the arguments must satisfy the inequality 0 <= ST(1) < ST(0) < +infinity.
 * On the 80287XL and later coprocessors, the range of the operands is unrestricted.  The result is
 * returned to ST(1), and the stack is popped, destroying both operands and leaving the result in ST(0).
 *
 * @this {FPUx86}
 */
FPUx86.FPATAN = function()
{
    if (this.setST(1, Math.atan2(this.getST(1), this.getST(0)))) this.popValue();
};

/**
 * FPTAN()
 *
 * FPTAN calculates the partial tangent of ST(0):
 *
 *      y / x = tan( ST(0) )
 *
 * The result of the operation is a ratio.  y replaces the argument on the stack, and x is pushed onto the stack,
 * where it becomes the new ST(0).
 *
 * On the 8087 and 80287, the FPTAN function assumes that its argument is valid and in-range.  No argument checking
 * is performed.  The value of ST(0) must satisfy the inequality -pi/4 <= ST(0) <= pi/4.  In the case of an invalid
 * argument, the result is undefined and no error is signaled.
 *
 * On the 80287XL and later coprocessors, if value of ST(0) satisfies the condition -2^63 < ST(0) < 2^63, it will
 * automatically be reduced to within range.  If the operand is outside this range, however, C2 is set to 1 to indicate
 * that the function is incomplete, and ST(0) is left unchanged.
 *
 * The 80287XL, 80387, and 80486 always push a value of +1.0 for x. The value of x pushed by the 8087 and 80287 may be
 * any real number.  In either case, the ratio is the same. The cotangent can be calculated by executing FDIVR immediately
 * after FPTAN.  The following code will leave the 8087 and 80287 in the same state as the later coprocessors:
 *
 *      FDIV
 *      FLD1
 *
 * ST(7) must be empty before this instruction is executed to avoid an invalid operation exception.  If the invalid
 * operation exception is masked, the 8087 and 80287 leave the original operand unchanged, but push it to ST(1).  On the
 * 80287XL and later coprocessors, both ST(0) and ST(1) will contain quiet NaNs.  On the 80287XL and later coprocessors,
 * if condition code bit C2 is 0 and the precision exception is raised, then C1=1 if the last bit was rounded up. C1 is
 * undefined for the 8087 and 80287.
 *
 * @this {FPUx86}
 */
FPUx86.FPTAN = function()
{
    if (this.setST(0, Math.tan(this.getST(0)))) this.pushValue(1.0);
};

/**
 * FPREM()
 *
 * FPREM performs modulo division of ST(0) by ST(1) and returns the result to ST(0).
 *
 * The FPREM instruction is used to reduce the real operand in ST(0) to a value whose magnitude is less than the
 * magnitude of ST(1).  FPREM produces an exact result, so the precision exception is never raised and the rounding
 * control has no effect.  The sign of the remainder is the same as the sign of the original operand.
 *
 * The remaindering operation is performed by iterative scaled subtractions and can reduce the exponent of ST(0) by
 * no more than 63 in one execution.  If the remainder is less than ST(1) (the modulus), the function is complete and
 * C2 in the status word is cleared.
 *
 * If the modulo function is incomplete, C2 is set to 1, and the result in ST(0) is termed the partial remainder.
 * C2 can be inspected by storing the status word and re-executing the instruction until C2 is clear. Alternately,
 * ST(0) can be compared to ST(1).  If ST(0) > ST(1), then FPREM must be executed again.  If ST(0) = ST(1), then the
 * remainder is 0.
 *
 * FPREM is important for reducing arguments to the periodic transcendental functions such as FPTAN.  Because FPREM
 * produces an exact result, no round-off error is introduced into the calculation.
 *
 * When reduction is complete, the three least-significant bits of the quotient are stored in the condition code bits
 * C3, C1, and C0, respectively.  When arguments to the tangent function are reduced by pi/4, this result can be used
 * to identify the octant that contained the original angle.
 *
 * The FPREM function operates differently than specified by the IEEE 754 standard when rounding the quotient to form
 * a partial remainder (see the algorithm).  The FPREM1 function (80287XL and up) is provided for compatibility with
 * that standard.
 *
 * The FPREM instruction can also be used to normalize ST(0).  If ST(0) is unnormal and ST(1) is greater than ST(0),
 * FPREM will normalize ST(0).  On the 8087 and 80287, operation on a denormal operand raises the invalid operation
 * exception.  Underflow is not possible.  On the 80287XL and later coprocessors, operation on a denormal is supported
 * and an underflow exception can occur.
 *
 * ALGORITHM:
 *
 *      t = EXPONENT(ST) - EXPONENT(ST(1))
 *      IF (t < 64) THEN
 *          q = R0UND(ST(0) / ST(1), CHOP)
 *          ST(0) = ST(0) - (ST(1) * q)
 *          C2 = 0
 *          C0 = BIT 2 of q
 *          C1 = BIT 1 of q
 *          C3 = BIT 0 of q
 *      ELSE
 *          n = a number between 32 and 63
 *          q = ROUND((ST(0) / ST(1)) / 2^(t-n), CHOP)
 *          ST(0) = ST(0) - (ST(1) * q * 2^(t-n))
 *          C2 = 1
 *      ENDIF
 *
 * TODO: Determine the extent to which the JavaScript MOD operator differs from the above algorithm.
 *
 * ERRATA: On the 8087 and 80287, the condition code bits C3, C1, and C0 are incorrect when performing a reduction of
 * 64^n + m, where n >= 1, and m=1 or m=2.  A bug fix should be implemented in software.
 *
 * @this {FPUx86}
 */
FPUx86.FPREM = function()
{
    this.setST(0, this.getST(0) % this.getST(1));
};

/**
 * FRSTOR()
 *
 * @this {FPUx86}
 */
FPUx86.FRSTOR = function()
{
    let cpu = this.cpu;
    let addr = this.loadEnv(cpu.regEA);
    let a = this.intTmpTR;
    for (let i = 0; i < this.regStack.length; i++) {
        a[0] = cpu.getLong(addr);
        a[1] = cpu.getLong(addr += 4);
        a[2] = cpu.getShort(addr += 4);
        this.setTR(i, a);
        addr += 2;
    }
};

/**
 * FRNDINT()
 *
 * @this {FPUx86}
 */
FPUx86.FRNDINT = function()
{
    this.setST(0, this.roundValue(this.getST(0), FPUx86.MAX_INT64));
};

/**
 * FSAVE()
 *
 * @this {FPUx86}
 */
FPUx86.FSAVE = function()
{
    let cpu = this.cpu;
    let addr = this.saveEnv(cpu.regEA);
    for (let i = 0; i < this.regStack.length; i++) {
        let a = this.getTR(i, true);
        cpu.setLong(addr, a[0]);
        cpu.setLong(addr += 4, a[1]);
        cpu.setShort(addr += 4, a[2]);
        addr += 2;
    }
    this.resetFPU();
};

/**
 * FSCALE()
 *
 * FSCALE interprets the value in ST(1) as an integer and adds this number to the exponent of the number in ST(0).
 *
 * The FSCALE instruction provides a means of quickly performing multiplication or division by powers of two.
 * This operation is often required when scaling array indexes.
 *
 * On the 8087 and 80287, FSCALE assumes that the scale factor in ST(1) is an integer that satisfies the inequality
 * -2^15 <= ST(1) < +2^15.  If ST(1) is not an integer value, the value is chopped to the next smallest integer in
 * magnitude (chopped toward zero).  If the value is out of range or 0 < ST(1) < 1, FSCALE produces an undefined
 * result and doesn't signal an exception.  Typically, the value in ST(0) is unchanged but should not be depended on.
 *
 * On the 80287XL and later coprocessors, there is no limit on the range of the scale factor in ST(1). The value in
 * ST(1) is still chopped toward zero.  If ST(1) is 0, ST(0) is unchanged.
 *
 * @this {FPUx86}
 */
FPUx86.FSCALE = function()
{
    let x = this.getST(0);
    let y = this.getST(1);
    if (x != null && y != null) this.setST(0, x * Math.pow(2, this.truncateValue(y)));
};

/**
 * FSETPM287()
 *
 * @this {FPUx86}
 */
FPUx86.FSETPM287 = function()
{
    if (this.isModel(X86.FPU.MODEL_80287)) {
        this.opUnimplemented();
    }
};

/**
 * FSINCOS387()
 *
 * @this {FPUx86}
 */
FPUx86.FSINCOS387 = function()
{
    if (this.isAtLeastModel(X86.FPU.MODEL_80287XL)) {
        this.opUnimplemented();
    }
};

/**
 * FSQRT()
 *
 * @this {FPUx86}
 */
FPUx86.FSQRT = function()
{
    this.setST(0, this.doSquareRoot(this.getST(0)));
};

/**
 * FSTlr()
 *
 * @this {FPUx86}
 */
FPUx86.FSTlr = function()
{
    if (this.getLR(0)) this.setEAFromLR();
};

/**
 * FSTsr()
 *
 * @this {FPUx86}
 */
FPUx86.FSTsr = function()
{
    if (this.getSR(0)) this.setEAFromSR();
};

/**
 * FSTsti()
 *
 * @this {FPUx86}
 */
FPUx86.FSTsti = function()
{
    this.setST(this.iStack, this.getST(0));
};

/**
 * FSTENV()
 *
 * @this {FPUx86}
 */
FPUx86.FSTENV = function()
{

    this.saveEnv(this.cpu.regEA);
    this.regControl |= X86.FPU.CONTROL.EXC;     // mask all exceptions (but do not set IEM)
};

/**
 * FSTPlr()
 *
 * @this {FPUx86}
 */
FPUx86.FSTPlr = function()
{
    if (this.getLR(0)) {
        this.setEAFromLR();
        this.popValue();
    }
};

/**
 * FSTPsr()
 *
 * @this {FPUx86}
 */
FPUx86.FSTPsr = function()
{
    if (this.getSR(0)) {
        this.setEAFromSR();
        this.popValue();
    }
};

/**
 * FSTPsti()
 *
 * @this {FPUx86}
 */
FPUx86.FSTPsti = function()
{
    if (this.setST(this.iStack, this.getST(0))) this.popValue();
};

/**
 * FSTP8087()
 *
 * NOTE: This is used with encodings (0xD9,0xD8-0xDF and 0xDF,0xD0-0xDF) that were valid for the 8087 and 80287
 * but may no longer be valid as of the 80387.
 *
 * @this {FPUx86}
 */
FPUx86.FSTP8087 = function()
{
    this.opObsolete();
    FPUx86.FSTPsti.call(this);
};

/**
 * FSTPtr()
 *
 * @this {FPUx86}
 */
FPUx86.FSTPtr = function()
{
    if (this.getTR(0)) {
        this.setEAFromTR();
        this.popValue();
    }
};

/**
 * FSTCW()
 *
 * @this {FPUx86}
 */
FPUx86.FSTCW = function()
{

    this.cpu.setShort(this.cpu.regEA, this.regControl);
};

/**
 * FSTSW()
 *
 * @this {FPUx86}
 */
FPUx86.FSTSW = function()
{

    this.cpu.setShort(this.cpu.regEA, this.getStatus());
};

/**
 * FSTSWAX287()
 *
 * @this {FPUx86}
 */
FPUx86.FSTSWAX287 = function()
{
    if (this.isAtLeastModel(X86.FPU.MODEL_80287)) {
        this.cpu.regEAX = (this.cpu.regEAX & ~0xffff) | this.getStatus();
    }
};

/**
 * FSUBlr()
 *
 * @this {FPUx86}
 */
FPUx86.FSUBlr = function()
{
    this.setST(0, this.doSubtract(this.getST(0), this.getLRFromEA()));
};

/**
 * FSUBsr()
 *
 * @this {FPUx86}
 */
FPUx86.FSUBsr = function()
{
    this.setST(0, this.doSubtract(this.getST(0), this.getSRFromEA()));
};

/**
 * FSUBst()
 *
 * Encoding 0xD8,0xE0-0xE7 ("FSUB ST,ST(i)"): ST(0) <- ST(0) - ST(i)
 *
 * @this {FPUx86}
 */
FPUx86.FSUBst = function()
{
    this.setST(0, this.doSubtract(this.getST(0), this.getST(this.iStack)));
};

/**
 * FSUBsti()
 *
 * Encoding 0xDC,0xE8-0xEF ("FSUB ST(i),ST"): ST(i) <- ST(i) - ST(0)
 *
 * @this {FPUx86}
 */
FPUx86.FSUBsti = function()
{
    this.setST(this.iStack, this.doSubtract(this.getST(this.iStack), this.getST(0)));
};

/**
 * FSUBPsti()
 *
 * Encoding 0xDE,0xE8-0xEF ("FSUBP ST(i),ST"): ST(i) <- ST(i) - ST(0), POP
 *
 * @this {FPUx86}
 */
FPUx86.FSUBPsti = function()
{
    if (this.setST(this.iStack, this.doSubtract(this.getST(this.iStack), this.getST(0)))) this.popValue();
};

/**
 * FSUBRlr()
 *
 * @this {FPUx86}
 */
FPUx86.FSUBRlr = function()
{
    this.setST(0, this.doSubtract(this.getLRFromEA(), this.getST(0)));
};

/**
 * FSUBRsr()
 *
 * @this {FPUx86}
 */
FPUx86.FSUBRsr = function()
{
    this.setST(0, this.doSubtract(this.getSRFromEA(), this.getST(0)));
};

/**
 * FSUBRst()
 *
 * Encoding 0xD8,0xE8-0xEF ("FSUBR ST,ST(i)"): ST(0) <- ST(i) - ST(0)
 *
 * @this {FPUx86}
 */
FPUx86.FSUBRst = function()
{
    this.setST(0, this.doSubtract(this.getST(this.iStack), this.getST(0)));
};

/**
 * FSUBRsti()
 *
 * Encoding 0xDC,0xE0-0xE7 ("FSUBR ST(i),ST"): ST(i) <- ST(0) - ST(i)
 *
 * @this {FPUx86}
 */
FPUx86.FSUBRsti = function()
{
    this.setST(this.iStack, this.doSubtract(this.getST(0), this.getST(this.iStack)));
};

/**
 * FSUBRPsti()
 *
 * Encoding 0xDE,0xE0-0xE7 ("FSUBRP ST(i),ST"): ST(i) <- ST(0) - ST(i), POP
 *
 * @this {FPUx86}
 */
FPUx86.FSUBRPsti = function()
{
    if (this.setST(this.iStack, this.doSubtract(this.getST(0), this.getST(this.iStack)))) this.popValue();
};

/**
 * FTST()
 *
 * @this {FPUx86}
 */
FPUx86.FTST = function()
{
    this.doCompare(this.getST(0), 0);
};

/**
 * FXAM()
 *
 * @this {FPUx86}
 */
FPUx86.FXAM = function()
{
    this.regStatus &= ~X86.FPU.STATUS.CC;

    if (this.getSTSign(0)) {
        this.regStatus |= X86.FPU.STATUS.C1;
    }
    if (this.getTag(this.iST) == X86.FPU.TAGS.EMPTY) {
        this.regStatus |= X86.FPU.STATUS.C0 | X86.FPU.STATUS.C3;
    }
    else {
        let v = this.getST(0);
        if (isNaN(v)) {
            this.regStatus |= X86.FPU.STATUS.C0;
        }
        else if (v === 0) {                                 // this equals -0, too (WTF, strict equality?)
            this.regStatus |= X86.FPU.STATUS.C3;
        }
        else if (v === Infinity || v === -Infinity) {       // these are so divergent that even non-strict equality doesn't consider them equal
            this.regStatus |= X86.FPU.STATUS.C0 | X86.FPU.STATUS.C2;
        }
        else {
            this.regStatus |= X86.FPU.STATUS.C2;
        }
    }
};

/**
 * FXCHsti()
 *
 * @this {FPUx86}
 */
FPUx86.FXCHsti = function()
{
    let tmp = this.getST(0);
    this.setST(0, this.getST(this.iStack));
    this.setST(this.iStack, tmp);
};

/**
 * FXCH8087()
 *
 * NOTE: This is used with encodings (0xDD,0xC8-0xCF and 0xDF,0xC8-0xCF) that were valid for the 8087 and 80287
 * but may no longer be valid as of the 80387.
 *
 * @this {FPUx86}
 */
FPUx86.FXCH8087 = function()
{
    this.opObsolete();
    FPUx86.FXCHsti.call(this);
};

/**
 * FXTRACT()
 *
 * FXTRACT splits the value encoded in ST(0) into two separate numbers representing the actual value of the
 * fraction (mantissa) and exponent fields.
 *
 * The FXTRACT instruction is used to decompose the two fields of the temporary real number in ST(0).  The exponent
 * replaces the value in ST(0), then the fraction is pushed onto the stack.  When execution is complete, ST(0)
 * contains the original fraction, expressed as a real number with a true exponent of 0 (0x3FFF in biased form),
 * and ST(1) contains the value of the original operand's true (unbiased) exponent expressed as a real number.
 *
 * If ST(0) is 0, the 8087 and 80287 will leave zeros in both ST(0) and ST(1); both zeros will have the same sign as
 * the original operand.  If ST(0) is +infinity, the invalid operation exception is raised.
 *
 * On the 80287XL and later coprocessors, if ST(0) is 0, the zero-divide exception is reported and ST(1) is set to
 * -infinity.  If ST(0) is +infinity, no exception is reported.
 *
 * The FXTRACT instruction may be thought of as the complement to the FSCALE instruction, which combines a separate
 * fraction and exponent into a single value.
 *
 * ALGORITHM:
 *
 *      IF (ST(0) = 0) THEN
 *          DEC TOP
 *          ST(0) = ST(1)
 *      ELSE
 *          temp = ST(0)
 *          ST(0) = EXPONENT(ST(0))     ; stored as true exponent
 *          DEC TOP
 *          ST(0) = FRACTION(ST(0))
 *      ENDIF
 *
 * @this {FPUx86}
 */
FPUx86.FXTRACT = function()
{
    let v = this.getST(0);
    if (v != null) {
        this.regTmpLR[0] = v;
        this.setST(0, ((this.intTmpLR[1] >> 20) & 0x7ff) - 0x3ff);
        this.intTmpLR[1] = (this.intTmpLR[1] | 0x3ff00000) & ~0x40000000;
        this.pushValue(this.regTmpLR[0]);
    }
};

/**
 * FYL2X()
 *
 * FYL2X (y log base 2 of x) calculates:
 *
 *      ST(1) = ST(1) * log2(ST(0))
 *
 * The operands must satisfy the inequalities 0 < ST(0) < +infinity and -infinity < ST(1) < +infinity.  FYL2X pops
 * the stack and returns the result to the new ST(0).  Both original operands are destroyed.
 *
 * The FYL2X function is designed to optimize the calculation of a log to a base, n, other than two.  In such a case,
 * the following multiplication is required; ie:
 *
 *      logn(x) = logn(2) * log2(x)
 *
 * @this {FPUx86}
 */
FPUx86.FYL2X = function()
{
    if (this.setST(1, this.getST(1) * Math.log(this.getST(0)) / Math.LN2)) this.popValue();
};

/**
 * FYL2XP1()
 *
 * FYL2XP1 (y log base 2 of x plus 1) calculates:
 *
 *      ST(1) = ST(1) * log2(ST(0) + 1)
 *
 * The operands must satisfy the inequalities -(1-sqrt(2)/2) < ST(0) < (1-sqrt(2)/2) and -infinity < ST(1) < +infinity.
 * FYL2XP1 pops the stack and returns the result to the new ST(0).  Both original operands are destroyed.
 *
 * The FYL2XP1 function provides greater accuracy than FYL2X in computing the log of a number that is very close to 1.
 *
 * FYL2XP1 is typically used when computing compound interest, for example, which requires the calculation of a logarithm
 * of 1.0 + n where 0 < n < 0.29.  If 1.0 was added to n, significant digits might be lost.  By using FYL2XP1, the result
 * will be as accurate as n to within three units of temporary real precision.
 *
 * @this {FPUx86}
 */
FPUx86.FYL2XP1 = function()
{
    if (this.setST(1, this.getST(1) * Math.log(this.getST(0) + 1.0) / Math.LN2)) this.popValue();
};

/**
 * FPU operation lookup table (be sure to keep the following table in sync with Debugger.aaaOpFPUDescs).
 *
 * The second lookup value corresponds to bits in the ModRegRM byte that follows the ESC byte (0xD8-0xDF).
 *
 * Here's a little cheat-sheet for how the 2nd lookup values relate to ModRegRM values; see opFPU() for details.
 *
 *      Lookup  ModRegRM value(s)
 *      ------  -------------------------------
 *      0x00:   0x00-0x07, 0x40-0x47, 0x80-0x87
 *      0x01:   0x08-0x0F, 0x48-0x4F, 0x88-0x8F
 *      0x02:   0x10-0x17, 0x50-0x57, 0x90-0x97
 *      0x03:   0x18-0x1F, 0x58-0x5F, 0x98-0x9F
 *      0x04:   0x20-0x27, 0x60-0x67, 0xA0-0xA7
 *      0x05:   0x28-0x2F, 0x68-0x6F, 0xA8-0xAF
 *      0x06:   0x30-0x37, 0x70-0x77, 0xB0-0xB7
 *      0x07:   0x38-0x3F, 0x78-0x7F, 0xB8-0xBF
 *      0x30:   0xC0-0xC7
 *      0x31:   0xC8-0xCF
 *      0x32:   0xD0-0xD7
 *      0x33:   0xD8-0xDF
 *      0x34:   0xE0-0xE7
 *      0x35:   0xE8-0xEF
 *      0x36:   0xF0-0xF7
 *      0x37:   0xF8-0xFF
 *
 * ESC bytes 0xD9 and 0xDB use the RM field to further describe the operation when the ModRegRM value >= 0xE0.
 * In those cases, we shift the Reg value into the high nibble and the RM value into the low nibble, resulting in
 * the following lookup values (which look a lot like hex-encoded octal):
 *
 *      0x40:   0xE0
 *      0x41:   0xE1
 *      ...     ...
 *      0x46:   0xE6
 *      0x47:   0xE7
 *
 *      0x50:   0xE8
 *      0x51:   0xE9
 *      ...     ...
 *      0x56:   0xEE
 *      0x57:   0xEF
 *
 *      0x60:   0xF0
 *      0x61:   0xF1
 *      ...     ...
 *      0x66:   0xF6
 *      0x67:   0xF7
 *
 *      0x70:   0xF8
 *      0x71:   0xF9
 *      ...     ...
 *      0x76:   0xFE
 *      0x77:   0xFF
 */
FPUx86.aaOps = {
    0xD8: {
        0x00: FPUx86.FADDsr,    0x01: FPUx86.FMULsr,    0x02: FPUx86.FCOMsr,    0x03: FPUx86.FCOMPsr,
        0x04: FPUx86.FSUBsr,    0x05: FPUx86.FSUBRsr,   0x06: FPUx86.FDIVsr,    0x07: FPUx86.FDIVsr,
        0x30: FPUx86.FADDst,    0x31: FPUx86.FMULst,    0x32: FPUx86.FCOMst,    0x33: FPUx86.FCOMPst,
        0x34: FPUx86.FSUBst,    0x35: FPUx86.FSUBRst,   0x36: FPUx86.FDIVst,    0x37: FPUx86.FDIVRst
    },
    0xD9: {
        0x00: FPUx86.FLDsr,                             0x02: FPUx86.FSTsr,     0x03: FPUx86.FSTPsr,
        0x04: FPUx86.FLDENV,    0x05: FPUx86.FLDCW,     0x06: FPUx86.FSTENV,    0x07: FPUx86.FSTCW,
        0x30: FPUx86.FLDsti,    0x31: FPUx86.FXCHsti,   0x32: FPUx86.FNOP,      0x33: FPUx86.FSTP8087,
        0x40: FPUx86.FCHS,      0x41: FPUx86.FABS,
        0x44: FPUx86.FTST,      0x45: FPUx86.FXAM,
        0x50: FPUx86.FLD1,      0x51: FPUx86.FLDL2T,    0x52: FPUx86.FLDL2E,    0x53: FPUx86.FLDPI,
        0x54: FPUx86.FLDLG2,    0x55: FPUx86.FLDLN2,    0x56: FPUx86.FLDZ,
        0x60: FPUx86.F2XM1,     0x61: FPUx86.FYL2X,     0x62: FPUx86.FPTAN,     0x63: FPUx86.FPATAN,
        0x64: FPUx86.FXTRACT,                           0x66: FPUx86.FDECSTP,   0x67: FPUx86.FINCSTP,
        0x70: FPUx86.FPREM,     0x71: FPUx86.FYL2XP1,   0x72: FPUx86.FSQRT,
        0x74: FPUx86.FRNDINT,   0x75: FPUx86.FSCALE
    },
    0xDA: {
        0x00: FPUx86.FIADD32,   0x01: FPUx86.FIMUL32,   0x02: FPUx86.FICOM32,   0x03: FPUx86.FICOMP32,
        0x04: FPUx86.FISUB32,   0x05: FPUx86.FISUBR32,  0x06: FPUx86.FIDIV32,   0x07: FPUx86.FIDIVR32
    },
    0xDB: {
        0x00: FPUx86.FILD32,    0x02: FPUx86.FIST32,    0x03: FPUx86.FISTP32,
                                0x05: FPUx86.FLDtr,                             0x07: FPUx86.FSTPtr,
        0x40: FPUx86.FENI8087,  0x41: FPUx86.FDISI8087, 0x42: FPUx86.FCLEX,     0x43: FPUx86.FINIT,
        0x44: FPUx86.FSETPM287,
        0x73: FPUx86.FSINCOS387
    },
    0xDC: {
        0x00: FPUx86.FADDlr,    0x01: FPUx86.FMULlr,    0x02: FPUx86.FCOMlr,    0x03: FPUx86.FCOMPlr,
        0x04: FPUx86.FSUBlr,    0x05: FPUx86.FSUBRlr,   0x06: FPUx86.FDIVlr,    0x07: FPUx86.FDIVRlr,
        0x30: FPUx86.FADDsti,   0x31: FPUx86.FMULsti,   0x32: FPUx86.FCOM8087,  0x33: FPUx86.FCOMP8087,
        /**
         * Intel's original 8087 datasheet had these forms of SUB and SUBR (and DIV and DIVR) swapped.
         */
        0x34: FPUx86.FSUBRsti,  0x35: FPUx86.FSUBsti,   0x36: FPUx86.FDIVRsti,  0x37: FPUx86.FDIVsti
    },
    0xDD: {
        0x00: FPUx86.FLDlr,                             0x02: FPUx86.FSTlr,     0x03: FPUx86.FSTPlr,
        0x04: FPUx86.FRSTOR,                            0x06: FPUx86.FSAVE,     0x07: FPUx86.FSTSW,
        0x30: FPUx86.FFREEsti,  0x31: FPUx86.FXCH8087,  0x32: FPUx86.FSTsti,    0x33: FPUx86.FSTPsti
    },
    0xDE: {
        0x00: FPUx86.FIADD16,   0x01: FPUx86.FIMUL16,   0x02: FPUx86.FICOM16,   0x03: FPUx86.FICOMP16,
        0x04: FPUx86.FISUB16,   0x05: FPUx86.FISUBR16,  0x06: FPUx86.FIDIV16,   0x07: FPUx86.FIDIVR16,
        0x30: FPUx86.FADDPsti,  0x31: FPUx86.FMULPsti,  0x32: FPUx86.FCOMP8087, 0x33: FPUx86.FCOMPP,
        /**
         * Intel's original 8087 datasheet had these forms of SUBP and SUBRP (and DIVP and DIVRP) swapped.
         */
        0x34: FPUx86.FSUBRPsti, 0x35: FPUx86.FSUBPsti,  0x36: FPUx86.FDIVRPsti, 0x37: FPUx86.FDIVPsti
    },
    0xDF: {
        0x00: FPUx86.FILD16,                            0x02: FPUx86.FIST16,    0x03: FPUx86.FISTP16,
        0x04: FPUx86.FBLDpd,    0x05: FPUx86.FILD64,    0x06: FPUx86.FBSTPpd,   0x07: FPUx86.FISTP64,
        0x30: FPUx86.FFREEP8087,0x31: FPUx86.FXCH8087,  0x32: FPUx86.FSTP8087,  0x33: FPUx86.FSTP8087,
        0x34: FPUx86.FSTSWAX287
    }
};

/**
 * An array of FPUx86 functions documented as preserving the "exception" registers.
 */
FPUx86.afnPreserveExceptions = [
    FPUx86.FCLEX,   FPUx86.FINIT,   FPUx86.FLDCW,   FPUx86.FLDENV,  FPUx86.FRSTOR,
    FPUx86.FSAVE,   FPUx86.FSTCW,   FPUx86.FSTENV,  FPUx86.FSTSW,   FPUx86.FSTSWAX287
];

/**
 * Initialize every FPU module on the page
 */
WebLib.onInit(FPUx86.init);

/**
 * @copyright https://www.pcjs.org/machines/pcx86/modules/v2/segx86.js (C) 2012-2024 Jeff Parsons
 */

/**
 * NOTE: The protected-mode support in this module was initially added for 80286 support, and is
 * currently being upgraded for 80386 support.  In a perfect world, all 80386-related support would
 * be disabled/skipped whenever the processor is merely an 80286.  And in fact, that's the case
 * with some of the early changes (eg, skipping X86.DESC.EXT.BASE2431 and X86.DESC.EXT.LIMIT1619
 * fields unless the processor is an 80386).
 *
 * However, the reality is that I won't always be that strict, either because I'm lazy or I don't
 * want to risk a run-time performance hit or (more pragmatically) because any 80286 code you're likely
 * to run probably won't attempt to use descriptor types or other features unique to the 80386 anyway,
 * so the extra paranoia may not be worth the effort.  Ultimately, I would like to see the code tailor
 * itself to the current CPU model, generally with model-specific functions, but that's a lot of work.
 */

/**
 * @class Segx86
 * @unrestricted (allows the class to define properties, both dot and named, outside of the constructor)
 */
class Segx86 {

    static ID = {
        NULL:   0,          // "NULL"
        CODE:   1,          // "CS"
        DATA:   2,          // "DS", "ES", "FS", "GS"
        STACK:  3,          // "SS"
        TSS:    4,          // "TSS"
        LDT:    5,          // "LDT"
        VER:    6,          // "VER"
        DBG:    7           // "DBG"
    };

    static CALLBREAK_SEL = 0x0001;

    /**
     * Segx86(cpu, sName)
     *
     * @this {Segx86}
     * @param {CPUx86} cpu
     * @param {number} id
     * @param {string} [sName] segment register name
     * @param {boolean} [fProt] true if segment register used exclusively in protected-mode (eg, segLDT)
     */
    constructor(cpu, id, sName, fProt)
    {
        this.cpu = cpu;
        this.id = id;
        this.sName = sName || "";
        this.sel = 0;
        this.limit = 0xffff;
        this.offMax = this.limit + 1;
        this.base = 0;
        this.acc = this.type = 0;
        this.ext = 0;
        this.cpl = this.dpl = 0;
        this.addrDesc = X86.ADDR_INVALID;
        this.sizeData = this.sizeAddr = 2;
        this.maskData = this.maskAddr = 0xffff;

        this.loadV86 = this.loadReal;
        this.checkReadV86 = this.checkReadWriteReal;
        this.checkWriteV86 = this.checkReadWriteReal;

        /**
         * Preallocated object for "probed" segment loads
         */
        this.probe = {
            sel: -1, base: 0, limit: 0, acc: 0, type: 0, ext: 0, addrDesc: X86.ADDR_INVALID
        };

        /**
         * The following properties are used for CODE segments only (ie, segCS); if the process of loading
         * CS also requires a stack switch, then fStackSwitch will be set to true; additionally, if the stack
         * switch was the result of a CALL (ie, fCall is true) and one or more (up to 32) parameters are on
         * the old stack, they will be copied to awParms, and then once the stack is switched, the parameters
         * will be pushed from awParms onto the new stack.
         *
         * The typical ways of loading a new segment into CS are JMPF, CALLF (or INT), and RETF (or IRET),
         * via CPU functions setCSIP() and helpINT(), which use segCS.loadCode() and segCS.loadIDT(), respectively.
         *
         * loadCode() requires an fCall value: null means NO privilege level transition may occur, true
         * allows a stack switch and a privilege transition to a numerically lower privilege, and false allows
         * a stack restore and a privilege transition to a numerically greater privilege.
         *
         * loadIDT() sets fCall to true unconditionally in protected-mode (fCall has no meaning in real-mode).
         */
        if (this.id == 1 /* Segx86.ID.CODE */) {        // don't use Segx86.ID.CODE until it's defined, or the Closure Compiler won't inline it
            this.offIP = 0;
            this.fCall = null;
            this.fStackSwitch = false;
            this.awParms = new Array(32);
            this.aCallBreaks = [];
        }

        this.updateMode(true, fProt);

        if (this.id == 0 /* Segx86.ID.NULL */) {
            this.checkRead = this.checkReadWriteNone;
            this.checkWrite = this.checkReadWriteNone;
        }
    }

    /**
     * addCallBreak(fn)
     *
     * Returns a "call break" address in an [off, sel] array.  The given function, fn(), is called
     * whenever that address is called, and if fn() returns false, then the call is skipped.  Otherwise,
     * the call is performed (ie, the old CS:[E]IP is pushed on the stack, and CS:[E]IP is set to the
     * "call break" address.  Which is probably a bad idea, so your function should probably always
     * return false.  Just sayin'.  TODO: Should probably just force all "call break" calls to be skipped.
     *
     * @this {Segx86}
     * @param {function()} fn
     * @returns {Array.<number>} containing offset and selector of call-break address
     */
    addCallBreak(fn)
    {
        this.aCallBreaks.push(fn);
        return [this.aCallBreaks.length, Segx86.CALLBREAK_SEL];
    }

    /**
     * loadCode(off, sel, fCall)
     *
     * A simple wrapper function that encapsulates setting offIP and fCall for segCS loads.
     *
     * @this {Segx86}
     * @param {number} off
     * @param {number} sel
     * @param {boolean|undefined} fCall is true if CALLF in progress, false if RETF/IRET in progress, undefined otherwise
     * @returns {number} base address of selected segment, or X86.ADDR_INVALID if error
     */
    loadCode(off, sel, fCall)
    {
        this.offIP = off;
        this.fCall = fCall;
        return this.load(sel);
    }

    /**
     * loadReal(sel, fProbe)
     *
     * The default segment load() function for real-mode.
     *
     * @this {Segx86}
     * @param {number} sel
     * @param {boolean} [fProbe] (here only to make the function signatures of loadReal() and loadProt() match)
     * @returns {number} base address of selected segment
     */
    loadReal(sel, fProbe)
    {
        this.sel = sel & 0xffff;
        /**
         * Loading a new value into a segment register in real-mode alters ONLY the selector and the base;
         * all other attributes (eg, limit, operand size, address size, etc) are unchanged.  If you run any
         * code that switches to protected-mode, loads a 32-bit code segment, and then switches back to
         * real-mode, it is THAT code's responsibility to load a 16-bit segment into CS before returning to
         * real-mode; otherwise, your machine will probably be toast.
         */
        return this.base = this.sel << 4;
    }

    /**
     * loadProt(sel, fProbe)
     *
     * This replaces the segment's default load() function whenever the segment is notified via updateMode() by the
     * CPU's setProtMode() that the processor is now in protected-mode.
     *
     * Segments in protected-mode are referenced by selectors, which are indexes into descriptor tables (GDT or LDT)
     * whose descriptors are 4-word (8-byte) entries:
     *
     *      word 0: segment limit (0-15)
     *      word 1: base address low
     *      word 2: base address high (0-7), segment type (8-11), descriptor type (12), DPL (13-14), present bit (15)
     *      word 3: used only on 80386 and up (should be set to zero for upward compatibility)
     *
     * See X86.DESC for offset and bit definitions.
     *
     * IDT descriptor entries are handled separately by loadIDT(), which is mapped to loadIDTReal() or loadIDTProt().
     *
     * @this {Segx86}
     * @param {number} sel
     * @param {boolean} [fProbe]
     * @returns {number} base address of selected segment, or X86.ADDR_INVALID if error
     */
    loadProt(sel, fProbe)
    {
        let addrDT;
        let addrDTLimit;
        let cpu = this.cpu;

        /**
         * Some instructions (eg, CALLF) load a 32-bit value for the selector, while others (eg, LDS) do not;
         * however, in ALL cases, only the low 16 bits are significant.
         */
        sel &= 0xffff;

        if (!(sel & X86.SEL.LDT)) {
            addrDT = cpu.addrGDT;
            addrDTLimit = cpu.addrGDTLimit;
        } else {
            addrDT = cpu.segLDT.base;
            addrDTLimit = (addrDT + cpu.segLDT.limit)|0;
        }
        /**
         * The ROM BIOS POST executes some test code in protected-mode without properly initializing the LDT,
         * which has no bearing on the ROM's own code, because it never loads any LDT selectors, but if at the same
         * time our Debugger attempts to validate a selector in one of its breakpoints, that could cause some grief.
         *
         * Fortunately, the Debugger now has its own interface, probeDesc(), so that should no longer be a concern.
         */
        if (addrDT) {
            let addrDesc = (addrDT + (sel & X86.SEL.MASK))|0;
            if ((addrDTLimit - addrDesc)|0 >= 7) {
                /**
                 * TODO: This is the first of many steps toward accurately counting cycles in protected mode;
                 * I simply noted that "POP segreg" takes 5 cycles in real mode and 20 in protected mode, so I'm
                 * starting with a 15-cycle difference.  Obviously the difference will vary with the instruction,
                 * and will be much greater whenever the load fails.
                 */
                cpu.nStepCycles -= 15;
                return this.loadDesc8(addrDesc, sel, fProbe);
            }
            if (this.id < Segx86.ID.VER) {
                X86.helpFault.call(cpu, fProbe && this.id == Segx86.ID.STACK? X86.EXCEPTION.TS_FAULT : X86.EXCEPTION.GP_FAULT, sel & X86.ERRCODE.SELMASK);
            }
        }
        return X86.ADDR_INVALID;
    }

    /**
     * loadIDTReal(nIDT, nBytes)
     *
     * @this {Segx86}
     * @param {number} nIDT
     * @param {number} [nBytes]
     * @returns {number} address from selected vector
     */
    loadIDTReal(nIDT, nBytes = 0)
    {
        let cpu = this.cpu;
        /**
         * NOTE: The COMPAQ DeskPro 386 ROM loads the IDTR for the real-mode IDT with a limit of 0xffff instead
         * of the normal 0x3ff.  A limit higher than 0x3ff is OK, since all real-mode IDT entries are 4 bytes, and
         * there's no way to issue an interrupt with a vector > 0xff.  Just something to be aware of.
         */


        if (DEBUGGER && cpu.dbg) {
            if (cpu.dbg.checkVectorBP(nIDT, nBytes, false)) {
                return X86.ADDR_INVALID;
            }
        }

        /**
         * Intel documentation for INT/INTO under "REAL ADDRESS MODE EXCEPTIONS" says:
         *
         *      "[T]he 80286 will shut down if the SP = 1, 3, or 5 before executing the INT or INTO instruction--due to lack of stack space"
         *
         * TODO: Verify that 80286 real-mode actually enforces the above.  See http://www.pcjs.org/pubs/pc/reference/intel/80286/progref/#page-260
         */
        let addrIDT = cpu.addrIDT + (nIDT << 2);
        let off = cpu.getShort(addrIDT);
        cpu.regPS &= ~(X86.PS.TF | X86.PS.IF);
        return (this.load(cpu.getShort(addrIDT + 2)) + off)|0;
    }

    /**
     * loadIDTProt(nIDT, nBytes)
     *
     * @this {Segx86}
     * @param {number} nIDT
     * @param {number} [nBytes]
     * @returns {number} address from selected vector, or X86.ADDR_INVALID if error
     */
    loadIDTProt(nIDT, nBytes = 0)
    {
        let cpu = this.cpu;


        if (DEBUGGER && cpu.dbg) {
            if (cpu.dbg.checkVectorBP(nIDT, nBytes, true)) {
                return X86.ADDR_INVALID;
            }
        }

        let offIDT = nIDT << 3;
        let addrDesc = (cpu.addrIDT + offIDT)|0;
        if (((cpu.addrIDTLimit - addrDesc)|0) >= 7) {
            this.fCall = true;
            let addr = this.loadDesc8(addrDesc, offIDT);
            if (addr !== X86.ADDR_INVALID) {
                addr += this.offIP;
            }
            return addr;
        }
        X86.helpFault.call(cpu, X86.EXCEPTION.GP_FAULT, offIDT | X86.ERRCODE.IDT);
        return X86.ADDR_INVALID;
    }

    /**
     * checkReadWriteNone(off, cb)
     *
     * @this {Segx86}
     * @param {number} off is a segment-relative offset
     * @param {number} cb is number of bytes to check (1, 2 or 4)
     * @returns {number} corresponding linear address
     */
    checkReadWriteNone(off, cb)
    {
        return (this.base + off)|0;
    }

    /**
     * checkReadWriteReal(off, cb)
     *
     * @this {Segx86}
     * @param {number} off is a segment-relative offset
     * @param {number} cb is number of bytes to check (1, 2 or 4)
     * @returns {number} corresponding linear address
     */
    checkReadWriteReal(off, cb)
    {
        /**
         * Since off could be a 32-bit value with the sign bit (bit 31) set, we must convert
         * it to an unsigned value using ">>>"; offMax was already converted at segment load time.
         */
        if ((off >>> 0) + cb > this.offMax) {
            if (this.cpu.model <= X86.MODEL_8088) {
                this.cpu.opFlags |= X86.OPFLAG.WRAP;
            } else {
                X86.helpFault.call(this.cpu, X86.EXCEPTION.GP_FAULT);
            }
        }
        return (this.base + off)|0;
    }

    /**
     * checkReadProt(off, cb)
     *
     * @this {Segx86}
     * @param {number} off is a segment-relative offset
     * @param {number} cb is number of bytes to check (1, 2 or 4)
     * @returns {number} corresponding linear address if valid, or X86.ADDR_INVALID if not
     */
    checkReadProt(off, cb)
    {
        /**
         * Since off could be a 32-bit value with the sign bit (bit 31) set, we must convert
         * it to an unsigned value using ">>>"; offMax was already converted at segment load time.
         */
        if ((off >>> 0) + cb <= this.offMax) {
            return (this.base + off)|0;
        }
        return this.checkReadProtDisallowed(off, cb);
    }

    /**
     * checkReadProtDown(off, cb)
     *
     * @this {Segx86}
     * @param {number} off is a segment-relative offset
     * @param {number} cb is number of bytes to check (1, 2 or 4)
     * @returns {number} corresponding linear address if valid, X86.ADDR_INVALID if not
     */
    checkReadProtDown(off, cb)
    {
        /**
         * Since off could be a 32-bit value with the sign bit (bit 31) set, we must convert
         * it to an unsigned value using ">>>"; offMax was already converted at segment load time.
         */
        if ((off >>> 0) + cb > this.offMax) {
            return (this.base + off)|0;
        }
        return this.checkReadProtDisallowed(off, cb);
    }

    /**
     * checkReadProtDisallowed(off, cb)
     *
     * @this {Segx86}
     * @param {number} off is a segment-relative offset
     * @param {number} cb is number of bytes to check (1, 2 or 4)
     * @returns {number} corresponding linear address if valid, X86.ADDR_INVALID if not
     */
    checkReadProtDisallowed(off, cb)
    {
        X86.helpFault.call(this.cpu, X86.EXCEPTION.GP_FAULT, 0);
        return X86.ADDR_INVALID;
    }

    /**
     * checkWriteProt(off, cb)
     *
     * @this {Segx86}
     * @param {number} off is a segment-relative offset
     * @param {number} cb is number of bytes to check (1, 2 or 4)
     * @returns {number} corresponding linear address if valid, X86.ADDR_INVALID if not
     */
    checkWriteProt(off, cb)
    {
        /**
         * Since off could be a 32-bit value with the sign bit (bit 31) set, we must convert
         * it to an unsigned value using ">>>"; offMax was already converted at segment load time.
         */
        if ((off >>> 0) + cb <= this.offMax) {
            return (this.base + off)|0;
        }
        return this.checkWriteProtDisallowed(off, cb);
    }

    /**
     * checkWriteProtDown(off, cb)
     *
     * @this {Segx86}
     * @param {number} off is a segment-relative offset
     * @param {number} cb is number of bytes to check (1, 2 or 4)
     * @returns {number} corresponding linear address if valid, X86.ADDR_INVALID if not
     */
    checkWriteProtDown(off, cb)
    {
        /**
         * Since off could be a 32-bit value with the sign bit (bit 31) set, we must convert
         * it to an unsigned value using ">>>"; offMax was already converted at segment load time.
         */
        if ((off >>> 0) + cb > this.offMax) {
            return (this.base + off)|0;
        }
        return this.checkWriteProtDisallowed(off, cb);
    }

    /**
     * checkWriteProtDisallowed(off, cb)
     *
     * @this {Segx86}
     * @param {number} off is a segment-relative offset
     * @param {number} cb is number of bytes to check (1, 2 or 4)
     * @returns {number} corresponding linear address if valid, X86.ADDR_INVALID if not
     */
    checkWriteProtDisallowed(off, cb)
    {
        X86.helpFault.call(this.cpu, X86.EXCEPTION.GP_FAULT, 0);
        return X86.ADDR_INVALID;
    }

    /**
     * checkReadDebugger(off, cb)
     *
     * @this {Segx86}
     * @param {number} off is a segment-relative offset
     * @param {number} cb is number of bytes to check (1, 2 or 4)
     * @returns {number} corresponding linear address if valid, or X86.ADDR_INVALID if error
     */
    checkReadDebugger(off, cb)
    {
        /**
         * The Debugger doesn't have separate "check" interfaces for real and protected mode,
         * since it's not performance-critical.  If addrDesc is invalid, then we assume real mode.
         *
         * TODO: This doesn't actually check the segment for readability.
         */
        if (DEBUGGER) {
            if (this.addrDesc === X86.ADDR_INVALID ||
                this.fExpDown && (off >>> 0) + cb > this.offMax ||
                !this.fExpDown && (off >>> 0) + cb <= this.offMax) {
                return (this.base + off)|0;
            }
        }
        return X86.ADDR_INVALID;
    }

    /**
     * checkWriteDebugger(off, cb)
     *
     * @this {Segx86}
     * @param {number} off is a segment-relative offset
     * @param {number} cb is number of bytes to check (1, 2 or 4)
     * @returns {number} corresponding linear address if valid, or X86.ADDR_INVALID if error
     */
    checkWriteDebugger(off, cb)
    {
        /**
         * The Debugger doesn't have separate "check" interfaces for real and protected mode,
         * since it's not performance-critical.  If addrDesc is invalid, then we assume real mode.
         *
         * TODO: This doesn't actually check the segment for writability.
         */
        if (DEBUGGER) {
            if (this.addrDesc === X86.ADDR_INVALID ||
                this.fExpDown && (off >>> 0) + cb > this.offMax ||
                !this.fExpDown && (off >>> 0) + cb <= this.offMax) {
                return (this.base + off)|0;
            }
        }
        return X86.ADDR_INVALID;
    }

    /**
     * loadDesc(sel, acc, base, limit)
     *
     * Used to manually load a segment register from the data provided (see LOADALL386).
     *
     * @this {Segx86}
     * @param {number} sel
     * @param {number} acc
     * @param {number} base
     * @param {number} limit
     */
    loadDesc(sel, acc, base, limit)
    {
        this.sel = sel;
        this.base = base;
        this.limit = limit;
        this.offMax = (limit >>> 0) + 1;
        this.acc = acc;
        this.type = (acc & X86.DESC.ACC.TYPE.MASK);
        this.ext = (acc >> 16) & (X86.DESC.EXT.BIG | X86.DESC.EXT.LIMITPAGES);

        let addrDT = (sel & X86.SEL.LDT)? this.cpu.segLDT.base : this.cpu.addrGDT;
        this.addrDesc = (addrDT + (sel & X86.SEL.MASK))|0;

        /**
         * NOTE: This code must take care to leave the mode of the TSS, LDT, and VER segment registers alone;
         * in particular, we must not allow a real-mode LOADALL to modify their mode, because the rest of PCx86
         * assumes that their mode will never change (they were allocated with fProt set to true).
         */
        if (this.id < Segx86.ID.TSS) this.updateMode(true);

        if (DEBUG) this.messageSeg(sel, base, limit, this.type);
    }

    /**
     * loadDesc6(addrDesc, sel)
     *
     * Used to load a protected-mode selector that refers to a 6-byte "descriptor cache" entry (see LOADALL286):
     *
     *      word 0: base address low
     *      word 1: base address high (0-7), segment type (8-11), descriptor type (12), DPL (13-14), present bit (15)
     *      word 2: segment limit (0-15)
     *
     * @this {Segx86}
     * @param {number} addrDesc is the descriptor address
     * @param {number} sel is the associated selector
     * @returns {number} base address of selected segment
     */
    loadDesc6(addrDesc, sel)
    {
        let cpu = this.cpu;
        let acc = cpu.getShort(addrDesc + 2);
        let base = cpu.getShort(addrDesc) | ((acc & 0xff) << 16);
        let limit = cpu.getShort(addrDesc + 4);

        this.sel = sel;
        this.base = base;
        this.limit = limit;
        this.offMax = (limit >>> 0) + 1;
        this.acc = acc;
        this.type = (acc & X86.DESC.ACC.TYPE.MASK);
        this.ext = 0;
        this.addrDesc = addrDesc;

        /**
         * NOTE: This code must take care to leave the mode of the TSS, LDT, and VER segment registers alone;
         * in particular, we must not allow a real-mode LOADALL to modify their mode, because the rest of PCx86
         * assumes that their mode will never change (they were allocated with fProt set to true).
         */
        if (this.id < Segx86.ID.TSS) this.updateMode(true);

        if (DEBUG) this.messageSeg(sel, base, limit, this.type);

        return base;
    }

    /**
     * loadDesc8(addrDesc, sel, fProbe)
     *
     * Used to load a protected-mode selector that refers to an 8-byte "descriptor table" (GDT, LDT, IDT) entry:
     *
     *      word 0: segment limit (0-15)
     *      word 1: base address low
     *      word 2: base address high (0-7), segment type (8-11), descriptor type (12), DPL (13-14), present bit (15)
     *      word 3: used only on 80386 and up (should be set to zero for upward compatibility)
     *
     * See X86.DESC for offset and bit definitions.
     *
     * When fProbe is set, we do NOT modify the public properties of the Segx86 object (see class Segx86 above).
     * We will generate a fault if any of the usual error conditions are detected (and return X86.ADDR_INVALID), but
     * otherwise, we merely stash all the descriptor values it reads in the Segx86's private "probe" object.
     *
     * Probed loads allow us to deal with complex segment load operations (ie, those involving an implied stack-switch
     * or task-switch), by allowing us to probe all the new selectors and generate the necessary faults before modifying
     * any segment registers; if all the probes succeed, then the original load can proceed.
     *
     * The next non-probed load of a probed selector will move those probed descriptor values into the Segx86 object,
     * saving us from having to reload and reparse the descriptor.  However, if a different selector is loaded between
     * the probed and non-probed loads, the probed data is tossed.
     *
     * @this {Segx86}
     * @param {number} addrDesc is the descriptor address
     * @param {number} sel is the associated selector, or nIDT*8 if IDT descriptor
     * @param {boolean} [fProbe] (true if this is a probe)
     * @returns {number} base address of selected segment, or X86.ADDR_INVALID if error
     */
    loadDesc8(addrDesc, sel, fProbe)
    {
        let cpu = this.cpu;

        /**
         * If the previous load was a successful "probed" load of the same segment, then we simply load
         * up all the cached descriptor values from the probe and return.
         */
        if (!fProbe && sel === this.probe.sel) {
            this.sel = sel;
            this.base = this.probe.base;
            this.limit = this.probe.limit;
            this.offMax = (this.probe.limit >>> 0) + 1;
            this.acc = this.probe.acc;
            this.type = this.probe.type;
            this.ext = this.probe.ext;
            this.addrDesc = this.probe.addrDesc;
            this.probe.sel = -1;
            this.updateMode(true, true, false);
            return this.base;
        }

        /**
         * Any other load, probed or otherwise, should "flush" the probe cache, by setting probe.sel to -1.
         */
        this.probe.sel = -1;

        /**
         * Load the descriptor from memory.
         */
        let limit = cpu.getShort(addrDesc + X86.DESC.LIMIT.OFFSET);
        let limitOrig;
        let acc = cpu.getShort(addrDesc + X86.DESC.ACC.OFFSET);
        let type = (acc & X86.DESC.ACC.TYPE.MASK);
        let base = cpu.getShort(addrDesc + X86.DESC.BASE.OFFSET) | ((acc & X86.DESC.ACC.BASE1623) << 16);
        let ext = cpu.getShort(addrDesc + X86.DESC.EXT.OFFSET);
        let selMasked = sel & X86.SEL.MASK;

        if (I386 && cpu.model >= X86.MODEL_80386) {
            limitOrig = limit;
            base |= (ext & X86.DESC.EXT.BASE2431) << 16;
            limit |= (ext & X86.DESC.EXT.LIMIT1619) << 16;
            if (ext & X86.DESC.EXT.LIMITPAGES) limit = (limit << 12) | 0xfff;
        }

        let rpl, dpl, fCall, typeTSS;
        let sizeGate, selCode, cplOld, cplNew, fIDT;
        let addrTSS, offSP, lenSP, regSPPrev, regSSPrev, regPSClear, regSP;

        switch (this.id) {

        case Segx86.ID.CODE:

            /**
             * NOTE: Since we are Segx86.ID.CODE, we can use this.cpl instead of the more convoluted
             * this.cpu.segCS.cpl.
             */
            fCall = this.fCall;
            this.fStackSwitch = false;

            /**
             * This special bit of code is currently used only by the Debugger, when it needs to inject
             * a 16:32 callback address into the machine that it can intercept calls to.  We call these
             * "call break" addresses, because they're essentially breakpoints that only operate when
             * a particular address is called; specifically, an address with selector 0x0001 and an offset
             * that forms a (1-based) index into the aCallBreaks function table.
             *
             * In protected-mode, any null selector, including 0x0001 (null with an RPL of 1), is
             * an invalid CS selector, and while it's not inconceivable that an operating system might
             * use such a selector for some strange purpose, I've not seen such an operating system.
             * And in any case, those operating systems are not likely to trigger the Debugger's call to
             * addCallBreak(), so no call breaks will be generated, and this code will never execute.
             *
             * TODO: If we ever need this to be mode-independent, it can be moved somewhere where it will
             * trigger for both real and protected-mode code segment loads, because CALLBREAK_SEL (0x0001)
             * is also a very unlikely real-mode CS value (but again, not inconceivable).  I think this is
             * a reasonable solution, and it's likely the best we can do without injecting code into the
             * machine that we could address -- and even then, it would not be a mode-independent address.
             */
            if (fCall && sel == Segx86.CALLBREAK_SEL && this.aCallBreaks.length) {
                let iBreak = this.offIP - 1;
                let fnCallBreak = this.aCallBreaks[iBreak];

                if (fnCallBreak && !fnCallBreak()) {
                    return X86.ADDR_INVALID;
                }
            }

            rpl = sel & X86.SEL.RPL;
            dpl = (acc & X86.DESC.ACC.DPL.MASK) >> X86.DESC.ACC.DPL.SHIFT;
            sizeGate = -1;

            if (!selMasked) {
                /**
                 * selMasked is really the descriptor table offset, and a zero offset is fine for the IDT,
                 * and it's probably fine for the LDT, but it's definitely NOT fine for the GDT, because
                 * that's a reference to the null selector.  A null selector is allowed in DS, ES, FS, or GS,
                 * but never CS or SS.  Since there's no parameter that tells us which table we're using,
                 * we have to check manually.
                 *
                 * If we ARE attempting to load a null selector from the GDT, then we zero type, ensuring that
                 * sizeGate will remain invalid (-1), triggering a GP_FAULT below.
                 */
                if (addrDesc >= cpu.addrGDT && addrDesc < cpu.addrGDTLimit) type = 0;
            }

            if (type >= X86.DESC.ACC.TYPE.CODE_EXECONLY) {
                /**
                 * There are three basic ways to load a new code segment (ignoring special cases like LOADALL):
                 *
                 *      1) CALLF (fCall is true)
                 *      2) RETF (fCall is false)
                 *      3) JMPF (fCall is undefined)
                 *
                 * Also, note that if fProbe is set, we're being called on behalf of a gate, in which case the
                 * gate logic will examine the relative privileges.
                 */
                if (fProbe != null) {
                    sizeGate = 0;
                }
                else if (fCall !== false) {
                    /**
                     * We deal with CALLF/JMPF first.  We've already ascertained that the selector type is a
                     * segment, not a gate, so the next important distinction is CONFORMING vs. non-CONFORMING.
                     *
                     * For a CONFORMING target, we must verify that its DPL <= CPL.  For a non-CONFORMING target,
                     * we must verify that RPL <= CPL and DPL == CPL.  Assuming both those tests pass, we must also
                     * ensure that the current CPL is recorded as the new RPL (that is, the RPL bits of sel must be
                     * updated).
                     */
                    if (type & X86.DESC.ACC.TYPE.CONFORMING) {
                        if (dpl <= this.cpl) {
                            sizeGate = 0;
                        }
                    } else {
                        if (rpl <= this.cpl && dpl == this.cpl) {
                            sizeGate = 0;
                        }
                    }
                    if (!sizeGate) {
                        sel = (sel & ~X86.SEL.RPL) | (this.cpl & X86.SEL.RPL);
                    }
                }
                else {
                    /**
                     * We deal with RETF next.  For starters, we must verify that RPL >= CPL.  Moreover, if
                     * RPL > CPL, then we have a privilege level change that requires a stack switch, assuming
                     * the stack selector is acceptable.
                     */
                    if (rpl >= this.cpl) {
                        if (rpl > this.cpl) {
                            /**
                             * TODO: See if we can defer calling setSS() and setSP() until AFTER the final checks
                             * below, because if, for example, the new CS is not PRESENT, we must generate a fault,
                             * which in turn must restore the original stack, which means helpRETF() must snapshot
                             * the stack registers.
                             */
                            regSP = cpu.popWord();
                            cpu.setSS(cpu.popWord(), true);
                            cpu.setSP(regSP);
                            this.fStackSwitch = true;
                        }
                        sizeGate = 0;
                    }
                }
            }
            else if (type == X86.DESC.ACC.TYPE.TSS286 || type == X86.DESC.ACC.TYPE.TSS386) {
                if (!this.switchTSS(sel, fCall)) {
                    return X86.ADDR_INVALID;
                }
                return this.base;
            }
            else if (type == X86.DESC.ACC.TYPE.GATE_CALL) {
                sizeGate = 2;
                regPSClear = 0;
                if (rpl < this.cpl) rpl = this.cpl;     // set RPL to max(RPL,CPL) for call gates
            }
            else if (type == X86.DESC.ACC.TYPE.GATE386_CALL) {
                sizeGate = 4;
                regPSClear = 0;
                if (rpl < this.cpl) rpl = this.cpl;     // set RPL to max(RPL,CPL) for call gates
            }
            else if (type == X86.DESC.ACC.TYPE.GATE286_INT) {
                sizeGate = 2;
                regPSClear = (X86.PS.VM | X86.PS.NT | X86.PS.TF | X86.PS.IF);

            }
            else if (type == X86.DESC.ACC.TYPE.GATE386_INT) {
                sizeGate = 4;
                regPSClear = (X86.PS.VM | X86.PS.NT | X86.PS.TF | X86.PS.IF);

            }
            else if (type == X86.DESC.ACC.TYPE.GATE286_TRAP) {
                sizeGate = 2;
                regPSClear = (X86.PS.VM | X86.PS.NT | X86.PS.TF);

            }
            else if (type == X86.DESC.ACC.TYPE.GATE386_TRAP) {
                sizeGate = 4;
                regPSClear = (X86.PS.VM | X86.PS.NT | X86.PS.TF);

            }
            else if (type == X86.DESC.ACC.TYPE.GATE_TASK) {
                if (!this.switchTSS(base & 0xffff, fCall)) {
                    return X86.ADDR_INVALID;
                }
                return this.base;
            }

            if (sizeGate > 0 && !(acc & X86.DESC.ACC.PRESENT)) sizeGate = 0;

            if (sizeGate > 0) {
                /**
                 * Note that since GATE_INT/GATE_TRAP descriptors should appear in the IDT only, that means sel
                 * will actually be nIDT * 8, which means the rpl will always be zero; additionally, the nWords
                 * portion of ACC should always be zero, but that's really dependent on the descriptor being properly
                 * set (which we assert above).
                 */
                cplOld = this.cpl;
                fIDT = (addrDesc == cpu.addrIDT + sel);

                /**
                 * Software interrupts (where fIDT is true and cpu.nFault < 0) require an additional test:
                 * if DPL < CPL, then we must fall into the GP_FAULT code at the end of this case.
                 */
                if (rpl <= dpl && (!fIDT || cpu.nFault >= 0 || cplOld <= dpl))  {

                    /**
                     * For gates, there is no "base" and "limit", but rather "selector" and "offset"; the selector
                     * is located where the first 16 bits of base are normally stored, and the offset comes from the
                     * original limit and ext fields.
                     *
                     * TODO: Verify the PRESENT bit of the gate descriptor, and issue NP_FAULT as appropriate.
                     */
                    selCode = base & 0xffff;
                    if (I386 && (type & X86.DESC.ACC.TYPE.NONSEG_386)) {
                        limit = limitOrig | (ext << 16);
                    }

                    let selStack = 0, offStack = 0;
                    cplNew = (selCode & X86.SEL.RPL);

                    /**
                     * If a stack switch is required, we must perform "probed" loads of both the new selCode
                     * and selStack segments, so that if either probe fails, a fault will be generated while the
                     * old code segment is still loaded.
                     */
                    if (cplNew < cplOld) {
                        /**
                         * Intel pseudo-code suggests that selStack should be "probed" before selCode, but it also
                         * implies that we need to have the DPL of selCode in order to select the correct selStack,
                         * so who knows...?
                         */
                        if (this.loadProt(selCode, true) === X86.ADDR_INVALID) {
                            return X86.ADDR_INVALID;
                        }
                        /**
                         * Intel pseudo-code suggests that the TSS stack pointer offset is based on the DPL of selCode
                         * rather than the RPL of selCode.  TODO: Check for instances where DPL and RPL of selCode differ,
                         * and then figure out which should really be used.
                         */
                        addrTSS = cpu.segTSS.base;
                        if (!I386 || !(cpu.segTSS.type & X86.DESC.ACC.TYPE.NONSEG_386)) {
                            offSP = (cplNew << 2) + X86.TSS286.CPL0_SP;
                            lenSP = 2;
                        } else {
                            offSP = (cplNew << 3) + X86.TSS386.CPL0_ESP;
                            lenSP = 4;
                        }
                        selStack = cpu.getShort(addrTSS + offSP + lenSP);

                        /**
                         * Intel pseudo-code indicates at least FIVE discrete selStack tests that could trigger
                         * a TS_FAULT at this point:
                         *
                         *      1) Selector must not be null else #TS(O)
                         *      2) Selector index must be within its descriptor table limits else #TS (SS selector)
                         *      3) Selector's RPL must equal DPL of code segment else #TS (SS selector)
                         *      4) Stack segment DPL must equal DPL of code segment else #TS (SS selector)
                         *      5) Descriptor must indicate writable data segment else #TS (SS selector)
                         */
                        if (!selStack) {
                            X86.helpFault.call(cpu, X86.EXCEPTION.TS_FAULT, selStack);
                            return X86.ADDR_INVALID;
                        }

                        if (cpu.segSS.loadProt(selStack, true) === X86.ADDR_INVALID) {
                            return X86.ADDR_INVALID;
                        }
                        /**
                         * Both probes succeeded, so we can proceed with "normal" loads for both selCode and
                         * selStack (which should automatically use the values cached by the "probed" loads above).
                         */
                        offStack = (lenSP == 2)? cpu.getShort(addrTSS + offSP) : cpu.getLong(addrTSS + offSP);
                    }

                    /**
                     * Now that we're past all the probes, it should be safe to clear all flags that need clearing.
                     */
                    let regPS = cpu.regPS;
                    cpu.regPS &= ~regPSClear;
                    if (regPS & X86.PS.VM) {
                        cpu.setProtMode(true, false);
                    }

                    /**
                     * TODO: Consider whether we can skip this loadProt() call if this.sel already contains selCode
                     * (and the previous mode matches, which might require we cache the mode in the Segx86 object, too).
                     */
                    if (this.loadProt(selCode, false) === X86.ADDR_INVALID) {
                        return X86.ADDR_INVALID;
                    }

                    cpu.setDataSize(sizeGate);

                    this.offIP = limit;

                    //

                    if (cplNew < cplOld) {

                        if (fCall !== true) {

                            return X86.ADDR_INVALID;
                        }

                        regSP = cpu.getSP();
                        let i = 0, nWords = (acc & 0x1f);
                        while (nWords--) {
                            this.awParms[i++] = cpu.getSOWord(cpu.segSS, regSP);
                            regSP += 2;
                        }

                        regSSPrev = cpu.getSS();
                        regSPPrev = cpu.getSP();

                        cpu.setSS(selStack, true);
                        cpu.setSP(offStack);

                        if (regPS & X86.PS.VM) {
                            /**
                             * Frames coming from V86-mode ALWAYS contain 32-bit values, and look like this:
                             *
                             *      low:    EIP
                             *              CS (upper 16 bits undefined)
                             *              EFLAGS
                             *              ESP
                             *              SS (upper 16 bits undefined)
                             *              ES (upper 16 bits undefined)
                             *              DS (upper 16 bits undefined)
                             *              FS (upper 16 bits undefined)
                             *      high:   GS (upper 16 bits undefined)
                             *
                             * Our caller (eg, helpINT()) will take care of pushing the final bits (EFLAGS, CS, and EIP).
                             */
                            cpu.setDataSize(4);

                            cpu.pushData(cpu.segGS.sel, 4, 2);
                            cpu.setGS(0);
                            cpu.pushData(cpu.segFS.sel, 4, 2);
                            cpu.setFS(0);
                            cpu.pushData(cpu.segDS.sel, 4, 2);
                            cpu.setDS(0);
                            cpu.pushData(cpu.segES.sel, 4, 2);
                            cpu.setES(0);
                        }
                        cpu.pushData(regSSPrev, cpu.sizeData, 2);
                        cpu.pushWord(regSPPrev);
                        while (i) cpu.pushWord(this.awParms[--i]);
                        this.fStackSwitch = true;
                    }
                    return this.base;
                }
            }

            if (sizeGate != 0) {
                X86.helpFault.call(cpu, X86.EXCEPTION.GP_FAULT, (sel & X86.ERRCODE.SELMASK) | (fIDT? X86.ERRCODE.IDT : 0));
                return X86.ADDR_INVALID;
            }

            if (!(acc & X86.DESC.ACC.PRESENT)) {
                X86.helpFault.call(cpu, X86.EXCEPTION.NP_FAULT, (sel & X86.ERRCODE.SELMASK) | (fIDT? X86.ERRCODE.IDT : 0));
                return X86.ADDR_INVALID;
            }
            break;

        case Segx86.ID.DATA:
            if (selMasked) {
                /**
                 * OS/2 1.0 faults on segments with "empty descriptors" multiple times during boot; for example:
                 *
                 *      Fault 0x0B (0x002C) on opcode 0x8E at 3190:3A05 (%112625)
                 *      AX=0000 BX=0970 CX=0300 DX=0300 SP=0ABE BP=0ABA SI=0000 DI=001A
                 *      SS=0038[175CE0,0B5F] DS=19C0[177300,2C5F] ES=001F[1743A0,07FF] A20=ON
                 *      CS=3190[10EC20,B89F] LD=0028[174BC0,003F] GD=[11A4E0,490F] ID=[11F61A,03FF]
                 *      TR=0010 MS=0000FFF3 PS=3256 V0 D0 I1 T0 S0 Z1 A1 P1 C0
                 *      3190:3A05 8E4604          MOV      ES,[BP+04]
                 *      ## dw ss:bp+4 l1
                 *      0038:0ABE  002F  19C0  0000  067C  07FC  0AD2  0010  C420   /.....|....... .
                 *      ## ds 2f
                 *      dumpDesc(0x002F): %174BE8
                 *      base=000000 limit=0000 type=0x00 (undefined) ext=0x0000 dpl=0x00
                 *
                 * And Windows 95 Setup, during the "Analyzing Your Computer" phase, will fault on an attempt to load
                 * a GDT selector of type LDT (why it does this is a mystery I've not yet investigated):
                 *
                 *      Fault 0x0D (0x26F0) on opcode 0x8E @039F:039B (%199E9B)
                 *      EAX=0000149F EBX=00000100 ECX=000026F3 EDX=0020149F
                 *      ESP=0000AA34 EBP=0000AA3C ESI=000026E7 EDI=00000080
                 *      SS=155F[002AC9D0,C0BF] DS=149F[0031B470,9B1F] ES=0237[000C0000,FFFF]
                 *      CS=039F[00199B00,2ABF] FS=0000[00000000,0000] GS=0000[00000000,0000]
                 *      LD=0038[00FA4C50,FFEF] GD=[00FA0800,011F] ID=[00FA0000,07FF] TR=0088 A20=ON
                 *      CR0=0000FFF1 CR2=00000000 CR3=00000000 PS=00003246 V0 D0 I1 T0 S0 Z1 A0 P1 C0
                 *      039F:039B 8EC1            MOV      ES,CX
                 *      ## ds cx
                 *      dumpDesc(0x26F3): %00FA2EF0
                 *      base=0006C726 limit=0000 type=0x02 (ldt,not present) ext=0x0000 dpl=0x00
                 *
                 * In both cases, the segment type is not valid for the target segment register *and* the PRESENT bit
                 * is clear.  OS/2 doesn't seem to care whether I report an NP_FAULT or GP_FAULT, but Windows 95 definitely
                 * cares: it will resolve the fault only if a GP_FAULT is reported.  And Intel's 80386 Programmers Reference
                 * implies that, yes, GP_FAULT checks are supposed to be performed *before* NP_FAULT checks.
                 */
                if (type < X86.DESC.ACC.TYPE.SEG || (type & (X86.DESC.ACC.TYPE.CODE | X86.DESC.ACC.TYPE.READABLE)) == X86.DESC.ACC.TYPE.CODE) {
                    X86.helpFault.call(cpu, X86.EXCEPTION.GP_FAULT, sel & X86.ERRCODE.SELMASK);
                    return X86.ADDR_INVALID;
                }
                /**
                 * TODO: This would be a good place to perform some additional access rights checks, too.
                 */
                if (!(acc & X86.DESC.ACC.PRESENT)) {
                    X86.helpFault.call(cpu, X86.EXCEPTION.NP_FAULT, sel & X86.ERRCODE.SELMASK);
                    return X86.ADDR_INVALID;
                }
            }
            break;

        case Segx86.ID.STACK:
            if (!selMasked || type < X86.DESC.ACC.TYPE.SEG || (type & (X86.DESC.ACC.TYPE.CODE | X86.DESC.ACC.TYPE.WRITABLE)) != X86.DESC.ACC.TYPE.WRITABLE) {
                X86.helpFault.call(cpu, X86.EXCEPTION.GP_FAULT, sel & X86.ERRCODE.SELMASK);
                return X86.ADDR_INVALID;
            }
            if (!(acc & X86.DESC.ACC.PRESENT)) {
                X86.helpFault.call(cpu, X86.EXCEPTION.SS_FAULT, sel & X86.ERRCODE.SELMASK);
                return X86.ADDR_INVALID;
            }
            break;

        case Segx86.ID.TSS:
            typeTSS = type & ~X86.DESC.ACC.TYPE.TSS_BUSY;
            if (!selMasked || typeTSS != X86.DESC.ACC.TYPE.TSS286 && typeTSS != X86.DESC.ACC.TYPE.TSS386) {
                X86.helpFault.call(cpu, X86.EXCEPTION.GP_FAULT, sel & X86.ERRCODE.SELMASK);
                return X86.ADDR_INVALID;
            }
            /**
             * For more efficient IOPM lookups, we cache the starting linear address in segTSS.addrIOPM, and the
             * last valid address in segTSS.addrIOPMLimit.
             */
            if (typeTSS == X86.DESC.ACC.TYPE.TSS386) {
                this.addrIOPM = (base + cpu.getShort(base + X86.TSS386.TASK_IOPM + 2)) >>> 0;
                this.addrIOPMLimit = (base + this.limit) >>> 0;
            }
            break;

        case Segx86.ID.VER:
            /**
             * For LSL, we must support any descriptor marked X86.DESC.ACC.TYPE.SEG, as well as TSS and LDT descriptors.
             */
            if (!(type & X86.DESC.ACC.TYPE.SEG) && type > X86.DESC.ACC.TYPE.TSS286_BUSY && type != X86.DESC.ACC.TYPE.TSS386 && type != X86.DESC.ACC.TYPE.TSS386_BUSY) {
                return X86.ADDR_INVALID;
            }
            break;

        default:
            /**
             * The only other cases are:
              *
              *     Segx86.ID.NULL, Segx86.ID.LDT, and Segx86.ID.DBG
              *
              * which correspond to segNULL, segLDT and segDebugger; however, segLDT is the only one that might require further validation (TODO: Investigate).
             */
            break;
        }

        if (fProbe) {
            this.probe.sel = sel;
            this.probe.base = base;
            this.probe.limit = limit;
            this.probe.acc = acc;
            this.probe.type = type;
            this.probe.ext = ext;
            this.probe.addrDesc = addrDesc;
        } else {
            this.sel = sel;
            this.base = base;
            this.limit = limit;
            this.offMax = (limit >>> 0) + 1;
            this.acc = acc;
            this.type = type;
            this.ext = ext;
            this.addrDesc = addrDesc;
            /**
             * A quick recap of what updateMode(fLoad=true, fProt=true, fV86=false) actually updates:
             *
             *      cpl
             *      dpl
             *      dataSize
             *      dataMask
             *      addrSize
             *      addrMask
             *      fExpDown
             *      load()
             *      loadIDT()
             *      checkRead()
             *      checkWrite()
             */
            this.updateMode(true, true, false);
        }

        if (DEBUG) this.messageSeg(sel, base, limit, type, ext);

        return base;
    }

    /**
     * switchTSS(selNew, fNest)
     *
     * Implements TSS (Task State Segment) task switching.
     *
     * NOTES: This typically occurs during double-fault processing, because the IDT entry for DF_FAULT normally
     * contains a task gate.  Interestingly, if we force a GP_FAULT to occur at a sufficiently early point in the
     * OS/2 1.0 initialization code, OS/2 does a nice job of displaying the GP fault and then shutting down:
     *
     *      0090:067B FB            STI
     *      0090:067C EBFD          JMP      067B
     *
     * but it may not have yet reprogrammed the master PIC to re-vector hardware interrupts to IDT entries 0x50-0x57,
     * so when the next timer interrupt (IRQ 0) occurs, it vectors through IDT entry 0x08, which is the DF_FAULT
     * vector. A spurious double-fault is generated, and a clean shutdown turns into a messy crash.
     *
     * Of course, that all could have been avoided if IBM had heeded Intel's advice and not used Intel-reserved IDT
     * entries for PC interrupts.
     *
     * TODO: Add TSS validity checks and appropriate generation of TS_FAULT exceptions; the only rudimentary checks
     * we currently perform are of the GP_FAULT variety.
     *
     * @this {Segx86}
     * @param {number} selNew
     * @param {boolean|null} [fNest] is true if nesting, false if un-nesting, null if neither
     * @returns {boolean} true if successful, false if error
     */
    switchTSS(selNew, fNest)
    {
        let cpu = this.cpu;


        let cplOld = this.cpl;
        let selOld = cpu.segTSS.sel;
        let addrOld = cpu.segTSS.base;

        if (!fNest) {
            /**
             * TODO: Verify that it is (always) correct to require that the BUSY bit be currently set.
             */
            if (!(cpu.segTSS.type & X86.DESC.ACC.TYPE.TSS_BUSY)) {
                X86.helpFault.call(cpu, X86.EXCEPTION.GP_FAULT, selNew & X86.ERRCODE.SELMASK);
                return false;
            }
            /**
             * TODO: Should I be more paranoid about writing our cached ACC value back into the descriptor?
             */
            cpu.setShort(cpu.segTSS.addrDesc + X86.DESC.ACC.OFFSET, cpu.segTSS.acc &= ~X86.DESC.ACC.TYPE.TSS_BUSY);
        }

        if (cpu.segTSS.load(selNew) === X86.ADDR_INVALID) {
            return false;
        }

        let addrNew = cpu.segTSS.base;
        if (DEBUG && DEBUGGER && cpu.dbg) {
            cpu.dbg.printf(MESSAGE.TSS, "%s: TR %#06x (%#06x), new TR %#06x (%#06x)\n", fNest? "Task switch" : "Task return", selOld, addrOld, selNew, addrNew);
        }

        if (fNest !== false) {
            if (cpu.segTSS.type & X86.DESC.ACC.TYPE.TSS_BUSY) {
                X86.helpFault.call(cpu, X86.EXCEPTION.GP_FAULT, selNew & X86.ERRCODE.SELMASK);
                return false;
            }
            cpu.setShort(cpu.segTSS.addrDesc + X86.DESC.ACC.OFFSET, cpu.segTSS.acc |= X86.DESC.ACC.TYPE.TSS_BUSY);
        }

        /**
         * Now that we're done checking the TSS_BUSY bit in the TYPE field (which is a subset of the ACC field),
         * sync any changes made above in the ACC field to the TYPE field.
         */
        cpu.segTSS.type = (cpu.segTSS.type & ~X86.DESC.ACC.TYPE.TSS_BUSY) | (cpu.segTSS.acc & X86.DESC.ACC.TYPE.TSS_BUSY);

        /**
         * Update the old TSS
         */
        let offSS;
        let offSP;
        if (cpu.segTSS.type == X86.DESC.ACC.TYPE.TSS286 || cpu.segTSS.type == X86.DESC.ACC.TYPE.TSS286_BUSY) {
            cpu.setShort(addrOld + X86.TSS286.TASK_IP, cpu.getIP());
            cpu.setShort(addrOld + X86.TSS286.TASK_PS, cpu.getPS());
            cpu.setShort(addrOld + X86.TSS286.TASK_AX, cpu.regEAX);
            cpu.setShort(addrOld + X86.TSS286.TASK_CX, cpu.regECX);
            cpu.setShort(addrOld + X86.TSS286.TASK_DX, cpu.regEDX);
            cpu.setShort(addrOld + X86.TSS286.TASK_BX, cpu.regEBX);
            cpu.setShort(addrOld + X86.TSS286.TASK_SP, cpu.getSP());
            cpu.setShort(addrOld + X86.TSS286.TASK_BP, cpu.regEBP);
            cpu.setShort(addrOld + X86.TSS286.TASK_SI, cpu.regESI);
            cpu.setShort(addrOld + X86.TSS286.TASK_DI, cpu.regEDI);
            cpu.setShort(addrOld + X86.TSS286.TASK_ES, cpu.segES.sel);
            cpu.setShort(addrOld + X86.TSS286.TASK_CS, cpu.segCS.sel);
            cpu.setShort(addrOld + X86.TSS286.TASK_SS, cpu.segSS.sel);
            cpu.setShort(addrOld + X86.TSS286.TASK_DS, cpu.segDS.sel);
            /**
             * Reload all registers from the new TSS; it's important to reload the LDTR sooner
             * rather than later, so that as segment registers are reloaded, any LDT selectors will
             * will be located in the correct table.
             */
            cpu.segLDT.load(cpu.getShort(addrNew + X86.TSS286.TASK_LDT));
            cpu.setPS(cpu.getShort(addrNew + X86.TSS286.TASK_PS) | (fNest? X86.PS.NT : 0));

            cpu.regEAX = cpu.getShort(addrNew + X86.TSS286.TASK_AX);
            cpu.regECX = cpu.getShort(addrNew + X86.TSS286.TASK_CX);
            cpu.regEDX = cpu.getShort(addrNew + X86.TSS286.TASK_DX);
            cpu.regEBX = cpu.getShort(addrNew + X86.TSS286.TASK_BX);
            cpu.regEBP = cpu.getShort(addrNew + X86.TSS286.TASK_BP);
            cpu.regESI = cpu.getShort(addrNew + X86.TSS286.TASK_SI);
            cpu.regEDI = cpu.getShort(addrNew + X86.TSS286.TASK_DI);
            cpu.segES.load(cpu.getShort(addrNew + X86.TSS286.TASK_ES));
            cpu.segDS.load(cpu.getShort(addrNew + X86.TSS286.TASK_DS));
            cpu.setCSIP(cpu.getShort(addrNew + X86.TSS286.TASK_IP), cpu.getShort(addrNew + X86.TSS286.TASK_CS));
            offSS = X86.TSS286.TASK_SS;
            offSP = X86.TSS286.TASK_SP;
            if (this.cpl < cplOld) {
                offSP = (this.cpl << 2) + X86.TSS286.CPL0_SP;
                offSS = offSP + 2;
            }
            cpu.setSS(cpu.getShort(addrNew + offSS), true);
            cpu.setSP(cpu.getShort(addrNew + offSP));
        } else {

            cpu.setLong(addrOld + X86.TSS386.TASK_CR3, cpu.regCR3);
            cpu.setLong(addrOld + X86.TSS386.TASK_EIP, cpu.getIP());
            cpu.setLong(addrOld + X86.TSS386.TASK_PS,  cpu.getPS());
            cpu.setLong(addrOld + X86.TSS386.TASK_EAX, cpu.regEAX);
            cpu.setLong(addrOld + X86.TSS386.TASK_ECX, cpu.regECX);
            cpu.setLong(addrOld + X86.TSS386.TASK_EDX, cpu.regEDX);
            cpu.setLong(addrOld + X86.TSS386.TASK_EBX, cpu.regEBX);
            cpu.setLong(addrOld + X86.TSS386.TASK_ESP, cpu.getSP());
            cpu.setLong(addrOld + X86.TSS386.TASK_EBP, cpu.regEBP);
            cpu.setLong(addrOld + X86.TSS386.TASK_ESI, cpu.regESI);
            cpu.setLong(addrOld + X86.TSS386.TASK_EDI, cpu.regEDI);
            cpu.setLong(addrOld + X86.TSS386.TASK_ES,  cpu.segES.sel);
            cpu.setLong(addrOld + X86.TSS386.TASK_CS,  cpu.segCS.sel);
            cpu.setLong(addrOld + X86.TSS386.TASK_SS,  cpu.segSS.sel);
            cpu.setLong(addrOld + X86.TSS386.TASK_DS,  cpu.segDS.sel);

            /**
             * segFS and segGS exist only on 80386 machines
             */

            cpu.setLong(addrOld + X86.TSS386.TASK_FS,  cpu.segFS.sel);
            cpu.setLong(addrOld + X86.TSS386.TASK_GS,  cpu.segGS.sel);

            /**
             * Reload all registers from the new TSS; it's important to reload the LDTR sooner
             * rather than later, so that as segment registers are reloaded, any LDT selectors will
             * will be located in the correct table.
             */
            X86.helpLoadCR3.call(cpu, cpu.getLong(addrNew + X86.TSS386.TASK_CR3));
            cpu.segLDT.load(cpu.getShort(addrNew + X86.TSS386.TASK_LDT));
            cpu.setPS(cpu.getLong(addrNew + X86.TSS386.TASK_PS) | (fNest? X86.PS.NT : 0));

            cpu.regEAX = cpu.getLong(addrNew + X86.TSS386.TASK_EAX);
            cpu.regECX = cpu.getLong(addrNew + X86.TSS386.TASK_ECX);
            cpu.regEDX = cpu.getLong(addrNew + X86.TSS386.TASK_EDX);
            cpu.regEBX = cpu.getLong(addrNew + X86.TSS386.TASK_EBX);
            cpu.regEBP = cpu.getLong(addrNew + X86.TSS386.TASK_EBP);
            cpu.regESI = cpu.getLong(addrNew + X86.TSS386.TASK_ESI);
            cpu.regEDI = cpu.getLong(addrNew + X86.TSS386.TASK_EDI);
            cpu.segES.load(cpu.getShort(addrNew + X86.TSS386.TASK_ES));
            cpu.segDS.load(cpu.getShort(addrNew + X86.TSS386.TASK_DS));

            /**
             * segFS and segGS exist only on 80386 machines
             */

            cpu.segFS.load(cpu.getShort(addrNew + X86.TSS386.TASK_FS));
            cpu.segGS.load(cpu.getShort(addrNew + X86.TSS386.TASK_GS));

            cpu.setCSIP(cpu.getLong(addrNew + X86.TSS386.TASK_EIP), cpu.getShort(addrNew + X86.TSS386.TASK_CS));
            offSS = X86.TSS386.TASK_SS;
            offSP = X86.TSS386.TASK_ESP;
            if (this.cpl < cplOld) {
                offSP = (this.cpl << 3) + X86.TSS386.CPL0_ESP;
                offSS = offSP + 4;
            }
            cpu.setSS(cpu.getShort(addrNew + offSS), true);
            cpu.setSP(cpu.getLong(addrNew + offSP));
        }

        /**
         * Fortunately, X86.TSS286.PREV_TSS and X86.TSS386.PREV_TSS refer to the same TSS offset.
         */
        if (fNest) cpu.setShort(addrNew + X86.TSS286.PREV_TSS, selOld);

        cpu.regCR0 |= X86.CR0.MSW.TS;
        return true;
    }

    /**
     * setBase(addr)
     *
     * This is used in unusual situations where the base must be set independently; normally, the base is
     * set according to the selector provided to load(), but there are a few cases where setBase() is required.
     *
     * For example, in resetRegs(), the real-mode CS selector must be reset to 0xF000 for an 80286 or 80386,
     * but the CS base must be set to 0x00FF0000 or 0xFFFF0000, respectively.  To simplify life for setBase()
     * callers, we allow them to specify 32-bit bases, which we then truncate to 24 bits as needed.
     *
     * WARNING: Since the CPU must maintain regLIP as the sum of the CS base and the current IP, all calls
     * to segCS.setBase() need to go through cpu.setCSBase().
     *
     * @this {Segx86}
     * @param {number} addr
     * @returns {number} addr, truncated as needed
     */
    setBase(addr)
    {
        if (this.cpu.model < X86.MODEL_80386) addr &= 0xffffff;
        return this.base = addr;
    }

    /**
     * save()
     *
     * Early versions of PCx86 saved only segment selectors, since that's all that mattered in real-mode;
     * newer versions need to save/restore all the "core" properties of the Segx86 object (ie, properties other
     * than those that updateMode() will take care of restoring later).
     *
     * @this {Segx86}
     * @returns {Array}
     */
    save()
    {
        return [
            this.sel,
            this.base,
            this.limit,
            this.acc,
            this.id,
            this.sName,
            this.cpl,
            this.dpl,
            this.addrDesc,
            this.sizeAddr,
            this.maskAddr,
            this.sizeData,
            this.maskData,
            this.type,
            this.offMax
        ];
    }

    /**
     * restore(a)
     *
     * Early versions of PCx86 saved only segment selectors, since that's all that mattered in real-mode;
     * newer versions need to save/restore all the "core" properties of the Segx86 object (ie, properties other
     * than those that updateMode() will take care of restoring later).
     *
     * @this {Segx86}
     * @param {Array|number} a
     */
    restore(a)
    {
        if (typeof a == "number") {
            this.load(a);
        } else {
            this.sel      = a[0];
            this.base     = a[1];
            this.limit    = a[2];
            this.acc      = a[3];
            this.id       = a[4];
            this.sName    = a[5];
            this.cpl      = a[6];
            this.dpl      = a[7];
            this.addrDesc = a[8];
            this.sizeAddr = a[9]  || 2;
            this.maskAddr = a[10] || 0xffff;
            this.sizeData = a[11] || 2;
            this.maskData = a[12] || 0xffff;
            this.type     = a[13] || (this.acc & X86.DESC.ACC.TYPE.MASK);
            this.offMax   = a[14] || (this.limit >>> 0) + 1;
        }
    }

    /**
     * updateMode(fLoad, fProt, fV86)
     *
     * Ensures that the segment register's access (ie, load and check methods) matches the specified (or current)
     * operating mode (real or protected).
     *
     * @this {Segx86}
     * @param {boolean} [fLoad] true if the segment was just (re)loaded, false if not
     * @param {boolean} [fProt] true for protected-mode access, false for real-mode access, undefined for current mode
     * @param {boolean} [fV86] true for V86-mode access, false for protected-mode access, undefined for current mode
     */
    updateMode(fLoad, fProt, fV86)
    {
        if (fProt === undefined) {
            fProt = !!(this.cpu.regCR0 & X86.CR0.MSW.PE);
        }

        /**
         * The fExpDown property is used for STACK segments only (ie, segSS); we want to make it easier for
         * setSS() to set stack lower and upper limits, which requires knowing whether or not the segment is
         * marked as EXPDOWN.
         */
        this.fExpDown = false;

        if (fProt) {
            this.load = this.loadProt;
            this.loadIDT = this.loadIDTProt;
            this.checkRead = this.checkReadProt;
            this.checkWrite = this.checkWriteProt;

            if (fV86 === undefined) {
                fV86 = !!(this.cpu.regPS & X86.PS.VM);
            }

            if (fV86) {
                this.load = this.loadV86;
                this.checkRead = this.checkReadV86;
                this.checkWrite = this.checkWriteV86;
                /**
                 * One important feature of V86-mode (as compared to real-mode) are that other segment attributes
                 * (eg, limit, operand size, address size, etc) ARE updated, whereas in real-mode, segment attributes
                 * remain set to whatever was in effect in protected-mode.
                 */
                this.cpl = this.dpl = 3;
                this.sizeData = this.sizeAddr = 2;
                this.maskData = this.maskAddr = 0xffff;
                this.limit = 0xffff;
                this.offMax = this.limit + 1;
                this.addrDesc = X86.ADDR_INVALID;
                this.fStackSwitch = false;
                return;
            }

            /**
             * TODO: For null GDT selectors, should we rely on the descriptor being invalid, or should we assume that
             * the null descriptor might contain uninitialized (or other) data?  I'm assuming the latter, hence the
             * following null selector test.  However, if we're not going to consult the descriptor, is there anything
             * else we should (or should not) be doing for null GDT selectors?
             */
            if (!(this.sel & ~X86.SEL.RPL)) {
                this.checkRead = this.checkReadProtDisallowed;
                this.checkWrite = this.checkWriteProtDisallowed;

            }
            else if (this.type & X86.DESC.ACC.TYPE.SEG) {
                /**
                 * If the READABLE bit of CODE_READABLE is not set, then disallow reads.
                 */
                if ((this.type & X86.DESC.ACC.TYPE.CODE_READABLE) == X86.DESC.ACC.TYPE.CODE_EXECONLY) {
                    this.checkRead = this.checkReadProtDisallowed;
                }
                /**
                 * If the CODE bit is set, or the the WRITABLE bit is not set, then disallow writes.
                 */
                if ((this.type & X86.DESC.ACC.TYPE.CODE) || !(this.type & X86.DESC.ACC.TYPE.WRITABLE)) {
                    this.checkWrite = this.checkWriteProtDisallowed;
                }
                /**
                 * If the CODE bit is not set *and* the EXPDOWN bit is set, then invert the limit check.
                 */
                if ((this.type & (X86.DESC.ACC.TYPE.CODE | X86.DESC.ACC.TYPE.EXPDOWN)) == X86.DESC.ACC.TYPE.EXPDOWN) {
                    if (this.checkRead == this.checkReadProt) this.checkRead = this.checkReadProtDown;
                    if (this.checkWrite == this.checkWriteProt) this.checkWrite = this.checkWriteProtDown;
                    this.fExpDown = true;
                }
                if (fLoad && this.id < Segx86.ID.VER) {
                    /**
                     * We must update the descriptor's ACCESSED bit whenever the segment is "accessed" (ie,
                     * loaded); unlike the ACCESSED and DIRTY bits in PTEs, a descriptor ACCESSED bit is only
                     * updated on loads, not on every memory access.
                     *
                     * We compute the address of the descriptor byte containing the ACCESSED bit (offset 0x5);
                     * note that it's perfectly normal for addrDesc to occasionally be invalid (eg, when the CPU
                     * is creating protected-mode-only segment registers like LDT and TSS, or when the CPU has
                     * transitioned from real-mode to protected-mode and new selector(s) have not been loaded yet).
                     *
                     * NOTE: I do NOT update the ACCESSED bit for null GDT selectors, because I'm assuming the
                     * hardware does not update it either.  In fact, I've seen code that uses the null GDT descriptor
                     * for other purposes, on the assumption that that descriptor is completely unused.
                     */
                    if ((this.sel & ~X86.SEL.RPL) && this.addrDesc !== X86.ADDR_INVALID) {
                        let addrType = this.addrDesc + X86.DESC.ACC.TYPE.OFFSET;
                        let bType = this.cpu.getByte(addrType);
                        /**
                         * This code used to ALWAYS call setByte(), but that's a waste of time if ACCESSED is already
                         * set.  TODO: It would also be nice if we could simply use the cached type value, and eliminate
                         * the getByte() call; that seems a bit risky, but I think we should still try it someday.
                         */
                        if (!(bType & (X86.DESC.ACC.TYPE.ACCESSED >> 8))) {
                            this.cpu.setByte(addrType, bType | (X86.DESC.ACC.TYPE.ACCESSED >> 8));
                        }
                    }
                }
            }

            /**
             * TODO: For non-SEG descriptors, are there other checks or functions we should establish?
             */

            /**
             * Any update to the following properties must occur only on segment loads, not simply when
             * we're updating segment registers as part of a mode change.
             */
            if (fLoad) {
                this.cpl = this.sel & X86.SEL.RPL;
                this.dpl = (this.acc & X86.DESC.ACC.DPL.MASK) >> X86.DESC.ACC.DPL.SHIFT;
                if (this.cpu.model < X86.MODEL_80386 || !(this.ext & X86.DESC.EXT.BIG)) {
                    this.sizeData = 2;
                    this.maskData = 0xffff;
                } else {
                    this.sizeData = 4;
                    this.maskData = (0xffffffff|0);
                }
                this.sizeAddr = this.sizeData;
                this.maskAddr = this.maskData;
            }
            return;
        }
        /**
         * One important feature of real-mode (as compared to V86-mode) are that other segment attributes
         * (eg, limit, operand size, address size, etc) are NOT updated, enabling features like "big real-mode"
         * (aka "unreal mode"), which is used by system software like HIMEM.SYS to access extended memory from
         * real-mode.
         */
        this.load = this.loadReal;
        this.loadIDT = this.loadIDTReal;
        this.checkRead = this.checkReadWriteReal;
        this.checkWrite = this.checkReadWriteReal;
        this.cpl = this.dpl = 0;
        this.addrDesc = X86.ADDR_INVALID;
        this.fStackSwitch = false;
    }

    /**
     * messageSeg(sel, base, limit, type, ext)
     *
     * @this {Segx86}
     * @param {number} sel
     * @param {number} base
     * @param {number} limit
     * @param {number} type
     * @param {number} [ext]
     */
    messageSeg(sel, base, limit, type, ext)
    {
        if (DEBUG) {
            let dbg = this.cpu.dbg;
            if (DEBUGGER && dbg && dbg.messageEnabled(MESSAGE.SEG)) {
                let ch = (this.sName.length < 3? " " : "");
                let sDPL = " dpl=" + this.dpl;
                if (this.id == Segx86.ID.CODE) sDPL += " cpl=" + this.cpl;
                dbg.printf(MESSAGE.SEG, "loadSeg(%s):%ssel=%#06x base=%x limit=%#06x type=%#06x%s\n", this.sName, ch, sel, base, limit, type, sDPL);
            }
            /**
             * Unless I've got a bug that's causing descriptor corruption, it appears that Windows 3.0 may be setting the
             * EXT field of descriptors, even when the processor is an 80286; eg, the EXT field below has been set to 0x000F:
             *
             *      ## ds 1bd
             *      dumpSel(0x01BD): %1101B8
             *      %001101B8  FFFF  C090  B317  000F
             *
             * So I've disabled this assert (I had already disabled the "base !== X86.ADDR_INVALID" check).
             *
             *
             */
        }
    }

    /**
     * probeDesc(sel)
     *
     * This is a neutered version of loadProt() designed for the Debugger.
     *
     * @this {Segx86}
     * @param {number} sel
     * @returns {number} base address of selected segment, or X86.ADDR_INVALID if error
     */
    probeDesc(sel)
    {
        if (DEBUGGER) {
            let addrDT;
            let addrDTLimit;
            let cpu = this.cpu;

            sel &= 0xffff;

            if (!(sel & X86.SEL.LDT)) {
                addrDT = cpu.addrGDT;
                addrDTLimit = cpu.addrGDTLimit;
            } else {
                addrDT = cpu.segLDT.base;
                addrDTLimit = (addrDT + cpu.segLDT.limit)|0;
            }

            let addrDesc = (addrDT + (sel & X86.SEL.MASK))|0;

            if ((addrDTLimit - addrDesc)|0 >= 7) {

                /**
                 * Load the descriptor from memory using probeAddr().
                 */
                let limit = cpu.probeAddr(addrDesc + X86.DESC.LIMIT.OFFSET, 2);
                let acc = cpu.probeAddr(addrDesc + X86.DESC.ACC.OFFSET, 2);
                let type = (acc & X86.DESC.ACC.TYPE.MASK);
                let base = cpu.probeAddr(addrDesc + X86.DESC.BASE.OFFSET, 2) | ((acc & X86.DESC.ACC.BASE1623) << 16);
                let ext = cpu.probeAddr(addrDesc + X86.DESC.EXT.OFFSET, 2);

                if (I386 && cpu.model >= X86.MODEL_80386) {
                    base |= (ext & X86.DESC.EXT.BASE2431) << 16;
                    limit |= (ext & X86.DESC.EXT.LIMIT1619) << 16;
                    if (ext & X86.DESC.EXT.LIMITPAGES) limit = (limit << 12) | 0xfff;
                }

                this.sel = sel;
                this.base = base;
                this.limit = limit;
                this.offMax = (limit >>> 0) + 1;
                this.acc = acc;
                this.type = type;
                this.ext = ext;
                this.addrDesc = addrDesc;
                this.updateMode(true, true, false);
                return base;
            }
        }
        return X86.ADDR_INVALID;
    }

    /**
     * loadAcc(sel, fGDT)
     *
     * this {Segx86}
     * param {number} sel (protected-mode only)
     * param {boolean} [fGDT] is true if sel must be in the GDT
     * return {number} ACC field from descriptor, or X86.DESC.ACC.INVALID if error
     *
     loadAcc(sel, fGDT)
     {
         let addrDT;
         let addrDTLimit;
         let cpu = this.cpu;

         if (!(sel & X86.SEL.LDT)) {
             addrDT = cpu.addrGDT;
             addrDTLimit = cpu.addrGDTLimit;
         } else if (!fGDT) {
             addrDT = cpu.segLDT.base;
             addrDTLimit = (addrDT + cpu.segLDT.limit)|0;
         }
         if (addrDT !== undefined) {
             let addrDesc = (addrDT + (sel & X86.SEL.MASK))|0;
             if (((addrDTLimit - addrDesc)|0) >= 7) {
                 return cpu.getShort(addrDesc + X86.DESC.ACC.OFFSET);
             }
         }
         X86.helpFault.call(cpu, X86.EXCEPTION.GP_FAULT, sel & X86.ERRCODE.SELMASK);
         return X86.DESC.ACC.INVALID;
     }
     */
}

/**
 * @copyright https://www.pcjs.org/machines/pcx86/modules/v2/x86func.js (C) 2012-2024 Jeff Parsons
 */

/**
 * fnADCb(dst, src)
 *
 * @this {CPUx86}
 * @param {number} dst
 * @param {number} src
 * @returns {number}
 */
X86.fnADCb = function(dst, src)
{
    let b = (dst + src + this.getCarry())|0;
    this.setArithResult(dst, src, b, X86.RESULT.BYTE | X86.RESULT.ALL);
    this.nStepCycles -= (this.regEAWrite === X86.ADDR_INVALID? (this.regEA === X86.ADDR_INVALID? this.cycleCounts.nOpCyclesArithRR : this.cycleCounts.nOpCyclesArithRM) : this.cycleCounts.nOpCyclesArithMR);
    return b & 0xff;
};

/**
 * fnADCw(dst, src)
 *
 * @this {CPUx86}
 * @param {number} dst
 * @param {number} src
 * @returns {number}
 */
X86.fnADCw = function(dst, src)
{
    let w = (dst + src + this.getCarry())|0;
    this.setArithResult(dst, src, w, this.typeData | X86.RESULT.ALL);
    this.nStepCycles -= (this.regEAWrite === X86.ADDR_INVALID? (this.regEA === X86.ADDR_INVALID? this.cycleCounts.nOpCyclesArithRR : this.cycleCounts.nOpCyclesArithRM) : this.cycleCounts.nOpCyclesArithMR);
    return w & this.maskData;
};

/**
 * fnADDb(dst, src)
 *
 * @this {CPUx86}
 * @param {number} dst
 * @param {number} src
 * @returns {number}
 */
X86.fnADDb = function(dst, src)
{
    let b = (dst + src)|0;
    this.setArithResult(dst, src, b, X86.RESULT.BYTE | X86.RESULT.ALL);
    this.nStepCycles -= (this.regEAWrite === X86.ADDR_INVALID? (this.regEA === X86.ADDR_INVALID? this.cycleCounts.nOpCyclesArithRR : this.cycleCounts.nOpCyclesArithRM) : this.cycleCounts.nOpCyclesArithMR);
    return b & 0xff;
};

/**
 * fnADDw(dst, src)
 *
 * @this {CPUx86}
 * @param {number} dst
 * @param {number} src
 * @returns {number}
 */
X86.fnADDw = function(dst, src)
{
    let w = (dst + src)|0;
    this.setArithResult(dst, src, w, this.typeData | X86.RESULT.ALL);
    this.nStepCycles -= (this.regEAWrite === X86.ADDR_INVALID? (this.regEA === X86.ADDR_INVALID? this.cycleCounts.nOpCyclesArithRR : this.cycleCounts.nOpCyclesArithRM) : this.cycleCounts.nOpCyclesArithMR);
    return w & this.maskData;
};

/**
 * fnANDb(dst, src)
 *
 * @this {CPUx86}
 * @param {number} dst
 * @param {number} src
 * @returns {number}
 */
X86.fnANDb = function(dst, src)
{
    let b = dst & src;
    this.setLogicResult(b, X86.RESULT.BYTE);
    this.nStepCycles -= (this.regEAWrite === X86.ADDR_INVALID? (this.regEA === X86.ADDR_INVALID? this.cycleCounts.nOpCyclesArithRR : this.cycleCounts.nOpCyclesArithRM) : this.cycleCounts.nOpCyclesArithMR);
    return b;
};

/**
 * fnANDw(dst, src)
 *
 * @this {CPUx86}
 * @param {number} dst
 * @param {number} src
 * @returns {number}
 */
X86.fnANDw = function(dst, src)
{
    this.nStepCycles -= (this.regEAWrite === X86.ADDR_INVALID? (this.regEA === X86.ADDR_INVALID? this.cycleCounts.nOpCyclesArithRR : this.cycleCounts.nOpCyclesArithRM) : this.cycleCounts.nOpCyclesArithMR);
    return this.setLogicResult(dst & src, this.typeData) & this.maskData;
};

/**
 * fnARPL(dst, src)
 *
 * @this {CPUx86}
 * @param {number} dst
 * @param {number} src
 * @returns {number}
 */
X86.fnARPL = function(dst, src)
{
    this.nStepCycles -= (10 + (this.regEA === X86.ADDR_INVALID? 0 : 1));
    if ((dst & X86.SEL.RPL) < (src & X86.SEL.RPL)) {
        dst = (dst & ~X86.SEL.RPL) | (src & X86.SEL.RPL);
        this.setZF();
        return dst;
    }
    this.clearZF();
    return dst;
};

/**
 * fnBOUND(dst, src)
 *
 * @this {CPUx86}
 * @param {number} dst
 * @param {number} src
 * @returns {number}
 */
X86.fnBOUND = function(dst, src)
{
    if (this.regEA === X86.ADDR_INVALID) {
        /**
         * Generate UD_FAULT (INT 0x06: Invalid Opcode) if src is not a memory operand.
         */
        X86.opInvalid.call(this);
        return dst;
    }
    /**
     * Note that BOUND performs signed comparisons, so we must transform all arguments into signed values.
     */
    let wIndex = dst;
    let wLower = this.getWord(this.regEA);
    let wUpper = this.getWord(this.regEA + this.sizeData);
    if (this.sizeData == 2) {
        wIndex = (dst << 16) >> 16;
        wLower = (wLower << 16) >> 16;
        wUpper = (wUpper << 16) >> 16;
    }
    this.nStepCycles -= this.cycleCounts.nOpCyclesBound;
    if (wIndex < wLower || wIndex > wUpper) {
        /**
         * The INT 0x05 handler must be called with CS:IP pointing to the BOUND instruction.
         *
         * TODO: Determine the cycle cost when a BOUND exception is triggered, over and above nCyclesBound,
         * and then call X86.helpFault(X86.EXCEPTION.BR_FAULT, null, nCycles).
         */
        X86.helpFault.call(this, X86.EXCEPTION.BR_FAULT);
    }
    this.opFlags |= X86.OPFLAG.NOWRITE;
    return dst;
};

/**
 * fnBSF(dst, src)
 *
 * Scan src starting at bit 0.  If a set bit is found, the bit index is stored in dst and ZF is cleared;
 * otherwise, ZF is set and dst is unchanged.
 *
 * NOTES: Early versions of the 80386 manuals misstated how ZF was set/cleared.  Also, Intel insists that
 * dst is undefined whenever ZF is set, but in fact, the 80386 leaves dst unchanged when that happens;
 * unfortunately, some early 80486s would always modify dst, so it is unsafe to rely on dst when ZF is set.
 *
 * @this {CPUx86}
 * @param {number} dst
 * @param {number} src
 * @returns {number}
 */
X86.fnBSF = function(dst, src)
{
    let n = 0;
    if (!src) {
        this.setZF();
    } else {
        this.clearZF();
        let bit = 0x1;
        while (bit & this.maskData) {
            if (src & bit) {
                dst = n;
                break;
            }
            bit <<= 1;
            n++;                // TODO: Determine if n should be incremented before the bailout for an accurate cycle count
        }
    }
    this.nStepCycles -= 11 + n * 3;
    return dst;
};

/**
 * fnBSR(dst, src)
 *
 * Scan src starting from the highest bit.  If a set bit is found, the bit index is stored in dst and ZF is
 * cleared; otherwise, ZF is set and dst is unchanged.
 *
 * NOTES: Early versions of the 80386 manuals misstated how ZF was set/cleared.  Also, Intel insists that
 * dst is undefined whenever ZF is set, but in fact, the 80386 leaves dst unchanged when that happens;
 * unfortunately, some early 80486s would always modify dst, so it is unsafe to rely on dst when ZF is set.
 *
 * @this {CPUx86}
 * @param {number} dst
 * @param {number} src
 * @returns {number}
 */
X86.fnBSR = function(dst, src)
{
    let n = 0;
    if (!src) {
        this.setZF();
    } else {
        this.clearZF();
        let i = (this.sizeData == 2? 15 : 31), bit = 1 << i;
        while (bit) {
            if (src & bit) {
                dst = i;
                break;
            }
            bit >>>= 1;
            n++; i--;           // TODO: Determine if n should be incremented before the bailout for an accurate cycle count
        }

    }
    this.nStepCycles -= 11 + n * 3;
    return dst;
};

/**
 * fnBT(dst, src)
 *
 * In this form of BT, src is an immediate operand (OR dst is register operand); immediate operands
 * are supposed to be masked with either 0xf or 0x1f for 16-bit or 32-bit operands, respectively.
 *
 * @this {CPUx86}
 * @param {number} dst
 * @param {number} src
 * @returns {number}
 */
X86.fnBT = function(dst, src)
{
    let bit = 1 << (src & (this.sizeData == 2? 0xf : 0x1f));
    if (dst & bit) this.setCF(); else this.clearCF();
    this.nStepCycles -= (this.regEA === X86.ADDR_INVALID? 3 : 6);
    this.opFlags |= X86.OPFLAG.NOWRITE;
    return dst;
};

/**
 * fnBTC(dst, src)
 *
 * In this form of BTC, src is an immediate operand (OR dst is register operand); immediate operands
 * are supposed to be masked with either 0xf or 0x1f for 16-bit or 32-bit operands, respectively.
 *
 * @this {CPUx86}
 * @param {number} dst
 * @param {number} src
 * @returns {number}
 */
X86.fnBTC = function(dst, src)
{
    let bit = 1 << (src & (this.sizeData == 2? 0xf : 0x1f));
    if (dst & bit) this.setCF(); else this.clearCF();
    this.nStepCycles -= (this.regEA === X86.ADDR_INVALID? 6 : 8);
    return dst ^ bit;
};

/**
 * fnBTR(dst, src)
 *
 * In this form of BTR, src is an immediate operand (OR dst is register operand); immediate operands
 * are supposed to be masked with either 0xf or 0x1f for 16-bit or 32-bit operands, respectively.
 *
 * @this {CPUx86}
 * @param {number} dst
 * @param {number} src
 * @returns {number}
 */
X86.fnBTR = function(dst, src)
{
    let bit = 1 << (src & (this.sizeData == 2? 0xf : 0x1f));
    if (dst & bit) this.setCF(); else this.clearCF();
    this.nStepCycles -= (this.regEA === X86.ADDR_INVALID? 6 : 8);
    return dst & ~bit;
};

/**
 * fnBTS(dst, src)
 *
 * In this form of BTS, src is an immediate operand (OR dst is register operand); immediate operands
 * are supposed to be masked with either 0xf or 0x1f for 16-bit or 32-bit operands, respectively.
 *
 * @this {CPUx86}
 * @param {number} dst
 * @param {number} src
 * @returns {number}
 */
X86.fnBTS = function(dst, src)
{
    let bit = 1 << (src & (this.sizeData == 2? 0xf : 0x1f));
    if (dst & bit) this.setCF(); else this.clearCF();
    this.nStepCycles -= (this.regEA === X86.ADDR_INVALID? 6 : 8);
    return dst | bit;
};

/**
 * fnBTMem(dst, src)
 *
 * In this form of BT, src is a register operand, which is NOT truncated if dst is a memory operand;
 * however, if dst is also a register operand, then we defer to the simpler function, fnBT().
 *
 * @this {CPUx86}
 * @param {number} dst
 * @param {number} src
 * @returns {number}
 */
X86.fnBTMem = function(dst, src)
{
    if (this.regEA === X86.ADDR_INVALID) {
        return X86.fnBT.call(this, dst, src);
    }
    /**
     * TODO: Consider a worker function that performs the following block of code for: BT, BTC, BTR, and BTS.
     * It's somewhat inconvenient, because it needs to provide two results: an updated src AND an updated dst.
     *
     * src is usually positive BUT can also be negative (as the IA32 spec says: "The offset operand then selects
     * a bit position within the range â231 to 231 â 1 for a register offset and 0 to 31 for an immediate offset.")
     */
    let max = this.sizeData << 3;
    if (src >= max || src < -max) {
        /**
         * Now we need to divide src by 16 or 32, according to the OPERAND size, which means shifting it right
         * by either 4 or 5 bits.  That gives us a short or long INDEX, which we then multiply by the OPERAND size
         * to obtain to the corresponding short or long OFFSET that we must add to the original EA offset.
         */
        let i = src >> (this.sizeData == 2? 4 : 5);
        dst = this.getEAWord(this.segEA, this.offEA + i * this.sizeData);
    }
    /**
     * Now we convert src from a bit index to a bit mask.
     */
    src = 1 << (src & (this.sizeData == 2? 0xf : 0x1f));
    if (dst & src) this.setCF(); else this.clearCF();

    this.nStepCycles -= 6;
    this.opFlags |= X86.OPFLAG.NOWRITE;
    return dst;
};

/**
 * fnBTCMem(dst, src)
 *
 * In this form of BTC, src is a register operand, which is NOT truncated if dst is a memory operand;
 * however, if dst is also a register operand, then we defer to the simpler function, fnBTC().
 *
 * @this {CPUx86}
 * @param {number} dst
 * @param {number} src
 * @returns {number}
 */
X86.fnBTCMem = function(dst, src)
{
    if (this.regEA === X86.ADDR_INVALID) {
        return X86.fnBTC.call(this, dst, src);
    }
    /**
     * src is usually positive BUT can also be negative (as the IA32 spec says: "The offset operand then selects
     * a bit position within the range â231 to 231 â 1 for a register offset and 0 to 31 for an immediate offset.")
     */
    let max = this.sizeData << 3;
    if (src >= max || src < -max) {
        /**
         * Now we need to divide src by 16 or 32, according to the OPERAND size, which means shifting it right
         * by either 4 or 5 bits.  That gives us a short or long INDEX, which we then multiply by the OPERAND size
         * to obtain to the corresponding short or long OFFSET that we must add to the original EA offset.
         */
        let i = src >> (this.sizeData == 2? 4 : 5);
        dst = this.getEAWord(this.segEA, this.offEA + i * this.sizeData);
    }
    /**
     * Now we convert src from a bit index to a bit mask.
     */
    src = 1 << (src & (this.sizeData == 2? 0xf : 0x1f));
    if (dst & src) this.setCF(); else this.clearCF();

    this.nStepCycles -= 8;
    return dst ^ src;
};

/**
 * fnBTRMem(dst, src)
 *
 * In this form of BTR, src is a register operand, which is NOT truncated if dst is a memory operand;
 * however, if dst is also a register operand, then we defer to the simpler function, fnBTR().
 *
 * @this {CPUx86}
 * @param {number} dst
 * @param {number} src
 * @returns {number}
 */
X86.fnBTRMem = function(dst, src)
{
    if (this.regEA === X86.ADDR_INVALID) {
        return X86.fnBTR.call(this, dst, src);
    }
    /**
     * src is usually positive BUT can also be negative (as the IA32 spec says: "The offset operand then selects
     * a bit position within the range â231 to 231 â 1 for a register offset and 0 to 31 for an immediate offset.")
     */
    let max = this.sizeData << 3;
    if (src >= max || src < -max) {
        /**
         * Now we need to divide src by 16 or 32, according to the OPERAND size, which means shifting it right
         * by either 4 or 5 bits.  That gives us a short or long INDEX, which we then multiply by the OPERAND size
         * to obtain to the corresponding short or long OFFSET that we must add to the original EA offset.
         */
        let i = src >> (this.sizeData == 2? 4 : 5);
        dst = this.getEAWord(this.segEA, this.offEA + i * this.sizeData);
    }
    /**
     * Now we convert src from a bit index to a bit mask.
     */
    src = 1 << (src & (this.sizeData == 2? 0xf : 0x1f));
    if (dst & src) this.setCF(); else this.clearCF();

    this.nStepCycles -= 8;
    return dst & ~src;
};

/**
 * fnBTSMem(dst, src)
 *
 * In this form of BTS, src is a register operand, which is NOT truncated if dst is a memory operand;
 * however, if dst is also a register operand, then we defer to the simpler function, fnBTS().
 *
 * @this {CPUx86}
 * @param {number} dst
 * @param {number} src
 * @returns {number}
 */
X86.fnBTSMem = function(dst, src)
{
    if (this.regEA === X86.ADDR_INVALID) {
        return X86.fnBTS.call(this, dst, src);
    }
    /**
     * src is usually positive BUT can also be negative (as the IA32 spec says: "The offset operand then selects
     * a bit position within the range â231 to 231 â 1 for a register offset and 0 to 31 for an immediate offset.")
     */
    let max = this.sizeData << 3;
    if (src >= max || src < -max) {
        /**
         * Now we need to divide src by 16 or 32, according to the OPERAND size, which means shifting it right
         * by either 4 or 5 bits.  That gives us a short or long INDEX, which we then multiply by the OPERAND size
         * to obtain to the corresponding short or long OFFSET that we must add to the original EA offset.
         */
        let i = src >> (this.sizeData == 2? 4 : 5);
        dst = this.getEAWord(this.segEA, this.offEA + i * this.sizeData);
    }
    /**
     * Now we convert src from a bit index to a bit mask.
     */
    src = 1 << (src & (this.sizeData == 2? 0xf : 0x1f));
    if (dst & src) this.setCF(); else this.clearCF();

    this.nStepCycles -= 8;
    return dst | src;
};

/**
 * fnCALLw(dst, src)
 *
 * @this {CPUx86}
 * @param {number} dst
 * @param {number} src (null)
 * @returns {number}
 */
X86.fnCALLw = function(dst, src)
{
    this.pushWord(this.getIP());
    this.setIP(dst);
    this.nStepCycles -= (this.regEA === X86.ADDR_INVALID? this.cycleCounts.nOpCyclesCallWR : this.cycleCounts.nOpCyclesCallWM);
    this.opFlags |= X86.OPFLAG.NOWRITE;
    return dst;
};

/**
 * fnCALLFdw(dst, src)
 *
 * @this {CPUx86}
 * @param {number} dst
 * @param {number} src (null)
 * @returns {number}
 */
X86.fnCALLFdw = function(dst, src)
{
    if (this.regEA === X86.ADDR_INVALID) {
        return X86.fnGRPUndefined.call(this, dst, src);
    }
    /**
     * Originally, we would snapshot regLSP into opLSP because helpCALLF() could trigger a segment fault,
     * but additionally, the stack segment could trigger either a segment fault or a page fault; indeed,
     * any operation that performs multiple stack modifications must take this precaution and snapshot regLSP.
     */
    this.opLSP = this.regLSP;

    X86.helpCALLF.call(this, dst, this.getShort(this.regEA + this.sizeData));
    this.nStepCycles -= this.cycleCounts.nOpCyclesCallDM;
    this.opFlags |= X86.OPFLAG.NOWRITE;

    this.opLSP = X86.ADDR_INVALID;
    return dst;
};

/**
 * fnCMPb(dst, src)
 *
 * @this {CPUx86}
 * @param {number} dst
 * @param {number} src
 * @returns {number} dst unchanged
 */
X86.fnCMPb = function(dst, src)
{
    let b = (dst - src)|0;
    this.setArithResult(dst, src, b, X86.RESULT.BYTE | X86.RESULT.ALL, true);
    this.nStepCycles -= (this.regEAWrite === X86.ADDR_INVALID? (this.regEA === X86.ADDR_INVALID? this.cycleCounts.nOpCyclesArithRR : this.cycleCounts.nOpCyclesCompareRM) : this.cycleCounts.nOpCyclesArithRM);
    this.opFlags |= X86.OPFLAG.NOWRITE;
    return dst;
};

/**
 * fnCMPw(dst, src)
 *
 * @this {CPUx86}
 * @param {number} dst
 * @param {number} src
 * @returns {number} dst unchanged
 */
X86.fnCMPw = function(dst, src)
{
    let w = (dst - src)|0;
    this.setArithResult(dst, src, w, this.typeData | X86.RESULT.ALL, true);
    this.nStepCycles -= (this.regEAWrite === X86.ADDR_INVALID? (this.regEA === X86.ADDR_INVALID? this.cycleCounts.nOpCyclesArithRR : this.cycleCounts.nOpCyclesCompareRM) : this.cycleCounts.nOpCyclesArithRM);
    this.opFlags |= X86.OPFLAG.NOWRITE;
    return dst;
};

/**
 * fnDECb(dst, src)
 *
 * @this {CPUx86}
 * @param {number} dst
 * @param {number} src (null)
 * @returns {number}
 */
X86.fnDECb = function(dst, src)
{
    let b = (dst - 1)|0;
    this.setArithResult(dst, 1, b, X86.RESULT.BYTE | X86.RESULT.NOTCF, true);
    this.nStepCycles -= (this.regEA === X86.ADDR_INVALID? this.cycleCounts.nOpCyclesIncR : this.cycleCounts.nOpCyclesIncM);
    return b & 0xff;
};

/**
 * fnDECw(dst, src)
 *
 * @this {CPUx86}
 * @param {number} dst
 * @param {number} src (null)
 * @returns {number}
 */
X86.fnDECw = function(dst, src)
{
    let w = (dst - 1)|0;
    this.setArithResult(dst, 1, w, this.typeData | X86.RESULT.NOTCF, true);
    this.nStepCycles -= (this.regEA === X86.ADDR_INVALID? this.cycleCounts.nOpCyclesIncR : this.cycleCounts.nOpCyclesIncM);
    return w & this.maskData;
};

/**
 * fnDIVb(dst, src)
 *
 * @this {CPUx86}
 * @param {number} dst (the divisor)
 * @param {number} src (null; AX is the implied src)
 * @returns {number} (we return dst unchanged, since it's actually AX that's modified)
 */
X86.fnDIVb = function(dst, src)
{
    /**
     * Detect zero divisor
     */
    if (!dst) {
        X86.helpDIVOverflow.call(this);
        return dst;
    }

    /**
     * Detect too-small divisor (quotient overflow)
     */
    let result = ((src = this.regEAX & 0xffff) / dst);
    if (result > 0xff) {
        X86.helpDIVOverflow.call(this);
        return dst;
    }

    this.regMDLo = (result & 0xff) | (((src % dst) & 0xff) << 8);
    this.fMDSet = true;

    this.nStepCycles -= (this.regEA === X86.ADDR_INVALID? this.cycleCounts.nOpCyclesDivBR : this.cycleCounts.nOpCyclesDivBM);
    this.opFlags |= X86.OPFLAG.NOWRITE;
    return dst;
};

/**
 * fnDIVw(dst, src)
 *
 * @this {CPUx86}
 * @param {number} dst (the divisor)
 * @param {number} src (null; DX:AX or EDX:EAX is the implied src)
 * @returns {number} (we return dst unchanged, since it's actually DX:AX that's modified)
 */
X86.fnDIVw = function(dst, src)
{
    if (this.sizeData == 2) {
        /**
         * Detect zero divisor
         */
        if (!dst) {
            X86.helpDIVOverflow.call(this);
            return dst;
        }
        /**
         * Detect too-small divisor (quotient overflow)
         *
         * WARNING: We CANNOT simply do "src = (this.regEDX << 16) | this.regEAX", because if bit 15 of DX
         * is set, JavaScript will create a negative 32-bit number.  So we instead use non-bitwise operators
         * to force JavaScript to create a floating-point value that won't suffer from 32-bit-math side-effects.
         */
        src = (this.regEDX & 0xffff) * 0x10000 + (this.regEAX & 0xffff);
        let result = (src / dst);
        if (result >= 0x10000) {
            X86.helpDIVOverflow.call(this);
            return dst;
        }
        this.regMDLo = (result & 0xffff);
        this.regMDHi = (src % dst) & 0xffff;
    }
    else {
        if (!X86.helpDIV32.call(this, this.regEAX, this.regEDX, dst)) {
            X86.helpDIVOverflow.call(this);
            return dst;
        }
        this.regMDLo |= 0;
        this.regMDHi |= 0;
    }

    this.fMDSet = true;

    this.nStepCycles -= (this.regEA === X86.ADDR_INVALID? this.cycleCounts.nOpCyclesDivWR : this.cycleCounts.nOpCyclesDivWM);
    this.opFlags |= X86.OPFLAG.NOWRITE;
    return dst;
};

/**
 * fnESC(dst, src)
 *
 * @this {CPUx86}
 * @param {number} dst
 * @param {number} src
 * @returns {number} dst unchanged
 */
X86.fnESC = function(dst, src)
{
    if (this.fpuActive) {
        this.fpuActive.opFPU(this.bOpcode, this.bModRM, dst, src);
    }
    this.nStepCycles -= (this.regEA === X86.ADDR_INVALID? 2 : 8);
    return dst;
};

/**
 * fnGRPFault(dst, src)
 *
 * @this {CPUx86}
 * @param {number} dst
 * @param {number} src
 * @returns {number}
 */
X86.fnGRPFault = function(dst, src)
{
    /**
     * This should NEVER be called on 8086/8088 CPUs, and yet we preset some of the handlers in aOpGrpPOPw,
     * aOpGrp4b, and aOpGrp4w to call it.  initProcessor() DOES patch aOpGrp4b[0x07] and aOpGrp4w[0x07] to
     * fnGRPInvalid, but that's it.
     *
     * However, given the infrequency of this call, it's simpler to continue presetting all the handlers in
     * aOpGrpPOPw to their post-8086 default, and deal with the appropriate 8086 behavior here (which for now,
     * is to call fnGRPUndefined instead).
     */
    if (this.model < X86.MODEL_80186) {
        return X86.fnGRPUndefined.call(this, dst, src);
    }
    X86.helpFault.call(this, X86.EXCEPTION.GP_FAULT, 0);
    return dst;
};

/**
 * fnGRPInvalid(dst, src)
 *
 * @this {CPUx86}
 * @param {number} dst
 * @param {number} src
 * @returns {number}
 */
X86.fnGRPInvalid = function(dst, src)
{
    X86.opInvalid.call(this);
    return dst;
};

/**
 * fnGRPUndefined(dst, src)
 *
 * @this {CPUx86}
 * @param {number} dst
 * @param {number} src
 * @returns {number}
 */
X86.fnGRPUndefined = function(dst, src)
{
    X86.opUndefined.call(this);
    return dst;
};

/**
 * fnIDIVb(dst, src)
 *
 * @this {CPUx86}
 * @param {number} dst (the divisor)
 * @param {number} src (null; AX is the implied src)
 * @returns {number} (we return dst unchanged, since it's actually AX that's modified)
 */
X86.fnIDIVb = function(dst, src)
{
    /**
     * Detect zero divisor
     */
    if (!dst) {
        X86.helpDIVOverflow.call(this);
        return dst;
    }

    /**
     * Detect too-small divisor (quotient overflow)
     */
    let div = ((dst << 24) >> 24);
    let result = ((src = (this.regEAX << 16) >> 16) / div)|0;

    /**
     * Note the following difference, from "AP-186: Introduction to the 80186 Microprocessor, March 1983":
     *
     *      "The 8086 will cause a divide error whenever the absolute value of the quotient is greater then 7FFFH
     *      (for word operations) or if the absolute value of the quotient is greater than 7FH (for byte operations).
     *      The 80186 has expanded the range of negative numbers allowed as a quotient by 1 to include 8000H and 80H.
     *      These numbers represent the most negative numbers representable using 2's complement arithmetic (equaling
     *      -32768 and -128 in decimal, respectively)."
     */
    if (result != ((result << 24) >> 24) || this.model <= X86.MODEL_8088 && result == -128) {
        X86.helpDIVOverflow.call(this);
        return dst;
    }

    this.regMDLo = (result & 0xff) | (((src % div) & 0xff) << 8);
    this.fMDSet = true;

    this.nStepCycles -= (this.regEA === X86.ADDR_INVALID? this.cycleCounts.nOpCyclesIDivBR : this.cycleCounts.nOpCyclesIDivBM);
    this.opFlags |= X86.OPFLAG.NOWRITE;
    return dst;
};

/**
 * fnIDIVw(dst, src)
 *
 * @this {CPUx86}
 * @param {number} dst (the divisor)
 * @param {number} src (null; DX:AX or EDX:EAX is the implied src)
 * @returns {number} (we return dst unchanged, since it's actually DX:AX that's modified)
 */
X86.fnIDIVw = function(dst, src)
{
    if (this.sizeData == 2) {
        /**
         * Detect zero divisor
         */
        if (!dst) {
            X86.helpDIVOverflow.call(this);
            return dst;
        }

        /**
         * Detect too-small divisor (quotient overflow)
         */
        let div = ((dst << 16) >> 16);
        let result = ((src = (this.regEDX << 16) | (this.regEAX & 0xffff)) / div)|0;

        /**
         * Note the following difference, from "AP-186: Introduction to the 80186 Microprocessor, March 1983":
         *
         *      "The 8086 will cause a divide error whenever the absolute value of the quotient is greater then 7FFFH
         *      (for word operations) or if the absolute value of the quotient is greater than 7FH (for byte operations).
         *      The 80186 has expanded the range of negative numbers allowed as a quotient by 1 to include 8000H and 80H.
         *      These numbers represent the most negative numbers representable using 2's complement arithmetic (equaling
         *      -32768 and -128 in decimal, respectively)."
         */
        if (result != ((result << 16) >> 16) || this.model <= X86.MODEL_8088 && result == -32768) {
            X86.helpDIVOverflow.call(this);
            return dst;
        }

        this.regMDLo = (result & 0xffff);
        this.regMDHi = (src % div) & 0xffff;
    }
    else {
        if (!X86.helpIDIV32.call(this, this.regEAX, this.regEDX, dst)) {
            X86.helpDIVOverflow.call(this);
            return dst;
        }
        this.regMDLo |= 0;
        this.regMDHi |= 0;
    }

    this.fMDSet = true;

    this.nStepCycles -= (this.regEA === X86.ADDR_INVALID? this.cycleCounts.nOpCyclesIDivWR : this.cycleCounts.nOpCyclesIDivWM);
    this.opFlags |= X86.OPFLAG.NOWRITE;
    return dst;
};

/**
 * fnIMUL8(dst, src)
 *
 * 80286_and_80287_Programmers_Reference_Manual_1987.pdf, p.B-44 (p.254) notes that:
 *
 *      "The low 16 bits of the product of a 16-bit signed multiply are the same as those of an
 *      unsigned multiply. The three operand IMUL instruction can be used for unsigned operands as well."
 *
 * However, we still sign-extend the operands before multiplying, making it easier to range-check the result.
 *
 * (80186/80188 and up)
 *
 * @this {CPUx86}
 * @param {number} dst
 * @param {number} src
 * @returns {number}
 */
X86.fnIMUL8 = function(dst, src)
{
    /**
     * NOTE: getIPDisp() already sign-extends the dst parameter, so fnIMULrw() needlessly sign-extends it again;
     * a small price to pay for a common function.
     */
    let result = X86.fnIMULrw.call(this, this.getIPDisp(), src);

    /**
     * NOTE: The above function already accounted for the 80386 cycle count, so we are simply accounting for the
     * increased time on an 80286; the 80186/80188 have even larger values, but we'll worry about that another day.
     */
    if (this.model < X86.MODEL_80386) this.nStepCycles -= 12;
    return result;
};

/**
 * fnIMULn(dst, src)
 *
 * 80286_and_80287_Programmers_Reference_Manual_1987.pdf, p.B-44 (p.254) notes that:
 *
 *      "The low 16 bits of the product of a 16-bit signed multiply are the same as those of an
 *      unsigned multiply. The three operand IMUL instruction can be used for unsigned operands as well."
 *
 * However, we still sign-extend the operands before multiplying, making it easier to range-check the result.
 *
 * (80186/80188 and up)
 *
 * @this {CPUx86}
 * @param {number} dst (not used)
 * @param {number} src
 * @returns {number}
 */
X86.fnIMULn = function(dst, src)
{
    let result;
    dst = this.getIPWord();

    if (this.sizeData == 2) {
        result = X86.fnIMULrw.call(this, dst, src);
    } else {
        result = X86.fnIMULrd.call(this, dst, src);
    }

    /**
     * NOTE: The above functions already accounted for 80386 cycle counts, so we are simply accounting for the
     * increased time on an 80286; the 80186/80188 have even larger values, but we'll worry about that another day.
     */
    if (this.model < X86.MODEL_80386) this.nStepCycles -= 12;
    return result;
};

/**
 * fnIMUL32(dst, src)
 *
 * This sets regMDHi:regMDLo to the 64-bit result of dst * src, both of which are treated as signed.
 *
 * @this {CPUx86}
 * @param {number} dst (any 32-bit number, treated as signed)
 * @param {number} src (any 32-bit number, treated as signed)
 */
X86.fnIMUL32 = function(dst, src)
{
    let fNeg = false;
    if (src < 0) {
        src = -src|0;
        fNeg = !fNeg;
    }
    if (dst < 0) {
        dst = -dst|0;
        fNeg = !fNeg;
    }
    X86.fnMUL32.call(this, dst, src);
    if (fNeg) {
        this.regMDLo = (~this.regMDLo + 1)|0;
        this.regMDHi = (~this.regMDHi + (this.regMDLo? 0 : 1))|0;
    }
};

/**
 * fnIMULb(dst, src)
 *
 * This 16-bit multiplication must indicate when the upper 8 bits are simply a sign-extension of the
 * lower 8 bits (carry clear) and when the upper 8 bits contain significant bits (carry set).  The latter
 * will occur whenever a positive result is > 127 (0x007f) and whenever a negative result is < -128
 * (0xff80).
 *
 * Example 1: 16 * 4 = 64 (0x0040): carry is clear
 * Example 2: 16 * 8 = 128 (0x0080): carry is set (the sign bit no longer fits in the lower 8 bits)
 * Example 3: 16 * -8 (0xf8) = -128 (0xff80): carry is clear (the sign bit *still* fits in the lower 8 bits)
 * Example 4: 16 * -16 (0xf0) = -256 (0xff00): carry is set (the sign bit no longer fits in the lower 8 bits)
 *
 * @this {CPUx86}
 * @param {number} dst
 * @param {number} src (null; AL is the implied src)
 * @returns {number} (we return dst unchanged, since it's actually AX that's modified)
 */
X86.fnIMULb = function(dst, src)
{
    let result = (((this.regEAX << 24) >> 24) * ((dst << 24) >> 24))|0;
    this.regMDLo = result & 0xffff;
    if (result > 127 || result < -128) {
        this.setCF(); this.setOF();
    } else {
        this.clearCF(); this.clearOF();
    }
    if (this.model <= X86.MODEL_8088) {
        this.clearZF();         // differentiate ourselves from a NEC V20
    }
    this.fMDSet = true;
    this.nStepCycles -= (this.regEA === X86.ADDR_INVALID? this.cycleCounts.nOpCyclesIMulBR : this.cycleCounts.nOpCyclesIMulBM);
    this.opFlags |= X86.OPFLAG.NOWRITE;
    return dst;
};

/**
 * fnIMULw(dst, src)
 *
 * regMDHi:regMDLo = dst * regEAX
 *
 * This 32-bit multiplication must indicate when the upper 16 bits are simply a sign-extension of the
 * lower 16 bits (carry clear) and when the upper 16 bits contain significant bits (carry set).  The latter
 * will occur whenever a positive result is > 32767 (0x00007fff) and whenever a negative result is < -32768
 * (0xffff8000).
 *
 * Example 1: 256 * 64 = 16384 (0x00004000): carry is clear
 * Example 2: 256 * 128 = 32768 (0x00008000): carry is set (the sign bit no longer fits in the lower 16 bits)
 * Example 3: 256 * -128 (0xff80) = -32768 (0xffff8000): carry is clear (the sign bit *still* fits in the lower 16 bits)
 * Example 4: 256 * -256 (0xff00) = -65536 (0xffff0000): carry is set (the sign bit no longer fits in the lower 16 bits)
 *
 * @this {CPUx86}
 * @param {number} dst
 * @param {number} src (null; AX or EAX is the implied src)
 * @returns {number} (we return dst unchanged, since it's actually DX:AX or EDX:EAX that's modified)
 */
X86.fnIMULw = function(dst, src)
{
    let fOverflow;
    if (this.sizeData == 2) {
        src = this.regEAX & 0xffff;
        let result = (((src << 16) >> 16) * ((dst << 16) >> 16))|0;
        this.regMDLo = result & 0xffff;
        this.regMDHi = (result >> 16) & 0xffff;
        fOverflow = (result > 32767 || result < -32768);
    } else {
        X86.fnIMUL32.call(this, dst, this.regEAX);
        fOverflow = (this.regMDHi != (this.regMDLo >> 31));
    }
    if (fOverflow) {
        this.setCF(); this.setOF();
    } else {
        this.clearCF(); this.clearOF();
    }
    if (this.model <= X86.MODEL_8088) {
        this.clearZF();         // differentiate ourselves from a NEC V20
    }
    this.fMDSet = true;
    this.nStepCycles -= (this.regEA === X86.ADDR_INVALID? this.cycleCounts.nOpCyclesIMulWR : this.cycleCounts.nOpCyclesIMulWM);
    this.opFlags |= X86.OPFLAG.NOWRITE;
    return dst;
};

/**
 * fnIMULrw(dst, src)
 *
 * This function exists for 16-bit IMUL instructions that produce a 16-bit result instead of a 32-bit result
 * (and don't implicitly use the accumulator).
 *
 * @this {CPUx86}
 * @param {number} dst
 * @param {number} src
 * @returns {number}
 */
X86.fnIMULrw = function(dst, src)
{
    /**
     * Unlike fnIMULrd() below, we can use normal JavaScript multiplication, because there's no danger of
     * overflowing the floating-point result and losing accuracy in the bottom 16 bits.
     */
    let result = (((dst << 16) >> 16) * ((src << 16) >> 16))|0;
    if (result > 32767 || result < -32768) {
        this.setCF(); this.setOF();
    } else {
        this.clearCF(); this.clearOF();
    }
    result &= 0xffff;
    this.nStepCycles -= (this.regEA === X86.ADDR_INVALID? 9 : 12);
    return result;
};

/**
 * fnIMULrd(dst, src)
 *
 * This function exists for 32-bit IMUL instructions that produce a 32-bit result instead of a 64-bit result
 * (and don't implicitly use the accumulator).
 *
 * @this {CPUx86}
 * @param {number} dst
 * @param {number} src
 * @returns {number}
 */
X86.fnIMULrd = function(dst, src)
{
    /**
     * The following code works, but I've stopped using it because it produces different results from an actual CPU
     * when overflow occurs; the bottom 32 bits of the result are still supposed to be accurate.
     *
     * And unfortunately, we cannot achieve that level of compatibility using normal JavaScript multiplication,
     * because the result may be too large to fit in a JavaScript floating-point variable, which means we could lose
     * accuracy in the bottom 32 bits, which would defeat what we're trying to achieve here.  So we must use the
     * slower fnIMUL32() function.
     *
     *      let result = dst * src;
     *      if (result > 2147483647 || result < -2147483648) {
     *          this.setCF(); this.setOF();
     *      } else {
     *          this.clearCF(); this.clearOF();
     *      }
     *      result |= 0;
     */
    X86.fnIMUL32.call(this, dst, src);
    let fOverflow = (this.regMDHi != (this.regMDLo >> 31));
    if (fOverflow) {
        this.setCF(); this.setOF();
    } else {
        this.clearCF(); this.clearOF();
    }
    this.nStepCycles -= (this.regEA === X86.ADDR_INVALID? 9 : 12);
    return this.regMDLo;
};

/**
 * fnINCb(dst, src)
 *
 * @this {CPUx86}
 * @param {number} dst
 * @param {number} src (null)
 * @returns {number}
 */
X86.fnINCb = function(dst, src)
{
    let b = (dst + 1)|0;
    this.setArithResult(dst, 1, b, X86.RESULT.BYTE | X86.RESULT.NOTCF);
    this.nStepCycles -= (this.regEA === X86.ADDR_INVALID? this.cycleCounts.nOpCyclesIncR : this.cycleCounts.nOpCyclesIncM);
    return b & 0xff;
};

/**
 * fnINCw(dst, src)
 *
 * @this {CPUx86}
 * @param {number} dst
 * @param {number} src (null)
 * @returns {number}
 */
X86.fnINCw = function(dst, src)
{
    let w = (dst + 1)|0;
    this.setArithResult(dst, 1, w, this.typeData | X86.RESULT.NOTCF);
    this.nStepCycles -= (this.regEA === X86.ADDR_INVALID? this.cycleCounts.nOpCyclesIncR : this.cycleCounts.nOpCyclesIncM);
    return w & this.maskData;
};

/**
 * fnJMPw(dst, src)
 *
 * @this {CPUx86}
 * @param {number} dst
 * @param {number} src (null)
 * @returns {number}
 */
X86.fnJMPw = function(dst, src)
{
    this.setIP(dst);
    this.nStepCycles -= (this.regEA === X86.ADDR_INVALID? this.cycleCounts.nOpCyclesJmpWR : this.cycleCounts.nOpCyclesJmpWM);
    this.opFlags |= X86.OPFLAG.NOWRITE;
    return dst;
};

/**
 * fnJMPFdw(dst, src)
 *
 * @this {CPUx86}
 * @param {number} dst
 * @param {number} src (null)
 * @returns {number}
 */
X86.fnJMPFdw = function(dst, src)
{
    if (this.regEA === X86.ADDR_INVALID) {
        return X86.fnGRPUndefined.call(this, dst, src);
    }
    this.setCSIP(dst, this.getShort(this.regEA + this.sizeData));
    if (MAXDEBUG && this.cIntReturn) this.checkIntReturn(this.regLIP);
    this.nStepCycles -= this.cycleCounts.nOpCyclesJmpDM;
    this.opFlags |= X86.OPFLAG.NOWRITE;
    return dst;
};

/**
 * fnLAR(dst, src)
 *
 * @this {CPUx86}
 * @param {number} dst
 * @param {number} src
 * @returns {number}
 */
X86.fnLAR = function(dst, src)
{
    this.nStepCycles -= (14 + (this.regEA === X86.ADDR_INVALID? 0 : 2));
    /**
     * Currently, segVER.load() will return an error only if the selector is beyond the bounds of the
     * descriptor table or the descriptor is not for a segment.
     *
     * TODO: This instruction's 80286 documentation does not discuss conforming code segments; determine
     * if we need a special check for them.
     */
    this.clearZF();
    if (this.segVER.load(src) !== X86.ADDR_INVALID) {
        if (this.segVER.dpl >= this.nCPL && this.segVER.dpl >= (src & X86.SEL.RPL)) {
            this.setZF();
            dst = this.segVER.acc & ~X86.DESC.ACC.BASE1623;
            if (this.sizeData > 2) {
                dst |= ((this.segVER.ext & ~X86.DESC.EXT.BASE2431) << 16);
            }
        }
    }
    return dst;
};

/**
 * fnLDS(dst, src)
 *
 * @this {CPUx86}
 * @param {number} dst
 * @param {number} src
 * @returns {number}
 */
X86.fnLDS = function(dst, src)
{
    if (this.regEA === X86.ADDR_INVALID) {
        X86.opUndefined.call(this);
        return dst;
    }
    this.setDS(this.getShort(this.regEA + this.sizeData));
    this.nStepCycles -= this.cycleCounts.nOpCyclesLS;
    return src;
};

/**
 * fnLEA(dst, src)
 *
 * @this {CPUx86}
 * @param {number} dst
 * @param {number} src
 * @returns {number}
 */
X86.fnLEA = function(dst, src)
{
    /**
     * This code was disabled when X86.ADDR_INVALID was -1, because otherwise a perfectly valid instruction
     * like "LEA ECX,[EAX-1]" would fail when EAX was zero; now that X86.ADDR_INVALID is defined as a number
     * outside the 32-bit range (ie, 0x100000000), it can be re-enabled.
     */
    if (this.regEA === X86.ADDR_INVALID) {
        /**
         * TODO: After reading http://www.os2museum.com/wp/undocumented-8086-opcodes/, it seems that this
         * form of LEA (eg, "LEA AX,DX") simply returns the last calculated EA.  Since we always reset regEA
         * at the start of a new instruction, we would need to preserve the previous EA if we want to mimic
         * that (undocumented) behavior.
         *
         * And for completeness, we would have to extend EA tracking beyond the usual ModRM instructions
         * (eg, XLAT, instructions that modify the stack pointer, and string instructions).  Anything else?
         */
        X86.opUndefined.call(this);
        return dst;
    }
    this.nStepCycles -= this.cycleCounts.nOpCyclesLEA;
    /**
     * To properly deal with instructions such as:
     *
     *      #0467:10F8 678D0480         LEA      AX,[EAX+EAX*4]
     *      #0467:10FC 678D0441         LEA      AX,[ECX+EAX*2]
     *
     * which may calculate values that exceed 16 bits, we must mask the result to the appropriate size.
     */
    return this.regEA & this.maskData;
};

/**
 * fnLES(dst, src)
 *
 * @this {CPUx86}
 * @param {number} dst
 * @param {number} src
 * @returns {number}
 */
X86.fnLES = function(dst, src)
{
    if (this.regEA === X86.ADDR_INVALID) {
        X86.opUndefined.call(this);
        return dst;
    }
    this.setES(this.getShort(this.regEA + this.sizeData));
    this.nStepCycles -= this.cycleCounts.nOpCyclesLS;
    return src;
};

/**
 * fnLFS(dst, src)
 *
 * @this {CPUx86}
 * @param {number} dst
 * @param {number} src
 * @returns {number}
 */
X86.fnLFS = function(dst, src)
{
    if (this.regEA === X86.ADDR_INVALID) {
        X86.opUndefined.call(this);
        return dst;
    }
    this.setFS(this.getShort(this.regEA + this.sizeData));
    this.nStepCycles -= this.cycleCounts.nOpCyclesLS;
    return src;
};

/**
 * fnLGDT(dst, src)
 *
 * op=0x0F,0x01,reg=0x2 (GRP7:LGDT)
 *
 * The 80286 LGDT instruction assumes a 40-bit operand: a 16-bit limit followed by a 24-bit base address;
 * the ModRM decoder has already supplied the first word of the operand (in dst), which corresponds to
 * the limit, so we must fetch the remaining bits ourselves.
 *
 * The 80386 LGDT instruction assumes a 48-bit operand: a 16-bit limit followed by a 32-bit base address,
 * but it ignores the last 8 bits of the base address if the OPERAND size is 16 bits; we interpret that to
 * mean that the 24-bit base address should be zero-extended to 32 bits.
 *
 * @this {CPUx86}
 * @param {number} dst
 * @param {number} src (null)
 * @returns {number}
 */
X86.fnLGDT = function(dst, src)
{
    /**
     * TODO: Consider swapping out this function whenever setProtMode() changes the mode to V86-mode.
     */
    if (this.regEA === X86.ADDR_INVALID || I386 && (this.regPS & X86.PS.VM)) {
        X86.opInvalid.call(this);
    } else {
        /**
         * Hopefully it won't hurt to always fetch a 32-bit base address (even on an 80286), which we then
         * mask appropriately.
         */
        this.addrGDT = this.getLong(this.regEA + 2) & (this.maskData | (this.maskData << 8));
        /**
         * An idiosyncrasy of our ModRM decoders is that, if the OPERAND size is 32 bits, then it will have
         * fetched a 32-bit dst operand; we mask off those extra bits now.
         */
        dst &= 0xffff;
        this.addrGDTLimit = this.addrGDT + dst;
        this.opFlags |= X86.OPFLAG.NOWRITE;
        this.nStepCycles -= 11;
    }
    return dst;
};

/**
 * fnLGS(dst, src)
 *
 * @this {CPUx86}
 * @param {number} dst
 * @param {number} src
 * @returns {number}
 */
X86.fnLGS = function(dst, src)
{
    if (this.regEA === X86.ADDR_INVALID) {
        X86.opUndefined.call(this);
        return dst;
    }
    this.setGS(this.getShort(this.regEA + this.sizeData));
    this.nStepCycles -= this.cycleCounts.nOpCyclesLS;
    return src;
};

/**
 * fnLIDT(dst, src)
 *
 * op=0x0F,0x01,reg=0x3 (GRP7:LIDT)
 *
 * The 80286 LIDT instruction assumes a 40-bit operand: a 16-bit limit followed by a 24-bit base address;
 * the ModRM decoder has already supplied the first word of the operand (in dst), which corresponds to
 * the limit, so we must fetch the remaining bits ourselves.
 *
 * The 80386 LIDT instruction assumes a 48-bit operand: a 16-bit limit followed by a 32-bit base address,
 * but it ignores the last 8 bits of the base address if the OPERAND size is 16 bits; we interpret that to
 * mean that the 24-bit base address should be zero-extended to 32 bits.
 *
 * @this {CPUx86}
 * @param {number} dst
 * @param {number} src (null)
 * @returns {number}
 */
X86.fnLIDT = function(dst, src)
{
    /**
     * TODO: Consider swapping out this function whenever setProtMode() changes the mode to V86-mode.
     */
    if (this.regEA === X86.ADDR_INVALID || I386 && (this.regPS & X86.PS.VM)) {
        X86.opInvalid.call(this);
    } else {
        /**
         * Hopefully it won't hurt to always fetch a 32-bit base address (even on an 80286), which we then
         * mask appropriately.
         */
        this.addrIDT = this.getLong(this.regEA + 2) & (this.maskData | (this.maskData << 8));
        /**
         * An idiosyncrasy of our ModRM decoders is that, if the OPERAND size is 32 bits, then it will have
         * fetched a 32-bit dst operand; we mask off those extra bits now.
         */
        dst &= 0xffff;
        this.addrIDTLimit = this.addrIDT + dst;
        this.opFlags |= X86.OPFLAG.NOWRITE;
        this.nStepCycles -= 12;
    }
    return dst;
};

/**
 * fnLLDT(dst, src)
 *
 * op=0x0F,0x00,reg=0x2 (GRP6:LLDT)
 *
 * @this {CPUx86}
 * @param {number} dst
 * @param {number} src (null)
 * @returns {number}
 */
X86.fnLLDT = function(dst, src)
{
    this.opFlags |= X86.OPFLAG.NOWRITE;
    this.segLDT.load(dst);
    this.nStepCycles -= (17 + (this.regEA === X86.ADDR_INVALID? 0 : 2));
    return dst;
};

/**
 * fnLMSW(dst, src)
 *
 * op=0x0F,0x01,reg=0x6 (GRP7:LMSW)
 *
 * @this {CPUx86}
 * @param {number} dst
 * @param {number} src (null)
 * @returns {number}
 */
X86.fnLMSW = function(dst, src)
{
    /**
     * TODO: Consider swapping out this function whenever setProtMode() changes the mode to V86-mode.
     */
    if (I386 && (this.regPS & X86.PS.VM)) {
        X86.opInvalid.call(this);
    } else {
        this.setMSW(dst);
        this.nStepCycles -= (this.regEA === X86.ADDR_INVALID? 3 : 6);
        this.opFlags |= X86.OPFLAG.NOWRITE;
    }
    return dst;
};

/**
 * fnLSL(dst, src)
 *
 * @this {CPUx86}
 * @param {number} dst
 * @param {number} src (the selector)
 * @returns {number}
 */
X86.fnLSL = function(dst, src)
{
    /**
     * TODO: Is this an invalid operation if regEAWrite is set?  dst is required to be a register.
     */
    this.nStepCycles -= (14 + (this.regEA === X86.ADDR_INVALID? 0 : 2));
    /**
     * Currently, segVER.load() will return an error only if the selector is beyond the bounds of the
     * descriptor table or the descriptor is not for a segment.
     *
     * TODO: LSL is explicitly documented as ALSO requiring a non-null selector, so we check X86.SEL.MASK;
     * are there any other instructions that were, um, less explicit but also require a non-null selector?
     */
    if ((src & X86.SEL.MASK) && this.segVER.load(src) !== X86.ADDR_INVALID) {
        let fConforming = ((this.segVER.acc & X86.DESC.ACC.TYPE.CODE_CONFORMING) == X86.DESC.ACC.TYPE.CODE_CONFORMING);
        if ((fConforming || this.segVER.dpl >= this.nCPL) && this.segVER.dpl >= (src & X86.SEL.RPL)) {
            this.setZF();
            return this.segVER.limit;
        }
    }
    this.clearZF();
    return dst;
};

/**
 * fnLSS(dst, src)
 *
 * @this {CPUx86}
 * @param {number} dst
 * @param {number} src
 * @returns {number}
 */
X86.fnLSS = function(dst, src)
{
    if (this.regEA === X86.ADDR_INVALID) {
        X86.opUndefined.call(this);
        return dst;
    }
    this.setSS(this.getShort(this.regEA + this.sizeData));
    this.nStepCycles -= this.cycleCounts.nOpCyclesLS;
    return src;
};

/**
 * fnLTR(dst, src)
 *
 * op=0x0F,0x00,reg=0x3 (GRP6:LTR)
 *
 * @this {CPUx86}
 * @param {number} dst
 * @param {number} src (null)
 * @returns {number}
 */
X86.fnLTR = function(dst, src)
{
    this.opFlags |= X86.OPFLAG.NOWRITE;
    if (this.segTSS.load(dst) !== X86.ADDR_INVALID) {
        this.setShort(this.segTSS.addrDesc + X86.DESC.ACC.OFFSET, this.segTSS.acc |= X86.DESC.ACC.TYPE.TSS_BUSY);
        this.segTSS.type |= X86.DESC.ACC.TYPE.TSS_BUSY;
    }
    this.nStepCycles -= (17 + (this.regEA === X86.ADDR_INVALID? 0 : 2));
    return dst;
};

/**
 * fnMOV(dst, src)
 *
 * @this {CPUx86}
 * @param {number} dst (current value, ignored)
 * @param {number} src (new value)
 * @returns {number} dst (updated value, from src)
 */
X86.fnMOV = function(dst, src)
{
    this.nStepCycles -= (this.regEAWrite === X86.ADDR_INVALID? (this.regEA === X86.ADDR_INVALID? this.cycleCounts.nOpCyclesMovRR : this.cycleCounts.nOpCyclesMovRM) : this.cycleCounts.nOpCyclesMovMR);
    return src;
};

/**
 * fnMOVXb(dst, src)
 *
 * Helper for opMOVSXb() and opMOVZXb() (which also take care of updating nStepCycles, so we don't have to)
 *
 * @this {CPUx86}
 * @param {number} dst (current value, ignored)
 * @param {number} src (new value)
 * @returns {number} dst (updated value, from src)
 */
X86.fnMOVXb = function(dst, src)
{
    /**
     * The ModRegByte handlers update the registers in the 1st column, but we need to update those in the 2nd column.
     *
     *      000:    AL      ->      000:    AX
     *      001:    CL      ->      001:    CX
     *      010:    DL      ->      010:    DX
     *      011:    BL      ->      011:    BX
     *      100:    AH      ->      100:    SP
     *      101:    CH      ->      101:    BP
     *      110:    DH      ->      110:    SI
     *      111:    BH      ->      111:    DI
     */
    let reg = (this.bModRM >> 3) & 0x7;

    switch(reg) {
    case 0x4:
        this.regXX = this.regEAX;
        break;
    case 0x5:
        this.regXX = this.regECX;
        break;
    case 0x6:
        this.regXX = this.regEDX;
        break;
    case 0x7:
        this.regXX = this.regEBX;
        break;
    }
    return src;
};

/**
 * fnMOVXw(dst, src)
 *
 * Helper for opMOVSXw() and opMOVZXw() (which also take care of updating nStepCycles, so we don't have to)
 *
 * @this {CPUx86}
 * @param {number} dst (current value, ignored)
 * @param {number} src (new value)
 * @returns {number} dst (updated value, from src)
 */
X86.fnMOVXw = function(dst, src)
{
    return src;
};

/**
 * fnMOVn(dst, src)
 *
 * @this {CPUx86}
 * @param {number} dst (current value, ignored)
 * @param {number} src (new value)
 * @returns {number} dst (updated value, from src)
 */
X86.fnMOVn = function(dst, src)
{
    this.nStepCycles -= (this.regEAWrite === X86.ADDR_INVALID? this.cycleCounts.nOpCyclesMovRI : this.cycleCounts.nOpCyclesMovMI);
    return src;
};

/**
 * fnMOVsrw(dst, src)
 *
 * This helper saves the contents of the general-purpose register that will be overwritten, so that the caller
 * can restore it after moving the updated value to the correct segment register.
 *
 * @this {CPUx86}
 * @param {number} dst (current value, ignored)
 * @param {number} src (new value)
 * @returns {number} dst (updated value, from src)
 */
X86.fnMOVsrw = function(dst, src)
{
    let reg = (this.bModRM >> 3) & 0x7;

    switch(reg) {
    case 0x0:
        this.regXX = this.regEAX;
        break;
    case 0x2:
        this.regXX = this.regEDX;
        break;
    case 0x3:
        this.regXX = this.regEBX;
        break;
    default:
        if (this.model == X86.MODEL_80286 || this.model == X86.MODEL_80386 && reg != 0x4 && reg != 0x5) {
            X86.opInvalid.call(this);
            break;
        }
        switch(reg) {
        case 0x1:           // MOV to CS is undocumented on 8086/8088/80186/80188, and invalid on 80286 and up
            this.regXX = this.regECX;
            break;
        case 0x4:           // this form of MOV to ES is undocumented on 8086/8088/80186/80188, invalid on 80286, and uses FS starting with 80386
            this.regXX = this.getSP();
            break;
        case 0x5:           // this form of MOV to CS is undocumented on 8086/8088/80186/80188, invalid on 80286, and uses GS starting with 80386
            this.regXX = this.regEBP;
            break;
        case 0x6:           // this form of MOV to SS is undocumented on 8086/8088/80186/80188, invalid on 80286 and up
            this.regXX = this.regESI;
            break;
        case 0x7:           // this form of MOV to DS is undocumented on 8086/8088/80186/80188, invalid on 80286 and up
            this.regXX = this.regEDI;
            break;
        default:
            break;
        }
        break;
    }
    /**
     * We could just return src, but nStepCycles needs to be updated, too.
     */
    return X86.fnMOV.call(this, dst, src);
};

/**
 * fnMOVwsr(dst, src)
 *
 * @this {CPUx86}
 * @param {number} dst (current value, ignored)
 * @param {number} src (new value)
 * @returns {number} dst
 */
X86.fnMOVwsr = function(dst, src)
{
    let reg = (this.bModRM >> 3) & 0x7;

    switch (reg) {
    case 0x0:
        src = this.segES.sel;
        break;
    case 0x1:
        src = this.segCS.sel;
        break;
    case 0x2:
        src = this.segSS.sel;
        break;
    case 0x3:
        src = this.segDS.sel;
        break;
    case 0x4:
        if (I386 && this.model >= X86.MODEL_80386) {
            src = this.segFS.sel;
            break;
        }
        X86.opInvalid.call(this);
        src = dst;
        break;
    case 0x5:
        if (I386 && this.model >= X86.MODEL_80386) {
            src = this.segGS.sel;
            break;
        }
        /* falls through */
    default:
        X86.opInvalid.call(this);
        src = dst;
        break;
    }

    /**
     * When a 32-bit OPERAND size is in effect, segment register writes via opMOVwsr() must write 32 bits
     * (zero-extended) if the destination is a register, but only 16 bits if the destination is memory,
     * hence the setDataSize(2) below.
     *
     * The only other caller, opMOVrc(), is not affected, because it writes only to register destinations.
     */
    if (this.regEAWrite !== X86.ADDR_INVALID) {
        this.setDataSize(2);
    }
    /**
     * We could just return src, but nStepCycles needs to be updated, too.
     */
    return X86.fnMOV.call(this, dst, src);
};

/**
 * fnMULb(dst, src)
 *
 * @this {CPUx86}
 * @param {number} dst
 * @param {number} src (null)
 * @returns {number} (we return dst unchanged, since it's actually AX that's modified)
 */
X86.fnMULb = function(dst, src)
{
    this.regMDLo = ((this.regEAX & 0xff) * dst) & 0xffff;
    if (this.regMDLo & 0xff00) {
        this.setCF(); this.setOF();
    } else {
        this.clearCF(); this.clearOF();
    }
    if (this.model <= X86.MODEL_8088) {
        this.clearZF();         // differentiate ourselves from a NEC V20
    }
    this.fMDSet = true;
    this.nStepCycles -= (this.regEA === X86.ADDR_INVALID? this.cycleCounts.nOpCyclesMulBR : this.cycleCounts.nOpCyclesMulBM);
    this.opFlags |= X86.OPFLAG.NOWRITE;
    return dst;
};

/**
 * fnMUL32(dst, src)
 *
 * This sets regMDHi:regMDLo to the 64-bit result of dst * src, both of which are treated as unsigned.
 *
 * The algorithm is based on the traditional "by hand" multiplication method, by treating the two inputs
 * (dst and src) as two 2-digit numbers, where each digit is a base-65536 digit.
 *
 * @this {CPUx86}
 * @param {number} dst (any 32-bit number, treated as unsigned)
 * @param {number} src (any 32-bit number, treated as unsigned)
 */
X86.fnMUL32 = function(dst, src)
{
    if (!(dst & ~0xffff) && !(src & ~0xffff)) {
        this.regMDLo = (dst * src)|0;
        this.regMDHi = 0;
    }
    else {
        let srcLo = src & 0xffff;
        let srcHi = src >>> 16;
        let dstLo = dst & 0xffff;
        let dstHi = dst >>> 16;

        let mul00 = srcLo * dstLo;
        let mul16 = ((mul00 >>> 16) + (srcHi * dstLo));
        let mul32 = mul16 >>> 16;
        mul16 = ((mul16 & 0xffff) + (srcLo * dstHi));
        mul32 += ((mul16 >>> 16) + (srcHi * dstHi));

        this.regMDLo = (mul16 << 16) | (mul00 & 0xffff);
        this.regMDHi = mul32|0;
    }
};

/**
 * fnMULw(dst, src)
 *
 * regMDHi:regMDLo = dst * regEAX
 *
 * @this {CPUx86}
 * @param {number} dst
 * @param {number} src (null; AX or EAX is the implied src)
 * @returns {number} (we return dst unchanged, since it's actually DX:AX that's modified)
 */
X86.fnMULw = function(dst, src)
{
    if (this.sizeData == 2) {
        src = this.regEAX & 0xffff;
        let result = (src * dst)|0;
        this.regMDLo = result & 0xffff;
        this.regMDHi = (result >> 16) & 0xffff;
    } else {
        X86.fnMUL32.call(this, dst, this.regEAX);
        if (this.stepping == X86.STEPPING_80386_B1) {
            if (this.regEAX == 0x0417A000 && dst == 0x00000081) {
                /**
                 * Normally, the result should be 0x20FE7A000 (ie, regMDHi should be 0x2).
                 * I'm not sure what a typical B1 stepping failure looked like, so I'll set regMDHi to 0.
                 *
                 * If you want a B1 stepping without this 32-bit multiplication flaw, select the B2 stepping.
                 */

                this.regMDHi = 0;
            }
        }
    }

    if (this.regMDHi) {
        this.setCF(); this.setOF();
    } else {
        this.clearCF(); this.clearOF();
    }
    if (this.model <= X86.MODEL_8088) {
        this.clearZF();         // differentiate ourselves from a NEC V20
    }
    this.fMDSet = true;
    this.nStepCycles -= (this.regEA === X86.ADDR_INVALID? this.cycleCounts.nOpCyclesMulWR : this.cycleCounts.nOpCyclesMulWM);
    this.opFlags |= X86.OPFLAG.NOWRITE;
    return dst;
};

/**
 * fnNEGb(dst, src)
 *
 * @this {CPUx86}
 * @param {number} dst
 * @param {number} src (null)
 * @returns {number}
 */
X86.fnNEGb = function(dst, src)
{
    let b = (-dst)|0;
    this.setArithResult(0, dst, b, X86.RESULT.BYTE | X86.RESULT.ALL, true);
    this.nStepCycles -= (this.regEA === X86.ADDR_INVALID? this.cycleCounts.nOpCyclesNegR : this.cycleCounts.nOpCyclesNegM);
    return b & 0xff;
};

/**
 * fnNEGw(dst, src)
 *
 * @this {CPUx86}
 * @param {number} dst
 * @param {number} src (null)
 * @returns {number}
 */
X86.fnNEGw = function(dst, src)
{
    let w = (-dst)|0;
    this.setArithResult(0, dst, w, this.typeData | X86.RESULT.ALL, true);
    this.nStepCycles -= (this.regEA === X86.ADDR_INVALID? this.cycleCounts.nOpCyclesNegR : this.cycleCounts.nOpCyclesNegM);
    return w & this.maskData;
};

/**
 * fnNOTb(dst, src)
 *
 * @this {CPUx86}
 * @param {number} dst
 * @param {number} src (null)
 * @returns {number}
 */
X86.fnNOTb = function(dst, src)
{
    this.nStepCycles -= (this.regEA === X86.ADDR_INVALID? this.cycleCounts.nOpCyclesNegR : this.cycleCounts.nOpCyclesNegM);
    return dst ^ 0xff;
};

/**
 * fnNOTw(dst, src)
 *
 * @this {CPUx86}
 * @param {number} dst
 * @param {number} src (null)
 * @returns {number}
 */
X86.fnNOTw = function(dst, src)
{
    this.nStepCycles -= (this.regEA === X86.ADDR_INVALID? this.cycleCounts.nOpCyclesNegR : this.cycleCounts.nOpCyclesNegM);
    return dst ^ this.maskData;
};

/**
 * fnORb(dst, src)
 *
 * @this {CPUx86}
 * @param {number} dst
 * @param {number} src
 * @returns {number}
 */
X86.fnORb = function(dst, src)
{
    this.nStepCycles -= (this.regEAWrite === X86.ADDR_INVALID? (this.regEA === X86.ADDR_INVALID? this.cycleCounts.nOpCyclesArithRR : this.cycleCounts.nOpCyclesArithRM) : this.cycleCounts.nOpCyclesArithMR);
    return this.setLogicResult(dst | src, X86.RESULT.BYTE);
};

/**
 * fnORw(dst, src)
 *
 * @this {CPUx86}
 * @param {number} dst
 * @param {number} src
 * @returns {number}
 */
X86.fnORw = function(dst, src)
{
    this.nStepCycles -= (this.regEAWrite === X86.ADDR_INVALID? (this.regEA === X86.ADDR_INVALID? this.cycleCounts.nOpCyclesArithRR : this.cycleCounts.nOpCyclesArithRM) : this.cycleCounts.nOpCyclesArithMR);
    return this.setLogicResult(dst | src, this.typeData) & this.maskData;
};

/**
 * fnPOPw(dst, src)
 *
 * @this {CPUx86}
 * @param {number} dst (current value, ignored)
 * @param {number} src (new value)
 * @returns {number} dst (updated value, from src)
 */
X86.fnPOPw = function(dst, src)
{
    this.nStepCycles -= (this.regEAWrite === X86.ADDR_INVALID? this.cycleCounts.nOpCyclesPopReg : this.cycleCounts.nOpCyclesPopMem);
    return src;
};

/**
 * fnPUSHw(dst, src)
 *
 * @this {CPUx86}
 * @param {number} dst
 * @param {number} src (null)
 * @returns {number}
 */
X86.fnPUSHw = function(dst, src)
{
    let w = dst;
    if (this.opFlags & X86.OPFLAG.PUSHSP) {
        /**
         * This is the one case where must actually modify dst, so that the ModRM function will
         * not put a stale value back into the SP register.
         */
        dst = (dst - 2) & 0xffff;
        /**
         * And on the 8086/8088, the value we just calculated also happens to be the value that must
         * be pushed.
         */
        if (this.model < X86.MODEL_80286) w = dst;
    }
    this.pushWord(w);
    this.nStepCycles -= (this.regEA === X86.ADDR_INVALID? this.cycleCounts.nOpCyclesPushReg : this.cycleCounts.nOpCyclesPushMem);
    /**
     * The PUSH is the only write that needs to occur; dst was the source operand and does not need to be rewritten.
     */
    this.opFlags |= X86.OPFLAG.NOWRITE;
    return dst;
};

/**
 * fnRCLb(dst, src)
 *
 * @this {CPUx86}
 * @param {number} dst
 * @param {number} src (1 or CL)
 * @returns {number}
 */
X86.fnRCLb = function(dst, src)
{
    let result = dst;
    let count = src & this.nShiftCountMask;
    if (count) {
        let carry = this.getCarry();
        count %= 9;
        if (!count) {
            carry <<= 7;
        } else {
            result = ((dst << count) | (carry << (count - 1)) | (dst >> (9 - count))) & 0xff;
            carry = dst << (count - 1);
        }
        this.setRotateResult(result, carry, X86.RESULT.BYTE);
    }
    return result;
};

/**
 * fnRCLw(dst, src)
 *
 * @this {CPUx86}
 * @param {number} dst
 * @param {number} src (1 or CL)
 * @returns {number}
 */
X86.fnRCLw = function(dst, src)
{
    let result = dst;
    let count = src & this.nShiftCountMask;
    if (count) {
        let carry = this.getCarry();
        count %= 17;
        if (!count) {
            carry <<= 15;
        } else {
            result = ((dst << count) | (carry << (count - 1)) | (dst >> (17 - count))) & 0xffff;
            carry = dst << (count - 1);
        }
        this.setRotateResult(result, carry, X86.RESULT.WORD);
    }
    return result;
};

/**
 * fnRCLd(dst, src)
 *
 * @this {CPUx86}
 * @param {number} dst
 * @param {number} src (1 or CL)
 * @returns {number}
 */
X86.fnRCLd = function(dst, src)
{
    let result = dst;
    let count = src & this.nShiftCountMask;     // this 32-bit-only function could mask with 0x1f directly
    if (count) {
        let carry = this.getCarry();
        /**
         * JavaScript Alert: much like a post-8086 Intel CPU, JavaScript shift counts are mod 32,
         * so "dst >>> 32" is equivalent to "dst >>> 0", which doesn't shift any bits at all.  To
         * compensate, we shift one bit less than the maximum, and then shift one bit farther.
         */
        result = (dst << count) | (carry << (count - 1)) | ((dst >>> (32 - count)) >>> 1);
        carry = dst << (count - 1);
        this.setRotateResult(result, carry, X86.RESULT.DWORD);
    }
    return result;
};

/**
 * fnRCRb(dst, src)
 *
 * @this {CPUx86}
 * @param {number} dst
 * @param {number} src (1 or CL)
 * @returns {number}
 */
X86.fnRCRb = function(dst, src)
{
    let result = dst;
    let count = src & this.nShiftCountMask;
    if (count) {
        let carry = this.getCarry();
        count %= 9;
        if (!count) {
            carry <<= 7;
        } else {
            result = ((dst >> count) | (carry << (8 - count)) | (dst << (9 - count))) & 0xff;
            carry = dst << (8 - count);
        }
        this.setRotateResult(result, carry, X86.RESULT.BYTE);
    }
    return result;
};

/**
 * fnRCRw(dst, src)
 *
 * @this {CPUx86}
 * @param {number} dst
 * @param {number} src (1 or CL)
 * @returns {number}
 */
X86.fnRCRw = function(dst, src)
{
    let result = dst;
    let count = src & this.nShiftCountMask;
    if (count) {
        let carry = this.getCarry();
        count %= 17;
        if (!count) {
            carry <<= 15;
        } else {
            result = ((dst >> count) | (carry << (16 - count)) | (dst << (17 - count))) & 0xffff;
            carry = dst << (16 - count);
        }
        this.setRotateResult(result, carry, X86.RESULT.WORD);
    }
    return result;
};

/**
 * fnRCRd(dst, src)
 *
 * @this {CPUx86}
 * @param {number} dst
 * @param {number} src (1 or CL)
 * @returns {number}
 */
X86.fnRCRd = function(dst, src)
{
    let result = dst;
    let count = src & this.nShiftCountMask;     // this 32-bit-only function could mask with 0x1f directly
    if (count) {
        let carry = this.getCarry();
        /**
         * JavaScript Alert: much like a post-8086 Intel CPU, JavaScript shift counts are mod 32,
         * so "dst << 32" is equivalent to "dst << 0", which doesn't shift any bits at all.  To
         * compensate, we shift one bit less than the maximum, and then shift one bit farther.
         */
        result = (dst >>> count) | (carry << (32 - count)) | ((dst << (32 - count)) << 1);
        carry = dst << (32 - count);
        this.setRotateResult(result, carry, X86.RESULT.DWORD);
    }
    return result;
};

/**
 * fnROLb(dst, src)
 *
 * @this {CPUx86}
 * @param {number} dst
 * @param {number} src (1 or CL)
 * @returns {number}
 */
X86.fnROLb = function(dst, src)
{
    let result = dst;
    let count = src & this.nShiftCountMask;
    if (count) {
        let carry;
        count &= 0x7;
        if (!count) {
            carry = dst << 7;
        } else {
            carry = dst << (count - 1);
            result = ((dst << count) | (dst >> (8 - count))) & 0xff;
        }
        this.setRotateResult(result, carry, X86.RESULT.BYTE);
    }
    return result;
};

/**
 * fnROLw(dst, src)
 *
 * @this {CPUx86}
 * @param {number} dst
 * @param {number} src (1 or CL)
 * @returns {number}
 */
X86.fnROLw = function(dst, src)
{
    let result = dst;
    let count = src & this.nShiftCountMask;
    if (count) {
        let carry;
        count &= 0xf;
        if (!count) {
            carry = dst << 15;
        } else {
            carry = dst << (count - 1);
            result = ((dst << count) | (dst >> (16 - count))) & 0xffff;
        }
        this.setRotateResult(result, carry, X86.RESULT.WORD);
    }
    return result;
};

/**
 * fnROLd(dst, src)
 *
 * @this {CPUx86}
 * @param {number} dst
 * @param {number} src (1 or CL)
 * @returns {number}
 */
X86.fnROLd = function(dst, src)
{
    let result = dst;
    let count = src & this.nShiftCountMask;
    if (count) {
        let carry = dst << (count - 1);
        result = (dst << count) | (dst >>> (32 - count));
        this.setRotateResult(result, carry, X86.RESULT.DWORD);
    }
    return result;
};

/**
 * fnRORb(dst, src)
 *
 * @this {CPUx86}
 * @param {number} dst
 * @param {number} src (1 or CL)
 * @returns {number}
 */
X86.fnRORb = function(dst, src)
{
    let result = dst;
    let count = src & this.nShiftCountMask;
    if (count) {
        let carry;
        count &= 0x7;
        if (!count) {
            carry = dst;
        } else {
            carry = dst << (8 - count);
            result = ((dst >>> count) | carry) & 0xff;
        }
        this.setRotateResult(result, carry, X86.RESULT.BYTE);
    }
    return result;
};

/**
 * fnRORw(dst, src)
 *
 * @this {CPUx86}
 * @param {number} dst
 * @param {number} src (1 or CL)
 * @returns {number}
 */
X86.fnRORw = function(dst, src)
{
    let result = dst;
    let count = src & this.nShiftCountMask;
    if (count) {
        let carry;
        count &= 0xf;
        if (!count) {
            carry = dst;
        } else {
            carry = dst << (16 - count);
            result = ((dst >>> count) | carry) & 0xffff;
        }
        this.setRotateResult(result, carry, X86.RESULT.WORD);
    }
    return result;
};

/**
 * fnRORd(dst, src)
 *
 * @this {CPUx86}
 * @param {number} dst
 * @param {number} src (1 or CL)
 * @returns {number}
 */
X86.fnRORd = function(dst, src)
{
    let result = dst;
    let count = src & this.nShiftCountMask;
    if (count) {
        let carry = dst << (32 - count);
        result = (dst >>> count) | carry;
        this.setRotateResult(result, carry, X86.RESULT.DWORD);
    }
    return result;
};

/**
 * fnSARb(dst, src)
 *
 * @this {CPUx86}
 * @param {number} dst
 * @param {number} src (1 or CL, or an immediate byte for 80186/80188 and up)
 * @returns {number}
 */
X86.fnSARb = function(dst, src)
{
    let count = src & this.nShiftCountMask;
    if (count) {
        if (count > 9) count = 9;
        let carry = ((dst << 24) >> 24) >> (count - 1);
        dst = (carry >> 1) & 0xff;
        this.setLogicResult(dst, X86.RESULT.BYTE, carry & 0x1);
    }
    return dst;
};

/**
 * fnSARw(dst, src)
 *
 * @this {CPUx86}
 * @param {number} dst
 * @param {number} src (1 or CL, or an immediate byte for 80186/80188 and up)
 * @returns {number}
 */
X86.fnSARw = function(dst, src)
{
    let count = src & this.nShiftCountMask;
    if (count) {
        if (count > 17) count = 17;
        let carry = ((dst << 16) >> 16) >> (count - 1);
        dst = (carry >> 1) & 0xffff;
        this.setLogicResult(dst, X86.RESULT.WORD, carry & 0x1);
    }
    return dst;
};

/**
 * fnSARd(dst, src)
 *
 * @this {CPUx86}
 * @param {number} dst
 * @param {number} src (1 or CL, or an immediate byte for 80186/80188 and up)
 * @returns {number}
 */
X86.fnSARd = function(dst, src)
{
    let count = src & this.nShiftCountMask;
    if (count) {
        let carry = dst >> (count - 1);
        dst = (carry >> 1);
        this.setLogicResult(dst, X86.RESULT.DWORD, carry & 0x1);
    }
    return dst;
};

/**
 * fnSBBb(dst, src)
 *
 * @this {CPUx86}
 * @param {number} dst
 * @param {number} src
 * @returns {number}
 */
X86.fnSBBb = function(dst, src)
{
    let b = (dst - src - this.getCarry())|0;
    this.setArithResult(dst, src, b, X86.RESULT.BYTE | X86.RESULT.ALL, true);
    this.nStepCycles -= (this.regEAWrite === X86.ADDR_INVALID? (this.regEA === X86.ADDR_INVALID? this.cycleCounts.nOpCyclesArithRR : this.cycleCounts.nOpCyclesArithRM) : this.cycleCounts.nOpCyclesArithMR);
    return b & 0xff;
};

/**
 * fnSBBw(dst, src)
 *
 * @this {CPUx86}
 * @param {number} dst
 * @param {number} src
 * @returns {number}
 */
X86.fnSBBw = function(dst, src)
{
    let w = (dst - src - this.getCarry())|0;
    this.setArithResult(dst, src, w, this.typeData | X86.RESULT.ALL, true);
    this.nStepCycles -= (this.regEAWrite === X86.ADDR_INVALID? (this.regEA === X86.ADDR_INVALID? this.cycleCounts.nOpCyclesArithRR : this.cycleCounts.nOpCyclesArithRM) : this.cycleCounts.nOpCyclesArithMR);
    return w & this.maskData;
};

/**
 * fnSETO(dst, src)
 *
 * @this {CPUx86}
 * @param {number} dst (ignored)
 * @param {number} src (ignored)
 * @returns {number}
 */
X86.fnSETO = function(dst, src)
{
    return (this.getOF()? 1 : 0);
};

/**
 * fnSETNO(dst, src)
 *
 * @this {CPUx86}
 * @param {number} dst (ignored)
 * @param {number} src (ignored)
 * @returns {number}
 */
X86.fnSETNO = function(dst, src)
{
    return (this.getOF()? 0 : 1);
};

/**
 * fnSETC(dst, src)
 *
 * @this {CPUx86}
 * @param {number} dst (ignored)
 * @param {number} src (ignored)
 * @returns {number}
 */
X86.fnSETC = function(dst, src)
{
    return (this.getCF()? 1 : 0);
};

/**
 * fnSETNC(dst, src)
 *
 * @this {CPUx86}
 * @param {number} dst (ignored)
 * @param {number} src (ignored)
 * @returns {number}
 */
X86.fnSETNC = function(dst, src)
{
    return (this.getCF()? 0 : 1);
};

/**
 * fnSETZ(dst, src)
 *
 * @this {CPUx86}
 * @param {number} dst (ignored)
 * @param {number} src (ignored)
 * @returns {number}
 */
X86.fnSETZ = function(dst, src)
{
    return (this.getZF()? 1 : 0);
};

/**
 * fnSETNZ(dst, src)
 *
 * @this {CPUx86}
 * @param {number} dst (ignored)
 * @param {number} src (ignored)
 * @returns {number}
 */
X86.fnSETNZ = function(dst, src)
{
    return (this.getZF()? 0 : 1);
};

/**
 * fnSETBE(dst, src)
 *
 * @this {CPUx86}
 * @param {number} dst (ignored)
 * @param {number} src (ignored)
 * @returns {number}
 */
X86.fnSETBE = function(dst, src)
{
    return (this.getCF() || this.getZF()? 1 : 0);
};

/**
 * fnSETNBE(dst, src)
 *
 * @this {CPUx86}
 * @param {number} dst (ignored)
 * @param {number} src (ignored)
 * @returns {number}
 */
X86.fnSETNBE = function(dst, src)
{
    return (this.getCF() || this.getZF()? 0 : 1);
};

/**
 * fnSETS(dst, src)
 *
 * @this {CPUx86}
 * @param {number} dst (ignored)
 * @param {number} src (ignored)
 * @returns {number}
 */
X86.fnSETS = function(dst, src)
{
    return (this.getSF()? 1 : 0);
};

/**
 * fnSETNS(dst, src)
 *
 * @this {CPUx86}
 * @param {number} dst (ignored)
 * @param {number} src (ignored)
 * @returns {number}
 */
X86.fnSETNS = function(dst, src)
{
    return (this.getSF()? 0 : 1);
};

/**
 * fnSETP(dst, src)
 *
 * @this {CPUx86}
 * @param {number} dst (ignored)
 * @param {number} src (ignored)
 * @returns {number}
 */
X86.fnSETP = function(dst, src)
{
    return (this.getPF()? 1 : 0);
};

/**
 * fnSETNP(dst, src)
 *
 * @this {CPUx86}
 * @param {number} dst (ignored)
 * @param {number} src (ignored)
 * @returns {number}
 */
X86.fnSETNP = function(dst, src)
{
    return (this.getPF()? 0 : 1);
};

/**
 * fnSETL(dst, src)
 *
 * @this {CPUx86}
 * @param {number} dst (ignored)
 * @param {number} src (ignored)
 * @returns {number}
 */
X86.fnSETL = function(dst, src)
{
    return (!this.getSF() != !this.getOF()? 1 : 0);
};

/**
 * fnSETNL(dst, src)
 *
 * @this {CPUx86}
 * @param {number} dst (ignored)
 * @param {number} src (ignored)
 * @returns {number}
 */
X86.fnSETNL = function(dst, src)
{
    return (!this.getSF() != !this.getOF()? 0 : 1);
};

/**
 * fnSETLE(dst, src)
 *
 * @this {CPUx86}
 * @param {number} dst (ignored)
 * @param {number} src (ignored)
 * @returns {number}
 */
X86.fnSETLE = function(dst, src)
{
    return (this.getZF() || !this.getSF() != !this.getOF()? 1 : 0);
};

/**
 * fnSETNLE(dst, src)
 *
 * @this {CPUx86}
 * @param {number} dst (ignored)
 * @param {number} src (ignored)
 * @returns {number}
 */
X86.fnSETNLE = function(dst, src)
{
    return (this.getZF() || !this.getSF() != !this.getOF()? 0 : 1);
};

/**
 * fnSGDT(dst, src)
 *
 * op=0x0F,0x01,reg=0x0 (GRP7:SGDT)
 *
 * @this {CPUx86}
 * @param {number} dst
 * @param {number} src (null)
 * @returns {number}
 */
X86.fnSGDT = function(dst, src)
{
    if (this.regEA === X86.ADDR_INVALID) {
        X86.opInvalid.call(this);
    } else {
        /**
         * We don't need to set the first word of the operand, because the ModRM group decoder that calls us
         * does that automatically with the value we return (dst).
         */
        dst = this.addrGDTLimit - this.addrGDT;


        let addr = this.addrGDT;
        if (this.model == X86.MODEL_80286) {
            /**
             * We previously left the 6th byte of the target operand "undefined".  But it turns out we have to set
             * it to *something*, because there's processor detection in PC-DOS 7.0 (at least in the SETUP portion)
             * that looks like this:
             *
             *      145E:4B84 9C            PUSHF
             *      145E:4B85 55            PUSH     BP
             *      145E:4B86 8BEC          MOV      BP,SP
             *      145E:4B88 B80000        MOV      AX,0000
             *      145E:4B8B 50            PUSH     AX
             *      145E:4B8C 9D            POPF
             *      145E:4B8D 9C            PUSHF
             *      145E:4B8E 58            POP      AX
             *      145E:4B8F 2500F0        AND      AX,F000
             *      145E:4B92 3D00F0        CMP      AX,F000
             *      145E:4B95 7511          JNZ      4BA8
             *      145E:4BA8 C8060000      ENTER    0006,00
             *      145E:4BAC 0F0146FA      SGDT     [BP-06]
             *      145E:4BB0 807EFFFF      CMP      [BP-01],FF
             *      145E:4BB4 C9            LEAVE
             *      145E:4BB5 BA8603        MOV      DX,0386
             *      145E:4BB8 7503          JNZ      4BBD
             *      145E:4BBA BA8602        MOV      DX,0286
             *      145E:4BBD 89163004      MOV      [0430],DX
             *      145E:4BC1 5D            POP      BP
             *      145E:4BC2 9D            POPF
             *      145E:4BC3 CB            RETF
             *
             * This code is expecting SGDT on an 80286 to set the 6th "undefined" byte to 0xFF, so that's what we do.
             */
            addr |= (0xff000000|0);
        }
        else if (this.model >= X86.MODEL_80386) {
            /**
             * The 80386 added another wrinkle: Intel's documentation claimed that the 6th byte is either set to zero
             * or the high byte of the BASE field, depending on the OPERAND size; from the "INTEL 80386 PROGRAMMER'S
             * REFERENCE MANUAL 1986":
             *
             *      The LIMIT field of the [GDTR or IDTR] register is assigned to the first word at the effective address.
             *      If the operand-size attribute is 32 bits, the next three bytes are assigned the BASE field of the
             *      register, and the fourth byte is written with zero. The last byte is undefined. Otherwise, if the
             *      operand-size attribute is 16 bits, the next 4 bytes are assigned the 32-bit BASE field of the register.
             *
             * However, Intel obviously meant the reverse (ie, that the BASE field is truncated when using a 16-bit
             * OPERAND size, not when using a 32-bit OPERAND size).
             */
            if (this.sizeData == 2) {
                /**
                 * Thanks to Michal Necasek, we now know that the: "386 in reality does not pay attention to the operand
                 * size (despite Intel's claims to the contrary). In fact Windows 3.11/Win32s relies on it -- at least in
                 * some configurations, it will execute SGDT in 16-bit code and will crash if all 6 bytes aren't stored."
                 *
                 * Based on the above information, we no longer mask the 6th byte on the 80386 when the OPERAND size is 2.
                 *
                 *      addr &= 0x00ffffff;
                 */
            } else {
                /**
                 * When the OPERAND size is 4, our ModRM group decoder will call setLong(dst) rather than setShort(dst);
                 * we could fix that by calling setDataSize(2), but it seems safer/simpler to set the high bits (16-31)
                 * of dst to match the low bits (0-15) of addr, so that the caller will harmlessly rewrite what we are
                 * already writing with the setLong() below.
                 */
                dst |= (addr << 16);
            }
        }
        this.setLong(this.regEA + 2, addr);
        this.nStepCycles -= 11;
    }
    return dst;
};

/**
 * fnSHLb(dst, src)
 *
 * @this {CPUx86}
 * @param {number} dst
 * @param {number} src (1 or CL, or an immediate byte for 80186/80188 and up)
 * @returns {number}
 */
X86.fnSHLb = function(dst, src)
{
    let result = dst;
    let count = src & this.nShiftCountMask;
    if (count) {
        let carry = 0;
        if (count > 8) {
            result = 0;
        } else {
            carry = dst << (count - 1);
            result = (carry << 1) & 0xff;
        }
        this.setLogicResult(result, X86.RESULT.BYTE, carry & X86.RESULT.BYTE, (result ^ carry) & X86.RESULT.BYTE);
    }
    return result;
};

/**
 * fnSHLw(dst, src)
 *
 * @this {CPUx86}
 * @param {number} dst
 * @param {number} src (1 or CL, or an immediate byte for 80186/80188 and up)
 * @returns {number}
 */
X86.fnSHLw = function(dst, src)
{
    let result = dst;
    let count = src & this.nShiftCountMask;
    if (count) {
        let carry = 0;
        if (count > 16) {
            result = 0;
        } else {
            carry = dst << (count - 1);
            result = (carry << 1) & 0xffff;
        }
        this.setLogicResult(result, X86.RESULT.WORD, carry & X86.RESULT.WORD, (result ^ carry) & X86.RESULT.WORD);
    }
    return result;
};

/**
 * fnSHLd(dst, src)
 *
 * @this {CPUx86}
 * @param {number} dst
 * @param {number} src (1 or CL, or an immediate byte for 80186/80188 and up)
 * @returns {number}
 */
X86.fnSHLd = function(dst, src)
{
    let result = dst;
    let count = src & this.nShiftCountMask;     // this 32-bit-only function could mask with 0x1f directly
    if (count) {
        let carry = dst << (count - 1);
        result = (carry << 1);
        this.setLogicResult(result, X86.RESULT.DWORD, carry & X86.RESULT.DWORD, (result ^ carry) & X86.RESULT.DWORD);
    }
    return result;
};

/**
 * fnSHLDwi(dst, src)
 *
 * @this {CPUx86}
 * @param {number} dst
 * @param {number} src
 * @returns {number}
 */
X86.fnSHLDwi = function(dst, src)
{
    return X86.helpSHLDw.call(this, dst, src, this.getIPByte());
};

/**
 * fnSHLDdi(dst, src)
 *
 * @this {CPUx86}
 * @param {number} dst
 * @param {number} src
 * @returns {number}
 */
X86.fnSHLDdi = function(dst, src)
{
    return X86.helpSHLDd.call(this, dst, src, this.getIPByte());
};

/**
 * fnSHLDwCL(dst, src)
 *
 * @this {CPUx86}
 * @param {number} dst
 * @param {number} src
 * @returns {number}
 */
X86.fnSHLDwCL = function(dst, src)
{
    return X86.helpSHLDw.call(this, dst, src, this.regECX & 0x1f);
};

/**
 * fnSHLDdCL(dst, src)
 *
 * @this {CPUx86}
 * @param {number} dst
 * @param {number} src
 * @returns {number}
 */
X86.fnSHLDdCL = function(dst, src)
{
    return X86.helpSHLDd.call(this, dst, src, this.regECX & 0x1f);
};

/**
 * fnSHRb(dst, src)
 *
 * @this {CPUx86}
 * @param {number} dst
 * @param {number} src (1 or CL, or an immediate byte for 80186/80188 and up)
 * @returns {number}
 */
X86.fnSHRb = function(dst, src)
{
    let count = src & this.nShiftCountMask;
    if (count) {
        let carry = (count > 8? 0 : (dst >>> (count - 1)));
        dst = (carry >>> 1) & 0xff;
        this.setLogicResult(dst, X86.RESULT.BYTE, carry & 0x1, dst & X86.RESULT.BYTE);
    }
    return dst;
};

/**
 * fnSHRw(dst, src)
 *
 * @this {CPUx86}
 * @param {number} dst
 * @param {number} src (1 or CL, or an immediate byte for 80186/80188 and up)
 * @returns {number}
 */
X86.fnSHRw = function(dst, src)
{
    let count = src & this.nShiftCountMask;
    if (count) {
        let carry = (count > 16? 0 : (dst >>> (count - 1)));
        dst = (carry >>> 1) & 0xffff;
        this.setLogicResult(dst, X86.RESULT.WORD, carry & 0x1, dst & X86.RESULT.WORD);
    }
    return dst;
};

/**
 * fnSHRd(dst, src)
 *
 * @this {CPUx86}
 * @param {number} dst
 * @param {number} src (1 or CL, or an immediate byte for 80186/80188 and up)
 * @returns {number}
 */
X86.fnSHRd = function(dst, src)
{
    let count = src & this.nShiftCountMask;
    if (count) {
        let carry = (dst >>> (count - 1));
        dst = (carry >>> 1);
        this.setLogicResult(dst, X86.RESULT.DWORD, carry & 0x1, dst & X86.RESULT.DWORD);
    }
    return dst;
};

/**
 * fnSHRDwi(dst, src)
 *
 * @this {CPUx86}
 * @param {number} dst
 * @param {number} src
 * @returns {number}
 */
X86.fnSHRDwi = function(dst, src)
{
    return X86.helpSHRDw.call(this, dst, src, this.getIPByte());
};

/**
 * fnSHRDdi(dst, src)
 *
 * @this {CPUx86}
 * @param {number} dst
 * @param {number} src
 * @returns {number}
 */
X86.fnSHRDdi = function(dst, src)
{
    return X86.helpSHRDd.call(this, dst, src, this.getIPByte());
};

/**
 * fnSHRDwCL(dst, src)
 *
 * @this {CPUx86}
 * @param {number} dst
 * @param {number} src
 * @returns {number}
 */
X86.fnSHRDwCL = function(dst, src)
{
    return X86.helpSHRDw.call(this, dst, src, this.regECX & 0x1f);
};

/**
 * fnSHRDdCL(dst, src)
 *
 * @this {CPUx86}
 * @param {number} dst
 * @param {number} src
 * @returns {number}
 */
X86.fnSHRDdCL = function(dst, src)
{
    return X86.helpSHRDd.call(this, dst, src, this.regECX & 0x1f);
};

/**
 * fnSIDT(dst, src)
 *
 * op=0x0F,0x01,reg=0x1 (GRP7:SIDT)
 *
 * @this {CPUx86}
 * @param {number} dst
 * @param {number} src (null)
 * @returns {number}
 */
X86.fnSIDT = function(dst, src)
{
    if (this.regEA === X86.ADDR_INVALID) {
        X86.opInvalid.call(this);
    } else {
        /**
         * We don't need to set the first word of the operand, because the ModRM group decoder that calls us
         * does that automatically with the value we return (dst).
         */
        dst = this.addrIDTLimit - this.addrIDT;

        /**
         * As with SGDT, the 6th byte is technically "undefined" on an 80286, but we now set it to 0xFF, for the
         * same reasons discussed in SGDT (above).
         */
        let addr = this.addrIDT;
        if (this.model == X86.MODEL_80286) {
            addr |= (0xff000000|0);
        }
        else if (this.model >= X86.MODEL_80386) {
            if (this.sizeData == 2) {
                /**
                 * Based on the SGDT information above, we no longer mask the 6th byte when the OPERAND size is 2.
                 *
                 *      addr &= 0x00ffffff;
                 */
            } else {
                dst |= (addr << 16);
            }
        }
        this.setLong(this.regEA + 2, addr);
        this.nStepCycles -= 12;
    }
    return dst;
};

/**
 * fnSLDT(dst, src)
 *
 * op=0x0F,0x00,reg=0x0 (GRP6:SLDT)
 *
 * @this {CPUx86}
 * @param {number} dst
 * @param {number} src (null)
 * @returns {number}
 */
X86.fnSLDT = function(dst, src)
{
    this.nStepCycles -= (2 + (this.regEA === X86.ADDR_INVALID? 0 : 1));
    return this.segLDT.sel;
};

/**
 * fnSMSW(dst, src)
 *
 * TODO: I've seen a claim that SMSW can be used with an operand size override to obtain the entire CR0.
 * I don't dispute that, so I allow it (ie, if an override is present, then maskData will be 0xffffffff),
 * but it should still be confirmed on real hardware at some point.  Note that this differs from LMSW,
 * which is REQUIRED to mask the source operand.
 *
 * op=0x0F,0x01,reg=0x4 (GRP7:SMSW)
 *
 * @this {CPUx86}
 * @param {number} dst
 * @param {number} src (null)
 * @returns {number}
 */
X86.fnSMSW = function(dst, src)
{
    this.nStepCycles -= (2 + (this.regEA === X86.ADDR_INVALID? 0 : 1));
    return this.regCR0 & this.maskData;
};

/**
 * fnSTR(dst, src)
 *
 * op=0x0F,0x00,reg=0x1 (GRP6:STR)
 *
 * @this {CPUx86}
 * @param {number} dst
 * @param {number} src (null)
 * @returns {number}
 */
X86.fnSTR = function(dst, src)
{
    this.nStepCycles -= (2 + (this.regEA === X86.ADDR_INVALID? 0 : 1));
    return this.segTSS.sel;
};

/**
 * fnSUBb(dst, src)
 *
 * @this {CPUx86}
 * @param {number} dst
 * @param {number} src
 * @returns {number}
 */
X86.fnSUBb = function(dst, src)
{
    let b = (dst - src)|0;
    this.setArithResult(dst, src, b, X86.RESULT.BYTE | X86.RESULT.ALL, true);
    this.nStepCycles -= (this.regEAWrite === X86.ADDR_INVALID? (this.regEA === X86.ADDR_INVALID? this.cycleCounts.nOpCyclesArithRR : this.cycleCounts.nOpCyclesArithRM) : this.cycleCounts.nOpCyclesArithMR);
    return b & 0xff;
};

/**
 * fnSUBw(dst, src)
 *
 * @this {CPUx86}
 * @param {number} dst
 * @param {number} src
 * @returns {number}
 */
X86.fnSUBw = function(dst, src)
{
    let w = (dst - src)|0;
    this.setArithResult(dst, src, w, this.typeData | X86.RESULT.ALL, true);
    this.nStepCycles -= (this.regEAWrite === X86.ADDR_INVALID? (this.regEA === X86.ADDR_INVALID? this.cycleCounts.nOpCyclesArithRR : this.cycleCounts.nOpCyclesArithRM) : this.cycleCounts.nOpCyclesArithMR);
    return w & this.maskData;
};

/**
 * fnTESTib(dst, src)
 *
 * @this {CPUx86}
 * @param {number} dst
 * @param {number} src (null; we have to supply the source ourselves)
 * @returns {number}
 */
X86.fnTESTib = function(dst, src)
{
    src = this.getIPByte();
    this.setLogicResult(dst & src, X86.RESULT.BYTE);
    this.nStepCycles -= (this.regEA === X86.ADDR_INVALID? this.cycleCounts.nOpCyclesTestRI : this.cycleCounts.nOpCyclesTestMI);
    this.opFlags |= X86.OPFLAG.NOWRITE;
    return dst;
};

/**
 * fnTESTiw(dst, src)
 *
 * @this {CPUx86}
 * @param {number} dst
 * @param {number} src (null; we have to supply the source ourselves)
 * @returns {number}
 */
X86.fnTESTiw = function(dst, src)
{
    src = this.getIPWord();
    this.setLogicResult(dst & src, this.typeData);
    this.nStepCycles -= (this.regEA === X86.ADDR_INVALID? this.cycleCounts.nOpCyclesTestRI : this.cycleCounts.nOpCyclesTestMI);
    this.opFlags |= X86.OPFLAG.NOWRITE;
    return dst;
};

/**
 * fnTESTb(dst, src)
 *
 * @this {CPUx86}
 * @param {number} dst
 * @param {number} src
 * @returns {number}
 */
X86.fnTESTb = function(dst, src)
{
    this.setLogicResult(dst & src, X86.RESULT.BYTE);
    this.nStepCycles -= (this.regEAWrite === X86.ADDR_INVALID? (this.regEA === X86.ADDR_INVALID? this.cycleCounts.nOpCyclesTestRR : this.cycleCounts.nOpCyclesTestRM) : this.cycleCounts.nOpCyclesTestRM);
    this.opFlags |= X86.OPFLAG.NOWRITE;
    return dst;
};

/**
 * fnTESTw(dst, src)
 *
 * @this {CPUx86}
 * @param {number} dst
 * @param {number} src
 * @returns {number}
 */
X86.fnTESTw = function(dst, src)
{
    this.setLogicResult(dst & src, this.typeData);
    this.nStepCycles -= (this.regEAWrite === X86.ADDR_INVALID? (this.regEA === X86.ADDR_INVALID? this.cycleCounts.nOpCyclesTestRR : this.cycleCounts.nOpCyclesTestRM) : this.cycleCounts.nOpCyclesTestRM);
    this.opFlags |= X86.OPFLAG.NOWRITE;
    return dst;
};

/**
 * fnVERR(dst, src)
 *
 * op=0x0F,0x00,reg=0x4 (GRP6:VERR)
 *
 * @this {CPUx86}
 * @param {number} dst
 * @param {number} src (null)
 * @returns {number}
 */
X86.fnVERR = function(dst, src)
{
    this.opFlags |= X86.OPFLAG.NOWRITE;
    /**
     * Currently, segVER.load() will return an error only if the selector is beyond the bounds of the
     * descriptor table or the descriptor is not for a segment.
     */
    this.nStepCycles -= (14 + (this.regEA === X86.ADDR_INVALID? 0 : 2));
    if (this.segVER.load(dst) !== X86.ADDR_INVALID) {
        /**
         * Verify that this is a readable segment; that is, of these four combinations (code+readable,
         * code+nonreadable, data+writable, date+nonwritable), make sure we're not the second combination.
         */
        if ((this.segVER.acc & (X86.DESC.ACC.TYPE.READABLE | X86.DESC.ACC.TYPE.CODE)) != X86.DESC.ACC.TYPE.CODE) {
            /**
             * For VERR, if the code segment is readable and conforming, the descriptor privilege level
             * (DPL) can be any value.
             *
             * Otherwise, DPL must be greater than or equal to (have less or the same privilege as) both the
             * current privilege level and the selector's RPL.
             */
            if (this.segVER.dpl >= this.nCPL && this.segVER.dpl >= (dst & X86.SEL.RPL) ||
                (this.segVER.acc & X86.DESC.ACC.TYPE.CODE_CONFORMING) == X86.DESC.ACC.TYPE.CODE_CONFORMING) {
                this.setZF();
                return dst;
            }
        }
    }
    this.clearZF();
    if (DEBUG && (this.sizeData > 2 || this.sizeAddr > 2)) this.stopCPU();
    return dst;
};

/**
 * fnVERW(dst, src)
 *
 * op=0x0F,0x00,reg=0x5 (GRP6:VERW)
 *
 * @this {CPUx86}
 * @param {number} dst
 * @param {number} src (null)
 * @returns {number}
 */
X86.fnVERW = function(dst, src)
{
    this.opFlags |= X86.OPFLAG.NOWRITE;
    /**
     * Currently, segVER.load() will return an error only if the selector is beyond the bounds of the
     * descriptor table or the descriptor is not for a segment.
     */
    this.nStepCycles -= (14 + (this.regEA === X86.ADDR_INVALID? 0 : 2));
    if (this.segVER.load(dst) !== X86.ADDR_INVALID) {
        /**
         * Verify that this is a writable data segment
         */
        if ((this.segVER.acc & (X86.DESC.ACC.TYPE.WRITABLE | X86.DESC.ACC.TYPE.CODE)) == X86.DESC.ACC.TYPE.WRITABLE) {
            /**
             * DPL must be greater than or equal to (have less or the same privilege as) both the current
             * privilege level and the selector's RPL.
             */
            if (this.segVER.dpl >= this.nCPL && this.segVER.dpl >= (dst & X86.SEL.RPL)) {
                this.setZF();
                return dst;
            }
        }
    }
    this.clearZF();
    if (DEBUG && (this.sizeData > 2 || this.sizeAddr > 2)) this.stopCPU();
    return dst;
};

/**
 * fnIBTS(dst, src)
 *
 * As best I can determine, this function copies the specified bits from src (starting at bit 0 for CL
 * bits) to dst (starting at bit offset in AX).  For register operands, that's simple enough.
 *
 * TODO: If dst refers to a memory location, then the bit index may refer to higher memory locations, just
 * like the BT/BTC/BTR/BTS instructions.  For an instruction that no one was really able to use, except
 * as a CPU stepping discriminator, that doesn't seem worth the effort.
 *
 * @this {CPUx86}
 * @param {number} dst
 * @param {number} src
 * @returns {number}
 */
X86.fnIBTS = function(dst, src)
{
    let shift = (this.regEAX & this.maskData);
    let mask = ((1 << (this.regECX & 0x1f)) - 1);
    return (dst & ~(mask << shift)) | ((src & mask) << shift);
};

/**
 * fnXBTS(dst, src)
 *
 * As best I can determine, this function copies the specified bits from src (starting at the bit offset
 * in AX, for the bit length in CL) to dst (starting at bit 0).  For register operands, that's simple enough.
 *
 * TODO: If src refers to a memory location, then the bit index may refer to higher memory locations, just
 * like the BT/BTC/BTR/BTS instructions.  For an instruction that no one was really able to use, except
 * as a CPU stepping discriminator, that doesn't seem worth the effort.
 *
 * @this {CPUx86}
 * @param {number} dst
 * @param {number} src
 * @returns {number}
 */
X86.fnXBTS = function(dst, src)
{
    /**
     * Shift src right by the bit offset in [E]AX, then apply a mask equal to the number of bits in CL,
     * then mask the resulting bit string with the current OPERAND size.
     */
    return ((src >> (this.regEAX & this.maskData)) & ((1 << (this.regECX & 0x1f)) - 1)) & this.maskData;
};

/**
 * fnXCHGrb(dst, src)
 *
 * If an instruction like "XCHG AL,AH" was a traditional "op dst,src" instruction, dst would contain AL,
 * src would contain AH, and we would return src, which the caller would then store in AL, and we'd be done.
 *
 * However, that's only half of what XCHG does, so THIS function must perform the other half; in the previous
 * example, that means storing the original AL (dst) into AH (src).
 *
 * BACKTRACK support is incomplete without also passing bti values as parameters, because the caller will
 * store btiAH in btiAL, but the original btiAL will be lost.  Similarly, if src is a memory operand, the
 * caller will store btiEALo in btiAL, but again, the original btiAL will be lost.
 *
 * BACKTRACK support for memory operands could be fixed by decoding the dst register in order to determine the
 * corresponding bti and then temporarily storing it in btiEALo around the setEAByte() call below.  Register-only
 * XCHGs would require a more extensive hack.  For now, I'm going to live with one-way BACKTRACK support here.
 *
 * TODO: Implement full BACKTRACK support for XCHG instructions.
 *
 * @this {CPUx86}
 * @param {number} dst
 * @param {number} src
 * @returns {number}
 */
X86.fnXCHGrb = function(dst, src)
{
    if (this.regEA === X86.ADDR_INVALID) {
        /**
         * Decode which register was src
         */

        switch (this.bModRM & 0x7) {
        case 0x0:       // AL
            this.regEAX = (this.regEAX & ~0xff) | dst;
            break;
        case 0x1:       // CL
            this.regECX = (this.regECX & ~0xff) | dst;
            break;
        case 0x2:       // DL
            this.regEDX = (this.regEDX & ~0xff) | dst;
            break;
        case 0x3:       // BL
            this.regEBX = (this.regEBX & ~0xff) | dst;
            break;
        case 0x4:       // AH
            this.regEAX = (this.regEAX & ~0xff00) | (dst << 8);
            break;
        case 0x5:       // CH
            this.regECX = (this.regECX & ~0xff00) | (dst << 8);
            break;
        case 0x6:       // DH
            this.regEDX = (this.regEDX & ~0xff00) | (dst << 8);
            break;
        case 0x7:       // BH
            this.regEBX = (this.regEBX & ~0xff00) | (dst << 8);
            break;
        default:
            break;      // there IS no other case, but JavaScript inspections don't know that
        }
        this.nStepCycles -= this.cycleCounts.nOpCyclesXchgRR;
    } else {
        /**
         * This is a case where the ModRM decoder that's calling us didn't know it should have set regEAWrite,
         * so we compensate by updating regEAWrite.  However, setEAWord() has since been changed to revalidate
         * the write using segEA:offEA, so updating regEAWrite here isn't strictly necessary.
         */
        this.regEAWrite = this.regEA;
        this.setEAByte(dst);
        this.nStepCycles -= this.cycleCounts.nOpCyclesXchgRM;
    }
    return src;
};

/**
 * fnXCHGrw(dst, src)
 *
 * If an instruction like "XCHG AX,DX" was a traditional "op dst,src" instruction, dst would contain AX,
 * src would contain DX, and we would return src, which the caller would then store in AX, and we'd be done.
 *
 * However, that's only half of what XCHG does, so THIS function must perform the other half; in the previous
 * example, that means storing the original AX (dst) into DX (src).
 *
 * TODO: Implement full BACKTRACK support for XCHG instructions (see fnXCHGrb comments).
 *
 * @this {CPUx86}
 * @param {number} dst
 * @param {number} src
 * @returns {number}
 */
X86.fnXCHGrw = function(dst, src)
{
    if (this.regEA === X86.ADDR_INVALID) {
        /**
         * Decode which register was src
         */

        switch (this.bModRM & 0x7) {
        case 0x0:       // [E]AX
            this.regEAX = (this.regEAX & ~this.maskData) | dst;
            break;
        case 0x1:       // [E]CX
            this.regECX = (this.regECX & ~this.maskData) | dst;
            break;
        case 0x2:       // [E]DX
            this.regEDX = (this.regEDX & ~this.maskData) | dst;
            break;
        case 0x3:       // [E]BX
            this.regEBX = (this.regEBX & ~this.maskData) | dst;
            break;
        case 0x4:       // [E]SP
            this.setSP((this.getSP() & ~this.maskData) | dst);
            break;
        case 0x5:       // [E]BP
            this.regEBP = (this.regEBX & ~this.maskData) | dst;
            break;
        case 0x6:       // [E]SI
            this.regESI = (this.regESI & ~this.maskData) | dst;
            break;
        case 0x7:       // [E]DI
            this.regEDI = (this.regEDI & ~this.maskData) | dst;
            break;
        default:
            break;      // there IS no other case, but JavaScript inspections don't know that
        }
        this.nStepCycles -= this.cycleCounts.nOpCyclesXchgRR;
    } else {
        /**
         * This is a case where the ModRM decoder that's calling us didn't know it should have set regEAWrite,
         * so we compensate by updating regEAWrite.  However, setEAWord() has since been changed to revalidate
         * the write using segEA:offEA, so updating regEAWrite here isn't strictly necessary.
         */
        this.regEAWrite = this.regEA;
        this.setEAWord(dst);
        this.nStepCycles -= this.cycleCounts.nOpCyclesXchgRM;
    }
    return src;
};

/**
 * fnXORb(dst, src)
 *
 * @this {CPUx86}
 * @param {number} dst
 * @param {number} src
 * @returns {number}
 */
X86.fnXORb = function(dst, src)
{
    let b = dst ^ src;
    this.setLogicResult(b, X86.RESULT.BYTE);
    this.nStepCycles -= (this.regEAWrite === X86.ADDR_INVALID? (this.regEA === X86.ADDR_INVALID? this.cycleCounts.nOpCyclesArithRR : this.cycleCounts.nOpCyclesArithRM) : this.cycleCounts.nOpCyclesArithMR);
    return b;
};

/**
 * fnXORw(dst, src)
 *
 * @this {CPUx86}
 * @param {number} dst
 * @param {number} src
 * @returns {number}
 */
X86.fnXORw = function(dst, src)
{
    this.nStepCycles -= (this.regEAWrite === X86.ADDR_INVALID? (this.regEA === X86.ADDR_INVALID? this.cycleCounts.nOpCyclesArithRR : this.cycleCounts.nOpCyclesArithRM) : this.cycleCounts.nOpCyclesArithMR);
    return this.setLogicResult(dst ^ src, this.typeData) & this.maskData;
};

/**
 * @copyright https://www.pcjs.org/machines/pcx86/modules/v2/x86help.js (C) 2012-2024 Jeff Parsons
 */

/**
 * helpAdd64(r64Dst, r64Src)
 *
 * Adds r64Src to r64Dst.
 *
 * @param {Array.<number>} r64Dst is a 64-bit value
 * @param {Array.<number>} r64Src is a 64-bit value
 */
X86.helpAdd64 = function(r64Dst, r64Src)
{
    r64Dst[0] += r64Src[0];
    r64Dst[1] += r64Src[1];
    if (r64Dst[0] > 0xffffffff) {
        r64Dst[0] >>>= 0;       // truncate r64Dst[0] to 32 bits AND keep it unsigned
        r64Dst[1]++;
    }
};

/**
 * helpCmp64(r64Dst, r64Src)
 *
 * Compares r64Dst to r64Src, by computing r64Dst - r64Src.
 *
 * @param {Array.<number>} r64Dst is a 64-bit value
 * @param {Array.<number>} r64Src is a 64-bit value
 * @returns {number} > 0 if r64Dst > r64Src, == 0 if r64Dst == r64Src, < 0 if r64Dst < r64Src
 */
X86.helpCmp64 = function(r64Dst, r64Src)
{
    let result = r64Dst[1] - r64Src[1];
    if (!result) result = r64Dst[0] - r64Src[0];
    return result;
};

/**
 * helpSet64(r64Dst, lo, hi)
 *
 * @param {Array.<number>} r64Dst
 * @param {number} lo
 * @param {number} hi
 * @returns {Array.<number>}
 */
X86.helpSet64 = function(r64Dst, lo, hi)
{
    r64Dst[0] = lo >>> 0;
    r64Dst[1] = hi >>> 0;
    return r64Dst;
};

/**
 * helpShr64(r64Dst)
 *
 * Shifts r64Dst right one bit.
 *
 * @param {Array.<number>} r64Dst is a 64-bit value
 */
X86.helpShr64 = function(r64Dst)
{
    r64Dst[0] >>>= 1;
    if (r64Dst[1] & 0x1) {
        r64Dst[0] = (r64Dst[0] | 0x80000000) >>> 0;
    }
    r64Dst[1] >>>= 1;
};

/**
 * helpSub64(r64Dst, r64Src)
 *
 * Subtracts r64Src from r64Dst.
 *
 * @param {Array.<number>} r64Dst is a 64-bit value
 * @param {Array.<number>} r64Src is a 64-bit value
 */
X86.helpSub64 = function(r64Dst, r64Src)
{
    r64Dst[0] -= r64Src[0];
    r64Dst[1] -= r64Src[1];
    if (r64Dst[0] < 0) {
        r64Dst[0] >>>= 0;       // truncate r64Dst[0] to 32 bits AND keep it unsigned
        r64Dst[1]--;
    }
};

/**
 * helpDECreg(w)
 *
 * @this {CPUx86}
 * @param {number} w
 * @returns {number}
 */
X86.helpDECreg = function(w)
{
    let result = (w - 1)|0;
    this.setArithResult(w, 1, result, this.typeData | X86.RESULT.NOTCF, true);
    this.nStepCycles -= 2;                          // the register form of DEC takes 2 cycles on all CPUs
    return (w & ~this.maskData) | (result & this.maskData);
};

/**
 * helpDIV32(dstLo, dstHi, src)
 *
 * This sets regMDLo to dstHi:dstLo / src, and regMDHi to dstHi:dstLo % src; all inputs are treated as unsigned.
 *
 * Refer to: http://lxr.linux.no/linux+v2.6.22/lib/div64.c
 *
 * @this {CPUx86}
 * @param {number} dstLo (low 32-bit portion of dividend)
 * @param {number} dstHi (high 32-bit portion of dividend)
 * @param {number} src (32-bit divisor)
 * @returns {boolean} true if successful, false if overflow (ie, the divisor was either zero or too small)
 */
X86.helpDIV32 = function(dstLo, dstHi, src)
{
    src >>>= 0;

    if (!src || src <= (dstHi >>> 0)) {
        return false;
    }

    let result = 0, bit = 1;

    let r64Div = X86.helpSet64(this.r64Div, src, 0);
    let r64Rem = X86.helpSet64(this.r64Rem, dstLo, dstHi);

    while (X86.helpCmp64(r64Rem, r64Div) > 0) {
        X86.helpAdd64(r64Div, r64Div);
        bit += bit;
    }
    do {
        if (X86.helpCmp64(r64Rem, r64Div) >= 0) {
            X86.helpSub64(r64Rem, r64Div);
            result += bit;
        }
        X86.helpShr64(r64Div);
        bit /= 2;
    } while (bit >= 1);



    this.regMDLo = result;      // result is the quotient, which callers expect in the low MD register
    this.regMDHi = r64Rem[0];   // r64Rem[0] is the remainder, which callers expect in the high MD register
    return true;
};

/**
 * helpIDIV32(dstLo, dstHi, src)
 *
 * This sets regMDLo to dstHi:dstLo / src, and regMDHi to dstHi:dstLo % src; all inputs are treated as signed.
 *
 * Refer to: http://lxr.linux.no/linux+v2.6.22/lib/div64.c
 *
 * @this {CPUx86}
 * @param {number} dstLo (low 32-bit portion of dividend)
 * @param {number} dstHi (high 32-bit portion of dividend)
 * @param {number} src (32-bit divisor)
 * @returns {boolean} true if successful, false if overflow (ie, the divisor was either zero or too small)
 */
X86.helpIDIV32 = function(dstLo, dstHi, src)
{
    let bNegLo = 0, bNegHi = 0;
    /**
     *      dividend    divisor       quotient    remainder
     *        (dst)      (src)          (lo)         (hi)
     *      --------    -------       --------    ---------
     *         +           +     ->       +           +
     *         +           -     ->       -           +
     *         -           +     ->       -           -
     *         -           -     ->       +           -
     */
    if (src < 0) {
        src = -src|0;
        bNegLo = 1 - bNegLo;
    }
    if (dstHi < 0) {
        dstLo = -dstLo|0;
        dstHi = (~dstHi + (dstLo? 0 : 1))|0;
        bNegHi = 1;
        bNegLo = 1 - bNegLo;
    }
    if (!X86.helpDIV32.call(this, dstLo, dstHi, src) || this.regMDLo > 0x7fffffff+bNegLo || this.regMDHi > 0x7fffffff+bNegHi) {
        return false;
    }
    if (bNegLo) this.regMDLo = -this.regMDLo;
    if (bNegHi) this.regMDHi = -this.regMDHi;
    return true;
};

/**
 * helpINCreg(w)
 *
 * @this {CPUx86}
 * @param {number} w
 * @returns {number}
 */
X86.helpINCreg = function(w)
{
    let result = (w + 1)|0;
    this.setArithResult(w, 1, result, this.typeData | X86.RESULT.NOTCF);
    this.nStepCycles -= 2;                          // the register form of INC takes 2 cycles on all CPUs
    return (w & ~this.maskData) | (result & this.maskData);
};

/**
 * helpLoadCR0(l)
 *
 * This is called by an 80386 control instruction (ie, MOV CR0,reg).
 *
 * @this {CPUx86}
 * @param {number} l
 */
X86.helpLoadCR0 = function(l)
{
    this.regCR0 = l | X86.CR0.ON;
    this.setProtMode();
    if (this.regCR0 & X86.CR0.PG) {
        /**
         * TODO: Determine if setting X86.CR0.PG when already set should really act as a flush;
         * I'm not currently worried about it, because I'm assuming CR0 is not rewritten that often.
         */
        this.enablePageBlocks();
    } else {
        this.disablePageBlocks();
    }
};

/**
 * helpLoadCR3(l)
 *
 * This is called by an 80386 control instruction (ie, MOV CR3,reg) or an 80386 task switch.
 *
 * @this {CPUx86}
 * @param {number} l
 */
X86.helpLoadCR3 = function(l)
{
    this.regCR3 = l;
    /**
     * Normal use of regCR3 involves adding a 0-4K (12-bit) offset to obtain a page directory entry,
     * so let's ensure that the low 12 bits of regCR3 are always zero.
     */

    this.flushPageBlocks();
};

/**
 * helpSETcc()
 *
 * @this {CPUx86}
 * @param {function(number,number)} fnSet
 */
X86.helpSETcc = function(fnSet)
{
    this.opFlags |= X86.OPFLAG.NOREAD;
    this.decodeModMemByte.call(this, fnSet);
    this.nStepCycles -= (this.regEA === X86.ADDR_INVALID? 4 : 5);
};

/**
 * helpSHLDw(dst, src, count)
 *
 * @this {CPUx86}
 * @param {number} dst
 * @param {number} src
 * @param {number} count (0-31)
 * @returns {number}
 */
X86.helpSHLDw = function(dst, src, count)
{
    if (count) {
        if (count > 16) {
            dst = src;
            count -= 16;
        }
        let carry = dst << (count - 1);
        dst = ((carry << 1) | (src >>> (16 - count))) & 0xffff;
        this.setLogicResult(dst, X86.RESULT.WORD, carry & X86.RESULT.WORD);
    }
    return dst;
};

/**
 * helpSHLDd(dst, src, count)
 *
 * @this {CPUx86}
 * @param {number} dst
 * @param {number} src
 * @param {number} count
 * @returns {number}
 */
X86.helpSHLDd = function(dst, src, count)
{
    if (count) {
        let carry = dst << (count - 1);
        dst = (carry << 1) | (src >>> (32 - count));
        this.setLogicResult(dst, X86.RESULT.DWORD, carry & X86.RESULT.DWORD);
    }
    return dst;
};

/**
 * helpSHRDw(dst, src, count)
 *
 * @this {CPUx86}
 * @param {number} dst
 * @param {number} src
 * @param {number} count (0-31)
 * @returns {number}
 */
X86.helpSHRDw = function(dst, src, count)
{
    if (count) {
        if (count > 16) {
            dst = src;
            count -= 16;
        }
        let carry = dst >>> (count - 1);
        dst = ((carry >>> 1) | (src << (16 - count))) & 0xffff;
        this.setLogicResult(dst, X86.RESULT.WORD, carry & 0x1);
    }
    return dst;
};

/**
 * helpSHRDd(dst, src, count)
 *
 * @this {CPUx86}
 * @param {number} dst
 * @param {number} src
 * @param {number} count
 * @returns {number}
 */
X86.helpSHRDd = function(dst, src, count)
{
    if (count) {
        let carry = dst >>> (count - 1);
        dst = (carry >>> 1) | (src << (32 - count));
        this.setLogicResult(dst, X86.RESULT.DWORD, carry & 0x1);
    }
    return dst;
};

/**
 * helpSRC1()
 *
 * @this {CPUx86}
 * @returns {number}
 */
X86.helpSRC1 = function()
{
    this.nStepCycles -= (this.regEA === X86.ADDR_INVALID? 2 : this.cycleCounts.nOpCyclesShift1M);
    return 1;
};

/**
 * helpSRCCL()
 *
 * @this {CPUx86}
 * @returns {number}
 */
X86.helpSRCCL = function()
{
    let count = this.regECX & 0xff;
    this.nStepCycles -= (this.regEA === X86.ADDR_INVALID? this.cycleCounts.nOpCyclesShiftCR : this.cycleCounts.nOpCyclesShiftCM) + (count << this.cycleCounts.nOpCyclesShiftCS);
    return count;
};

/**
 * helpSRCByte()
 *
 * @this {CPUx86}
 * @returns {number}
 */
X86.helpSRCByte = function()
{
    let count = this.getIPByte();
    this.nStepCycles -= (this.regEA === X86.ADDR_INVALID? this.cycleCounts.nOpCyclesShiftCR : this.cycleCounts.nOpCyclesShiftCM) + (count << this.cycleCounts.nOpCyclesShiftCS);
    return count;
};

/**
 * helpSRCNone()
 *
 * @this {CPUx86}
 * @returns {number|null}
 */
X86.helpSRCNone = function()
{
    return null;
};

/**
 * helpSRCxx()
 *
 * This is used by opPOPmw(), because the actual pop must occur BEFORE the effective address (EA)
 * calculation.  So opPOPmw() does the pop, saves the popped value in regXX, and this passes src function
 * to the EA worker.
 *
 * @this {CPUx86}
 * @returns {number} regXX
 */
X86.helpSRCxx = function()
{
    return this.regXX;
};

/**
 * helpCALLF(off, sel)
 *
 * For protected-mode, this function must attempt to load the new code segment first, because if the new segment
 * requires a change in privilege level, the return address must be pushed on the NEW stack, not the current stack.
 *
 * Also, we rely on a new function, pushData(), instead of pushWord(), to accommodate the outgoing segment size,
 * which may differ from the incoming segment.  For example, when a 32-bit code segment performs a 16:32 call to a
 * 16-bit code segment, we must push 32-bit segment and offset values.
 *
 * TODO: Since setCSIP() already informs the segCS load() function when it's making a call, the load() function
 * could automatically push the old CS and IP values *before* segCS is updated -- which would be a better time to do
 * those pushes AND eliminate the need for pushData().  Unfortunately, load() is also used by loadIDT(), and loadIDT()
 * has different requirements (eg, pushing flags first), so it's not a trivial change.
 *
 * @this {CPUx86}
 * @param {number} off
 * @param {number} sel
 */
X86.helpCALLF = function(off, sel)
{
    /**
     * Since we always push the return address AFTER calling setCSIP(), and since either push could trigger
     * a fault (eg, segment fault, page fault, etc), we must not only snapshot regSS and regLSP, but also regCS,
     * so that helpFault() can always make CALLF restartable.
     */
    this.opCS = this.getCS();
    this.opSS = this.getSS();
    this.opLSP = this.regLSP;
    let oldIP = this.getIP();
    let oldSize = (I386? this.sizeData : 2);
    if (this.setCSIP(off, sel, true) != null) {
        /**
         * When the OPERAND size is 32 bits, the 80386 will decrement the stack pointer by 4, write the selector
         * into the 2 lower bytes, and leave the 2 upper bytes untouched; at least, that's the case for all other
         * segment register writes, so we assume this case is no different.  Hence, the hard-coded size of 2.
         */
        this.pushData(this.opCS, oldSize, 2);
        this.pushData(oldIP, oldSize, oldSize);
    }
    this.opLSP = X86.ADDR_INVALID;
    this.opCS = this.opSS = -1;
};

/**
 * helpINT(nIDT, nError, nBytes, nCycles)
 *
 * NOTE: We no longer use setCSIP(), because it always loads the new CS using segCS.load(), which only knows
 * how to load GDT and LDT descriptors, whereas interrupts must use setCS.loadIDT(), which deals exclusively
 * with IDT descriptors.
 *
 * @this {CPUx86}
 * @param {number} nIDT
 * @param {number|null} [nError]
 * @param {number} [nBytes] (size of opcode, if any)
 * @param {number} [nCycles] (in addition to the default of nOpCyclesInt)
 */
X86.helpINT = function(nIDT, nError, nBytes = 0, nCycles = 0)
{
    /**
     * TODO: We assess the cycle cost up front, because otherwise, if loadIDT() fails, no cost may be assessed.
     */
    this.nStepCycles -= this.cycleCounts.nOpCyclesInt + nCycles;
    let oldPS = this.getPS();
    let oldCS = this.getCS();
    let oldIP = this.getIP();
    /**
     * Support for INT 06h operation checks.  The only operation we consume is the one reserved for breakpoints,
     * and only if our debugger is running.  All these should only occur in DEBUG builds of the underlying operating
     * system (ie, BASIC-DOS), which should clean up after itself.  See https://github.com/jeffpar/basicdos.
     */
    if (nIDT == 0x06 && this.model <= X86.MODEL_8088) {
        let op = this.getSOWord(this.segCS, oldIP-2);
        if (op == 0x06CD) {
            let actual;
            let argA = this.getSOWord(this.segSS, this.regEBP+10) | (this.getSOWord(this.segSS, this.regEBP+12) << 16);
            let argB = this.getSOWord(this.segSS, this.regEBP+6) | (this.getSOWord(this.segSS, this.regEBP+8) << 16);
            let result = this.regEAX | (this.regEDX << 16);
            let remainder = this.regEDI | (this.regESI << 16);
            switch(this.peekIPByte()) {
            case 0xCC:
                if (DEBUGGER && this.dbg && this.flags.running) {
                    this.getIPByte();
                    this.printf("debugger halting on INT 0x06,0xCC\n");
                    this.dbg.stopCPU();
                    return;
                }
                break;
            case 0xFB:
                actual = (argA * argB)|0;
                if (result != actual) {
                    if (!COMPILED) this.printf(MESSAGE.INT, "result %#x for %#x * %#x does not match actual: %#x\n", result, argA, argB, actual);
                }
                break;
            case 0xFC:
                actual = (argA / argB)|0;
                if (result != actual) {
                    if (!COMPILED) this.printf(MESSAGE.INT, "result %#x for %#x / %#x does not match actual: %#x\n", result, argA, argB, actual);
                }
                actual = (argA % argB)|0;
                if (remainder != actual) {
                    if (!COMPILED) this.printf(MESSAGE.INT, "result %#x for %#x % %#x does not match actual: %#x\n", result, argA, argB, actual);
                }
                break;
            }
        }
    }
    if (nIDT == 0x13 && this.model <= X86.MODEL_8088) {
        if (DEBUGGER && this.dbg && this.regEAX == 0x0201 && this.regEBX == 0x7C00 && this.segES.sel == 0) {
            this.setShort(0x52D, 0x4442);       // on 8088 boot up, set a special "BD" boot indicator in low memory
        }
    }
    let addr = this.segCS.loadIDT(nIDT, nBytes);
    if (addr !== X86.ADDR_INVALID) {
        /**
         * TODO: Determine if we should use pushData() instead of pushWord() for oldCS and nError, to deal with
         * the same 32-bit 80386 compatibility issue that helpCALLF(), opPUSHCS(), et al must deal with; namely, that
         * 32-bit segment register writes (and, reportedly, 32-bit error codes) don't modify the upper 16 bits.
         *
         * Also, note that helpCALLF() is using the OPERAND size in effect *before* CS is loaded, whereas here we're
         * using the OPERAND size in effect *after* CS is loaded.  Is that correct?  And does an explicit OPERAND
         * size override on an "INT" instruction have any effect on that behavior?  Is that even allowed?
         */
        this.pushWord(oldPS);
        this.pushWord(oldCS);
        this.pushWord(oldIP);
        if (nError != null) this.pushWord(nError);
        this.nFault = -1;
        this.setLIP(addr);
    }
};

/**
 * helpIRET()
 *
 * @this {CPUx86}
 */
X86.helpIRET = function()
{
    this.opSS = this.getSS();
    this.opLSP = this.regLSP;

    this.nStepCycles -= this.cycleCounts.nOpCyclesIRet;

    if ((this.regCR0 & X86.CR0.MSW.PE) && (this.regPS & (X86.PS.NT | X86.PS.VM)) == X86.PS.NT) {
        let addrNew = this.segTSS.base;
        /**
         * Fortunately, X86.TSS286.PREV_TSS and X86.TSS386.PREV_TSS refer to the same TSS offset.
         * TODO: Update switchTS() to assess a cycle cost; currently, all we assess is what's shown above.
         */
        let sel = this.getShort(addrNew + X86.TSS286.PREV_TSS);
        this.segCS.switchTSS(sel, false);
    }
    else {
        let cpl = this.nCPL;
        let newIP = this.popWord();
        let newCS = this.popWord();
        let newPS = this.popWord();

        if (I386) {
            if (this.regPS & X86.PS.VM) {
                /**
                 * On the 80386, in V86-mode, RF is the only defined EFLAGS bit above bit 15 that may be changed by IRETD.
                 * This is less restrictive than POPFD, which cannot change ANY bits above bit 15; see opPOPF() for details.
                 */
                newPS = (newPS & (0xffff | X86.PS.RF)) | (this.regPS & ~(0xffff | X86.PS.RF));
            }
            else {
                if (newPS & X86.PS.VM) {
                    /**
                     * As noted in loadDesc8(), where the V86-mode frame we're about to pop was originally pushed,
                     * these frames ALWAYS contain 32-bit values, so make sure that sizeData reflects that.
                     */

                    /**
                     * We have to assume that a full V86-mode interrupt frame was on the protected-mode stack; namely:
                     *
                     *      low:    EIP
                     *              CS (padded to 32 bits)
                     *              EFLAGS
                     *              ESP
                     *              SS (padded to 32 bits)
                     *              ES (padded to 32 bits)
                     *              DS (padded to 32 bits)
                     *              FS (padded to 32 bits)
                     *      high:   GS (padded to 32 bits)
                     *
                     * We've already popped EIP, CS, and EFLAGS into newIP, newCS and newPS, respectively, so we must now
                     * pop the rest, while we're still in protected-mode, before the switch to V86-mode alters the current
                     * operand size (among other things).
                     */
                    let newSP = this.popWord();
                    let newSS = this.popWord();
                    let newES = this.popWord();
                    let newDS = this.popWord();
                    let newFS = this.popWord();
                    let newGS = this.popWord();
                    this.setProtMode(true, true);       // flip the switch to V86-mode now
                    this.setSS(newSS);
                    this.setSP(newSP);
                    this.setES(newES);
                    this.setDS(newDS);
                    this.setFS(newFS);
                    this.setGS(newGS);
                }
            }
        }

        if (this.setCSIP(newIP, newCS, false) != null) {
            this.setPS(newPS, cpl);
            if (this.cIntReturn) this.checkIntReturn(this.regLIP);
        }
    }

    this.opLSP = X86.ADDR_INVALID;
    this.opSS = -1;
};

/**
 * helpRETF(n)
 *
 * For protected-mode, this function must pop any arguments off the current stack AND whatever stack
 * we may have switched to; setCSIP() returns true if a stack switch occurred, false if not, and null
 * if an error occurred.
 *
 * @this {CPUx86}
 * @param {number} n
 */
X86.helpRETF = function(n)
{
    this.opSS = this.getSS();
    this.opLSP = this.regLSP;

    let newIP = this.popWord();
    let newCS = this.popWord();

    if (n) this.setSP(this.getSP() + n);            // TODO: optimize

    if (this.setCSIP(newIP, newCS, false)) {        // returns true if a stack switch occurred
        /**
         * Fool me once, shame on... whatever.  If setCSIP() indicates a stack switch occurred,
         * make sure we're in protected mode, because automatic stack switches can't occur in real mode.
         */


        if (n) this.setSP(this.getSP() + n);        // TODO: optimize

        /**
         * As per Intel documentation: "If any of [the DS or ES] registers refer to segments whose DPL is
         * less than the new CPL (excluding conforming code segments), the segment register is loaded with
         * the null selector."
         *
         * TODO: I'm not clear on whether a conforming code segment must also be marked readable, so I'm playing
         * it safe and using CODE_CONFORMING instead of CODE_CONFORMING_READABLE.  Also, for the record, I've not
         * seen this situation occur yet (eg, in OS/2 1.0).
         */
        X86.zeroSeg.call(this, this.segDS);
        X86.zeroSeg.call(this, this.segES);
        if (I386 && this.model >= X86.MODEL_80386) {
            X86.zeroSeg.call(this, this.segFS);
            X86.zeroSeg.call(this, this.segGS);
        }
    }
    if (n == 2 && this.cIntReturn) this.checkIntReturn(this.regLIP);

    this.opLSP = X86.ADDR_INVALID;
    this.opSS = -1;
};

/**
 * helpDIVOverflow()
 *
 * @this {CPUx86}
 */
X86.helpDIVOverflow = function()
{
    /**
     * Divide error exceptions are traps on the 8086 and faults on later processors.  I question the value of that
     * change, because it implies that someone might actually want to restart a failing divide.  The only reasonable
     * explanation I can see for the change is to enable the exception handler to accurately record the address of
     * the failing divide, which seems like a very minor benefit.  It doesn't change the fact that, on any processor,
     * the exception handler's only reasonable recourse is to unwind execution to a safe point (or terminate the app).
     *
     * TODO: Determine the proper cycle cost.
     */
    if (this.model <= X86.MODEL_8088) {
        X86.helpTrap.call(this, X86.EXCEPTION.DE_EXC, 0, 2);
    } else {
        X86.helpFault.call(this, X86.EXCEPTION.DE_EXC, null, 2);
    }
};

/**
 * helpInterrupt(nIDT, nCycles)
 *
 * Helper to dispatch external interrupts.  nCycles defaults to 11 for the 8086/8088
 * if no alternate value is specified.
 *
 * @this {CPUx86}
 * @param {number} nIDT
 * @param {number} [nCycles] (number of cycles in addition to the default of nOpCyclesInt)
 */
X86.helpInterrupt = function(nIDT, nCycles = 11)
{
    this.nFault = nIDT;
    X86.helpINT.call(this, nIDT, null, 0, nCycles);
};

/**
 * helpTrap(nIDT, nBytes, nCycles)
 *
 * Helper to dispatch traps (ie, exceptions that occur AFTER the instruction, with NO error code)
 *
 * @this {CPUx86}
 * @param {number} nIDT
 * @param {number} [nBytes] (size of opcode, of any)
 * @param {number} [nCycles] (number of cycles in addition to the default of nOpCyclesInt)
 */
X86.helpTrap = function(nIDT, nBytes, nCycles)
{
    this.nFault = -1;
    X86.helpINT.call(this, nIDT, null, nBytes, nCycles);
};

/**
 * helpFault(nFault, nError, nCycles, fHalt)
 *
 * Helper to dispatch faults (ie, exceptions that occur DURING an instruction and MAY generate an error code)
 *
 * @this {CPUx86}
 * @param {number} nFault
 * @param {number|null} [nError] (if omitted, no error code will be pushed)
 * @param {number} [nCycles] cycle count to pass through to helpINT(), if any
 * @param {boolean} [fHalt] (true to halt the CPU, false to not, undefined if "it depends")
 */
X86.helpFault = function(nFault, nError, nCycles, fHalt)
{
    let fDispatch = false;

    if (!this.flags.complete) {
        /**
         * Prior to each new burst of instructions, stepCPU() sets fComplete to true, and the only (normal) way
         * for fComplete to become false is through stopCPU(), which isn't ordinarily called, except by the Debugger.
         */
        this.setLIP(this.opLIP);
    }
    else if (this.model >= X86.MODEL_80186) {

        fDispatch = true;

        if (this.nFault < 0) {
            /**
             * Single-fault (error code is passed through, and the responsible instruction is restartable.
             *
             * TODO: The following opCS/opLIP/opSS/opLSP checks are primarily required for 80386-based machines
             * with paging enabled, because page faults introduce a new set of complex faults that our current
             * segment load "probes" are insufficient to catch.  So as a stop-gap measure, we rely on these four
             * "snapshot" registers to resolve the general instruction restartability problem (for now).
             *
             * If you want to closely examine the underlying causes of these more complex faults, set breakpoints
             * where indicated below, and examine the stack trace.
             */
            if (this.opCS != -1) {
                if (this.opCS !== this.segCS.sel) {
                    /**
                     * HACK: We slam the RPL into this.segCS.cpl to ensure that loading the original CS segment doesn't
                     * fail.  For example, if we faulted in the middle of a ring transition that loaded CS with a higher
                     * privilege (lower CPL) code segment, then our attempt here to reload the lower privilege (higher CPL)
                     * code segment could be viewed as a privilege violation (which it would be outside this context).
                     */
                    this.segCS.cpl = this.opCS & 0x3;           // set breakpoint here to inspect complex faults
                    this.setCS(this.opCS);
                }
                this.opCS = -1;
            }
            if (this.opLIP !== this.regLIP) {
                this.setLIP(this.opLIP);                        // set breakpoint here to inspect complex faults

            }
            if (this.opSS != -1) {
                if (this.opSS !== this.segSS.sel) {
                    this.setSS(this.opSS);                      // set breakpoint here to inspect complex faults
                }
                this.opSS = -1;
            }
            if (this.opLSP !== X86.ADDR_INVALID) {
                if (this.opLSP !== this.regLSP) {               // set breakpoint below to inspect complex faults
                    this.setSP((this.regESP & ~this.segSS.maskAddr) | (this.opLSP - this.segSS.base));

                }
                this.opLSP = X86.ADDR_INVALID;
            }
        }
        else if (this.nFault != X86.EXCEPTION.DF_FAULT) {
            /**
             * Double-fault (error code is always zero, and the responsible instruction is not restartable).
             */
            nError = 0;
            nFault = X86.EXCEPTION.DF_FAULT;
        }
        else {
            /**
             * This is a triple-fault (usually referred to in Intel literature as a "shutdown", but it's actually a
             * "reset").  There's nothing to "dispatch" in this case, but we still want to let helpCheckFault() see
             * the triple-fault.  However, regardless what helpCheckFault() returns, we must leave via "throw -1",
             * because we need to blow off whatever context triggered the triple-fault; that was less critical when
             * all we dealt with were 80286-based triple-faults (at least the "normal" triple-faults that OS/2 would
             * generate), but for any other unexpected triple-faults, "dispatching" a throw is critical.
             */
            nError = 0;
            nFault = -1;
            fHalt = false;
            this.resetRegs();
        }
    }

    if (X86.helpCheckFault.call(this, nFault, nError, fHalt) || nFault < 0) {
        /**
         * If this is a fault that would normally be dispatched BUT helpCheckFault() wants us to halt,
         * then we throw a bogus fault number (-1), simply to interrupt the current instruction in exactly
         * the same way that a dispatched fault would interrupt it.
         */
        if (fDispatch) throw -1;
    }

    if (fDispatch) {

        this.nFault = nFault;
        X86.helpINT.call(this, nFault, nError, 0, nCycles);

        /**
         * REPeated instructions that rewind regLIP to opLIP used to screw up this dispatch,
         * so now we slip the new regLIP into opLIP, effectively turning their action into a no-op.
         */
        this.opLIP = this.regLIP;

        /**
         * X86.OPFLAG.FAULT flag is used by selected opcodes to provide an early exit, restore register(s),
         * or whatever is needed to help ensure instruction restartability; there is currently no general
         * mechanism for snapping and restoring all registers for any instruction that might fault.
         *
         * X86.EXCEPTION.DB_EXC exceptions set their own special flag, X86.OPFLAG.DBEXC, to prevent redundant
         * DEBUG exceptions, so we don't need to set OPFLAG.FAULT in that case, because a DEBUG exception
         * doesn't actually prevent an instruction from executing (and therefore doesn't need to be restarted).
         */
        if (nFault == X86.EXCEPTION.DB_EXC) {
            this.opFlags |= X86.OPFLAG.DBEXC;
        } else {

            this.opFlags |= X86.OPFLAG.FAULT;
        }

        /**
         * Since this fault is likely being issued in the context of an instruction that hasn't finished
         * executing, if we don't do anything to interrupt that execution (eg, throw a JavaScript exception),
         * then we would need to shut off all further reads/writes for the current instruction.
         *
         * That's easy for any EA-based memory accesses: simply set both the NOREAD and NOWRITE flags.
         * However, there are also direct, non-EA-based memory accesses to consider.  A perfect example is
         * opPUSHA(): if a GP fault occurs on any PUSH other than the last, a subsequent PUSH is likely to
         * cause another fault, which we will misinterpret as a double-fault -- unless the handler for
         * such an opcode checks this.opFlags for X86.OPFLAG.FAULT after each step of the operation.
         *
         *      this.opFlags |= (X86.OPFLAG.NOREAD | X86.OPFLAG.NOWRITE);
         *
         * Fortunately, we now throw an exception that terminates the current instruction, so the above hack
         * should no longer be necessary.
         */
        throw nFault;
    }
};

/**
 * helpPageFault(addr, fPresent, fWrite)
 *
 * Helper to dispatch page faults.
 *
 * @this {CPUx86}
 * @param {number} addr
 * @param {boolean} fPresent
 * @param {boolean} fWrite
 */
X86.helpPageFault = function(addr, fPresent, fWrite)
{
    this.regCR2 = addr;
    let nError = 0;
    if (fPresent) nError |= X86.PTE.PRESENT;
    if (fWrite) nError |= X86.PTE.READWRITE;
    if (this.nCPL == 3) nError |= X86.PTE.USER;
    X86.helpFault.call(this, X86.EXCEPTION.PF_FAULT, nError);
};

/**
 * helpCheckFault(nFault, nError, fHalt)
 *
 * Aside from giving the Debugger an opportunity to report every fault, this also gives us the ability to
 * halt exception processing in tracks: return true to prevent the fault handler from being dispatched.
 *
 * At the moment, the only Debugger control you have over fault interception is setting MESSAGE.FAULT, which
 * will display faults as they occur, and MESSAGE.HALT, which will halt after any Debugger message, including
 * MESSAGE.FAULT.  If you want execution to continue after halting, clear MESSAGE.FAULT and/or MESSAGE.HALT,
 * or single-step over the offending instruction, which will allow the fault to be dispatched.
 *
 * @this {CPUx86}
 * @param {number} nFault
 * @param {number|null} [nError] (if omitted, no error code will be reported)
 * @param {boolean} [fHalt] (true to halt the CPU, false to not, undefined if "it depends")
 * @returns {boolean|undefined} true to block the fault (often desirable when fHalt is true), otherwise dispatch it
 */
X86.helpCheckFault = function(nFault, nError, fHalt)
{
    let bitsMessage = MESSAGE.FAULT;

    let bOpcode = this.probeAddr(this.regLIP);

    /**
     * OS/2 1.0 uses an INT3 (0xCC) opcode in conjunction with an invalid IDT to trigger a triple-fault
     * reset and return to real-mode, and these resets happen quite frequently during boot; for example,
     * OS/2 startup messages are displayed using a series of INT 0x10 BIOS calls for each character, and
     * each series of BIOS calls requires a round-trip mode switch.
     *
     * Since we really only want to halt on "bad" faults, not "good" (ie, intentional) faults, we take
     * advantage of the fact that all 3 faults comprising the triple-fault point to an INT3 (0xCC) opcode,
     * and so whenever we see that opcode, we ignore the caller's fHalt flag, and suppress FAULT messages
     * unless CPU messages are also enabled.
     *
     * When a triple fault shows up, nFault is -1; it displays as 0xff only because we use toHexByte().
     */
    if (bOpcode == X86.OPCODE.INT3 && !this.addrIDTLimit) {
        fHalt = false;
    }

    /**
     * There are a number of V86-mode exceptions we don't need to know about.  For starters, Windows 3.00
     * (and other versions of enhanced-mode Windows) use an ARPL to switch out of V86-mode, so we can ignore
     * those UD_FAULTs.
     *
     * Ditto for software interrupts, which will generate a GP_FAULT when the interrupt number (eg, 0x6D)
     * exceeds the protected-mode IDT's limit (eg, a limit of 0x2FF corresponds to a maximum interrupt number
     * of 0x5F).  Windows doesn't really care if its IDT is too small, because it has to simulate all software
     * interrupts in V86-mode regardless (they generate a GP_FAULT if IOPL < 3, and even when IOPL == 3, only
     * the protected-mode IDT handler gets to run).
     *
     * Ditto for I/O instructions, which may generate a GP_FAULT depending on the IOPL and/or the IOPM.
     */
    if (this.regPS & X86.PS.VM) {
        if (nFault == X86.EXCEPTION.UD_FAULT && bOpcode == X86.OPCODE.ARPL ||
            nFault == X86.EXCEPTION.GP_FAULT && (
                bOpcode == X86.OPCODE.PUSHF || bOpcode == X86.OPCODE.POPF ||
                bOpcode == X86.OPCODE.INTN || bOpcode == X86.OPCODE.IRET ||
                bOpcode >= X86.OPCODE.INB && bOpcode <= X86.OPCODE.OUTW ||
                bOpcode >= X86.OPCODE.INDXB && bOpcode <= X86.OPCODE.OUTDXW ||
                bOpcode == X86.OPCODE.CLI || bOpcode == X86.OPCODE.STI
            )) {
            fHalt = false;
        }
    }
    // else if (DEBUG && nFault == X86.EXCEPTION.GP_FAULT && fHalt === undefined) fHalt = true;

    /**
     * If fHalt has been explicitly set to false, we also take that as a cue to disable fault messages
     * (which you can override by turning on CPU messages).
     */
    if (fHalt === false) {
        bitsMessage |= MESSAGE.CPU;
    }

    /**
     * Similarly, the PC AT ROM BIOS deliberately generates a couple of GP faults as part of the POST
     * (Power-On Self Test); we don't want to ignore those, but we don't want to halt on them either.  We
     * detect those faults by virtue of the LIP being in the range 0x0F0000 to 0x0FFFFF.
     *
     * TODO: Be aware that this test can trigger false positives, such as when a V86-mode ARPL is hit; eg:
     *
     *      &FD82:22F7 6338            ARPL     [BX+SI],DI
     */
    if (this.regLIP >= 0x0F0000 && this.regLIP <= 0x0FFFFF) {
        fHalt = false;
    }

    /**
     * However, the foregoing notwithstanding, if MESSAGE.HALT is enabled along with all the other required
     * MESSAGE bits, then we want to halt regardless.
     */
    if (this.messageEnabled(bitsMessage + MESSAGE.HALT)) {
        fHalt = true;
    }

    if (this.messageEnabled(bitsMessage) || fHalt) {

        let fRunning = this.flags.running;
        let sMessage = "Fault " + StrLib.toHexByte(nFault) + (nError != null? " (" + StrLib.toHexWord(nError) + ")" : "") + " on opcode " + StrLib.toHexByte(bOpcode);
        if (fHalt) {
            if (fRunning) sMessage += " (blocked)";
        }
        if (DEBUGGER && this.dbg) {
            this.printf((fHalt? MESSAGE.PROGRESS : bitsMessage) + MESSAGE.ADDR, "%s\n", sMessage);
            if (fHalt) {
                /**
                 * By setting fHalt to fRunning (which is true while running but false while single-stepping),
                 * this allows a fault to be dispatched when you single-step over a faulting instruction; you can
                 * then continue single-stepping into the fault handler, or start running again.
                 *
                 * Note that we had to capture fRunning before calling printf(), because if MESSAGE.HALT is set,
                 * printf() will have already halted the CPU.
                 */
                fHalt = fRunning;
                this.dbg.stopCPU();
            }
        } else {
            /**
             * If there's no Debugger, then messageEnabled() must have returned false, which means that fHalt must
             * be true.  Which means we should shut the machine down.
             */

            this.printf(MESSAGE.NOTICE, "%s\n", sMessage);
            this.stopCPU();
        }
    }
    return fHalt;
};

/**
 * zeroSeg(seg)
 *
 * Helper to zero a segment register whenever transitioning to a less privileged (numerically higher) level.
 *
 * @this {CPUx86}
 * @param {Segx86} seg
 */
X86.zeroSeg = function(seg)
{
    let acc = seg.acc & X86.DESC.ACC.TYPE.CODE_OR_DATA;
    if (seg.sel & X86.SEL.MASK) {
        if (acc == X86.DESC.ACC.TYPE.CODE_EXECONLY ||           // non-readable code segment (not allowed)
            acc == X86.DESC.ACC.TYPE.CODE_CONFORMING ||         // non-readable code segment (not allowed)
            acc < X86.DESC.ACC.TYPE.CODE_CONFORMING && seg.dpl < this.nCPL && seg.dpl < (seg.sel & X86.SEL.RPL)) {
            seg.load(0);
        }
    }
};

/**
 * @copyright https://www.pcjs.org/machines/pcx86/modules/v2/x86mods.js (C) 2012-2024 Jeff Parsons
 */

/**
 * Before 80386 support was added to PCx86, the approach to decoding ModRegRM bytes (which I usually
 * just call ModRM bytes) used one generated function per ModRM value.  This was optimal for 16-bit processors,
 * because the functions were small, and it was maximally efficient, turning the entire ModRM decoding operation
 * into one table lookup and function call.
 *
 * However, that approach didn't scale well for 32-bit processors, which had extended ModRM capabilities in both
 * the addressing mode dimension and the operand size dimension.  So I've rewritten ModRM decoding as 18 functions.
 * The first 9 are for 16-bit addressing modes, and the second 9 are for 32-bit addressing modes.  Within each
 * group of 9, there are 3 for 8-bit operands, 3 for 16-bit operands, and 3 for 32-bit operands.  And each group of 3
 * contains functions for register-source, memory-source, and group-source.
 *
 * Each of the 18 functions must do additional work to examine the ModRM bits, which makes decoding slightly slower,
 * but it's not really noticeable, and the speed difference didn't justify the additional generated code.  So one much
 * smaller file (x86mods.js) replaces a host of older files (x86modb.js, x86modw.js, x86modb16.js, x86modw16.js,
 * x86modb32.js, x86modw32.js, and x86modsib.js).
 *
 * You can dig up the older files from the repository if you're curious, or you can run /tools/misc/x86gen.js to
 * get a sense of what they contained (x86gen.js created most of the code, but it still had to be massaged afterward).
 */

/**
 * modRegByte16(fn)
 *
 * @this {CPUx86}
 * @param {function(number,number)} fn (dst,src)
 */
X86.modRegByte16 = function(fn)
{
    let dst, src;
    let bModRM = (this.bModRM = this.getIPByte()) & 0xC7;

    switch(bModRM) {
    case 0x00:
        src = this.getEAByteData(this.regEBX + this.regESI);
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseIndex;
        break;
    case 0x01:
        src = this.getEAByteData(this.regEBX + this.regEDI);
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseIndexExtra;
        break;
    case 0x02:
        src = this.getEAByteStack(this.regEBP + this.regESI);
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseIndexExtra;
        break;
    case 0x03:
        src = this.getEAByteStack(this.regEBP + this.regEDI);
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseIndex;
        break;
    case 0x04:
        src = this.getEAByteData(this.regESI);
        this.nStepCycles -= this.cycleCounts.nEACyclesBase;
        break;
    case 0x05:
        src = this.getEAByteData(this.regEDI);
        this.nStepCycles -= this.cycleCounts.nEACyclesBase;
        break;
    case 0x06:
        src = this.getEAByteData(this.getIPAddr());
        this.nStepCycles -= this.cycleCounts.nEACyclesDisp;
        break;
    case 0x07:
        src = this.getEAByteData(this.regEBX);
        this.nStepCycles -= this.cycleCounts.nEACyclesBase;
        break;
    case 0x40:
        src = this.getEAByteData(this.regEBX + this.regESI + this.getIPDisp());
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseIndexDisp;
        break;
    case 0x41:
        src = this.getEAByteData(this.regEBX + this.regEDI + this.getIPDisp());
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseIndexDispExtra;
        break;
    case 0x42:
        src = this.getEAByteStack(this.regEBP + this.regESI + this.getIPDisp());
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseIndexDispExtra;
        break;
    case 0x43:
        src = this.getEAByteStack(this.regEBP + this.regEDI + this.getIPDisp());
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseIndexDisp;
        break;
    case 0x44:
        src = this.getEAByteData(this.regESI + this.getIPDisp());
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseDisp;
        break;
    case 0x45:
        src = this.getEAByteData(this.regEDI + this.getIPDisp());
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseDisp;
        break;
    case 0x46:
        src = this.getEAByteStack(this.regEBP + this.getIPDisp());
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseDisp;
        break;
    case 0x47:
        src = this.getEAByteData(this.regEBX + this.getIPDisp());
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseDisp;
        break;
    case 0x80:
        src = this.getEAByteData(this.regEBX + this.regESI + this.getIPAddr());
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseIndexDisp;
        break;
    case 0x81:
        src = this.getEAByteData(this.regEBX + this.regEDI + this.getIPAddr());
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseIndexDispExtra;
        break;
    case 0x82:
        src = this.getEAByteStack(this.regEBP + this.regESI + this.getIPAddr());
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseIndexDispExtra;
        break;
    case 0x83:
        src = this.getEAByteStack(this.regEBP + this.regEDI + this.getIPAddr());
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseIndexDisp;
        break;
    case 0x84:
        src = this.getEAByteData(this.regESI + this.getIPAddr());
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseDisp;
        break;
    case 0x85:
        src = this.getEAByteData(this.regEDI + this.getIPAddr());
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseDisp;
        break;
    case 0x86:
        src = this.getEAByteStack(this.regEBP + this.getIPAddr());
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseDisp;
        break;
    case 0x87:
        src = this.getEAByteData(this.regEBX + this.getIPAddr());
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseDisp;
        break;
    case 0xC0:
        src = this.regEAX & 0xff;
        if (BACKTRACK) this.backTrack.btiEALo = this.backTrack.btiAL;
        break;
    case 0xC1:
        src = this.regECX & 0xff;
        if (BACKTRACK) this.backTrack.btiEALo = this.backTrack.btiCL;
        break;
    case 0xC2:
        src = this.regEDX & 0xff;
        if (BACKTRACK) this.backTrack.btiEALo = this.backTrack.btiDL;
        break;
    case 0xC3:
        src = this.regEBX & 0xff;
        if (BACKTRACK) this.backTrack.btiEALo = this.backTrack.btiBL;
        break;
    case 0xC4:
        src = (this.regEAX >> 8) & 0xff;
        if (BACKTRACK) this.backTrack.btiEALo = this.backTrack.btiAH;
        break;
    case 0xC5:
        src = (this.regECX >> 8) & 0xff;
        if (BACKTRACK) this.backTrack.btiEALo = this.backTrack.btiCH;
        break;
    case 0xC6:
        src = (this.regEDX >> 8) & 0xff;
        if (BACKTRACK) this.backTrack.btiEALo = this.backTrack.btiDH;
        break;
    case 0xC7:
        src = (this.regEBX >> 8) & 0xff;
        if (BACKTRACK) this.backTrack.btiEALo = this.backTrack.btiBH;
        break;
    default:
        src = 0;

        break;
    }

    let reg = (this.bModRM >> 3) & 0x7;

    switch(reg) {
    case 0x0:
        dst = this.regEAX & 0xff;
        break;
    case 0x1:
        dst = this.regECX & 0xff;
        break;
    case 0x2:
        dst = this.regEDX & 0xff;
        break;
    case 0x3:
        dst = this.regEBX & 0xff;
        break;
    case 0x4:
        dst = (this.regEAX >> 8) & 0xff;
        break;
    case 0x5:
        dst = (this.regECX >> 8) & 0xff;
        break;
    case 0x6:
        dst = (this.regEDX >> 8) & 0xff;
        break;
    case 0x7:
        dst = (this.regEBX >> 8) & 0xff;
        break;
    default:
        dst = 0;
        break;
    }

    let b = fn.call(this, dst, src);

    switch(reg) {
    case 0x0:
        this.regEAX = (this.regEAX & ~0xff) | b;
        if (BACKTRACK) this.backTrack.btiAL = this.backTrack.btiEALo;
        break;
    case 0x1:
        this.regECX = (this.regECX & ~0xff) | b;
        if (BACKTRACK) this.backTrack.btiCL = this.backTrack.btiEALo;
        break;
    case 0x2:
        this.regEDX = (this.regEDX & ~0xff) | b;
        if (BACKTRACK) this.backTrack.btiDL = this.backTrack.btiEALo;
        break;
    case 0x3:
        this.regEBX = (this.regEBX & ~0xff) | b;
        if (BACKTRACK) this.backTrack.btiBL = this.backTrack.btiEALo;
        break;
    case 0x4:
        this.regEAX = (this.regEAX & ~0xff00) | (b << 8);
        if (BACKTRACK) this.backTrack.btiAH = this.backTrack.btiEALo;
        break;
    case 0x5:
        this.regECX = (this.regECX & ~0xff00) | (b << 8);
        if (BACKTRACK) this.backTrack.btiCH = this.backTrack.btiEALo;
        break;
    case 0x6:
        this.regEDX = (this.regEDX & ~0xff00) | (b << 8);
        if (BACKTRACK) this.backTrack.btiDH = this.backTrack.btiEALo;
        break;
    case 0x7:
        this.regEBX = (this.regEBX & ~0xff00) | (b << 8);
        if (BACKTRACK) this.backTrack.btiBH = this.backTrack.btiEALo;
        break;
    }
};

/**
 * modMemByte16(fn)
 *
 * @this {CPUx86}
 * @param {function(number,number)} fn (dst,src)
 */
X86.modMemByte16 = function(fn)
{
    let dst, src;
    let bModRM = (this.bModRM = this.getIPByte()) & 0xC7;

    switch(bModRM) {
    case 0x00:
        dst = this.getEAByteData(this.regEBX + this.regESI);
        this.regEAWrite = this.regEA;
        break;
    case 0x01:
        dst = this.getEAByteData(this.regEBX + this.regEDI);
        this.regEAWrite = this.regEA;
        break;
    case 0x02:
        dst = this.getEAByteStack(this.regEBP + this.regESI);
        this.regEAWrite = this.regEA;
        break;
    case 0x03:
        dst = this.getEAByteStack(this.regEBP + this.regEDI);
        this.regEAWrite = this.regEA;
        break;
    case 0x04:
        dst = this.getEAByteData(this.regESI);
        this.regEAWrite = this.regEA;
        break;
    case 0x05:
        dst = this.getEAByteData(this.regEDI);
        this.regEAWrite = this.regEA;
        break;
    case 0x06:
        dst = this.getEAByteData(this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x07:
        dst = this.getEAByteData(this.regEBX);
        this.regEAWrite = this.regEA;
        break;
    case 0x40:
        dst = this.getEAByteData(this.regEBX + this.regESI + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x41:
        dst = this.getEAByteData(this.regEBX + this.regEDI + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x42:
        dst = this.getEAByteStack(this.regEBP + this.regESI + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x43:
        dst = this.getEAByteStack(this.regEBP + this.regEDI + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x44:
        dst = this.getEAByteData(this.regESI + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x45:
        dst = this.getEAByteData(this.regEDI + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x46:
        dst = this.getEAByteStack(this.regEBP + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x47:
        dst = this.getEAByteData(this.regEBX + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x80:
        dst = this.getEAByteData(this.regEBX + this.regESI + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x81:
        dst = this.getEAByteData(this.regEBX + this.regEDI + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x82:
        dst = this.getEAByteStack(this.regEBP + this.regESI + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x83:
        dst = this.getEAByteStack(this.regEBP + this.regEDI + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x84:
        dst = this.getEAByteData(this.regESI + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x85:
        dst = this.getEAByteData(this.regEDI + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x86:
        dst = this.getEAByteStack(this.regEBP + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x87:
        dst = this.getEAByteData(this.regEBX + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0xC0:
        dst = this.regEAX & 0xff;
        break;
    case 0xC1:
        dst = this.regECX & 0xff;
        break;
    case 0xC2:
        dst = this.regEDX & 0xff;
        break;
    case 0xC3:
        dst = this.regEBX & 0xff;
        break;
    case 0xC4:
        dst = (this.regEAX >> 8) & 0xff;
        break;
    case 0xC5:
        dst = (this.regECX >> 8) & 0xff;
        break;
    case 0xC6:
        dst = (this.regEDX >> 8) & 0xff;
        break;
    case 0xC7:
        dst = (this.regEBX >> 8) & 0xff;
        break;
    default:
        dst = 0;

        break;
    }

    let reg = (this.bModRM >> 3) & 0x7;

    switch(reg) {
    case 0x0:
        src = this.regEAX & 0xff;
        if (BACKTRACK) this.backTrack.btiEALo = this.backTrack.btiAL;
        break;
    case 0x1:
        src = this.regECX & 0xff;
        if (BACKTRACK) this.backTrack.btiEALo = this.backTrack.btiCL;
        break;
    case 0x2:
        src = this.regEDX & 0xff;
        if (BACKTRACK) this.backTrack.btiEALo = this.backTrack.btiDL;
        break;
    case 0x3:
        src = this.regEBX & 0xff;
        if (BACKTRACK) this.backTrack.btiEALo = this.backTrack.btiBL;
        break;
    case 0x4:
        src = (this.regEAX >> 8) & 0xff;
        if (BACKTRACK) this.backTrack.btiEALo = this.backTrack.btiAH;
        break;
    case 0x5:
        src = (this.regECX >> 8) & 0xff;
        if (BACKTRACK) this.backTrack.btiEALo = this.backTrack.btiCH;
        break;
    case 0x6:
        src = (this.regEDX >> 8) & 0xff;
        if (BACKTRACK) this.backTrack.btiEALo = this.backTrack.btiDH;
        break;
    case 0x7:
        src = (this.regEBX >> 8) & 0xff;
        if (BACKTRACK) this.backTrack.btiEALo = this.backTrack.btiBH;
        break;
    default:
        src = 0;
        break;
    }

    let b = fn.call(this, dst, src);

    switch(bModRM) {
    case 0x00:
    case 0x03:
        this.setEAByte(b);
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseIndex;
        break;
    case 0x01:
    case 0x02:
        this.setEAByte(b);
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseIndexExtra;
        break;
    case 0x04:
    case 0x05:
    case 0x07:
        this.setEAByte(b);
        this.nStepCycles -= this.cycleCounts.nEACyclesBase;
        break;
    case 0x06:
        this.setEAByte(b);
        this.nStepCycles -= this.cycleCounts.nEACyclesDisp;
        break;
    case 0x40:
    case 0x43:
    case 0x80:
    case 0x83:
        this.setEAByte(b);
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseIndexDisp;
        break;
    case 0x41:
    case 0x42:
    case 0x81:
    case 0x82:
        this.setEAByte(b);
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseIndexDispExtra;
        break;
    case 0x44:
    case 0x45:
    case 0x46:
    case 0x47:
    case 0x84:
    case 0x85:
    case 0x86:
    case 0x87:
        this.setEAByte(b);
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseDisp;
        break;
    case 0xC0:
        this.regEAX = (this.regEAX & ~0xff) | b;
        if (BACKTRACK) this.backTrack.btiAL = this.backTrack.btiEALo;
        break;
    case 0xC1:
        this.regECX = (this.regECX & ~0xff) | b;
        if (BACKTRACK) this.backTrack.btiCL = this.backTrack.btiEALo;
        break;
    case 0xC2:
        this.regEDX = (this.regEDX & ~0xff) | b;
        if (BACKTRACK) this.backTrack.btiDL = this.backTrack.btiEALo;
        break;
    case 0xC3:
        this.regEBX = (this.regEBX & ~0xff) | b;
        if (BACKTRACK) this.backTrack.btiBL = this.backTrack.btiEALo;
        break;
    case 0xC4:
        this.regEAX = (this.regEAX & ~0xff00) | (b << 8);
        if (BACKTRACK) this.backTrack.btiAH = this.backTrack.btiEALo;
        break;
    case 0xC5:
        this.regECX = (this.regECX & ~0xff00) | (b << 8);
        if (BACKTRACK) this.backTrack.btiCH = this.backTrack.btiEALo;
        break;
    case 0xC6:
        this.regEDX = (this.regEDX & ~0xff00) | (b << 8);
        if (BACKTRACK) this.backTrack.btiDH = this.backTrack.btiEALo;
        break;
    case 0xC7:
        this.regEBX = (this.regEBX & ~0xff00) | (b << 8);
        if (BACKTRACK) this.backTrack.btiBH = this.backTrack.btiEALo;
        break;
    default:

        break;
    }
};

/**
 * modGrpByte16(afnGrp, fnSrc)
 *
 * @this {CPUx86}
 * @param {Array.<function(number,number)>} afnGrp
 * @param {function()} fnSrc
 */
X86.modGrpByte16 = function(afnGrp, fnSrc)
{
    let dst;
    let bModRM = (this.bModRM = this.getIPByte()) & 0xC7;

    switch(bModRM) {
    case 0x00:
        dst = this.getEAByteData(this.regEBX + this.regESI);
        this.regEAWrite = this.regEA;
        break;
    case 0x01:
        dst = this.getEAByteData(this.regEBX + this.regEDI);
        this.regEAWrite = this.regEA;
        break;
    case 0x02:
        dst = this.getEAByteStack(this.regEBP + this.regESI);
        this.regEAWrite = this.regEA;
        break;
    case 0x03:
        dst = this.getEAByteStack(this.regEBP + this.regEDI);
        this.regEAWrite = this.regEA;
        break;
    case 0x04:
        dst = this.getEAByteData(this.regESI);
        this.regEAWrite = this.regEA;
        break;
    case 0x05:
        dst = this.getEAByteData(this.regEDI);
        this.regEAWrite = this.regEA;
        break;
    case 0x06:
        dst = this.getEAByteData(this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x07:
        dst = this.getEAByteData(this.regEBX);
        this.regEAWrite = this.regEA;
        break;
    case 0x40:
        dst = this.getEAByteData(this.regEBX + this.regESI + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x41:
        dst = this.getEAByteData(this.regEBX + this.regEDI + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x42:
        dst = this.getEAByteStack(this.regEBP + this.regESI + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x43:
        dst = this.getEAByteStack(this.regEBP + this.regEDI + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x44:
        dst = this.getEAByteData(this.regESI + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x45:
        dst = this.getEAByteData(this.regEDI + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x46:
        dst = this.getEAByteStack(this.regEBP + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x47:
        dst = this.getEAByteData(this.regEBX + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x80:
        dst = this.getEAByteData(this.regEBX + this.regESI + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x81:
        dst = this.getEAByteData(this.regEBX + this.regEDI + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x82:
        dst = this.getEAByteStack(this.regEBP + this.regESI + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x83:
        dst = this.getEAByteStack(this.regEBP + this.regEDI + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x84:
        dst = this.getEAByteData(this.regESI + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x85:
        dst = this.getEAByteData(this.regEDI + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x86:
        dst = this.getEAByteStack(this.regEBP + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x87:
        dst = this.getEAByteData(this.regEBX + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0xC0:
        dst = this.regEAX & 0xff;
        break;
    case 0xC1:
        dst = this.regECX & 0xff;
        break;
    case 0xC2:
        dst = this.regEDX & 0xff;
        break;
    case 0xC3:
        dst = this.regEBX & 0xff;
        break;
    case 0xC4:
        dst = (this.regEAX >> 8) & 0xff;
        break;
    case 0xC5:
        dst = (this.regECX >> 8) & 0xff;
        break;
    case 0xC6:
        dst = (this.regEDX >> 8) & 0xff;
        break;
    case 0xC7:
        dst = (this.regEBX >> 8) & 0xff;
        break;
    default:
        dst = 0;

        break;
    }

    let reg = (this.bModRM >> 3) & 0x7;

    let b = afnGrp[reg].call(this, dst, fnSrc.call(this));

    switch(bModRM) {
    case 0x00:
    case 0x03:
        this.setEAByte(b);
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseIndex;
        break;
    case 0x01:
    case 0x02:
        this.setEAByte(b);
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseIndexExtra;
        break;
    case 0x04:
    case 0x05:
    case 0x07:
        this.setEAByte(b);
        this.nStepCycles -= this.cycleCounts.nEACyclesBase;
        break;
    case 0x06:
        this.setEAByte(b);
        this.nStepCycles -= this.cycleCounts.nEACyclesDisp;
        break;
    case 0x40:
    case 0x43:
    case 0x80:
    case 0x83:
        this.setEAByte(b);
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseIndexDisp;
        break;
    case 0x41:
    case 0x42:
    case 0x81:
    case 0x82:
        this.setEAByte(b);
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseIndexDispExtra;
        break;
    case 0x44:
    case 0x45:
    case 0x46:
    case 0x47:
    case 0x84:
    case 0x85:
    case 0x86:
    case 0x87:
        this.setEAByte(b);
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseDisp;
        break;
    case 0xC0:
        this.regEAX = (this.regEAX & ~0xff) | b;
        break;
    case 0xC1:
        this.regECX = (this.regECX & ~0xff) | b;
        break;
    case 0xC2:
        this.regEDX = (this.regEDX & ~0xff) | b;
        break;
    case 0xC3:
        this.regEBX = (this.regEBX & ~0xff) | b;
        break;
    case 0xC4:
        this.regEAX = (this.regEAX & ~0xff00) | (b << 8);
        break;
    case 0xC5:
        this.regECX = (this.regECX & ~0xff00) | (b << 8);
        break;
    case 0xC6:
        this.regEDX = (this.regEDX & ~0xff00) | (b << 8);
        break;
    case 0xC7:
        this.regEBX = (this.regEBX & ~0xff00) | (b << 8);
        break;
    }
};

/**
 * modRegShort16(fn)
 *
 * @this {CPUx86}
 * @param {function(number,number)} fn (dst,src)
 */
X86.modRegShort16 = function(fn)
{
    let dst, src;
    let bModRM = (this.bModRM = this.getIPByte()) & 0xC7;

    switch(bModRM) {
    case 0x00:
        src = this.getEAShortData(this.regEBX + this.regESI);
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseIndex;
        break;
    case 0x01:
        src = this.getEAShortData(this.regEBX + this.regEDI);
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseIndexExtra;
        break;
    case 0x02:
        src = this.getEAShortStack(this.regEBP + this.regESI);
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseIndexExtra;
        break;
    case 0x03:
        src = this.getEAShortStack(this.regEBP + this.regEDI);
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseIndex;
        break;
    case 0x04:
        src = this.getEAShortData(this.regESI);
        this.nStepCycles -= this.cycleCounts.nEACyclesBase;
        break;
    case 0x05:
        src = this.getEAShortData(this.regEDI);
        this.nStepCycles -= this.cycleCounts.nEACyclesBase;
        break;
    case 0x06:
        src = this.getEAShortData(this.getIPAddr());
        this.nStepCycles -= this.cycleCounts.nEACyclesDisp;
        break;
    case 0x07:
        src = this.getEAShortData(this.regEBX);
        this.nStepCycles -= this.cycleCounts.nEACyclesBase;
        break;
    case 0x40:
        src = this.getEAShortData(this.regEBX + this.regESI + this.getIPDisp());
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseIndexDisp;
        break;
    case 0x41:
        src = this.getEAShortData(this.regEBX + this.regEDI + this.getIPDisp());
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseIndexDispExtra;
        break;
    case 0x42:
        src = this.getEAShortStack(this.regEBP + this.regESI + this.getIPDisp());
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseIndexDispExtra;
        break;
    case 0x43:
        src = this.getEAShortStack(this.regEBP + this.regEDI + this.getIPDisp());
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseIndexDisp;
        break;
    case 0x44:
        src = this.getEAShortData(this.regESI + this.getIPDisp());
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseDisp;
        break;
    case 0x45:
        src = this.getEAShortData(this.regEDI + this.getIPDisp());
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseDisp;
        break;
    case 0x46:
        src = this.getEAShortStack(this.regEBP + this.getIPDisp());
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseDisp;
        break;
    case 0x47:
        src = this.getEAShortData(this.regEBX + this.getIPDisp());
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseDisp;
        break;
    case 0x80:
        src = this.getEAShortData(this.regEBX + this.regESI + this.getIPAddr());
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseIndexDisp;
        break;
    case 0x81:
        src = this.getEAShortData(this.regEBX + this.regEDI + this.getIPAddr());
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseIndexDispExtra;
        break;
    case 0x82:
        src = this.getEAShortStack(this.regEBP + this.regESI + this.getIPAddr());
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseIndexDispExtra;
        break;
    case 0x83:
        src = this.getEAShortStack(this.regEBP + this.regEDI + this.getIPAddr());
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseIndexDisp;
        break;
    case 0x84:
        src = this.getEAShortData(this.regESI + this.getIPAddr());
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseDisp;
        break;
    case 0x85:
        src = this.getEAShortData(this.regEDI + this.getIPAddr());
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseDisp;
        break;
    case 0x86:
        src = this.getEAShortStack(this.regEBP + this.getIPAddr());
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseDisp;
        break;
    case 0x87:
        src = this.getEAShortData(this.regEBX + this.getIPAddr());
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseDisp;
        break;
    case 0xC0:
        src = this.regEAX & 0xffff;
        if (BACKTRACK) {
            this.backTrack.btiEALo = this.backTrack.btiAL; this.backTrack.btiEAHi = this.backTrack.btiAH;
        }
        break;
    case 0xC1:
        src = this.regECX & 0xffff;
        if (BACKTRACK) {
            this.backTrack.btiEALo = this.backTrack.btiCL; this.backTrack.btiEAHi = this.backTrack.btiCH;
        }
        break;
    case 0xC2:
        src = this.regEDX & 0xffff;
        if (BACKTRACK) {
            this.backTrack.btiEALo = this.backTrack.btiDL; this.backTrack.btiEAHi = this.backTrack.btiDH;
        }
        break;
    case 0xC3:
        src = this.regEBX & 0xffff;
        if (BACKTRACK) {
            this.backTrack.btiEALo = this.backTrack.btiBL; this.backTrack.btiEAHi = this.backTrack.btiBH;
        }
        break;
    case 0xC4:
        src = this.getSP() & 0xffff;
        if (BACKTRACK) {
            this.backTrack.btiEALo = X86.BTINFO.SP_LO; this.backTrack.btiEAHi = X86.BTINFO.SP_HI;
        }
        break;
    case 0xC5:
        src = this.regEBP & 0xffff;
        if (BACKTRACK) {
            this.backTrack.btiEALo = this.backTrack.btiBPLo; this.backTrack.btiEAHi = this.backTrack.btiBPHi;
        }
        break;
    case 0xC6:
        src = this.regESI & 0xffff;
        if (BACKTRACK) {
            this.backTrack.btiEALo = this.backTrack.btiSILo; this.backTrack.btiEAHi = this.backTrack.btiSIHi;
        }
        break;
    case 0xC7:
        src = this.regEDI & 0xffff;
        if (BACKTRACK) {
            this.backTrack.btiEALo = this.backTrack.btiDILo; this.backTrack.btiEAHi = this.backTrack.btiDIHi;
        }
        break;
    default:
        src = 0;

        break;
    }

    let reg = (this.bModRM >> 3) & 0x7;

    switch(reg) {
    case 0x0:
        dst = this.regEAX & 0xffff;
        break;
    case 0x1:
        dst = this.regECX & 0xffff;
        break;
    case 0x2:
        dst = this.regEDX & 0xffff;
        break;
    case 0x3:
        dst = this.regEBX & 0xffff;
        break;
    case 0x4:
        dst = this.getSP() & 0xffff;
        break;
    case 0x5:
        dst = this.regEBP & 0xffff;
        break;
    case 0x6:
        dst = this.regESI & 0xffff;
        break;
    case 0x7:
        dst = this.regEDI & 0xffff;
        break;
    default:
        dst = 0;
        break;
    }

    let w = fn.call(this, dst, src);


    switch(reg) {
    case 0x0:
        this.regEAX = (this.regEAX & ~0xffff) | w;
        if (BACKTRACK) {
            this.backTrack.btiAL = this.backTrack.btiEALo; this.backTrack.btiAH = this.backTrack.btiEAHi;
        }
        break;
    case 0x1:
        this.regECX = (this.regECX & ~0xffff) | w;
        if (BACKTRACK) {
            this.backTrack.btiCL = this.backTrack.btiEALo; this.backTrack.btiCH = this.backTrack.btiEAHi;
        }
        break;
    case 0x2:
        this.regEDX = (this.regEDX & ~0xffff) | w;
        if (BACKTRACK) {
            this.backTrack.btiDL = this.backTrack.btiEALo; this.backTrack.btiDH = this.backTrack.btiEAHi;
        }
        break;
    case 0x3:
        this.regEBX = (this.regEBX & ~0xffff) | w;
        if (BACKTRACK) {
            this.backTrack.btiBL = this.backTrack.btiEALo; this.backTrack.btiBH = this.backTrack.btiEAHi;
        }
        break;
    case 0x4:
        this.setSP((this.getSP() & ~0xffff) | w);
        break;
    case 0x5:
        this.regEBP = (this.regEBP & ~0xffff) | w;
        if (BACKTRACK) {
            this.backTrack.btiBPLo = this.backTrack.btiEALo; this.backTrack.btiBPHi = this.backTrack.btiEAHi;
        }
        break;
    case 0x6:
        this.regESI = (this.regESI & ~0xffff) | w;
        if (BACKTRACK) {
            this.backTrack.btiSILo = this.backTrack.btiEALo; this.backTrack.btiSIHi = this.backTrack.btiEAHi;
        }
        break;
    case 0x7:
        this.regEDI = (this.regEDI & ~0xffff) | w;
        if (BACKTRACK) {
            this.backTrack.btiDILo = this.backTrack.btiEALo; this.backTrack.btiDIHi = this.backTrack.btiEAHi;
        }
        break;
    }
};

/**
 * modMemShort16(fn)
 *
 * @this {CPUx86}
 * @param {function(number,number)} fn (dst,src)
 */
X86.modMemShort16 = function(fn)
{
    let dst, src;
    let bModRM = (this.bModRM = this.getIPByte()) & 0xC7;

    switch(bModRM) {
    case 0x00:
        dst = this.getEAShortData(this.regEBX + this.regESI);
        this.regEAWrite = this.regEA;
        break;
    case 0x01:
        dst = this.getEAShortData(this.regEBX + this.regEDI);
        this.regEAWrite = this.regEA;
        break;
    case 0x02:
        dst = this.getEAShortStack(this.regEBP + this.regESI);
        this.regEAWrite = this.regEA;
        break;
    case 0x03:
        dst = this.getEAShortStack(this.regEBP + this.regEDI);
        this.regEAWrite = this.regEA;
        break;
    case 0x04:
        dst = this.getEAShortData(this.regESI);
        this.regEAWrite = this.regEA;
        break;
    case 0x05:
        dst = this.getEAShortData(this.regEDI);
        this.regEAWrite = this.regEA;
        break;
    case 0x06:
        dst = this.getEAShortData(this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x07:
        dst = this.getEAShortData(this.regEBX);
        this.regEAWrite = this.regEA;
        break;
    case 0x40:
        dst = this.getEAShortData(this.regEBX + this.regESI + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x41:
        dst = this.getEAShortData(this.regEBX + this.regEDI + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x42:
        dst = this.getEAShortStack(this.regEBP + this.regESI + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x43:
        dst = this.getEAShortStack(this.regEBP + this.regEDI + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x44:
        dst = this.getEAShortData(this.regESI + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x45:
        dst = this.getEAShortData(this.regEDI + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x46:
        dst = this.getEAShortStack(this.regEBP + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x47:
        dst = this.getEAShortData(this.regEBX + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x80:
        dst = this.getEAShortData(this.regEBX + this.regESI + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x81:
        dst = this.getEAShortData(this.regEBX + this.regEDI + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x82:
        dst = this.getEAShortStack(this.regEBP + this.regESI + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x83:
        dst = this.getEAShortStack(this.regEBP + this.regEDI + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x84:
        dst = this.getEAShortData(this.regESI + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x85:
        dst = this.getEAShortData(this.regEDI + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x86:
        dst = this.getEAShortStack(this.regEBP + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x87:
        dst = this.getEAShortData(this.regEBX + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0xC0:
        dst = this.regEAX & 0xffff;
        break;
    case 0xC1:
        dst = this.regECX & 0xffff;
        break;
    case 0xC2:
        dst = this.regEDX & 0xffff;
        break;
    case 0xC3:
        dst = this.regEBX & 0xffff;
        break;
    case 0xC4:
        dst = this.getSP() & 0xffff;
        break;
    case 0xC5:
        dst = this.regEBP & 0xffff;
        break;
    case 0xC6:
        dst = this.regESI & 0xffff;
        break;
    case 0xC7:
        dst = this.regEDI & 0xffff;
        break;
    default:
        dst = 0;

        break;
    }

    let reg = (this.bModRM >> 3) & 0x7;

    switch(reg) {
    case 0x0:
        src = this.regEAX & 0xffff;
        if (BACKTRACK) {
            this.backTrack.btiEALo = this.backTrack.btiAL; this.backTrack.btiEAHi = this.backTrack.btiAH;
        }
        break;
    case 0x1:
        src = this.regECX & 0xffff;
        if (BACKTRACK) {
            this.backTrack.btiEALo = this.backTrack.btiCL; this.backTrack.btiEAHi = this.backTrack.btiCH;
        }
        break;
    case 0x2:
        src = this.regEDX & 0xffff;
        if (BACKTRACK) {
            this.backTrack.btiEALo = this.backTrack.btiDL; this.backTrack.btiEAHi = this.backTrack.btiDH;
        }
        break;
    case 0x3:
        src = this.regEBX & 0xffff;
        if (BACKTRACK) {
            this.backTrack.btiEALo = this.backTrack.btiBL; this.backTrack.btiEAHi = this.backTrack.btiBH;
        }
        break;
    case 0x4:
        src = this.getSP() & 0xffff;
        if (BACKTRACK) {
            this.backTrack.btiEALo = X86.BTINFO.SP_LO; this.backTrack.btiEAHi = X86.BTINFO.SP_HI;
        }
        break;
    case 0x5:
        src = this.regEBP & 0xffff;
        if (BACKTRACK) {
            this.backTrack.btiEALo = this.backTrack.btiBPLo; this.backTrack.btiEAHi = this.backTrack.btiBPHi;
        }
        break;
    case 0x6:
        src = this.regESI & 0xffff;
        if (BACKTRACK) {
            this.backTrack.btiEALo = this.backTrack.btiSILo; this.backTrack.btiEAHi = this.backTrack.btiSIHi;
        }
        break;
    case 0x7:
        src = this.regEDI & 0xffff;
        if (BACKTRACK) {
            this.backTrack.btiEALo = this.backTrack.btiDILo; this.backTrack.btiEAHi = this.backTrack.btiDIHi;
        }
        break;
    default:
        src = 0;
        break;
    }

    let w = fn.call(this, dst, src);


    switch(bModRM) {
    case 0x00:
    case 0x03:
        this.setEAShort(w);
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseIndex;
        break;
    case 0x01:
    case 0x02:
        this.setEAShort(w);
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseIndexExtra;
        break;
    case 0x04:
    case 0x05:
    case 0x07:
        this.setEAShort(w);
        this.nStepCycles -= this.cycleCounts.nEACyclesBase;
        break;
    case 0x06:
        this.setEAShort(w);
        this.nStepCycles -= this.cycleCounts.nEACyclesDisp;
        break;
    case 0x40:
    case 0x43:
    case 0x80:
    case 0x83:
        this.setEAShort(w);
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseIndexDisp;
        break;
    case 0x41:
    case 0x42:
    case 0x81:
    case 0x82:
        this.setEAShort(w);
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseIndexDispExtra;
        break;
    case 0x44:
    case 0x45:
    case 0x46:
    case 0x47:
    case 0x84:
    case 0x85:
    case 0x86:
    case 0x87:
        this.setEAShort(w);
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseDisp;
        break;
    case 0xC0:
        this.regEAX = (this.regEAX & ~0xffff) | w;
        if (BACKTRACK) {
            this.backTrack.btiAL = this.backTrack.btiEALo; this.backTrack.btiAH = this.backTrack.btiEAHi;
        }
        break;
    case 0xC1:
        this.regECX = (this.regECX & ~0xffff) | w;
        if (BACKTRACK) {
            this.backTrack.btiCL = this.backTrack.btiEALo; this.backTrack.btiCH = this.backTrack.btiEAHi;
        }
        break;
    case 0xC2:
        this.regEDX = (this.regEDX & ~0xffff) | w;
        if (BACKTRACK) {
            this.backTrack.btiDL = this.backTrack.btiEALo; this.backTrack.btiDH = this.backTrack.btiEAHi;
        }
        break;
    case 0xC3:
        this.regEBX = (this.regEBX & ~0xffff) | w;
        if (BACKTRACK) {
            this.backTrack.btiBL = this.backTrack.btiEALo; this.backTrack.btiBH = this.backTrack.btiEAHi;
        }
        break;
    case 0xC4:
        this.setSP((this.getSP() & ~0xffff) | w);
        break;
    case 0xC5:
        this.regEBP = (this.regEBP & ~0xffff) | w;
        if (BACKTRACK) {
            this.backTrack.btiBPLo = this.backTrack.btiEALo; this.backTrack.btiBPHi = this.backTrack.btiEAHi;
        }
        break;
    case 0xC6:
        this.regESI = (this.regESI & ~0xffff) | w;
        if (BACKTRACK) {
            this.backTrack.btiSILo = this.backTrack.btiEALo; this.backTrack.btiSIHi = this.backTrack.btiEAHi;
        }
        break;
    case 0xC7:
        this.regEDI = (this.regEDI & ~0xffff) | w;
        if (BACKTRACK) {
            this.backTrack.btiDILo = this.backTrack.btiEALo; this.backTrack.btiDIHi = this.backTrack.btiEAHi;
        }
        break;
    default:

        break;
    }
};

/**
 * modGrpShort16(afnGrp, fnSrc)
 *
 * @this {CPUx86}
 * @param {Array.<function(number,number)>} afnGrp
 * @param {function()} fnSrc
 */
X86.modGrpShort16 = function(afnGrp, fnSrc)
{
    let dst;
    let bModRM = (this.bModRM = this.getIPByte()) & 0xC7;

    switch(bModRM) {
    case 0x00:
        dst = this.getEAShortData(this.regEBX + this.regESI);
        this.regEAWrite = this.regEA;
        break;
    case 0x01:
        dst = this.getEAShortData(this.regEBX + this.regEDI);
        this.regEAWrite = this.regEA;
        break;
    case 0x02:
        dst = this.getEAShortStack(this.regEBP + this.regESI);
        this.regEAWrite = this.regEA;
        break;
    case 0x03:
        dst = this.getEAShortStack(this.regEBP + this.regEDI);
        this.regEAWrite = this.regEA;
        break;
    case 0x04:
        dst = this.getEAShortData(this.regESI);
        this.regEAWrite = this.regEA;
        break;
    case 0x05:
        dst = this.getEAShortData(this.regEDI);
        this.regEAWrite = this.regEA;
        break;
    case 0x06:
        dst = this.getEAShortData(this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x07:
        dst = this.getEAShortData(this.regEBX);
        this.regEAWrite = this.regEA;
        break;
    case 0x40:
        dst = this.getEAShortData(this.regEBX + this.regESI + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x41:
        dst = this.getEAShortData(this.regEBX + this.regEDI + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x42:
        dst = this.getEAShortStack(this.regEBP + this.regESI + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x43:
        dst = this.getEAShortStack(this.regEBP + this.regEDI + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x44:
        dst = this.getEAShortData(this.regESI + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x45:
        dst = this.getEAShortData(this.regEDI + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x46:
        dst = this.getEAShortStack(this.regEBP + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x47:
        dst = this.getEAShortData(this.regEBX + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x80:
        dst = this.getEAShortData(this.regEBX + this.regESI + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x81:
        dst = this.getEAShortData(this.regEBX + this.regEDI + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x82:
        dst = this.getEAShortStack(this.regEBP + this.regESI + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x83:
        dst = this.getEAShortStack(this.regEBP + this.regEDI + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x84:
        dst = this.getEAShortData(this.regESI + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x85:
        dst = this.getEAShortData(this.regEDI + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x86:
        dst = this.getEAShortStack(this.regEBP + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x87:
        dst = this.getEAShortData(this.regEBX + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0xC0:
        dst = this.regEAX & 0xffff;
        break;
    case 0xC1:
        dst = this.regECX & 0xffff;
        break;
    case 0xC2:
        dst = this.regEDX & 0xffff;
        break;
    case 0xC3:
        dst = this.regEBX & 0xffff;
        break;
    case 0xC4:
        dst = this.getSP() & 0xffff;
        break;
    case 0xC5:
        dst = this.regEBP & 0xffff;
        break;
    case 0xC6:
        dst = this.regESI & 0xffff;
        break;
    case 0xC7:
        dst = this.regEDI & 0xffff;
        break;
    default:
        dst = 0;

        break;
    }

    let reg = (this.bModRM >> 3) & 0x7;
    let w = afnGrp[reg].call(this, dst, fnSrc.call(this));


    switch(bModRM) {
    case 0x00:
    case 0x03:
        this.setEAShort(w);
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseIndex;
        break;
    case 0x01:
    case 0x02:
        this.setEAShort(w);
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseIndexExtra;
        break;
    case 0x04:
    case 0x05:
    case 0x07:
        this.setEAShort(w);
        this.nStepCycles -= this.cycleCounts.nEACyclesBase;
        break;
    case 0x06:
        this.setEAShort(w);
        this.nStepCycles -= this.cycleCounts.nEACyclesDisp;
        break;
    case 0x40:
    case 0x43:
    case 0x80:
    case 0x83:
        this.setEAShort(w);
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseIndexDisp;
        break;
    case 0x41:
    case 0x42:
    case 0x81:
    case 0x82:
        this.setEAShort(w);
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseIndexDispExtra;
        break;
    case 0x44:
    case 0x45:
    case 0x46:
    case 0x47:
    case 0x84:
    case 0x85:
    case 0x86:
    case 0x87:
        this.setEAShort(w);
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseDisp;
        break;
    case 0xC0:
        this.regEAX = (this.regEAX & ~0xffff) | w;
        break;
    case 0xC1:
        this.regECX = (this.regECX & ~0xffff) | w;
        break;
    case 0xC2:
        this.regEDX = (this.regEDX & ~0xffff) | w;
        break;
    case 0xC3:
        this.regEBX = (this.regEBX & ~0xffff) | w;
        break;
    case 0xC4:
        this.setSP((this.getSP() & ~0xffff) | w);
        break;
    case 0xC5:
        this.regEBP = (this.regEBP & ~0xffff) | w;
        break;
    case 0xC6:
        this.regESI = (this.regESI & ~0xffff) | w;
        break;
    case 0xC7:
        this.regEDI = (this.regEDI & ~0xffff) | w;
        break;
    }
};

/**
 * modRegLong16(fn)
 *
 * @this {CPUx86}
 * @param {function(number,number)} fn (dst,src)
 */
X86.modRegLong16 = function(fn)
{
    let dst, src;
    let bModRM = (this.bModRM = this.getIPByte()) & 0xC7;

    switch(bModRM) {
    case 0x00:
        src = this.getEALongData(this.regEBX + this.regESI);
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseIndex;
        break;
    case 0x01:
        src = this.getEALongData(this.regEBX + this.regEDI);
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseIndexExtra;
        break;
    case 0x02:
        src = this.getEALongStack(this.regEBP + this.regESI);
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseIndexExtra;
        break;
    case 0x03:
        src = this.getEALongStack(this.regEBP + this.regEDI);
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseIndex;
        break;
    case 0x04:
        src = this.getEALongData(this.regESI);
        this.nStepCycles -= this.cycleCounts.nEACyclesBase;
        break;
    case 0x05:
        src = this.getEALongData(this.regEDI);
        this.nStepCycles -= this.cycleCounts.nEACyclesBase;
        break;
    case 0x06:
        src = this.getEALongData(this.getIPAddr());
        this.nStepCycles -= this.cycleCounts.nEACyclesDisp;
        break;
    case 0x07:
        src = this.getEALongData(this.regEBX);
        this.nStepCycles -= this.cycleCounts.nEACyclesBase;
        break;
    case 0x40:
        src = this.getEALongData(this.regEBX + this.regESI + this.getIPDisp());
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseIndexDisp;
        break;
    case 0x41:
        src = this.getEALongData(this.regEBX + this.regEDI + this.getIPDisp());
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseIndexDispExtra;
        break;
    case 0x42:
        src = this.getEALongStack(this.regEBP + this.regESI + this.getIPDisp());
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseIndexDispExtra;
        break;
    case 0x43:
        src = this.getEALongStack(this.regEBP + this.regEDI + this.getIPDisp());
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseIndexDisp;
        break;
    case 0x44:
        src = this.getEALongData(this.regESI + this.getIPDisp());
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseDisp;
        break;
    case 0x45:
        src = this.getEALongData(this.regEDI + this.getIPDisp());
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseDisp;
        break;
    case 0x46:
        src = this.getEALongStack(this.regEBP + this.getIPDisp());
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseDisp;
        break;
    case 0x47:
        src = this.getEALongData(this.regEBX + this.getIPDisp());
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseDisp;
        break;
    case 0x80:
        src = this.getEALongData(this.regEBX + this.regESI + this.getIPAddr());
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseIndexDisp;
        break;
    case 0x81:
        src = this.getEALongData(this.regEBX + this.regEDI + this.getIPAddr());
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseIndexDispExtra;
        break;
    case 0x82:
        src = this.getEALongStack(this.regEBP + this.regESI + this.getIPAddr());
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseIndexDispExtra;
        break;
    case 0x83:
        src = this.getEALongStack(this.regEBP + this.regEDI + this.getIPAddr());
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseIndexDisp;
        break;
    case 0x84:
        src = this.getEALongData(this.regESI + this.getIPAddr());
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseDisp;
        break;
    case 0x85:
        src = this.getEALongData(this.regEDI + this.getIPAddr());
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseDisp;
        break;
    case 0x86:
        src = this.getEALongStack(this.regEBP + this.getIPAddr());
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseDisp;
        break;
    case 0x87:
        src = this.getEALongData(this.regEBX + this.getIPAddr());
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseDisp;
        break;
    case 0xC0:
        src = this.regEAX;
        if (BACKTRACK) {
            this.backTrack.btiEALo = this.backTrack.btiAL; this.backTrack.btiEAHi = this.backTrack.btiAH;
        }
        break;
    case 0xC1:
        src = this.regECX;
        if (BACKTRACK) {
            this.backTrack.btiEALo = this.backTrack.btiCL; this.backTrack.btiEAHi = this.backTrack.btiCH;
        }
        break;
    case 0xC2:
        src = this.regEDX;
        if (BACKTRACK) {
            this.backTrack.btiEALo = this.backTrack.btiDL; this.backTrack.btiEAHi = this.backTrack.btiDH;
        }
        break;
    case 0xC3:
        src = this.regEBX;
        if (BACKTRACK) {
            this.backTrack.btiEALo = this.backTrack.btiBL; this.backTrack.btiEAHi = this.backTrack.btiBH;
        }
        break;
    case 0xC4:
        src = this.getSP();
        if (BACKTRACK) {
            this.backTrack.btiEALo = X86.BTINFO.SP_LO; this.backTrack.btiEAHi = X86.BTINFO.SP_HI;
        }
        break;
    case 0xC5:
        src = this.regEBP;
        if (BACKTRACK) {
            this.backTrack.btiEALo = this.backTrack.btiBPLo; this.backTrack.btiEAHi = this.backTrack.btiBPHi;
        }
        break;
    case 0xC6:
        src = this.regESI;
        if (BACKTRACK) {
            this.backTrack.btiEALo = this.backTrack.btiSILo; this.backTrack.btiEAHi = this.backTrack.btiSIHi;
        }
        break;
    case 0xC7:
        src = this.regEDI;
        if (BACKTRACK) {
            this.backTrack.btiEALo = this.backTrack.btiDILo; this.backTrack.btiEAHi = this.backTrack.btiDIHi;
        }
        break;
    default:
        src = 0;

        break;
    }

    let reg = (this.bModRM >> 3) & 0x7;

    switch(reg) {
    case 0x0:
        dst = this.regEAX;
        break;
    case 0x1:
        dst = this.regECX;
        break;
    case 0x2:
        dst = this.regEDX;
        break;
    case 0x3:
        dst = this.regEBX;
        break;
    case 0x4:
        dst = this.getSP();
        break;
    case 0x5:
        dst = this.regEBP;
        break;
    case 0x6:
        dst = this.regESI;
        break;
    case 0x7:
        dst = this.regEDI;
        break;
    default:
        dst = 0;
        break;
    }

    let l = fn.call(this, dst, src);

    switch(reg) {
    case 0x0:
        this.regEAX = l;
        if (BACKTRACK) {
            this.backTrack.btiAL = this.backTrack.btiEALo; this.backTrack.btiAH = this.backTrack.btiEAHi;
        }
        break;
    case 0x1:
        this.regECX = l;
        if (BACKTRACK) {
            this.backTrack.btiCL = this.backTrack.btiEALo; this.backTrack.btiCH = this.backTrack.btiEAHi;
        }
        break;
    case 0x2:
        this.regEDX = l;
        if (BACKTRACK) {
            this.backTrack.btiDL = this.backTrack.btiEALo; this.backTrack.btiDH = this.backTrack.btiEAHi;
        }
        break;
    case 0x3:
        this.regEBX = l;
        if (BACKTRACK) {
            this.backTrack.btiBL = this.backTrack.btiEALo; this.backTrack.btiBH = this.backTrack.btiEAHi;
        }
        break;
    case 0x4:
        this.setSP(l);
        break;
    case 0x5:
        this.regEBP = l;
        if (BACKTRACK) {
            this.backTrack.btiBPLo = this.backTrack.btiEALo; this.backTrack.btiBPHi = this.backTrack.btiEAHi;
        }
        break;
    case 0x6:
        this.regESI = l;
        if (BACKTRACK) {
            this.backTrack.btiSILo = this.backTrack.btiEALo; this.backTrack.btiSIHi = this.backTrack.btiEAHi;
        }
        break;
    case 0x7:
        this.regEDI = l;
        if (BACKTRACK) {
            this.backTrack.btiDILo = this.backTrack.btiEALo; this.backTrack.btiDIHi = this.backTrack.btiEAHi;
        }
        break;
    }
};

/**
 * modMemLong16(fn)
 *
 * @this {CPUx86}
 * @param {function(number,number)} fn (dst,src)
 */
X86.modMemLong16 = function(fn)
{
    let dst, src;
    let bModRM = (this.bModRM = this.getIPByte()) & 0xC7;

    switch(bModRM) {
    case 0x00:
        dst = this.getEALongData(this.regEBX + this.regESI);
        this.regEAWrite = this.regEA;
        break;
    case 0x01:
        dst = this.getEALongData(this.regEBX + this.regEDI);
        this.regEAWrite = this.regEA;
        break;
    case 0x02:
        dst = this.getEALongStack(this.regEBP + this.regESI);
        this.regEAWrite = this.regEA;
        break;
    case 0x03:
        dst = this.getEALongStack(this.regEBP + this.regEDI);
        this.regEAWrite = this.regEA;
        break;
    case 0x04:
        dst = this.getEALongData(this.regESI);
        this.regEAWrite = this.regEA;
        break;
    case 0x05:
        dst = this.getEALongData(this.regEDI);
        this.regEAWrite = this.regEA;
        break;
    case 0x06:
        dst = this.getEALongData(this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x07:
        dst = this.getEALongData(this.regEBX);
        this.regEAWrite = this.regEA;
        break;
    case 0x40:
        dst = this.getEALongData(this.regEBX + this.regESI + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x41:
        dst = this.getEALongData(this.regEBX + this.regEDI + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x42:
        dst = this.getEALongStack(this.regEBP + this.regESI + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x43:
        dst = this.getEALongStack(this.regEBP + this.regEDI + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x44:
        dst = this.getEALongData(this.regESI + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x45:
        dst = this.getEALongData(this.regEDI + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x46:
        dst = this.getEALongStack(this.regEBP + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x47:
        dst = this.getEALongData(this.regEBX + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x80:
        dst = this.getEALongData(this.regEBX + this.regESI + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x81:
        dst = this.getEALongData(this.regEBX + this.regEDI + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x82:
        dst = this.getEALongStack(this.regEBP + this.regESI + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x83:
        dst = this.getEALongStack(this.regEBP + this.regEDI + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x84:
        dst = this.getEALongData(this.regESI + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x85:
        dst = this.getEALongData(this.regEDI + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x86:
        dst = this.getEALongStack(this.regEBP + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x87:
        dst = this.getEALongData(this.regEBX + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0xC0:
        dst = this.regEAX;
        break;
    case 0xC1:
        dst = this.regECX;
        break;
    case 0xC2:
        dst = this.regEDX;
        break;
    case 0xC3:
        dst = this.regEBX;
        break;
    case 0xC4:
        dst = this.getSP();
        break;
    case 0xC5:
        dst = this.regEBP;
        break;
    case 0xC6:
        dst = this.regESI;
        break;
    case 0xC7:
        dst = this.regEDI;
        break;
    default:
        dst = 0;

        break;
    }

    let reg = (this.bModRM >> 3) & 0x7;

    switch(reg) {
    case 0x0:
        src = this.regEAX;
        if (BACKTRACK) {
            this.backTrack.btiEALo = this.backTrack.btiAL; this.backTrack.btiEAHi = this.backTrack.btiAH;
        }
        break;
    case 0x1:
        src = this.regECX;
        if (BACKTRACK) {
            this.backTrack.btiEALo = this.backTrack.btiCL; this.backTrack.btiEAHi = this.backTrack.btiCH;
        }
        break;
    case 0x2:
        src = this.regEDX;
        if (BACKTRACK) {
            this.backTrack.btiEALo = this.backTrack.btiDL; this.backTrack.btiEAHi = this.backTrack.btiDH;
        }
        break;
    case 0x3:
        src = this.regEBX;
        if (BACKTRACK) {
            this.backTrack.btiEALo = this.backTrack.btiBL; this.backTrack.btiEAHi = this.backTrack.btiBH;
        }
        break;
    case 0x4:
        src = this.getSP();
        if (BACKTRACK) {
            this.backTrack.btiEALo = X86.BTINFO.SP_LO; this.backTrack.btiEAHi = X86.BTINFO.SP_HI;
        }
        break;
    case 0x5:
        src = this.regEBP;
        if (BACKTRACK) {
            this.backTrack.btiEALo = this.backTrack.btiBPLo; this.backTrack.btiEAHi = this.backTrack.btiBPHi;
        }
        break;
    case 0x6:
        src = this.regESI;
        if (BACKTRACK) {
            this.backTrack.btiEALo = this.backTrack.btiSILo; this.backTrack.btiEAHi = this.backTrack.btiSIHi;
        }
        break;
    case 0x7:
        src = this.regEDI;
        if (BACKTRACK) {
            this.backTrack.btiEALo = this.backTrack.btiDILo; this.backTrack.btiEAHi = this.backTrack.btiDIHi;
        }
        break;
    default:
        src = 0;
        break;
    }

    let l = fn.call(this, dst, src);

    switch(bModRM) {
    case 0x00:
    case 0x03:
        this.setEALong(l);
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseIndex;
        break;
    case 0x01:
    case 0x02:
        this.setEALong(l);
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseIndexExtra;
        break;
    case 0x04:
    case 0x05:
    case 0x07:
        this.setEALong(l);
        this.nStepCycles -= this.cycleCounts.nEACyclesBase;
        break;
    case 0x06:
        this.setEALong(l);
        this.nStepCycles -= this.cycleCounts.nEACyclesDisp;
        break;
    case 0x40:
    case 0x43:
    case 0x80:
    case 0x83:
        this.setEALong(l);
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseIndexDisp;
        break;
    case 0x41:
    case 0x42:
    case 0x81:
    case 0x82:
        this.setEALong(l);
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseIndexDispExtra;
        break;
    case 0x44:
    case 0x45:
    case 0x46:
    case 0x47:
    case 0x84:
    case 0x85:
    case 0x86:
    case 0x87:
        this.setEALong(l);
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseDisp;
        break;
    case 0xC0:
        this.regEAX = l;
        if (BACKTRACK) {
            this.backTrack.btiAL = this.backTrack.btiEALo; this.backTrack.btiAH = this.backTrack.btiEAHi;
        }
        break;
    case 0xC1:
        this.regECX = l;
        if (BACKTRACK) {
            this.backTrack.btiCL = this.backTrack.btiEALo; this.backTrack.btiCH = this.backTrack.btiEAHi;
        }
        break;
    case 0xC2:
        this.regEDX = l;
        if (BACKTRACK) {
            this.backTrack.btiDL = this.backTrack.btiEALo; this.backTrack.btiDH = this.backTrack.btiEAHi;
        }
        break;
    case 0xC3:
        this.regEBX = l;
        if (BACKTRACK) {
            this.backTrack.btiBL = this.backTrack.btiEALo; this.backTrack.btiBH = this.backTrack.btiEAHi;
        }
        break;
    case 0xC4:
        this.setSP(l);
        break;
    case 0xC5:
        this.regEBP = l;
        if (BACKTRACK) {
            this.backTrack.btiBPLo = this.backTrack.btiEALo; this.backTrack.btiBPHi = this.backTrack.btiEAHi;
        }
        break;
    case 0xC6:
        this.regESI = l;
        if (BACKTRACK) {
            this.backTrack.btiSILo = this.backTrack.btiEALo; this.backTrack.btiSIHi = this.backTrack.btiEAHi;
        }
        break;
    case 0xC7:
        this.regEDI = l;
        if (BACKTRACK) {
            this.backTrack.btiDILo = this.backTrack.btiEALo; this.backTrack.btiDIHi = this.backTrack.btiEAHi;
        }
        break;
    default:

        break;
    }
};

/**
 * modGrpLong16(afnGrp, fnSrc)
 *
 * @this {CPUx86}
 * @param {Array.<function(number,number)>} afnGrp
 * @param {function()} fnSrc
 */
X86.modGrpLong16 = function(afnGrp, fnSrc)
{
    let dst;
    let bModRM = (this.bModRM = this.getIPByte()) & 0xC7;

    switch(bModRM) {
    case 0x00:
        dst = this.getEALongData(this.regEBX + this.regESI);
        this.regEAWrite = this.regEA;
        break;
    case 0x01:
        dst = this.getEALongData(this.regEBX + this.regEDI);
        this.regEAWrite = this.regEA;
        break;
    case 0x02:
        dst = this.getEALongStack(this.regEBP + this.regESI);
        this.regEAWrite = this.regEA;
        break;
    case 0x03:
        dst = this.getEALongStack(this.regEBP + this.regEDI);
        this.regEAWrite = this.regEA;
        break;
    case 0x04:
        dst = this.getEALongData(this.regESI);
        this.regEAWrite = this.regEA;
        break;
    case 0x05:
        dst = this.getEALongData(this.regEDI);
        this.regEAWrite = this.regEA;
        break;
    case 0x06:
        dst = this.getEALongData(this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x07:
        dst = this.getEALongData(this.regEBX);
        this.regEAWrite = this.regEA;
        break;
    case 0x40:
        dst = this.getEALongData(this.regEBX + this.regESI + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x41:
        dst = this.getEALongData(this.regEBX + this.regEDI + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x42:
        dst = this.getEALongStack(this.regEBP + this.regESI + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x43:
        dst = this.getEALongStack(this.regEBP + this.regEDI + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x44:
        dst = this.getEALongData(this.regESI + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x45:
        dst = this.getEALongData(this.regEDI + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x46:
        dst = this.getEALongStack(this.regEBP + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x47:
        dst = this.getEALongData(this.regEBX + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x80:
        dst = this.getEALongData(this.regEBX + this.regESI + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x81:
        dst = this.getEALongData(this.regEBX + this.regEDI + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x82:
        dst = this.getEALongStack(this.regEBP + this.regESI + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x83:
        dst = this.getEALongStack(this.regEBP + this.regEDI + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x84:
        dst = this.getEALongData(this.regESI + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x85:
        dst = this.getEALongData(this.regEDI + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x86:
        dst = this.getEALongStack(this.regEBP + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x87:
        dst = this.getEALongData(this.regEBX + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0xC0:
        dst = this.regEAX;
        break;
    case 0xC1:
        dst = this.regECX;
        break;
    case 0xC2:
        dst = this.regEDX;
        break;
    case 0xC3:
        dst = this.regEBX;
        break;
    case 0xC4:
        dst = this.getSP();
        break;
    case 0xC5:
        dst = this.regEBP;
        break;
    case 0xC6:
        dst = this.regESI;
        break;
    case 0xC7:
        dst = this.regEDI;
        break;
    default:

        break;
    }

    let reg = (this.bModRM >> 3) & 0x7;

    let l = afnGrp[reg].call(this, dst, fnSrc.call(this));

    switch(bModRM) {
    case 0x00:
    case 0x03:
        this.setEALong(l);
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseIndex;
        break;
    case 0x01:
    case 0x02:
        this.setEALong(l);
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseIndexExtra;
        break;
    case 0x04:
    case 0x05:
    case 0x07:
        this.setEALong(l);
        this.nStepCycles -= this.cycleCounts.nEACyclesBase;
        break;
    case 0x06:
        this.setEALong(l);
        this.nStepCycles -= this.cycleCounts.nEACyclesDisp;
        break;
    case 0x40:
    case 0x43:
    case 0x80:
    case 0x83:
        this.setEALong(l);
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseIndexDisp;
        break;
    case 0x41:
    case 0x42:
    case 0x81:
    case 0x82:
        this.setEALong(l);
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseIndexDispExtra;
        break;
    case 0x44:
    case 0x45:
    case 0x46:
    case 0x47:
    case 0x84:
    case 0x85:
    case 0x86:
    case 0x87:
        this.setEALong(l);
        this.nStepCycles -= this.cycleCounts.nEACyclesBaseDisp;
        break;
    case 0xC0:
        this.regEAX = l;
        break;
    case 0xC1:
        this.regECX = l;
        break;
    case 0xC2:
        this.regEDX = l;
        break;
    case 0xC3:
        this.regEBX = l;
        break;
    case 0xC4:
        this.setSP(l);
        break;
    case 0xC5:
        this.regEBP = l;
        break;
    case 0xC6:
        this.regESI = l;
        break;
    case 0xC7:
        this.regEDI = l;
        break;
    }
};

/**
 * modRegByte32(fn)
 *
 * @this {CPUx86}
 * @param {function(number,number)} fn (dst,src)
 */
X86.modRegByte32 = function(fn)
{
    let dst, src;
    let bModRM = (this.bModRM = this.getIPByte()) & 0xC7;

    switch(bModRM) {
    case 0x00:
        src = this.getEAByteData(this.regEAX);
        break;
    case 0x01:
        src = this.getEAByteData(this.regECX);
        break;
    case 0x02:
        src = this.getEAByteData(this.regEDX);
        break;
    case 0x03:
        src = this.getEAByteData(this.regEBX);
        break;
    case 0x04:
        src = this.getEAByteData(X86.modSIB.call(this, 0));
        break;
    case 0x05:
        src = this.getEAByteData(this.getIPAddr());
        break;
    case 0x06:
        src = this.getEAByteData(this.regESI);
        break;
    case 0x07:
        src = this.getEAByteData(this.regEDI);
        break;
    case 0x40:
        src = this.getEAByteData(this.regEAX + this.getIPDisp());
        break;
    case 0x41:
        src = this.getEAByteData(this.regECX + this.getIPDisp());
        break;
    case 0x42:
        src = this.getEAByteData(this.regEDX + this.getIPDisp());
        break;
    case 0x43:
        src = this.getEAByteData(this.regEBX + this.getIPDisp());
        break;
    case 0x44:
        src = this.getEAByteData(X86.modSIB.call(this, 1) + this.getIPDisp());
        break;
    case 0x45:
        src = this.getEAByteStack(this.regEBP + this.getIPDisp());
        break;
    case 0x46:
        src = this.getEAByteData(this.regESI + this.getIPDisp());
        break;
    case 0x47:
        src = this.getEAByteData(this.regEDI + this.getIPDisp());
        break;
    case 0x80:
        src = this.getEAByteData(this.regEAX + this.getIPAddr());
        break;
    case 0x81:
        src = this.getEAByteData(this.regECX + this.getIPAddr());
        break;
    case 0x82:
        src = this.getEAByteData(this.regEDX + this.getIPAddr());
        break;
    case 0x83:
        src = this.getEAByteData(this.regEBX + this.getIPAddr());
        break;
    case 0x84:
        src = this.getEAByteData(X86.modSIB.call(this, 2) + this.getIPAddr());
        break;
    case 0x85:
        src = this.getEAByteStack(this.regEBP + this.getIPAddr());
        break;
    case 0x86:
        src = this.getEAByteData(this.regESI + this.getIPAddr());
        break;
    case 0x87:
        src = this.getEAByteData(this.regEDI + this.getIPAddr());
        break;
    case 0xC0:
        src = this.regEAX & 0xff;
        if (BACKTRACK) this.backTrack.btiEALo = this.backTrack.btiAL;
        break;
    case 0xC1:
        src = this.regECX & 0xff;
        if (BACKTRACK) this.backTrack.btiEALo = this.backTrack.btiCL;
        break;
    case 0xC2:
        src = this.regEDX & 0xff;
        if (BACKTRACK) this.backTrack.btiEALo = this.backTrack.btiDL;
        break;
    case 0xC3:
        src = this.regEBX & 0xff;
        if (BACKTRACK) this.backTrack.btiEALo = this.backTrack.btiBL;
        break;
    case 0xC4:
        src = (this.regEAX >> 8) & 0xff;
        if (BACKTRACK) this.backTrack.btiEALo = this.backTrack.btiAH;
        break;
    case 0xC5:
        src = (this.regECX >> 8) & 0xff;
        if (BACKTRACK) this.backTrack.btiEALo = this.backTrack.btiCH;
        break;
    case 0xC6:
        src = (this.regEDX >> 8) & 0xff;
        if (BACKTRACK) this.backTrack.btiEALo = this.backTrack.btiDH;
        break;
    case 0xC7:
        src = (this.regEBX >> 8) & 0xff;
        if (BACKTRACK) this.backTrack.btiEALo = this.backTrack.btiBH;
        break;
    default:
        src = 0;

        break;
    }

    let reg = (this.bModRM >> 3) & 0x7;

    switch(reg) {
    case 0x0:
        dst = this.regEAX & 0xff;
        break;
    case 0x1:
        dst = this.regECX & 0xff;
        break;
    case 0x2:
        dst = this.regEDX & 0xff;
        break;
    case 0x3:
        dst = this.regEBX & 0xff;
        break;
    case 0x4:
        dst = (this.regEAX >> 8) & 0xff;
        break;
    case 0x5:
        dst = (this.regECX >> 8) & 0xff;
        break;
    case 0x6:
        dst = (this.regEDX >> 8) & 0xff;
        break;
    case 0x7:
        dst = (this.regEBX >> 8) & 0xff;
        break;
    default:
        dst = 0;
        break;
    }

    let b = fn.call(this, dst, src);

    switch(reg) {
    case 0x0:
        this.regEAX = (this.regEAX & ~0xff) | b;
        if (BACKTRACK) this.backTrack.btiAL = this.backTrack.btiEALo;
        break;
    case 0x1:
        this.regECX = (this.regECX & ~0xff) | b;
        if (BACKTRACK) this.backTrack.btiCL = this.backTrack.btiEALo;
        break;
    case 0x2:
        this.regEDX = (this.regEDX & ~0xff) | b;
        if (BACKTRACK) this.backTrack.btiDL = this.backTrack.btiEALo;
        break;
    case 0x3:
        this.regEBX = (this.regEBX & ~0xff) | b;
        if (BACKTRACK) this.backTrack.btiBL = this.backTrack.btiEALo;
        break;
    case 0x4:
        this.regEAX = (this.regEAX & ~0xff00) | (b << 8);
        if (BACKTRACK) this.backTrack.btiAH = this.backTrack.btiEALo;
        break;
    case 0x5:
        this.regECX = (this.regECX & ~0xff00) | (b << 8);
        if (BACKTRACK) this.backTrack.btiCH = this.backTrack.btiEALo;
        break;
    case 0x6:
        this.regEDX = (this.regEDX & ~0xff00) | (b << 8);
        if (BACKTRACK) this.backTrack.btiDH = this.backTrack.btiEALo;
        break;
    case 0x7:
        this.regEBX = (this.regEBX & ~0xff00) | (b << 8);
        if (BACKTRACK) this.backTrack.btiBH = this.backTrack.btiEALo;
        break;
    }
};

/**
 * modMemByte32(fn)
 *
 * @this {CPUx86}
 * @param {function(number,number)} fn (dst,src)
 */
X86.modMemByte32 = function(fn)
{
    let dst, src;
    let bModRM = (this.bModRM = this.getIPByte()) & 0xC7;

    switch(bModRM) {
    case 0x00:
        dst = this.getEAByteData(this.regEAX);
        this.regEAWrite = this.regEA;
        break;
    case 0x01:
        dst = this.getEAByteData(this.regECX);
        this.regEAWrite = this.regEA;
        break;
    case 0x02:
        dst = this.getEAByteData(this.regEDX);
        this.regEAWrite = this.regEA;
        break;
    case 0x03:
        dst = this.getEAByteData(this.regEBX);
        this.regEAWrite = this.regEA;
        break;
    case 0x04:
        dst = this.getEAByteData(X86.modSIB.call(this, 0));
        this.regEAWrite = this.regEA;
        break;
    case 0x05:
        dst = this.getEAByteData(this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x06:
        dst = this.getEAByteData(this.regESI);
        this.regEAWrite = this.regEA;
        break;
    case 0x07:
        dst = this.getEAByteData(this.regEDI);
        this.regEAWrite = this.regEA;
        break;
    case 0x40:
        dst = this.getEAByteData(this.regEAX + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x41:
        dst = this.getEAByteData(this.regECX + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x42:
        dst = this.getEAByteData(this.regEDX + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x43:
        dst = this.getEAByteData(this.regEBX + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x44:
        dst = this.getEAByteData(X86.modSIB.call(this, 1) + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x45:
        dst = this.getEAByteStack(this.regEBP + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x46:
        dst = this.getEAByteData(this.regESI + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x47:
        dst = this.getEAByteData(this.regEDI + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x80:
        dst = this.getEAByteData(this.regEAX + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x81:
        dst = this.getEAByteData(this.regECX + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x82:
        dst = this.getEAByteData(this.regEDX + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x83:
        dst = this.getEAByteData(this.regEBX + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x84:
        dst = this.getEAByteData(X86.modSIB.call(this, 2) + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x85:
        dst = this.getEAByteStack(this.regEBP + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x86:
        dst = this.getEAByteData(this.regESI + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x87:
        dst = this.getEAByteData(this.regEDI + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0xC0:
        dst = this.regEAX & 0xff;
        break;
    case 0xC1:
        dst = this.regECX & 0xff;
        break;
    case 0xC2:
        dst = this.regEDX & 0xff;
        break;
    case 0xC3:
        dst = this.regEBX & 0xff;
        break;
    case 0xC4:
        dst = (this.regEAX >> 8) & 0xff;
        break;
    case 0xC5:
        dst = (this.regECX >> 8) & 0xff;
        break;
    case 0xC6:
        dst = (this.regEDX >> 8) & 0xff;
        break;
    case 0xC7:
        dst = (this.regEBX >> 8) & 0xff;
        break;
    default:
        dst = 0;

        break;
    }

    let reg = (this.bModRM >> 3) & 0x7;

    switch(reg) {
    case 0x0:
        src = this.regEAX & 0xff;
        if (BACKTRACK) this.backTrack.btiEALo = this.backTrack.btiAL;
        break;
    case 0x1:
        src = this.regECX & 0xff;
        if (BACKTRACK) this.backTrack.btiEALo = this.backTrack.btiCL;
        break;
    case 0x2:
        src = this.regEDX & 0xff;
        if (BACKTRACK) this.backTrack.btiEALo = this.backTrack.btiDL;
        break;
    case 0x3:
        src = this.regEBX & 0xff;
        if (BACKTRACK) this.backTrack.btiEALo = this.backTrack.btiBL;
        break;
    case 0x4:
        src = (this.regEAX >> 8) & 0xff;
        if (BACKTRACK) this.backTrack.btiEALo = this.backTrack.btiAH;
        break;
    case 0x5:
        src = (this.regECX >> 8) & 0xff;
        if (BACKTRACK) this.backTrack.btiEALo = this.backTrack.btiCH;
        break;
    case 0x6:
        src = (this.regEDX >> 8) & 0xff;
        if (BACKTRACK) this.backTrack.btiEALo = this.backTrack.btiDH;
        break;
    case 0x7:
        src = (this.regEBX >> 8) & 0xff;
        if (BACKTRACK) this.backTrack.btiEALo = this.backTrack.btiBH;
        break;
    default:
        src = 0;
        break;
    }

    let b = fn.call(this, dst, src);

    switch(bModRM) {
    case 0xC0:
        this.regEAX = (this.regEAX & ~0xff) | b;
        if (BACKTRACK) this.backTrack.btiAL = this.backTrack.btiEALo;
        break;
    case 0xC1:
        this.regECX = (this.regECX & ~0xff) | b;
        if (BACKTRACK) this.backTrack.btiCL = this.backTrack.btiEALo;
        break;
    case 0xC2:
        this.regEDX = (this.regEDX & ~0xff) | b;
        if (BACKTRACK) this.backTrack.btiDL = this.backTrack.btiEALo;
        break;
    case 0xC3:
        this.regEBX = (this.regEBX & ~0xff) | b;
        if (BACKTRACK) this.backTrack.btiBL = this.backTrack.btiEALo;
        break;
    case 0xC4:
        this.regEAX = (this.regEAX & ~0xff00) | (b << 8);
        if (BACKTRACK) this.backTrack.btiAH = this.backTrack.btiEALo;
        break;
    case 0xC5:
        this.regECX = (this.regECX & ~0xff00) | (b << 8);
        if (BACKTRACK) this.backTrack.btiCH = this.backTrack.btiEALo;
        break;
    case 0xC6:
        this.regEDX = (this.regEDX & ~0xff00) | (b << 8);
        if (BACKTRACK) this.backTrack.btiDH = this.backTrack.btiEALo;
        break;
    case 0xC7:
        this.regEBX = (this.regEBX & ~0xff00) | (b << 8);
        if (BACKTRACK) this.backTrack.btiBH = this.backTrack.btiEALo;
        break;
    default:
        this.setEAByte(b);
        break;
    }
};

/**
 * modGrpByte32(afnGrp, fnSrc)
 *
 * @this {CPUx86}
 * @param {Array.<function(number,number)>} afnGrp
 * @param {function()} fnSrc
 */
X86.modGrpByte32 = function(afnGrp, fnSrc)
{
    let dst;
    let bModRM = (this.bModRM = this.getIPByte()) & 0xC7;

    switch(bModRM) {
    case 0x00:
        dst = this.getEAByteData(this.regEAX);
        this.regEAWrite = this.regEA;
        break;
    case 0x01:
        dst = this.getEAByteData(this.regECX);
        this.regEAWrite = this.regEA;
        break;
    case 0x02:
        dst = this.getEAByteData(this.regEDX);
        this.regEAWrite = this.regEA;
        break;
    case 0x03:
        dst = this.getEAByteData(this.regEBX);
        this.regEAWrite = this.regEA;
        break;
    case 0x04:
        dst = this.getEAByteData(X86.modSIB.call(this, 0));
        this.regEAWrite = this.regEA;
        break;
    case 0x05:
        dst = this.getEAByteData(this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x06:
        dst = this.getEAByteData(this.regESI);
        this.regEAWrite = this.regEA;
        break;
    case 0x07:
        dst = this.getEAByteData(this.regEDI);
        this.regEAWrite = this.regEA;
        break;
    case 0x40:
        dst = this.getEAByteData(this.regEAX + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x41:
        dst = this.getEAByteData(this.regECX + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x42:
        dst = this.getEAByteData(this.regEDX + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x43:
        dst = this.getEAByteData(this.regEBX + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x44:
        dst = this.getEAByteData(X86.modSIB.call(this, 1) + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x45:
        dst = this.getEAByteStack(this.regEBP + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x46:
        dst = this.getEAByteData(this.regESI + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x47:
        dst = this.getEAByteData(this.regEDI + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x80:
        dst = this.getEAByteData(this.regEAX + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x81:
        dst = this.getEAByteData(this.regECX + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x82:
        dst = this.getEAByteData(this.regEDX + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x83:
        dst = this.getEAByteData(this.regEBX + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x84:
        dst = this.getEAByteData(X86.modSIB.call(this, 2) + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x85:
        dst = this.getEAByteStack(this.regEBP + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x86:
        dst = this.getEAByteData(this.regESI + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x87:
        dst = this.getEAByteData(this.regEDI + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0xC0:
        dst = this.regEAX & 0xff;
        break;
    case 0xC1:
        dst = this.regECX & 0xff;
        break;
    case 0xC2:
        dst = this.regEDX & 0xff;
        break;
    case 0xC3:
        dst = this.regEBX & 0xff;
        break;
    case 0xC4:
        dst = (this.regEAX >> 8) & 0xff;
        break;
    case 0xC5:
        dst = (this.regECX >> 8) & 0xff;
        break;
    case 0xC6:
        dst = (this.regEDX >> 8) & 0xff;
        break;
    case 0xC7:
        dst = (this.regEBX >> 8) & 0xff;
        break;
    default:
        dst = 0;

        break;
    }

    let reg = (this.bModRM >> 3) & 0x7;

    let b = afnGrp[reg].call(this, dst, fnSrc.call(this));

    switch(bModRM) {
    case 0xC0:
        this.regEAX = (this.regEAX & ~0xff) | b;
        break;
    case 0xC1:
        this.regECX = (this.regECX & ~0xff) | b;
        break;
    case 0xC2:
        this.regEDX = (this.regEDX & ~0xff) | b;
        break;
    case 0xC3:
        this.regEBX = (this.regEBX & ~0xff) | b;
        break;
    case 0xC4:
        this.regEAX = (this.regEAX & ~0xff00) | (b << 8);
        break;
    case 0xC5:
        this.regECX = (this.regECX & ~0xff00) | (b << 8);
        break;
    case 0xC6:
        this.regEDX = (this.regEDX & ~0xff00) | (b << 8);
        break;
    case 0xC7:
        this.regEBX = (this.regEBX & ~0xff00) | (b << 8);
        break;
    default:
        this.setEAByte(b);
        break;
    }
};

/**
 * modRegShort32(fn)
 *
 * @this {CPUx86}
 * @param {function(number,number)} fn (dst,src)
 */
X86.modRegShort32 = function(fn)
{
    let dst, src;
    let bModRM = (this.bModRM = this.getIPByte()) & 0xC7;

    switch(bModRM) {
    case 0x00:
        src = this.getEAShortData(this.regEAX);
        break;
    case 0x01:
        src = this.getEAShortData(this.regECX);
        break;
    case 0x02:
        src = this.getEAShortData(this.regEDX);
        break;
    case 0x03:
        src = this.getEAShortData(this.regEBX);
        break;
    case 0x04:
        src = this.getEAShortData(X86.modSIB.call(this, 0));
        break;
    case 0x05:
        src = this.getEAShortData(this.getIPAddr());
        break;
    case 0x06:
        src = this.getEAShortData(this.regESI);
        break;
    case 0x07:
        src = this.getEAShortData(this.regEDI);
        break;
    case 0x40:
        src = this.getEAShortData(this.regEAX + this.getIPDisp());
        break;
    case 0x41:
        src = this.getEAShortData(this.regECX + this.getIPDisp());
        break;
    case 0x42:
        src = this.getEAShortData(this.regEDX + this.getIPDisp());
        break;
    case 0x43:
        src = this.getEAShortData(this.regEBX + this.getIPDisp());
        break;
    case 0x44:
        src = this.getEAShortData(X86.modSIB.call(this, 1) + this.getIPDisp());
        break;
    case 0x45:
        src = this.getEAShortStack(this.regEBP + this.getIPDisp());
        break;
    case 0x46:
        src = this.getEAShortData(this.regESI + this.getIPDisp());
        break;
    case 0x47:
        src = this.getEAShortData(this.regEDI + this.getIPDisp());
        break;
    case 0x80:
        src = this.getEAShortData(this.regEAX + this.getIPAddr());
        break;
    case 0x81:
        src = this.getEAShortData(this.regECX + this.getIPAddr());
        break;
    case 0x82:
        src = this.getEAShortData(this.regEDX + this.getIPAddr());
        break;
    case 0x83:
        src = this.getEAShortData(this.regEBX + this.getIPAddr());
        break;
    case 0x84:
        src = this.getEAShortData(X86.modSIB.call(this, 2) + this.getIPAddr());
        break;
    case 0x85:
        src = this.getEAShortStack(this.regEBP + this.getIPAddr());
        break;
    case 0x86:
        src = this.getEAShortData(this.regESI + this.getIPAddr());
        break;
    case 0x87:
        src = this.getEAShortData(this.regEDI + this.getIPAddr());
        break;
    case 0xC0:
        src = this.regEAX & 0xffff;
        if (BACKTRACK) {
            this.backTrack.btiEALo = this.backTrack.btiAL; this.backTrack.btiEAHi = this.backTrack.btiAH;
        }
        break;
    case 0xC1:
        src = this.regECX & 0xffff;
        if (BACKTRACK) {
            this.backTrack.btiEALo = this.backTrack.btiCL; this.backTrack.btiEAHi = this.backTrack.btiCH;
        }
        break;
    case 0xC2:
        src = this.regEDX & 0xffff;
        if (BACKTRACK) {
            this.backTrack.btiEALo = this.backTrack.btiDL; this.backTrack.btiEAHi = this.backTrack.btiDH;
        }
        break;
    case 0xC3:
        src = this.regEBX & 0xffff;
        if (BACKTRACK) {
            this.backTrack.btiEALo = this.backTrack.btiBL; this.backTrack.btiEAHi = this.backTrack.btiBH;
        }
        break;
    case 0xC4:
        src = this.getSP() & 0xffff;
        if (BACKTRACK) {
            this.backTrack.btiEALo = X86.BTINFO.SP_LO; this.backTrack.btiEAHi = X86.BTINFO.SP_HI;
        }
        break;
    case 0xC5:
        src = this.regEBP & 0xffff;
        if (BACKTRACK) {
            this.backTrack.btiEALo = this.backTrack.btiBPLo; this.backTrack.btiEAHi = this.backTrack.btiBPHi;
        }
        break;
    case 0xC6:
        src = this.regESI & 0xffff;
        if (BACKTRACK) {
            this.backTrack.btiEALo = this.backTrack.btiSILo; this.backTrack.btiEAHi = this.backTrack.btiSIHi;
        }
        break;
    case 0xC7:
        src = this.regEDI & 0xffff;
        if (BACKTRACK) {
            this.backTrack.btiEALo = this.backTrack.btiDILo; this.backTrack.btiEAHi = this.backTrack.btiDIHi;
        }
        break;
    default:
        src = 0;

        break;
    }

    let reg = (this.bModRM >> 3) & 0x7;

    switch(reg) {
    case 0x0:
        dst = this.regEAX & 0xffff;
        break;
    case 0x1:
        dst = this.regECX & 0xffff;
        break;
    case 0x2:
        dst = this.regEDX & 0xffff;
        break;
    case 0x3:
        dst = this.regEBX & 0xffff;
        break;
    case 0x4:
        dst = this.getSP() & 0xffff;
        break;
    case 0x5:
        dst = this.regEBP & 0xffff;
        break;
    case 0x6:
        dst = this.regESI & 0xffff;
        break;
    case 0x7:
        dst = this.regEDI & 0xffff;
        break;
    default:
        dst = 0;
        break;
    }

    let w = fn.call(this, dst, src);


    switch(reg) {
    case 0x0:
        this.regEAX = (this.regEAX & ~0xffff) | w;
        if (BACKTRACK) {
            this.backTrack.btiAL = this.backTrack.btiEALo; this.backTrack.btiAH = this.backTrack.btiEAHi;
        }
        break;
    case 0x1:
        this.regECX = (this.regECX & ~0xffff) | w;
        if (BACKTRACK) {
            this.backTrack.btiCL = this.backTrack.btiEALo; this.backTrack.btiCH = this.backTrack.btiEAHi;
        }
        break;
    case 0x2:
        this.regEDX = (this.regEDX & ~0xffff) | w;
        if (BACKTRACK) {
            this.backTrack.btiDL = this.backTrack.btiEALo; this.backTrack.btiDH = this.backTrack.btiEAHi;
        }
        break;
    case 0x3:
        this.regEBX = (this.regEBX & ~0xffff) | w;
        if (BACKTRACK) {
            this.backTrack.btiBL = this.backTrack.btiEALo; this.backTrack.btiBH = this.backTrack.btiEAHi;
        }
        break;
    case 0x4:
        this.setSP((this.getSP() & ~0xffff) | w);
        break;
    case 0x5:
        this.regEBP = (this.regEBP & ~0xffff) | w;
        if (BACKTRACK) {
            this.backTrack.btiBPLo = this.backTrack.btiEALo; this.backTrack.btiBPHi = this.backTrack.btiEAHi;
        }
        break;
    case 0x6:
        this.regESI = (this.regESI & ~0xffff) | w;
        if (BACKTRACK) {
            this.backTrack.btiSILo = this.backTrack.btiEALo; this.backTrack.btiSIHi = this.backTrack.btiEAHi;
        }
        break;
    case 0x7:
        this.regEDI = (this.regEDI & ~0xffff) | w;
        if (BACKTRACK) {
            this.backTrack.btiDILo = this.backTrack.btiEALo; this.backTrack.btiDIHi = this.backTrack.btiEAHi;
        }
        break;
    }
};

/**
 * modMemShort32(fn)
 *
 * @this {CPUx86}
 * @param {function(number,number)} fn (dst,src)
 */
X86.modMemShort32 = function(fn)
{
    let dst, src;
    let bModRM = (this.bModRM = this.getIPByte()) & 0xC7;

    switch(bModRM) {
    case 0x00:
        dst = this.getEAShortData(this.regEAX);
        this.regEAWrite = this.regEA;
        break;
    case 0x01:
        dst = this.getEAShortData(this.regECX);
        this.regEAWrite = this.regEA;
        break;
    case 0x02:
        dst = this.getEAShortData(this.regEDX);
        this.regEAWrite = this.regEA;
        break;
    case 0x03:
        dst = this.getEAShortData(this.regEBX);
        this.regEAWrite = this.regEA;
        break;
    case 0x04:
        dst = this.getEAShortData(X86.modSIB.call(this, 0));
        this.regEAWrite = this.regEA;
        break;
    case 0x05:
        dst = this.getEAShortData(this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x06:
        dst = this.getEAShortData(this.regESI);
        this.regEAWrite = this.regEA;
        break;
    case 0x07:
        dst = this.getEAShortData(this.regEDI);
        this.regEAWrite = this.regEA;
        break;
    case 0x40:
        dst = this.getEAShortData(this.regEAX + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x41:
        dst = this.getEAShortData(this.regECX + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x42:
        dst = this.getEAShortData(this.regEDX + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x43:
        dst = this.getEAShortData(this.regEBX + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x44:
        dst = this.getEAShortData(X86.modSIB.call(this, 1) + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x45:
        dst = this.getEAShortStack(this.regEBP + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x46:
        dst = this.getEAShortData(this.regESI + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x47:
        dst = this.getEAShortData(this.regEDI + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x80:
        dst = this.getEAShortData(this.regEAX + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x81:
        dst = this.getEAShortData(this.regECX + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x82:
        dst = this.getEAShortData(this.regEDX + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x83:
        dst = this.getEAShortData(this.regEBX + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x84:
        dst = this.getEAShortData(X86.modSIB.call(this, 2) + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x85:
        dst = this.getEAShortStack(this.regEBP + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x86:
        dst = this.getEAShortData(this.regESI + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x87:
        dst = this.getEAShortData(this.regEDI + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0xC0:
        dst = this.regEAX & 0xffff;
        break;
    case 0xC1:
        dst = this.regECX & 0xffff;
        break;
    case 0xC2:
        dst = this.regEDX & 0xffff;
        break;
    case 0xC3:
        dst = this.regEBX & 0xffff;
        break;
    case 0xC4:
        dst = this.getSP() & 0xffff;
        break;
    case 0xC5:
        dst = this.regEBP & 0xffff;
        break;
    case 0xC6:
        dst = this.regESI & 0xffff;
        break;
    case 0xC7:
        dst = this.regEDI & 0xffff;
        break;
    default:
        dst = 0;

        break;
    }

    let reg = (this.bModRM >> 3) & 0x7;

    switch(reg) {
    case 0x0:
        src = this.regEAX & 0xffff;
        if (BACKTRACK) {
            this.backTrack.btiEALo = this.backTrack.btiAL; this.backTrack.btiEAHi = this.backTrack.btiAH;
        }
        break;
    case 0x1:
        src = this.regECX & 0xffff;
        if (BACKTRACK) {
            this.backTrack.btiEALo = this.backTrack.btiCL; this.backTrack.btiEAHi = this.backTrack.btiCH;
        }
        break;
    case 0x2:
        src = this.regEDX & 0xffff;
        if (BACKTRACK) {
            this.backTrack.btiEALo = this.backTrack.btiDL; this.backTrack.btiEAHi = this.backTrack.btiDH;
        }
        break;
    case 0x3:
        src = this.regEBX & 0xffff;
        if (BACKTRACK) {
            this.backTrack.btiEALo = this.backTrack.btiBL; this.backTrack.btiEAHi = this.backTrack.btiBH;
        }
        break;
    case 0x4:
        src = this.getSP() & 0xffff;
        if (BACKTRACK) {
            this.backTrack.btiEALo = X86.BTINFO.SP_LO; this.backTrack.btiEAHi = X86.BTINFO.SP_HI;
        }
        break;
    case 0x5:
        src = this.regEBP & 0xffff;
        if (BACKTRACK) {
            this.backTrack.btiEALo = this.backTrack.btiBPLo; this.backTrack.btiEAHi = this.backTrack.btiBPHi;
        }
        break;
    case 0x6:
        src = this.regESI & 0xffff;
        if (BACKTRACK) {
            this.backTrack.btiEALo = this.backTrack.btiSILo; this.backTrack.btiEAHi = this.backTrack.btiSIHi;
        }
        break;
    case 0x7:
        src = this.regEDI & 0xffff;
        if (BACKTRACK) {
            this.backTrack.btiEALo = this.backTrack.btiDILo; this.backTrack.btiEAHi = this.backTrack.btiDIHi;
        }
        break;
    default:
        src = 0;
        break;
    }

    let w = fn.call(this, dst, src);


    switch(bModRM) {
    case 0xC0:
        this.regEAX = (this.regEAX & ~0xffff) | w;
        if (BACKTRACK) {
            this.backTrack.btiAL = this.backTrack.btiEALo; this.backTrack.btiAH = this.backTrack.btiEAHi;
        }
        break;
    case 0xC1:
        this.regECX = (this.regECX & ~0xffff) | w;
        if (BACKTRACK) {
            this.backTrack.btiCL = this.backTrack.btiEALo; this.backTrack.btiCH = this.backTrack.btiEAHi;
        }
        break;
    case 0xC2:
        this.regEDX = (this.regEDX & ~0xffff) | w;
        if (BACKTRACK) {
            this.backTrack.btiDL = this.backTrack.btiEALo; this.backTrack.btiDH = this.backTrack.btiEAHi;
        }
        break;
    case 0xC3:
        this.regEBX = (this.regEBX & ~0xffff) | w;
        if (BACKTRACK) {
            this.backTrack.btiBL = this.backTrack.btiEALo; this.backTrack.btiBH = this.backTrack.btiEAHi;
        }
        break;
    case 0xC4:
        this.setSP((this.getSP() & ~0xffff) | w);
        break;
    case 0xC5:
        this.regEBP = (this.regEBP & ~0xffff) | w;
        if (BACKTRACK) {
            this.backTrack.btiBPLo = this.backTrack.btiEALo; this.backTrack.btiBPHi = this.backTrack.btiEAHi;
        }
        break;
    case 0xC6:
        this.regESI = (this.regESI & ~0xffff) | w;
        if (BACKTRACK) {
            this.backTrack.btiSILo = this.backTrack.btiEALo; this.backTrack.btiSIHi = this.backTrack.btiEAHi;
        }
        break;
    case 0xC7:
        this.regEDI = (this.regEDI & ~0xffff) | w;
        if (BACKTRACK) {
            this.backTrack.btiDILo = this.backTrack.btiEALo; this.backTrack.btiDIHi = this.backTrack.btiEAHi;
        }
        break;
    default:
        this.setEAShort(w);
        break;
    }
};

/**
 * modGrpShort32(afnGrp, fnSrc)
 *
 * @this {CPUx86}
 * @param {Array.<function(number,number)>} afnGrp
 * @param {function()} fnSrc
 */
X86.modGrpShort32 = function(afnGrp, fnSrc)
{
    let dst;
    let bModRM = (this.bModRM = this.getIPByte()) & 0xC7;

    switch(bModRM) {
    case 0x00:
        dst = this.getEAShortData(this.regEAX);
        this.regEAWrite = this.regEA;
        break;
    case 0x01:
        dst = this.getEAShortData(this.regECX);
        this.regEAWrite = this.regEA;
        break;
    case 0x02:
        dst = this.getEAShortData(this.regEDX);
        this.regEAWrite = this.regEA;
        break;
    case 0x03:
        dst = this.getEAShortData(this.regEBX);
        this.regEAWrite = this.regEA;
        break;
    case 0x04:
        dst = this.getEAShortData(X86.modSIB.call(this, 0));
        this.regEAWrite = this.regEA;
        break;
    case 0x05:
        dst = this.getEAShortData(this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x06:
        dst = this.getEAShortData(this.regESI);
        this.regEAWrite = this.regEA;
        break;
    case 0x07:
        dst = this.getEAShortData(this.regEDI);
        this.regEAWrite = this.regEA;
        break;
    case 0x40:
        dst = this.getEAShortData(this.regEAX + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x41:
        dst = this.getEAShortData(this.regECX + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x42:
        dst = this.getEAShortData(this.regEDX + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x43:
        dst = this.getEAShortData(this.regEBX + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x44:
        dst = this.getEAShortData(X86.modSIB.call(this, 1) + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x45:
        dst = this.getEAShortStack(this.regEBP + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x46:
        dst = this.getEAShortData(this.regESI + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x47:
        dst = this.getEAShortData(this.regEDI + this.getIPDisp());
        this.regEAWrite = this.regEA;
        break;
    case 0x80:
        dst = this.getEAShortData(this.regEAX + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x81:
        dst = this.getEAShortData(this.regECX + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x82:
        dst = this.getEAShortData(this.regEDX + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x83:
        dst = this.getEAShortData(this.regEBX + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x84:
        dst = this.getEAShortData(X86.modSIB.call(this, 2) + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x85:
        dst = this.getEAShortStack(this.regEBP + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x86:
        dst = this.getEAShortData(this.regESI + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0x87:
        dst = this.getEAShortData(this.regEDI + this.getIPAddr());
        this.regEAWrite = this.regEA;
        break;
    case 0xC0:
        dst = this.regEAX & 0xffff;
        break;
    case 0xC1:
        dst = this.regECX & 0xffff;
        break;
    case 0xC2:
        dst = this.regEDX & 0xffff;
        break;
    case 0xC3:
        dst = this.regEBX & 0xffff;
        break;
    case 0xC4:
        dst = this.getSP() & 0xffff;
        break;
    case 0xC5:
        dst = this.regEBP & 0xffff;
        break;
    case 0xC6:
        dst = this.regESI & 0xffff;
        break;
    case 0xC7:
        dst = this.regEDI & 0xffff;
        break;
    default:
        dst = 0;

        break;
    }

    let reg = (this.bModRM >> 3) & 0x7;

    let w = afnGrp[reg].call(this, dst, fnSrc.call(this));


    switch(bModRM) {
    case 0xC0:
        this.regEAX = (this.regEAX & ~0xffff) | w;
        break;
    case 0xC1:
        this.regECX = (this.regECX & ~0xffff) | w;
        break;
    case 0xC2:
        this.regEDX = (this.regEDX & ~0xffff) | w;
        break;
    case 0xC3:
        this.regEBX = (this.regEBX & ~0xffff) | w;
        break;
    case 0xC4:
        this.setSP((this.getSP() & ~0xffff) | w);
        break;
    case 0xC5:
        this.regEBP = (this.regEBP & ~0xffff) | w;
        break;
    case 0xC6:
        this.regESI = (this.regESI & ~0xffff) | w;
        break;
    case 0xC7:
        this.regEDI = (this.regEDI & ~0xffff) | w;
        break;
    default:
        this.setEAShort(w);
        break;
    }
};

/**
 * modRegLong32(fn)
 *
 * @this {CPUx86}
 * @param {function(number,number)} fn (dst,src)
 */
X86.modRegLong32 = function(fn)
{
    let dst, src, l;
    let bModRM = this.bModRM = this.getIPByte();

    switch(bModRM & 0xC7) {
    case 0x00:
        src = this.getEALongData(this.regEAX);
        break;
    case 0x01:
        src = this.getEALongData(this.regECX);
        break;
    case 0x02:
        src = this.getEALongData(this.regEDX);
        break;
    case 0x03:
        src = this.getEALongData(this.regEBX);
        break;
    case 0x04:
        src = this.getEALongData(X86.modSIB.call(this, 0));
        break;
    case 0x05:
        src = this.getEALongData(this.getIPAddr());
        break;
    case 0x06:
        src = this.getEALongData(this.regESI);
        break;
    case 0x07:
        src = this.getEALongData(this.regEDI);
        break;
    case 0x40:
        src = this.getEALongData(this.regEAX + this.getIPDisp());
        break;
    case 0x41:
        src = this.getEALongData(this.regECX + this.getIPDisp());
        break;
    case 0x42:
        src = this.getEALongData(this.regEDX + this.getIPDisp());
        break;
    case 0x43:
        src = this.getEALongData(this.regEBX + this.getIPDisp());
        break;
    case 0x44:
        src = this.getEALongData(X86.modSIB.call(this, 1) + this.getIPDisp());
        break;
    case 0x45:
        src = this.getEALongStack(this.regEBP + this.getIPDisp());
        break;
    case 0x46:
        src = this.getEALongData(this.regESI + this.getIPDisp());
        break;
    case 0x47:
        src = this.getEALongData(this.regEDI + this.getIPDisp());
        break;
    case 0x80:
        src = this.getEALongData(this.regEAX + this.getIPAddr());
        break;
    case 0x81:
        src = this.getEALongData(this.regECX + this.getIPAddr());
        break;
    case 0x82:
        src = this.getEALongData(this.regEDX + this.getIPAddr());
        break;
    case 0x83:
        src = this.getEALongData(this.regEBX + this.getIPAddr());
        break;
    case 0x84:
        src = this.getEALongData(X86.modSIB.call(this, 2) + this.getIPAddr());
        break;
    case 0x85:
        src = this.getEALongStack(this.regEBP + this.getIPAddr());
        break;
    case 0x86:
        src = this.getEALongData(this.regESI + this.getIPAddr());
        break;
    case 0x87:
        src = this.getEALongData(this.regEDI + this.getIPAddr());
        break;
    case 0xC0:
        src = this.regEAX;
        if (BACKTRACK) {this.backTrack.btiEALo = this.backTrack.btiAL; this.backTrack.btiEAHi = this.backTrack.btiAH;}
        break;
    case 0xC1:
        src = this.regECX;
        if (BACKTRACK) {this.backTrack.btiEALo = this.backTrack.btiCL; this.backTrack.btiEAHi = this.backTrack.btiCH;}
        break;
    case 0xC2:
        src = this.regEDX;
        if (BACKTRACK) {this.backTrack.btiEALo = this.backTrack.btiDL; this.backTrack.btiEAHi = this.backTrack.btiDH;}
        break;
    case 0xC3:
        src = this.regEBX;
        if (BACKTRACK) {this.backTrack.btiEALo = this.backTrack.btiBL; this.backTrack.btiEAHi = this.backTrack.btiBH;}
        break;
    case 0xC4:
        src = this.getSP();
        if (BACKTRACK) {this.backTrack.btiEALo = X86.BTINFO.SP_LO; this.backTrack.btiEAHi = X86.BTINFO.SP_HI;}
        break;
    case 0xC5:
        src = this.regEBP;
        if (BACKTRACK) {this.backTrack.btiEALo = this.backTrack.btiBPLo; this.backTrack.btiEAHi = this.backTrack.btiBPHi;}
        break;
    case 0xC6:
        src = this.regESI;
        if (BACKTRACK) {this.backTrack.btiEALo = this.backTrack.btiSILo; this.backTrack.btiEAHi = this.backTrack.btiSIHi;}
        break;
    case 0xC7:
        src = this.regEDI;
        if (BACKTRACK) {this.backTrack.btiEALo = this.backTrack.btiDILo; this.backTrack.btiEAHi = this.backTrack.btiDIHi;}
        break;
    }

    switch((bModRM >> 3) & 0x7) {
    case 0x0:
        dst = this.regEAX;
        l = fn.call(this, dst, src);
        this.regEAX = l;
        if (BACKTRACK) {this.backTrack.btiAL = this.backTrack.btiEALo; this.backTrack.btiAH = this.backTrack.btiEAHi;}
        break;
    case 0x1:
        dst = this.regECX;
        l = fn.call(this, dst, src);
        this.regECX = l;
        if (BACKTRACK) {this.backTrack.btiCL = this.backTrack.btiEALo; this.backTrack.btiCH = this.backTrack.btiEAHi;}
        break;
    case 0x2:
        dst = this.regEDX;
        l = fn.call(this, dst, src);
        this.regEDX = l;
        if (BACKTRACK) {this.backTrack.btiDL = this.backTrack.btiEALo; this.backTrack.btiDH = this.backTrack.btiEAHi;}
        break;
    case 0x3:
        dst = this.regEBX;
        l = fn.call(this, dst, src);
        this.regEBX = l;
        if (BACKTRACK) {this.backTrack.btiBL = this.backTrack.btiEALo; this.backTrack.btiBH = this.backTrack.btiEAHi;}
        break;
    case 0x4:
        dst = this.getSP();
        l = fn.call(this, dst, src);
        this.setSP(l);
        break;
    case 0x5:
        dst = this.regEBP;
        l = fn.call(this, dst, src);
        this.regEBP = l;
        if (BACKTRACK) {this.backTrack.btiBPLo = this.backTrack.btiEALo; this.backTrack.btiBPHi = this.backTrack.btiEAHi;}
        break;
    case 0x6:
        dst = this.regESI;
        l = fn.call(this, dst, src);
        this.regESI = l;
        if (BACKTRACK) {this.backTrack.btiSILo = this.backTrack.btiEALo; this.backTrack.btiSIHi = this.backTrack.btiEAHi;}
        break;
    case 0x7:
        dst = this.regEDI;
        l = fn.call(this, dst, src);
        this.regEDI = l;
        if (BACKTRACK) {this.backTrack.btiDILo = this.backTrack.btiEALo; this.backTrack.btiDIHi = this.backTrack.btiEAHi;}
        break;
    }
};

/**
 * modMemLong32(fn)
 *
 * @this {CPUx86}
 * @param {function(number,number)} fn (dst,src)
 */
X86.modMemLong32 = function(fn)
{
    let dst, src;
    let bModRM = this.bModRM = this.getIPByte();

    switch(bModRM & 0xC7) {
    case 0x00:
        dst = this.getEALongDataWrite(this.regEAX);
        break;
    case 0x01:
        dst = this.getEALongDataWrite(this.regECX);
        break;
    case 0x02:
        dst = this.getEALongDataWrite(this.regEDX);
        break;
    case 0x03:
        dst = this.getEALongDataWrite(this.regEBX);
        break;
    case 0x04:
        dst = this.getEALongDataWrite(X86.modSIB.call(this, 0));
        break;
    case 0x05:
        dst = this.getEALongDataWrite(this.getIPAddr());
        break;
    case 0x06:
        dst = this.getEALongDataWrite(this.regESI);
        break;
    case 0x07:
        dst = this.getEALongDataWrite(this.regEDI);
        break;
    case 0x40:
        dst = this.getEALongDataWrite(this.regEAX + this.getIPDisp());
        break;
    case 0x41:
        dst = this.getEALongDataWrite(this.regECX + this.getIPDisp());
        break;
    case 0x42:
        dst = this.getEALongDataWrite(this.regEDX + this.getIPDisp());
        break;
    case 0x43:
        dst = this.getEALongDataWrite(this.regEBX + this.getIPDisp());
        break;
    case 0x44:
        dst = this.getEALongDataWrite(X86.modSIB.call(this, 1) + this.getIPDisp());
        break;
    case 0x45:
        dst = this.getEALongStackWrite(this.regEBP + this.getIPDisp());
        break;
    case 0x46:
        dst = this.getEALongDataWrite(this.regESI + this.getIPDisp());
        break;
    case 0x47:
        dst = this.getEALongDataWrite(this.regEDI + this.getIPDisp());
        break;
    case 0x80:
        dst = this.getEALongDataWrite(this.regEAX + this.getIPAddr());
        break;
    case 0x81:
        dst = this.getEALongDataWrite(this.regECX + this.getIPAddr());
        break;
    case 0x82:
        dst = this.getEALongDataWrite(this.regEDX + this.getIPAddr());
        break;
    case 0x83:
        dst = this.getEALongDataWrite(this.regEBX + this.getIPAddr());
        break;
    case 0x84:
        dst = this.getEALongDataWrite(X86.modSIB.call(this, 2) + this.getIPAddr());
        break;
    case 0x85:
        dst = this.getEALongStackWrite(this.regEBP + this.getIPAddr());
        break;
    case 0x86:
        dst = this.getEALongDataWrite(this.regESI + this.getIPAddr());
        break;
    case 0x87:
        dst = this.getEALongDataWrite(this.regEDI + this.getIPAddr());
        break;
    case 0xC0:
        dst = this.regEAX;
        break;
    case 0xC1:
        dst = this.regECX;
        break;
    case 0xC2:
        dst = this.regEDX;
        break;
    case 0xC3:
        dst = this.regEBX;
        break;
    case 0xC4:
        dst = this.getSP();
        break;
    case 0xC5:
        dst = this.regEBP;
        break;
    case 0xC6:
        dst = this.regESI;
        break;
    case 0xC7:
        dst = this.regEDI;
        break;
    }

    switch((bModRM >> 3) & 0x7) {
    case 0x0:
        src = this.regEAX;
        if (BACKTRACK) {this.backTrack.btiEALo = this.backTrack.btiAL; this.backTrack.btiEAHi = this.backTrack.btiAH;}
        break;
    case 0x1:
        src = this.regECX;
        if (BACKTRACK) {this.backTrack.btiEALo = this.backTrack.btiCL; this.backTrack.btiEAHi = this.backTrack.btiCH;}
        break;
    case 0x2:
        src = this.regEDX;
        if (BACKTRACK) {this.backTrack.btiEALo = this.backTrack.btiDL; this.backTrack.btiEAHi = this.backTrack.btiDH;}
        break;
    case 0x3:
        src = this.regEBX;
        if (BACKTRACK) {this.backTrack.btiEALo = this.backTrack.btiBL; this.backTrack.btiEAHi = this.backTrack.btiBH;}
        break;
    case 0x4:
        src = this.getSP();
        if (BACKTRACK) {this.backTrack.btiEALo = X86.BTINFO.SP_LO; this.backTrack.btiEAHi = X86.BTINFO.SP_HI;}
        break;
    case 0x5:
        src = this.regEBP;
        if (BACKTRACK) {this.backTrack.btiEALo = this.backTrack.btiBPLo; this.backTrack.btiEAHi = this.backTrack.btiBPHi;}
        break;
    case 0x6:
        src = this.regESI;
        if (BACKTRACK) {this.backTrack.btiEALo = this.backTrack.btiSILo; this.backTrack.btiEAHi = this.backTrack.btiSIHi;}
        break;
    case 0x7:
        src = this.regEDI;
        if (BACKTRACK) {this.backTrack.btiEALo = this.backTrack.btiDILo; this.backTrack.btiEAHi = this.backTrack.btiDIHi;}
        break;
    }

    let l = fn.call(this, dst, src);

    switch(bModRM & 0xC7) {
    case 0xC0:
        this.regEAX = l;
        if (BACKTRACK) {this.backTrack.btiAL = this.backTrack.btiEALo; this.backTrack.btiAH = this.backTrack.btiEAHi;}
        break;
    case 0xC1:
        this.regECX = l;
        if (BACKTRACK) {this.backTrack.btiCL = this.backTrack.btiEALo; this.backTrack.btiCH = this.backTrack.btiEAHi;}
        break;
    case 0xC2:
        this.regEDX = l;
        if (BACKTRACK) {this.backTrack.btiDL = this.backTrack.btiEALo; this.backTrack.btiDH = this.backTrack.btiEAHi;}
        break;
    case 0xC3:
        this.regEBX = l;
        if (BACKTRACK) {this.backTrack.btiBL = this.backTrack.btiEALo; this.backTrack.btiBH = this.backTrack.btiEAHi;}
        break;
    case 0xC4:
        this.setSP(l);
        break;
    case 0xC5:
        this.regEBP = l;
        if (BACKTRACK) {this.backTrack.btiBPLo = this.backTrack.btiEALo; this.backTrack.btiBPHi = this.backTrack.btiEAHi;}
        break;
    case 0xC6:
        this.regESI = l;
        if (BACKTRACK) {this.backTrack.btiSILo = this.backTrack.btiEALo; this.backTrack.btiSIHi = this.backTrack.btiEAHi;}
        break;
    case 0xC7:
        this.regEDI = l;
        if (BACKTRACK) {this.backTrack.btiDILo = this.backTrack.btiEALo; this.backTrack.btiDIHi = this.backTrack.btiEAHi;}
        break;
    default:
        this.setEALong(l);
        break;
    }
};

/**
 * modGrpLong32(afnGrp, fnSrc)
 *
 * @this {CPUx86}
 * @param {Array.<function(number,number)>} afnGrp
 * @param {function()} fnSrc
 */
X86.modGrpLong32 = function(afnGrp, fnSrc)
{
    let dst;
    let bModRM = this.bModRM = this.getIPByte();

    switch(bModRM & 0xC7) {
    case 0x00:
        dst = this.getEALongDataWrite(this.regEAX);
        break;
    case 0x01:
        dst = this.getEALongDataWrite(this.regECX);
        break;
    case 0x02:
        dst = this.getEALongDataWrite(this.regEDX);
        break;
    case 0x03:
        dst = this.getEALongDataWrite(this.regEBX);
        break;
    case 0x04:
        dst = this.getEALongDataWrite(X86.modSIB.call(this, 0));
        break;
    case 0x05:
        dst = this.getEALongDataWrite(this.getIPAddr());
        break;
    case 0x06:
        dst = this.getEALongDataWrite(this.regESI);
        break;
    case 0x07:
        dst = this.getEALongDataWrite(this.regEDI);
        break;
    case 0x40:
        dst = this.getEALongDataWrite(this.regEAX + this.getIPDisp());
        break;
    case 0x41:
        dst = this.getEALongDataWrite(this.regECX + this.getIPDisp());
        break;
    case 0x42:
        dst = this.getEALongDataWrite(this.regEDX + this.getIPDisp());
        break;
    case 0x43:
        dst = this.getEALongDataWrite(this.regEBX + this.getIPDisp());
        break;
    case 0x44:
        dst = this.getEALongDataWrite(X86.modSIB.call(this, 1) + this.getIPDisp());
        break;
    case 0x45:
        dst = this.getEALongStackWrite(this.regEBP + this.getIPDisp());
        break;
    case 0x46:
        dst = this.getEALongDataWrite(this.regESI + this.getIPDisp());
        break;
    case 0x47:
        dst = this.getEALongDataWrite(this.regEDI + this.getIPDisp());
        break;
    case 0x80:
        dst = this.getEALongDataWrite(this.regEAX + this.getIPAddr());
        break;
    case 0x81:
        dst = this.getEALongDataWrite(this.regECX + this.getIPAddr());
        break;
    case 0x82:
        dst = this.getEALongDataWrite(this.regEDX + this.getIPAddr());
        break;
    case 0x83:
        dst = this.getEALongDataWrite(this.regEBX + this.getIPAddr());
        break;
    case 0x84:
        dst = this.getEALongDataWrite(X86.modSIB.call(this, 2) + this.getIPAddr());
        break;
    case 0x85:
        dst = this.getEALongStackWrite(this.regEBP + this.getIPAddr());
        break;
    case 0x86:
        dst = this.getEALongDataWrite(this.regESI + this.getIPAddr());
        break;
    case 0x87:
        dst = this.getEALongDataWrite(this.regEDI + this.getIPAddr());
        break;
    case 0xC0:
        dst = this.regEAX;
        break;
    case 0xC1:
        dst = this.regECX;
        break;
    case 0xC2:
        dst = this.regEDX;
        break;
    case 0xC3:
        dst = this.regEBX;
        break;
    case 0xC4:
        dst = this.getSP();
        break;
    case 0xC5:
        dst = this.regEBP;
        break;
    case 0xC6:
        dst = this.regESI;
        break;
    case 0xC7:
        dst = this.regEDI;
        break;
    }

    let l = afnGrp[(bModRM >> 3) & 0x7].call(this, dst, fnSrc.call(this));

    switch(bModRM & 0xC7) {
    case 0xC0:
        this.regEAX = l;
        break;
    case 0xC1:
        this.regECX = l;
        break;
    case 0xC2:
        this.regEDX = l;
        break;
    case 0xC3:
        this.regEBX = l;
        break;
    case 0xC4:
        this.setSP(l);
        break;
    case 0xC5:
        this.regEBP = l;
        break;
    case 0xC6:
        this.regESI = l;
        break;
    case 0xC7:
        this.regEDI = l;
        break;
    default:
        this.setEALong(l);
        break;
    }
};

/**
 * modSIB(mod)
 *
 * @this {CPUx86}
 * @param {number} mod
 * @returns {number}
 */
X86.modSIB = function(mod)
{
    let bSIB = this.getIPByte();
    let scale = bSIB >> 6, index, base;

    switch((bSIB >> 3) & 0x7) {
    case 0:
        index = this.regEAX;
        break;
    case 1:
        index = this.regECX;
        break;
    case 2:
        index = this.regEDX;
        break;
    case 3:
        index = this.regEBX;
        break;
    case 4:
        index = 0;
        break;
    case 5:
        index = this.regEBP;
        break;
    case 6:
        index = this.regESI;
        break;
    case 7:
        index = this.regEDI;
        break;
    }

    switch(bSIB & 0x07) {
    case 0:
        base = this.regEAX;
        break;
    case 1:
        base = this.regECX;
        break;
    case 2:
        base = this.regEDX;
        break;
    case 3:
        base = this.regEBX;
        break;
    case 4:
        base = this.getSP();
        this.segData = this.segStack;
        break;
    case 5:
        if (mod) {
            base = this.regEBP;
            this.segData = this.segStack;
        } else {
            base = this.getIPAddr();
        }
        break;
    case 6:
        base = this.regESI;
        break;
    case 7:
        base = this.regEDI;
        break;
    }

    return ((index << scale) + base)|0;
};

/**
 * @copyright https://www.pcjs.org/machines/pcx86/modules/v2/x86ops.js (C) 2012-2024 Jeff Parsons
 */

/**
 * op=0x00 (ADD byte,reg)
 *
 * @this {CPUx86}
 */
X86.opADDmb = function()
{
    this.decodeModMemByte.call(this, X86.fnADDb);
    /**
     * Opcode bytes 0x00 0x00 are sufficiently uncommon that it's more likely we've started
     * executing in the weeds, so if you're in DEBUG mode, we'll print a warning and stop the
     * CPU if a Debugger is available.
     *
     * Notice that we also test fRunning: this allows the Debugger to step over the instruction,
     * because its trace ("t") command doesn't "run" the CPU; it merely "steps" the CPU.
     */
    if (DEBUG && !this.bModRM && this.flags.running) {
        this.printf("suspicious opcode (0x00,0x00)\n");
        if (DEBUGGER && this.dbg) this.dbg.stopCPU();
    }
};

/**
 * op=0x01 (ADD word,reg)
 *
 * @this {CPUx86}
 */
X86.opADDmw = function()
{
    this.decodeModMemWord.call(this, X86.fnADDw);
};

/**
 * op=0x02 (ADD reg,byte)
 *
 * @this {CPUx86}
 */
X86.opADDrb = function()
{
    this.decodeModRegByte.call(this, X86.fnADDb);
};

/**
 * op=0x03 (ADD reg,word)
 *
 * @this {CPUx86}
 */
X86.opADDrw = function()
{
    this.decodeModRegWord.call(this, X86.fnADDw);
};

/**
 * op=0x04 (ADD AL,imm8)
 *
 * @this {CPUx86}
 */
X86.opADDALb = function()
{
    this.regEAX = (this.regEAX & ~0xff) | X86.fnADDb.call(this, this.regEAX & 0xff, this.getIPByte());
    /**
     * NOTE: Whenever the result is "blended" value (eg, of btiAL and btiMem0), a new bti should be
     * allocated to reflect that fact; however, I'm leaving "perfect" BACKTRACK support for another day.
     */
    if (BACKTRACK) this.backTrack.btiAL = this.backTrack.btiMem0;
    this.nStepCycles--;         // in the absence of any EA calculations, we need deduct only one more cycle
};

/**
 * op=0x05 (ADD AX,imm16 or ADD EAX,imm32)
 *
 * @this {CPUx86}
 */
X86.opADDAX = function()
{
    this.regEAX = (this.regEAX & ~this.maskData) | X86.fnADDw.call(this, this.regEAX & this.maskData, this.getIPWord());
    if (BACKTRACK) {
        this.backTrack.btiAL = this.backTrack.btiMem0; this.backTrack.btiAH = this.backTrack.btiMem1;
    }
    this.nStepCycles--;         // in the absence of any EA calculations, we need deduct only one more cycle
};

/**
 * op=0x06 (PUSH ES)
 *
 * @this {CPUx86}
 */
X86.opPUSHES = function()
{
    /**
     * When the OPERAND size is 32 bits, the 80386 will decrement the stack pointer by 4, write the selector
     * into the 2 lower bytes, and leave the 2 upper bytes untouched; to properly emulate that, we must use the
     * more generic pushData() instead of pushWord().
     */
    if (!I386) {
        this.pushWord(this.segES.sel);
    } else {
        this.pushData(this.segES.sel, this.sizeData, 2);
    }
    this.nStepCycles -= this.cycleCounts.nOpCyclesPushSeg;
};

/**
 * op=0x07 (POP ES)
 *
 * @this {CPUx86}
 */
X86.opPOPES = function()
{
    /**
     * Any operation that modifies the stack before loading a new segment must snapshot regLSP first.
     */
    this.opLSP = this.regLSP;
    this.setES(this.popWord());
    this.nStepCycles -= this.cycleCounts.nOpCyclesPopReg;
    this.opLSP = X86.ADDR_INVALID;
};

/**
 * op=0x08 (OR byte,reg)
 *
 * @this {CPUx86}
 */
X86.opORmb = function()
{
    this.decodeModMemByte.call(this, X86.fnORb);
};

/**
 * op=0x09 (OR word,reg)
 *
 * @this {CPUx86}
 */
X86.opORmw = function()
{
    this.decodeModMemWord.call(this, X86.fnORw);
};

/**
 * op=0x0A (OR reg,byte)
 *
 * @this {CPUx86}
 */
X86.opORrb = function()
{
    this.decodeModRegByte.call(this, X86.fnORb);
};

/**
 * op=0x0B (OR reg,word)
 *
 * @this {CPUx86}
 */
X86.opORrw = function()
{
    this.decodeModRegWord.call(this, X86.fnORw);
};

/**
 * op=0x0C (OR AL,imm8)
 *
 * @this {CPUx86}
 */
X86.opORALb = function()
{
    this.regEAX = (this.regEAX & ~0xff) | X86.fnORb.call(this, this.regEAX & 0xff, this.getIPByte());
    if (BACKTRACK) this.backTrack.btiAL = this.backTrack.btiMem0;
    this.nStepCycles--;         // in the absence of any EA calculations, we need deduct only one more cycle
};

/**
 * op=0x0D (OR AX,imm16 or OR EAX,imm32)
 *
 * @this {CPUx86}
 */
X86.opORAX = function()
{
    this.regEAX = (this.regEAX & ~this.maskData) | X86.fnORw.call(this, this.regEAX & this.maskData, this.getIPWord());
    if (BACKTRACK) {
        this.backTrack.btiAL = this.backTrack.btiMem0; this.backTrack.btiAH = this.backTrack.btiMem1;
    }
    this.nStepCycles--;         // in the absence of any EA calculations, we need deduct only one more cycle
};

/**
 * op=0x0E (PUSH CS)
 *
 * @this {CPUx86}
 */
X86.opPUSHCS = function()
{
    /**
     * When the OPERAND size is 32 bits, the 80386 will decrement the stack pointer by 4, write the selector
     * into the 2 lower bytes, and leave the 2 upper bytes untouched; to properly emulate that, we must use the
     * more generic pushData() instead of pushWord().
     */
    if (!I386) {
        this.pushWord(this.segCS.sel);
    } else {
        this.pushData(this.segCS.sel, this.sizeData, 2);
    }
    this.nStepCycles -= this.cycleCounts.nOpCyclesPushSeg;
};

/**
 * op=0x0F (POP CS) (undocumented on 8086/8088; replaced with opInvalid() on 80186/80188, and op0F() on 80286 and up)
 *
 * @this {CPUx86}
 */
X86.opPOPCS = function()
{
    /**
     * Because this is an 8088-only operation, we don't have to worry about taking a snapshot of regLSP first.
     */
    this.setCS(this.popWord());
    this.nStepCycles -= this.cycleCounts.nOpCyclesPopReg;
};

/**
 * op=0x0F (handler for two-byte opcodes; 80286 and up)
 *
 * @this {CPUx86}
 */
X86.op0F = function()
{
    this.aOps0F[this.getIPByte()].call(this);
};

/**
 * op=0x10 (ADC byte,reg)
 *
 * @this {CPUx86}
 */
X86.opADCmb = function()
{
    this.decodeModMemByte.call(this, X86.fnADCb);
};

/**
 * op=0x11 (ADC word,reg)
 *
 * @this {CPUx86}
 */
X86.opADCmw = function()
{
    this.decodeModMemWord.call(this, X86.fnADCw);
};

/**
 * op=0x12 (ADC reg,byte)
 *
 * @this {CPUx86}
 */
X86.opADCrb = function()
{
    this.decodeModRegByte.call(this, X86.fnADCb);
};

/**
 * op=0x13 (ADC reg,word)
 *
 * @this {CPUx86}
 */
X86.opADCrw = function()
{
    this.decodeModRegWord.call(this, X86.fnADCw);
};

/**
 * op=0x14 (ADC AL,imm8)
 *
 * @this {CPUx86}
 */
X86.opADCALb = function()
{
    this.regEAX = (this.regEAX & ~0xff) | X86.fnADCb.call(this, this.regEAX & 0xff, this.getIPByte());
    if (BACKTRACK) this.backTrack.btiAL = this.backTrack.btiMem0;
    this.nStepCycles--;         // in the absence of any EA calculations, we need deduct only one more cycle
};

/**
 * op=0x15 (ADC AX,imm16 or ADC EAX,imm32)
 *
 * @this {CPUx86}
 */
X86.opADCAX = function()
{
    this.regEAX = (this.regEAX & ~this.maskData) | X86.fnADCw.call(this, this.regEAX & this.maskData, this.getIPWord());
    if (BACKTRACK) {
        this.backTrack.btiAL = this.backTrack.btiMem0; this.backTrack.btiAH = this.backTrack.btiMem1;
    }
    this.nStepCycles--;         // in the absence of any EA calculations, we need deduct only one more cycle
};

/**
 * op=0x16 (PUSH SS)
 *
 * @this {CPUx86}
 */
X86.opPUSHSS = function()
{
    /**
     * When the OPERAND size is 32 bits, the 80386 will decrement the stack pointer by 4, write the selector
     * into the 2 lower bytes, and leave the 2 upper bytes untouched; to properly emulate that, we must use the
     * more generic pushData() instead of pushWord().
     */
    if (!I386) {
        this.pushWord(this.segSS.sel);
    } else {
        this.pushData(this.segSS.sel, this.sizeData, 2);
    }
    this.nStepCycles -= this.cycleCounts.nOpCyclesPushSeg;
};

/**
 * op=0x17 (POP SS)
 *
 * @this {CPUx86}
 */
X86.opPOPSS = function()
{
    /**
     * Any operation that modifies the stack before loading a new segment must snapshot regLSP first.
     */
    this.opLSP = this.regLSP;
    this.setSS(this.popWord());
    this.nStepCycles -= this.cycleCounts.nOpCyclesPopReg;
    this.opLSP = X86.ADDR_INVALID;
};

/**
 * op=0x18 (SBB byte,reg)
 *
 * @this {CPUx86}
 */
X86.opSBBmb = function()
{
    this.decodeModMemByte.call(this, X86.fnSBBb);
};

/**
 * op=0x19 (SBB word,reg)
 *
 * @this {CPUx86}
 */
X86.opSBBmw = function()
{
    this.decodeModMemWord.call(this, X86.fnSBBw);
};

/**
 * op=0x1A (SBB reg,byte)
 *
 * @this {CPUx86}
 */
X86.opSBBrb = function()
{
    this.decodeModRegByte.call(this, X86.fnSBBb);
};

/**
 * op=0x1B (SBB reg,word)
 *
 * @this {CPUx86}
 */
X86.opSBBrw = function()
{
    this.decodeModRegWord.call(this, X86.fnSBBw);
};

/**
 * op=0x1C (SBB AL,imm8)
 *
 * @this {CPUx86}
 */
X86.opSBBALb = function()
{
    this.regEAX = (this.regEAX & ~0xff) | X86.fnSBBb.call(this, this.regEAX & 0xff, this.getIPByte());
    if (BACKTRACK) this.backTrack.btiAL = this.backTrack.btiMem0;
    this.nStepCycles--;         // in the absence of any EA calculations, we need deduct only one more cycle
};

/**
 * op=0x1D (SBB AX,imm16 or SBB EAX,imm32)
 *
 * @this {CPUx86}
 */
X86.opSBBAX = function()
{
    this.regEAX = (this.regEAX & ~this.maskData) | X86.fnSBBw.call(this, this.regEAX & this.maskData, this.getIPWord());
    if (BACKTRACK) {
        this.backTrack.btiAL = this.backTrack.btiMem0; this.backTrack.btiAH = this.backTrack.btiMem1;
    }
    this.nStepCycles--;         // in the absence of any EA calculations, we need deduct only one more cycle
};

/**
 * op=0x1E (PUSH DS)
 *
 * @this {CPUx86}
 */
X86.opPUSHDS = function()
{
    /**
     * When the OPERAND size is 32 bits, the 80386 will decrement the stack pointer by 4, write the selector
     * into the 2 lower bytes, and leave the 2 upper bytes untouched; to properly emulate that, we must use the
     * more generic pushData() instead of pushWord().
     */
    if (!I386) {
        this.pushWord(this.segDS.sel);
    } else {
        this.pushData(this.segDS.sel, this.sizeData, 2);
    }
    this.nStepCycles -= this.cycleCounts.nOpCyclesPushSeg;
};

/**
 * op=0x1F (POP DS)
 *
 * @this {CPUx86}
 */
X86.opPOPDS = function()
{
    /**
     * Any operation that modifies the stack before loading a new segment must snapshot regLSP first.
     */
    this.opLSP = this.regLSP;
    this.setDS(this.popWord());
    this.nStepCycles -= this.cycleCounts.nOpCyclesPopReg;
    this.opLSP = X86.ADDR_INVALID;
};

/**
 * op=0x20 (AND byte,reg)
 *
 * @this {CPUx86}
 */
X86.opANDmb = function()
{
    this.decodeModMemByte.call(this, X86.fnANDb);
};

/**
 * op=0x21 (AND word,reg)
 *
 * @this {CPUx86}
 */
X86.opANDmw = function()
{
    this.decodeModMemWord.call(this, X86.fnANDw);
};

/**
 * op=0x22 (AND reg,byte)
 *
 * @this {CPUx86}
 */
X86.opANDrb = function()
{
    this.decodeModRegByte.call(this, X86.fnANDb);
};

/**
 * op=0x23 (AND reg,word)
 *
 * @this {CPUx86}
 */
X86.opANDrw = function()
{
    this.decodeModRegWord.call(this, X86.fnANDw);
};

/**
 * op=0x24 (AND AL,imm8)
 *
 * @this {CPUx86}
 */
X86.opANDAL = function()
{
    this.regEAX = (this.regEAX & ~0xff) | X86.fnANDb.call(this, this.regEAX & 0xff, this.getIPByte());
    if (BACKTRACK) this.backTrack.btiAL = this.backTrack.btiMem0;
    this.nStepCycles--;         // in the absence of any EA calculations, we need deduct only one more cycle
};

/**
 * op=0x25 (AND AX,imm16 or AND EAX,imm32)
 *
 * @this {CPUx86}
 */
X86.opANDAX = function()
{
    this.regEAX = (this.regEAX & ~this.maskData) | X86.fnANDw.call(this, this.regEAX & this.maskData, this.getIPWord());
    if (BACKTRACK) {
        this.backTrack.btiAL = this.backTrack.btiMem0; this.backTrack.btiAH = this.backTrack.btiMem1;
    }
    this.nStepCycles--;         // in the absence of any EA calculations, we need deduct only one more cycle
};

/**
 * op=0x26 (ES:)
 *
 * @this {CPUx86}
 */
X86.opES = function()
{
    this.opFlags |= X86.OPFLAG.SEG | X86.OPFLAG.NOINTR;
    this.segData = this.segStack = this.segES;
    this.nStepCycles -= this.cycleCounts.nOpCyclesPrefix;
};

/**
 * op=0x27 (DAA)
 *
 * @this {CPUx86}
 */
X86.opDAA = function()
{
    let AL = this.regEAX & 0xff;
    let AF = this.getAF();
    let CF = this.getCF();
    if ((AL & 0xf) > 9 || AF) {
        AL += 0x6;
        AF = X86.PS.AF;
    } else {
        AF = 0;
    }
    if (AL > 0x9f || CF) {
        AL += 0x60;
        CF = X86.PS.CF;
    } else {
        CF = 0;
    }
    let b = (AL & 0xff);
    this.regEAX = (this.regEAX & ~0xff) | b;
    this.setLogicResult(b, X86.RESULT.BYTE);
    if (CF) this.setCF(); else this.clearCF();
    if (AF) this.setAF(); else this.clearAF();
    this.nStepCycles -= this.cycleCounts.nOpCyclesAAA;          // AAA and DAA have the same cycle times
};

/**
 * op=0x28 (SUB byte,reg)
 *
 * @this {CPUx86}
 */
X86.opSUBmb = function()
{
    this.decodeModMemByte.call(this, X86.fnSUBb);
};

/**
 * op=0x29 (SUB word,reg)
 *
 * @this {CPUx86}
 */
X86.opSUBmw = function()
{
    this.decodeModMemWord.call(this, X86.fnSUBw);
};

/**
 * op=0x2A (SUB reg,byte)
 *
 * @this {CPUx86}
 */
X86.opSUBrb = function()
{
    this.decodeModRegByte.call(this, X86.fnSUBb);
};

/**
 * op=0x2B (SUB reg,word)
 *
 * @this {CPUx86}
 */
X86.opSUBrw = function()
{
    this.decodeModRegWord.call(this, X86.fnSUBw);
};

/**
 * op=0x2C (SUB AL,imm8)
 *
 * @this {CPUx86}
 */
X86.opSUBALb = function()
{
    this.regEAX = (this.regEAX & ~0xff) | X86.fnSUBb.call(this, this.regEAX & 0xff, this.getIPByte());
    if (BACKTRACK) this.backTrack.btiAL = this.backTrack.btiMem0;
    this.nStepCycles--;         // in the absence of any EA calculations, we need deduct only one more cycle
};

/**
 * op=0x2D (SUB AX,imm16 or SUB EAX,imm32)
 *
 * @this {CPUx86}
 */
X86.opSUBAX = function()
{
    this.regEAX = (this.regEAX & ~this.maskData) | X86.fnSUBw.call(this, this.regEAX & this.maskData, this.getIPWord());
    if (BACKTRACK) {
        this.backTrack.btiAL = this.backTrack.btiMem0; this.backTrack.btiAH = this.backTrack.btiMem1;
    }
    this.nStepCycles--;         // in the absence of any EA calculations, we need deduct only one more cycle
};

/**
 * op=0x2E (CS:)
 *
 * @this {CPUx86}
 */
X86.opCS = function()
{
    this.opFlags |= X86.OPFLAG.SEG | X86.OPFLAG.NOINTR;
    this.segData = this.segStack = this.segCS;
    this.nStepCycles -= this.cycleCounts.nOpCyclesPrefix;
};

/**
 * op=0x2F (DAS)
 *
 * @this {CPUx86}
 */
X86.opDAS = function()
{
    let AL = this.regEAX & 0xff;
    let AF = this.getAF();
    let CF = this.getCF();
    if ((AL & 0xf) > 9 || AF) {
        AL -= 0x6;
        AF = X86.PS.AF;
    } else {
        AF = 0;
    }
    if (AL > 0x9f || CF) {
        AL -= 0x60;
        CF = X86.PS.CF;
    } else {
        CF = 0;
    }
    let b = (AL & 0xff);
    this.regEAX = (this.regEAX & ~0xff) | b;
    this.setLogicResult(b, X86.RESULT.BYTE);
    if (CF) this.setCF(); else this.clearCF();
    if (AF) this.setAF(); else this.clearAF();
    this.nStepCycles -= this.cycleCounts.nOpCyclesAAA;          // AAA and DAS have the same cycle times
};

/**
 * op=0x30 (XOR byte,reg)
 *
 * @this {CPUx86}
 */
X86.opXORmb = function()
{
    this.decodeModMemByte.call(this, X86.fnXORb);
};

/**
 * op=0x31 (XOR word,reg)
 *
 * @this {CPUx86}
 */
X86.opXORmw = function()
{
    this.decodeModMemWord.call(this, X86.fnXORw);
};

/**
 * op=0x32 (XOR reg,byte)
 *
 * @this {CPUx86}
 */
X86.opXORrb = function()
{
    this.decodeModRegByte.call(this, X86.fnXORb);
};

/**
 * op=0x33 (XOR reg,word)
 *
 * @this {CPUx86}
 */
X86.opXORrw = function()
{
    this.decodeModRegWord.call(this, X86.fnXORw);
};

/**
 * op=0x34 (XOR AL,imm8)
 *
 * @this {CPUx86}
 */
X86.opXORALb = function()
{
    this.regEAX = (this.regEAX & ~0xff) | X86.fnXORb.call(this, this.regEAX & 0xff, this.getIPByte());
    if (BACKTRACK) this.backTrack.btiAL = this.backTrack.btiMem0;
    this.nStepCycles--;         // in the absence of any EA calculations, we need deduct only one more cycle
};

/**
 * op=0x35 (XOR AX,imm16 or XOR EAX,imm32)
 *
 * @this {CPUx86}
 */
X86.opXORAX = function()
{
    this.regEAX = (this.regEAX & ~this.maskData) | X86.fnXORw.call(this, this.regEAX & this.maskData, this.getIPWord());
    if (BACKTRACK) {
        this.backTrack.btiAL = this.backTrack.btiMem0; this.backTrack.btiAH = this.backTrack.btiMem1;
    }
    this.nStepCycles--;         // in the absence of any EA calculations, we need deduct only one more cycle
};

/**
 * op=0x36 (SS:)
 *
 * @this {CPUx86}
 */
X86.opSS = function()
{
    this.opFlags |= X86.OPFLAG.SEG | X86.OPFLAG.NOINTR;
    this.segData = this.segStack = this.segSS;      // QUESTION: Is there a case where segStack would not already be segSS? (eg, multiple segment overrides?)
    this.nStepCycles -= this.cycleCounts.nOpCyclesPrefix;
};

/**
 * op=0x37 (AAA)
 *
 * @this {CPUx86}
 */
X86.opAAA = function()
{
    let CF, AF;
    let AL = this.regEAX & 0xff;
    let AH = (this.regEAX >> 8) & 0xff;
    if ((AL & 0xf) > 9 || this.getAF()) {
        AL += 6;
        /**
         * Simulate the fact that the 80286 and higher add 6 to AX rather than AL.
         */
        if (this.model >= X86.MODEL_80286 && AL > 0xff) AH++;
        AH++;
        CF = AF = 1;
    } else {
        CF = AF = 0;
    }
    this.regEAX = (this.regEAX & ~0xffff) | (((AH << 8) | AL) & 0xff0f);
    if (CF) this.setCF(); else this.clearCF();
    if (AF) this.setAF(); else this.clearAF();
    this.nStepCycles -= this.cycleCounts.nOpCyclesAAA;
};

/**
 * op=0x38 (CMP byte,reg)
 *
 * @this {CPUx86}
 */
X86.opCMPmb = function()
{
    this.decodeModMemByte.call(this, X86.fnCMPb);
};

/**
 * op=0x39 (CMP word,reg)
 *
 * @this {CPUx86}
 */
X86.opCMPmw = function()
{
    this.decodeModMemWord.call(this, X86.fnCMPw);
};

/**
 * op=0x3A (CMP reg,byte)
 *
 * @this {CPUx86}
 */
X86.opCMPrb = function()
{
    this.decodeModRegByte.call(this, X86.fnCMPb);
};

/**
 * op=0x3B (CMP reg,word)
 *
 * @this {CPUx86}
 */
X86.opCMPrw = function()
{
    this.decodeModRegWord.call(this, X86.fnCMPw);
};

/**
 * op=0x3C (CMP AL,imm8)
 *
 * @this {CPUx86}
 */
X86.opCMPALb = function()
{
    X86.fnCMPb.call(this, this.regEAX & 0xff, this.getIPByte());
    this.nStepCycles--;         // in the absence of any EA calculations, we need deduct only one more cycle
};

/**
 * op=0x3D (CMP AX,imm16 or CMP EAX,imm32)
 *
 * @this {CPUx86}
 */
X86.opCMPAX = function()
{
    X86.fnCMPw.call(this, this.regEAX & this.maskData, this.getIPWord());
    this.nStepCycles--;         // in the absence of any EA calculations, we need deduct only one more cycle
};

/**
 * op=0x3E (DS:)
 *
 * @this {CPUx86}
 */
X86.opDS = function()
{
    this.opFlags |= X86.OPFLAG.SEG | X86.OPFLAG.NOINTR;
    this.segData = this.segStack = this.segDS;      // QUESTION: Is there a case where segData would not already be segDS? (eg, multiple segment overrides?)
    this.nStepCycles -= this.cycleCounts.nOpCyclesPrefix;
};

/**
 * op=0x3D (AAS)
 *
 * @this {CPUx86}
 */
X86.opAAS = function()
{
    let CF, AF;
    let AL = this.regEAX & 0xff;
    let AH = (this.regEAX >> 8) & 0xff;
    if ((AL & 0xf) > 9 || this.getAF()) {
        AL = (AL - 0x6) & 0xf;
        AH = (AH - 1) & 0xff;
        CF = AF = 1;
    } else {
        CF = AF = 0;
    }
    this.regEAX = (this.regEAX & ~0xffff) | ((AH << 8) | AL);
    if (CF) this.setCF(); else this.clearCF();
    if (AF) this.setAF(); else this.clearAF();
    this.nStepCycles -= this.cycleCounts.nOpCyclesAAA;   // AAA and AAS have the same cycle times
};

/**
 * op=0x40 (INC [E]AX)
 *
 * @this {CPUx86}
 */
X86.opINCAX = function()
{
    this.regEAX = X86.helpINCreg.call(this, this.regEAX);
};

/**
 * op=0x41 (INC [E]CX)
 *
 * @this {CPUx86}
 */
X86.opINCCX = function()
{
    this.regECX = X86.helpINCreg.call(this, this.regECX);
};

/**
 * op=0x42 (INC [E]DX)
 *
 * @this {CPUx86}
 */
X86.opINCDX = function()
{
    this.regEDX = X86.helpINCreg.call(this, this.regEDX);
};

/**
 * op=0x43 (INC [E]BX)
 *
 * @this {CPUx86}
 */
X86.opINCBX = function()
{
    this.regEBX = X86.helpINCreg.call(this, this.regEBX);
};

/**
 * op=0x44 (INC [E]SP)
 *
 * @this {CPUx86}
 */
X86.opINCSP = function()
{
    this.setSP(X86.helpINCreg.call(this, this.getSP()));
};

/**
 * op=0x45 (INC [E]BP)
 *
 * @this {CPUx86}
 */
X86.opINCBP = function()
{
    this.regEBP = X86.helpINCreg.call(this, this.regEBP);
};

/**
 * op=0x46 (INC [E]SI)
 *
 * @this {CPUx86}
 */
X86.opINCSI = function()
{
    this.regESI = X86.helpINCreg.call(this, this.regESI);
};

/**
 * op=0x47 (INC [E]DI)
 *
 * @this {CPUx86}
 */
X86.opINCDI = function()
{
    this.regEDI = X86.helpINCreg.call(this, this.regEDI);
};

/**
 * op=0x48 (DEC [E]AX)
 *
 * @this {CPUx86}
 */
X86.opDECAX = function()
{
    this.regEAX = X86.helpDECreg.call(this, this.regEAX);
};

/**
 * op=0x49 (DEC [E]CX)
 *
 * @this {CPUx86}
 */
X86.opDECCX = function()
{
    this.regECX = X86.helpDECreg.call(this, this.regECX);
};

/**
 * op=0x4A (DEC [E]DX)
 *
 * @this {CPUx86}
 */
X86.opDECDX = function()
{
    this.regEDX = X86.helpDECreg.call(this, this.regEDX);
};

/**
 * op=0x4B (DEC [E]BX)
 *
 * @this {CPUx86}
 */
X86.opDECBX = function()
{
    this.regEBX = X86.helpDECreg.call(this, this.regEBX);
};

/**
 * op=0x4C (DEC [E]SP)
 *
 * @this {CPUx86}
 */
X86.opDECSP = function()
{
    this.setSP(X86.helpDECreg.call(this, this.getSP()));
};

/**
 * op=0x4D (DEC [E]BP)
 *
 * @this {CPUx86}
 */
X86.opDECBP = function()
{
    this.regEBP = X86.helpDECreg.call(this, this.regEBP);
};

/**
 * op=0x4E (DEC [E]SI)
 *
 * @this {CPUx86}
 */
X86.opDECSI = function()
{
    this.regESI = X86.helpDECreg.call(this, this.regESI);
};

/**`
 * op=0x4F (DEC [E]DI)
 *
 * @this {CPUx86}
 */
X86.opDECDI = function()
{
    this.regEDI = X86.helpDECreg.call(this, this.regEDI);
};

/**
 * op=0x50 (PUSH [E]AX)
 *
 * @this {CPUx86}
 */
X86.opPUSHAX = function()
{
    if (BACKTRACK) {
        this.backTrack.btiMem0 = this.backTrack.btiAL; this.backTrack.btiMem1 = this.backTrack.btiAH;
    }
    this.pushWord(this.regEAX & this.maskData);
    this.nStepCycles -= this.cycleCounts.nOpCyclesPushReg;
};

/**
 * op=0x51 (PUSH [E]CX)
 *
 * @this {CPUx86}
 */
X86.opPUSHCX = function()
{
    if (BACKTRACK) {
        this.backTrack.btiMem0 = this.backTrack.btiCL; this.backTrack.btiMem1 = this.backTrack.btiCH;
    }
    this.pushWord(this.regECX & this.maskData);
    this.nStepCycles -= this.cycleCounts.nOpCyclesPushReg;
};

/**
 * op=0x52 (PUSH [E]DX)
 *
 * @this {CPUx86}
 */
X86.opPUSHDX = function()
{
    if (BACKTRACK) {
        this.backTrack.btiMem0 = this.backTrack.btiDL; this.backTrack.btiMem1 = this.backTrack.btiDH;
    }
    this.pushWord(this.regEDX & this.maskData);
    this.nStepCycles -= this.cycleCounts.nOpCyclesPushReg;
};

/**
 * op=0x53 (PUSH [E]BX)
 *
 * @this {CPUx86}
 */
X86.opPUSHBX = function()
{
    if (BACKTRACK) {
        this.backTrack.btiMem0 = this.backTrack.btiBL; this.backTrack.btiMem1 = this.backTrack.btiBH;
    }
    this.pushWord(this.regEBX & this.maskData);
    this.nStepCycles -= this.cycleCounts.nOpCyclesPushReg;
};

/**
 * op=0x54 (PUSH SP)
 *
 * NOTE: Having an accurate implementation of "PUSH SP" for the 8086/8088 isn't just a nice idea, it affects real
 * code.  Case in point: early Microsoft C floating-point libraries relied on "PUSH SP" behavior to quickly determine
 * whether an 8088 (and therefore presumably an 8087) or an 80286 (and presumably an 80287) was being used; eg:
 *
 *      &0910:1E82 D93E1709        FSTCW    WORD [0917]
 *      &0910:1E86 CD3D            INT      3D
 *      &0E4E:06D3 50              PUSH     AX
 *      &0E4E:06D4 B83DA2          MOV      AX,A23D
 *      &0E4E:06D7 EB04            JMP      06DD
 *      &0E4E:06DD 55              PUSH     BP
 *      &0E4E:06DE 1E              PUSH     DS
 *      &0E4E:06DF 56              PUSH     SI
 *      &0E4E:06E0 8BEC            MOV      BP,SP
 *      &0E4E:06E2 C57608          LDS      SI,[BP+08]
 *      &0E4E:06E5 4E              DEC      SI
 *      &0E4E:06E6 4E              DEC      SI
 *      &0E4E:06E7 897608          MOV      [BP+08],SI
 *      &0E4E:06EA 2904            SUB      [SI],AX
 *      &0E4E:06EC 53              PUSH     BX
 *      &0E4E:06ED 33DB            XOR      BX,BX
 *      &0E4E:06EF 54              PUSH     SP          ; beginning of processor check
 *      &0E4E:06F0 58              POP      AX
 *      &0E4E:06F1 3BC4            CMP      AX,SP
 *      &0E4E:06F3 7528            JNZ      071D        ; jump if 8086/8088/80186/80188, no jump if 80286 or later
 *      &0E4E:06F5 8B4001          MOV      AX,[BX+SI+01]
 *      &0E4E:06F8 25FB30          AND      AX,30FB
 *      &0E4E:06FB 3DD930          CMP      AX,30D9
 *      &0E4E:06FE 7507            JNZ      0707
 *      &0E4E:0700 8A4002          MOV      AL,[BX+SI+02]
 *      &0E4E:0703 3CF0            CMP      AL,F0
 *      &0E4E:0705 7216            JC       071D
 *      &0E4E:0707 8B4001          MOV      AX,[BX+SI+01]
 *      &0E4E:070A 25FFFE          AND      AX,FEFF
 *      &0E4E:070D 3DDBE2          CMP      AX,E2DB
 *      &0E4E:0710 740B            JZ       071D
 *      &0E4E:0712 8B4001          MOV      AX,[BX+SI+01]
 *      &0E4E:0715 3DDFE0          CMP      AX,E0DF
 *      &0E4E:0718 7403            JZ       071D
 *      &0E4E:071A C60490          MOV      [SI],90
 *      &0E4E:071D 5B              POP      BX
 *      &0E4E:071E 5E              POP      SI
 *      &0E4E:071F 1F              POP      DS
 *      &0E4E:0720 5D              POP      BP
 *      &0E4E:0721 58              POP      AX
 *      &0E4E:0722 CF              IRET
 *
 * @this {CPUx86}
 */
X86.opPUSHSP_8086 = function()
{
    let w = (this.getSP() - 2) & 0xffff;
    this.pushWord(w);
    this.nStepCycles -= this.cycleCounts.nOpCyclesPushReg;
};

/**
 * op=0x54 (PUSH [E]SP)
 *
 * @this {CPUx86}
 */
X86.opPUSHSP = function()
{
    this.pushWord(this.getSP() & this.maskData);
    this.nStepCycles -= this.cycleCounts.nOpCyclesPushReg;
};

/**
 * op=0x55 (PUSH [E]BP)
 *
 * @this {CPUx86}
 */
X86.opPUSHBP = function()
{
    if (BACKTRACK) {
        this.backTrack.btiMem0 = this.backTrack.btiBPLo; this.backTrack.btiMem1 = this.backTrack.btiBPHi;
    }
    this.pushWord(this.regEBP & this.maskData);
    this.nStepCycles -= this.cycleCounts.nOpCyclesPushReg;
};

/**
 * op=0x56 (PUSH [E]SI)
 *
 * @this {CPUx86}
 */
X86.opPUSHSI = function()
{
    if (BACKTRACK) {
        this.backTrack.btiMem0 = this.backTrack.btiSILo; this.backTrack.btiMem1 = this.backTrack.btiSIHi;
    }
    this.pushWord(this.regESI & this.maskData);
    this.nStepCycles -= this.cycleCounts.nOpCyclesPushReg;
};

/**
 * op=0x57 (PUSH [E]DI)
 *
 * @this {CPUx86}
 */
X86.opPUSHDI = function()
{
    if (BACKTRACK) {
        this.backTrack.btiMem0 = this.backTrack.btiDILo; this.backTrack.btiMem1 = this.backTrack.btiDIHi;
    }
    this.pushWord(this.regEDI & this.maskData);
    this.nStepCycles -= this.cycleCounts.nOpCyclesPushReg;
};

/**
 * op=0x58 (POP [E]AX)
 *
 * @this {CPUx86}
 */
X86.opPOPAX = function()
{
    this.regEAX = (this.regEAX & ~this.maskData) | this.popWord();
    if (BACKTRACK) {
        this.backTrack.btiAL = this.backTrack.btiMem0; this.backTrack.btiAH = this.backTrack.btiMem1;
    }
    this.nStepCycles -= this.cycleCounts.nOpCyclesPopReg;
};

/**
 * op=0x59 (POP [E]CX)
 *
 * @this {CPUx86}
 */
X86.opPOPCX = function()
{
    this.regECX = (this.regECX & ~this.maskData) | this.popWord();
    if (BACKTRACK) {
        this.backTrack.btiCL = this.backTrack.btiMem0; this.backTrack.btiCH = this.backTrack.btiMem1;
    }
    this.nStepCycles -= this.cycleCounts.nOpCyclesPopReg;
};

/**
 * op=0x5A (POP [E]DX)
 *
 * @this {CPUx86}
 */
X86.opPOPDX = function()
{
    this.regEDX = (this.regEDX & ~this.maskData) | this.popWord();
    if (BACKTRACK) {
        this.backTrack.btiDL = this.backTrack.btiMem0; this.backTrack.btiDH = this.backTrack.btiMem1;
    }
    this.nStepCycles -= this.cycleCounts.nOpCyclesPopReg;
};

/**
 * op=0x5B (POP [E]BX)
 *
 * @this {CPUx86}
 */
X86.opPOPBX = function()
{
    this.regEBX = (this.regEBX & ~this.maskData) | this.popWord();
    if (BACKTRACK) {
        this.backTrack.btiBL = this.backTrack.btiMem0; this.backTrack.btiBH = this.backTrack.btiMem1;
    }
    this.nStepCycles -= this.cycleCounts.nOpCyclesPopReg;
};

/**
 * op=0x5C (POP [E]SP)
 *
 * @this {CPUx86}
 */
X86.opPOPSP = function()
{
    this.setSP((this.getSP() & ~this.maskData) | this.popWord());
    this.nStepCycles -= this.cycleCounts.nOpCyclesPopReg;
};

/**
 * op=0x5D (POP [E]BP)
 *
 * @this {CPUx86}
 */
X86.opPOPBP = function()
{
    this.regEBP = (this.regEBP & ~this.maskData) | this.popWord();
    if (BACKTRACK) {
        this.backTrack.btiBPLo = this.backTrack.btiMem0; this.backTrack.btiBPHi = this.backTrack.btiMem1;
    }
    this.nStepCycles -= this.cycleCounts.nOpCyclesPopReg;
};

/**
 * op=0x5E (POP [E]SI)
 *
 * @this {CPUx86}
 */
X86.opPOPSI = function()
{
    this.regESI = (this.regESI & ~this.maskData) | this.popWord();
    if (BACKTRACK) {
        this.backTrack.btiSILo = this.backTrack.btiMem0; this.backTrack.btiSIHi = this.backTrack.btiMem1;
    }
    this.nStepCycles -= this.cycleCounts.nOpCyclesPopReg;
};

/**
 * op=0x5F (POP [E]DI)
 *
 * @this {CPUx86}
 */
X86.opPOPDI = function()
{
    this.regEDI = (this.regEDI & ~this.maskData) | this.popWord();
    if (BACKTRACK) {
        this.backTrack.btiDILo = this.backTrack.btiMem0; this.backTrack.btiDIHi = this.backTrack.btiMem1;
    }
    this.nStepCycles -= this.cycleCounts.nOpCyclesPopReg;
};

/**
 * op=0x60 (PUSHA) (80186/80188 and up)
 *
 * @this {CPUx86}
 */
X86.opPUSHA = function()
{
    /**
     * Any operation that performs multiple stack modifications must snapshot regLSP first.
     */
    this.opLSP = this.regLSP;

    /**
     * TODO: regLSP needs to be pre-bounds-checked against regLSPLimitLow
     */
    let temp = this.getSP() & this.maskData;
    if (BACKTRACK) {
        this.backTrack.btiMem0 = this.backTrack.btiAL; this.backTrack.btiMem1 = this.backTrack.btiAH;
    }
    this.pushWord(this.regEAX & this.maskData);
    if (BACKTRACK) {
        this.backTrack.btiMem0 = this.backTrack.btiCL; this.backTrack.btiMem1 = this.backTrack.btiCH;
    }
    this.pushWord(this.regECX & this.maskData);
    if (BACKTRACK) {
        this.backTrack.btiMem0 = this.backTrack.btiDL; this.backTrack.btiMem1 = this.backTrack.btiDH;
    }
    this.pushWord(this.regEDX & this.maskData);
    if (BACKTRACK) {
        this.backTrack.btiMem0 = this.backTrack.btiBL; this.backTrack.btiMem1 = this.backTrack.btiBH;
    }
    this.pushWord(this.regEBX & this.maskData);
    this.pushWord(temp);
    if (BACKTRACK) {
        this.backTrack.btiMem0 = this.backTrack.btiBPLo; this.backTrack.btiMem1 = this.backTrack.btiBPHi;
    }
    this.pushWord(this.regEBP & this.maskData);
    if (BACKTRACK) {
        this.backTrack.btiMem0 = this.backTrack.btiSILo; this.backTrack.btiMem1 = this.backTrack.btiSIHi;
    }
    this.pushWord(this.regESI & this.maskData);
    if (BACKTRACK) {
        this.backTrack.btiMem0 = this.backTrack.btiDILo; this.backTrack.btiMem1 = this.backTrack.btiDIHi;
    }
    this.pushWord(this.regEDI & this.maskData);
    this.nStepCycles -= this.cycleCounts.nOpCyclesPushAll;

    this.opLSP = X86.ADDR_INVALID;
};

/**
 * op=0x61 (POPA) (80186/80188 and up)
 *
 * @this {CPUx86}
 */
X86.opPOPA = function()
{
    /**
     * Any operation that performs multiple stack modifications must snapshot regLSP first.
     */
    this.opLSP = this.regLSP;

    this.regEDI = (this.regEDI & ~this.maskData) | this.popWord();
    if (BACKTRACK) {
        this.backTrack.btiDILo = this.backTrack.btiMem0; this.backTrack.btiDIHi = this.backTrack.btiMem1;
    }
    this.regESI = (this.regESI & ~this.maskData) | this.popWord();
    if (BACKTRACK) {
        this.backTrack.btiSILo = this.backTrack.btiMem0; this.backTrack.btiSIHi = this.backTrack.btiMem1;
    }
    this.regEBP = (this.regEBP & ~this.maskData) | this.popWord();
    if (BACKTRACK) {
        this.backTrack.btiBPLo = this.backTrack.btiMem0; this.backTrack.btiBPHi = this.backTrack.btiMem1;
    }
    /**
     * TODO: regLSP needs to be pre-bounds-checked against regLSPLimit at the start
     */
    this.setSP(this.getSP() + this.sizeData);
    // this.regLSP += (I386? this.sizeData : 2);
    this.regEBX = (this.regEBX & ~this.maskData) | this.popWord();
    if (BACKTRACK) {
        this.backTrack.btiBL = this.backTrack.btiMem0; this.backTrack.btiBH = this.backTrack.btiMem1;
    }
    this.regEDX = (this.regEDX & ~this.maskData) | this.popWord();
    if (BACKTRACK) {
        this.backTrack.btiDL = this.backTrack.btiMem0; this.backTrack.btiDH = this.backTrack.btiMem1;
    }
    this.regECX = (this.regECX & ~this.maskData) | this.popWord();
    if (BACKTRACK) {
        this.backTrack.btiCL = this.backTrack.btiMem0; this.backTrack.btiCH = this.backTrack.btiMem1;
    }
    this.regEAX = (this.regEAX & ~this.maskData) | this.popWord();
    if (BACKTRACK) {
        this.backTrack.btiAL = this.backTrack.btiMem0; this.backTrack.btiAH = this.backTrack.btiMem1;
    }
    this.nStepCycles -= this.cycleCounts.nOpCyclesPopAll;

    this.opLSP = X86.ADDR_INVALID;
};

/**
 * op=0x62 (BOUND reg,word) (80186/80188 and up)
 *
 * @this {CPUx86}
 */
X86.opBOUND = function()
{
    this.decodeModRegWord.call(this, X86.fnBOUND);
};

/**
 * op=0x63 (ARPL word,reg) (80286 and up)
 *
 * @this {CPUx86}
 */
X86.opARPL = function()
{
    /**
     * ARPL is one of several protected-mode instructions that are meaningless and not allowed in either real-mode
     * or V86-mode; others include LAR, LSL, VERR and VERW.  More meaningful but potentially harmful protected-mode
     * instructions that ARE allowed in real-mode but NOT in V86-mode include LIDT, LGDT, LMSW, CLTS, HLT, and
     * control register MOV instructions.
     *
     * ARPL is somewhat more noteworthy because enhanced-mode Windows (going back to at least Windows 3.00, and
     * possibly even the earliest versions of Windows/386) selected the ARPL opcode as a controlled means of exiting
     * V86-mode via the UD_FAULT exception.  Windows would use the same ARPL for all controlled exits, using different
     * segment:offset pointers to the ARPL to differentiate them.  ARPL was probably chosen because it could trigger
     * a UD_FAULT with a single byte (0x63); any subsequent address bytes would be irrelevant.
     *
     * Which is WHY we must perform the CPU mode tests below rather than in the fnARPL() worker; otherwise we could
     * generate additional (bogus) faults, based on the address of the first operand.
     *
     * TODO: You may have noticed that setProtMode() already swaps out a 0x0F opcode dispatch table for another based
     * on the mode, because none of the "GRP6" 0x0F opcodes (eg, SLDT, STR, LLDT, LTR, VERR and VERW) are allowed in
     * real-mode, and it was easy to swap all those handlers in/out with a single update.  We've extended that particular
     * swap to include V86-mode as well, but we might want to consider swapping out more opcode handlers in a similar
     * fashion, instead of using these in-line mode tests.
     */
    if (!(this.regCR0 & X86.CR0.MSW.PE) || I386 && (this.regPS & X86.PS.VM)) {
        X86.opInvalid.call(this);
        return;
    }
    this.decodeModMemWord.call(this, X86.fnARPL);
};

/**
 * op=0x64 (FS:)
 *
 * @this {CPUx86}
 */
X86.opFS = function()
{
    this.opFlags |= X86.OPFLAG.SEG | X86.OPFLAG.NOINTR;
    this.segData = this.segStack = this.segFS;
    this.nStepCycles -= this.cycleCounts.nOpCyclesPrefix;
};

/**
 * op=0x65 (GS:)
 *
 * @this {CPUx86}
 */
X86.opGS = function()
{
    this.opFlags |= X86.OPFLAG.SEG | X86.OPFLAG.NOINTR;
    this.segData = this.segStack = this.segGS;
    this.nStepCycles -= this.cycleCounts.nOpCyclesPrefix;
};

/**
 * op=0x66 (OS:) (80386 and up)
 *
 * TODO: Review other effective operand-size criteria, cycle count, etc.
 *
 * @this {CPUx86}
 */
X86.opOS = function()
{
    if (I386) {
        /**
         * See opAS() for a discussion of multiple prefixes, which applies equally to both
         * operand-size and address-size prefixes.
         *
         * The simple fix here is to skip the bulk of the operation if the prefix is redundant.
         */
        this.opFlags |= X86.OPFLAG.DATASIZE;
        if (!(this.opPrefixes & X86.OPFLAG.DATASIZE)) {
            this.sizeData ^= 0x6;               // that which is 2 shall become 4, and vice versa
            this.maskData ^= (0xffff0000|0);    // that which is 0x0000ffff shall become 0xffffffff, and vice versa
            this.updateDataSize();
        }
        this.nStepCycles -= this.cycleCounts.nOpCyclesPrefix;
    }
};

/**
 * op=0x67 (AS:) (80386 and up)
 *
 * TODO: Review other effective address-size criteria, cycle count, etc.
 *
 * @this {CPUx86}
 */
X86.opAS = function()
{
    if (I386) {
        /**
         * Live and learn: multiple address-size prefixes can and do occur on a single instruction,
         * and contrary to my original assumption that the prefixes act independently, they do not.
         * During Windows 95 SETUP, the following instruction is executed:
         *
         *      06AF:1B4D 67672E          CS:
         *      06AF:1B50 FFA25A1B        JMP      [BP+SI+1B5A]
         *
         * which is in fact:
         *
         *      06AF:1B4D 67672E          CS:
         *      06AF:1B50 FFA25A1B0000    JMP      [EDX+00001B5A]
         *
         * The other interesting question is: why/how did this instruction get encoded that way?
         * All I can say is, there were no explicit prefixes in the source (BSG.ASM), so we'll chalk
         * it up to a glitch in MASM.
         *
         * The simple fix here is to skip the bulk of the operation if the prefix is redundant.
         */
        this.opFlags |= X86.OPFLAG.ADDRSIZE;
        if (!(this.opPrefixes & X86.OPFLAG.ADDRSIZE)) {
            this.sizeAddr ^= 0x06;              // that which is 2 shall become 4, and vice versa
            this.maskAddr ^= (0xffff0000|0);    // that which is 0x0000ffff shall become 0xffffffff, and vice versa
            this.updateAddrSize();
        }
        this.nStepCycles -= this.cycleCounts.nOpCyclesPrefix;
    }
};

/**
 * op=0x68 (PUSH imm) (80186/80188 and up)
 *
 * @this {CPUx86}
 */
X86.opPUSHn = function()
{
    this.pushWord(this.getIPWord());
    this.nStepCycles -= this.cycleCounts.nOpCyclesPushReg;
};

/**
 * op=0x69 (IMUL reg,word,imm) (80186/80188 and up)
 *
 * @this {CPUx86}
 */
X86.opIMULn = function()
{
    this.decodeModRegWord.call(this, X86.fnIMULn);
};

/**
 * op=0x6A (PUSH imm8) (80186/80188 and up)
 *
 * @this {CPUx86}
 */
X86.opPUSH8 = function()
{
    if (BACKTRACK) this.backTrack.btiMem1 = 0;
    this.pushWord(this.getIPDisp());
    this.nStepCycles -= this.cycleCounts.nOpCyclesPushReg;
};

/**
 * op=0x6B (IMUL reg,word,imm8) (80186/80188 and up)
 *
 * @this {CPUx86}
 */
X86.opIMUL8 = function()
{
    this.decodeModRegWord.call(this, X86.fnIMUL8);
};

/**
 * op=0x6C (INSB) (80186/80188 and up)
 *
 * NOTE: Segment overrides are ignored for this instruction, so we must use segES instead of segData.
 *
 * @this {CPUx86}
 */
X86.opINSb = function()
{
    let nReps = 1;
    let nDelta = 0;
    let maskAddr = this.maskAddr;

    /**
     * NOTE: 5 + 4n is the cycle time for the 80286; the 80186/80188 has different values: 14 cycles for
     * an unrepeated INS, and 8 + 8n for a repeated INS.  However, accurate cycle times for the 80186/80188 is
     * low priority.
     */
    let nCycles = 5;

    /**
     * The (normal) REP prefix, if used, is REPNZ (0xf2), but either one works....
     */
    if (this.opPrefixes & (X86.OPFLAG.REPZ | X86.OPFLAG.REPNZ)) {
        nReps = this.regECX & maskAddr;
        nDelta = 1;
        if (this.opPrefixes & X86.OPFLAG.REPEAT) nCycles = 4;
    }

    if (nReps--) {
        let port = this.regEDX & 0xffff;
        if (!this.checkIOPM(port, 1, true)) return;
        let b = this.bus.checkPortInputNotify(port, 1, this.regLIP - nDelta - 1);
        this.setSOByte(this.segES, this.regEDI & maskAddr, b);
        /**
         * helpFault() throws exceptions now, so inline checks of X86.OPFLAG.FAULT should no longer be necessary.
         *
         *      if (this.opFlags & X86.OPFLAG.FAULT) return;
         */
        if (BACKTRACK) this.backTrack.btiMem0 = this.backTrack.btiIO;
        this.regEDI = (this.regEDI & ~maskAddr) | ((this.regEDI + ((this.regPS & X86.PS.DF)? -1 : 1)) & maskAddr);
        this.regECX = (this.regECX & ~maskAddr) | ((this.regECX - nDelta) & maskAddr);
        this.nStepCycles -= nCycles;
        if (nReps) this.rewindIP();
    }
};

/**
 * op=0x6D (INSW) (80186/80188 and up)
 *
 * NOTE: Segment overrides are ignored for this instruction, so we must use segDS instead of segData.
 *
 * @this {CPUx86}
 */
X86.opINSw = function()
{
    let nReps = 1;
    let nDelta = 0;
    let maskAddr = this.maskAddr;

    /**
     * NOTE: 5 + 4n is the cycle time for the 80286; the 80186/80188 has different values: 14 cycles for
     * an unrepeated INS, and 8 + 8n for a repeated INS.  However, accurate cycle times for the 80186/80188 is
     * low priority.
     */
    let nCycles = 5;

    /**
     * The (normal) REP prefix, if used, is REPNZ (0xf2), but either one works....
     */
    if (this.opPrefixes & (X86.OPFLAG.REPZ | X86.OPFLAG.REPNZ)) {
        nReps = this.regECX & maskAddr;
        nDelta = 1;
        if (this.opPrefixes & X86.OPFLAG.REPEAT) nCycles = 4;
    }
    if (nReps--) {
        let port = this.regEDX & 0xffff;
        if (!this.checkIOPM(port, this.sizeData, true)) return;
        let w = this.bus.checkPortInputNotify(port, this.sizeData, this.regLIP - nDelta - 1);
        if (BACKTRACK) {
            this.backTrack.btiMem0 = this.backTrack.btiIO;
            this.backTrack.btiMem1 = this.backTrack.btiIO;
        }
        this.setSOWord(this.segES, this.regEDI & maskAddr, w);
        /**
         * helpFault() throws exceptions now, so inline checks of X86.OPFLAG.FAULT should no longer be necessary.
         *
         *      if (this.opFlags & X86.OPFLAG.FAULT) return;
         */
        this.regEDI = (this.regEDI & ~maskAddr) | ((this.regEDI + ((this.regPS & X86.PS.DF)? -this.sizeData : this.sizeData)) & maskAddr);
        this.regECX = (this.regECX & ~maskAddr) | ((this.regECX - nDelta) & maskAddr);
        this.nStepCycles -= nCycles;
        if (nReps) this.rewindIP();
    }
};

/**
 * op=0x6E (OUTSB) (80186/80188 and up)
 *
 * NOTE: Segment overrides are ignored for this instruction, so we must use segDS instead of segData.
 *
 * @this {CPUx86}
 */
X86.opOUTSb = function()
{
    let nReps = 1;
    let nDelta = 0;
    let maskAddr = this.maskAddr;

    /**
     * NOTE: 5 + 4n is the cycle time for the 80286; the 80186/80188 has different values: 14 cycles for
     * an unrepeated INS, and 8 + 8n for a repeated INS.  TODO: Fix this someday.
     */
    let nCycles = 5;

    /**
     * The (normal) REP prefix, if used, is REPNZ (0xf2), but either one works....
     */
    if (this.opPrefixes & (X86.OPFLAG.REPZ | X86.OPFLAG.REPNZ)) {
        nReps = this.regECX & maskAddr;
        nDelta = 1;
        if (this.opPrefixes & X86.OPFLAG.REPEAT) nCycles = 4;
    }
    if (nReps--) {
        let port = this.regEDX & 0xffff;
        if (!this.checkIOPM(port, 1, false)) return;
        let b = this.getSOByte(this.segDS, this.regESI & maskAddr);
        /**
         * helpFault() throws exceptions now, so inline checks of X86.OPFLAG.FAULT should no longer be necessary.
         *
         *      if (this.opFlags & X86.OPFLAG.FAULT) return;
         */
        if (BACKTRACK) this.backTrack.btiIO = this.backTrack.btiMem0;
        this.bus.checkPortOutputNotify(port, 1, b, this.regLIP - nDelta - 1);
        this.regESI = (this.regESI & ~maskAddr) | ((this.regESI + ((this.regPS & X86.PS.DF)? -1 : 1)) & maskAddr);
        this.regECX = (this.regECX & ~maskAddr) | ((this.regECX - nDelta) & maskAddr);
        this.nStepCycles -= nCycles;
        if (nReps) this.rewindIP();
    }
};

/**
 * op=0x6F (OUTSW) (80186/80188 and up)
 *
 * NOTE: Segment overrides are ignored for this instruction, so we must use segDS instead of segData.
 *
 * @this {CPUx86}
 */
X86.opOUTSw = function()
{
    let nReps = 1;
    let nDelta = 0;
    let maskAddr = this.maskAddr;

    /**
     * NOTE: 5 + 4n is the cycle time for the 80286; the 80186/80188 has different values: 14 cycles for
     * an unrepeated INS, and 8 + 8n for a repeated INS.  TODO: Fix this someday.
     */
    let nCycles = 5;

    /**
     * The (normal) REP prefix, if used, is REPNZ (0xf2), but either one works....
     */
    if (this.opPrefixes & (X86.OPFLAG.REPZ | X86.OPFLAG.REPNZ)) {
        nReps = this.regECX & maskAddr;
        nDelta = 1;
        if (this.opPrefixes & X86.OPFLAG.REPEAT) nCycles = 4;
    }
    if (nReps--) {
        let w = this.getSOWord(this.segDS, this.regESI & maskAddr);
        /**
         * helpFault() throws exceptions now, so inline checks of X86.OPFLAG.FAULT should no longer be necessary.
         *
         *      if (this.opFlags & X86.OPFLAG.FAULT) return;
         */
        let port = this.regEDX & 0xffff;
        if (!this.checkIOPM(port, this.sizeData, false)) return;
        if (BACKTRACK) {
            this.backTrack.btiIO = this.backTrack.btiMem0;
            this.backTrack.btiIO = this.backTrack.btiMem1;
        }
        this.bus.checkPortOutputNotify(port, this.sizeData, w, this.regLIP - nDelta - 1);
        this.regESI = (this.regESI & ~maskAddr) | ((this.regESI + ((this.regPS & X86.PS.DF)? -this.sizeData : this.sizeData)) & maskAddr);
        this.regECX = (this.regECX & ~maskAddr) | ((this.regECX - nDelta) & maskAddr);
        this.nStepCycles -= nCycles;
        if (nReps) this.rewindIP();
    }
};

/**
 * op=0x70 (JO disp)
 *
 * @this {CPUx86}
 */
X86.opJO = function()
{
    let disp = this.getIPDisp();
    if (this.getOF()) {
        this.setIP(this.getIP() + disp);
        this.nStepCycles -= this.cycleCounts.nOpCyclesJmpC;
        return;
    }
    this.nStepCycles -= this.cycleCounts.nOpCyclesJmpCFall;
};

/**
 * op=0x71 (JNO disp)
 *
 * @this {CPUx86}
 */
X86.opJNO = function()
{
    let disp = this.getIPDisp();
    if (!this.getOF()) {
        this.setIP(this.getIP() + disp);
        this.nStepCycles -= this.cycleCounts.nOpCyclesJmpC;
        return;
    }
    this.nStepCycles -= this.cycleCounts.nOpCyclesJmpCFall;
};

/**
 * op=0x72 (JC disp, aka JB disp)
 *
 * @this {CPUx86}
 */
X86.opJC = function()
{
    let disp = this.getIPDisp();
    if (this.getCF()) {
        this.setIP(this.getIP() + disp);
        this.nStepCycles -= this.cycleCounts.nOpCyclesJmpC;
        return;
    }
    this.nStepCycles -= this.cycleCounts.nOpCyclesJmpCFall;
};

/**
 * op=0x73 (JNC disp, aka JAE disp)
 *
 * @this {CPUx86}
 */
X86.opJNC = function()
{
    let disp = this.getIPDisp();
    if (!this.getCF()) {
        this.setIP(this.getIP() + disp);
        this.nStepCycles -= this.cycleCounts.nOpCyclesJmpC;
        return;
    }
    this.nStepCycles -= this.cycleCounts.nOpCyclesJmpCFall;
};

/**
 * op=0x74 (JZ disp)
 *
 * @this {CPUx86}
 */
X86.opJZ = function()
{
    let disp = this.getIPDisp();
    if (this.getZF()) {
        this.setIP(this.getIP() + disp);
        this.nStepCycles -= this.cycleCounts.nOpCyclesJmpC;
        return;
    }
    this.nStepCycles -= this.cycleCounts.nOpCyclesJmpCFall;
};

/**
 * op=0x75 (JNZ disp)
 *
 * @this {CPUx86}
 */
X86.opJNZ = function()
{
    let disp = this.getIPDisp();
    if (!this.getZF()) {
        this.setIP(this.getIP() + disp);
        this.nStepCycles -= this.cycleCounts.nOpCyclesJmpC;
        return;
    }
    this.nStepCycles -= this.cycleCounts.nOpCyclesJmpCFall;
};

/**
 * op=0x76 (JBE disp)
 *
 * @this {CPUx86}
 */
X86.opJBE = function()
{
    let disp = this.getIPDisp();
    if (this.getCF() || this.getZF()) {
        this.setIP(this.getIP() + disp);
        this.nStepCycles -= this.cycleCounts.nOpCyclesJmpC;
        return;
    }
    this.nStepCycles -= this.cycleCounts.nOpCyclesJmpCFall;
};

/**
 * op=0x77 (JNBE disp, JA disp)
 *
 * @this {CPUx86}
 */
X86.opJNBE = function()
{
    let disp = this.getIPDisp();
    if (!this.getCF() && !this.getZF()) {
        this.setIP(this.getIP() + disp);
        this.nStepCycles -= this.cycleCounts.nOpCyclesJmpC;
        return;
    }
    this.nStepCycles -= this.cycleCounts.nOpCyclesJmpCFall;
};

/**
 * op=0x78 (JS disp)
 *
 * @this {CPUx86}
 */
X86.opJS = function()
{
    let disp = this.getIPDisp();
    if (this.getSF()) {
        this.setIP(this.getIP() + disp);
        this.nStepCycles -= this.cycleCounts.nOpCyclesJmpC;
        return;
    }
    this.nStepCycles -= this.cycleCounts.nOpCyclesJmpCFall;
};

/**
 * op=0x79 (JNS disp)
 *
 * @this {CPUx86}
 */
X86.opJNS = function()
{
    let disp = this.getIPDisp();
    if (!this.getSF()) {
        this.setIP(this.getIP() + disp);
        this.nStepCycles -= this.cycleCounts.nOpCyclesJmpC;
        return;
    }
    this.nStepCycles -= this.cycleCounts.nOpCyclesJmpCFall;
};

/**
 * op=0x7A (JP disp)
 *
 * @this {CPUx86}
 */
X86.opJP = function()
{
    let disp = this.getIPDisp();
    if (this.getPF()) {
        this.setIP(this.getIP() + disp);
        this.nStepCycles -= this.cycleCounts.nOpCyclesJmpC;
        return;
    }
    this.nStepCycles -= this.cycleCounts.nOpCyclesJmpCFall;
};

/**
 * op=0x7B (JNP disp)
 *
 * @this {CPUx86}
 */
X86.opJNP = function()
{
    let disp = this.getIPDisp();
    if (!this.getPF()) {
        this.setIP(this.getIP() + disp);
        this.nStepCycles -= this.cycleCounts.nOpCyclesJmpC;
        return;
    }
    this.nStepCycles -= this.cycleCounts.nOpCyclesJmpCFall;
};

/**
 * op=0x7C (JL disp)
 *
 * @this {CPUx86}
 */
X86.opJL = function()
{
    let disp = this.getIPDisp();
    if (!this.getSF() != !this.getOF()) {
        this.setIP(this.getIP() + disp);
        this.nStepCycles -= this.cycleCounts.nOpCyclesJmpC;
        return;
    }
    this.nStepCycles -= this.cycleCounts.nOpCyclesJmpCFall;
};

/**
 * op=0x7D (JNL disp, aka JGE disp)
 *
 * @this {CPUx86}
 */
X86.opJNL = function()
{
    let disp = this.getIPDisp();
    if (!this.getSF() == !this.getOF()) {
        this.setIP(this.getIP() + disp);
        this.nStepCycles -= this.cycleCounts.nOpCyclesJmpC;
        return;
    }
    this.nStepCycles -= this.cycleCounts.nOpCyclesJmpCFall;
};

/**
 * op=0x7E (JLE disp)
 *
 * @this {CPUx86}
 */
X86.opJLE = function()
{
    let disp = this.getIPDisp();
    if (this.getZF() || !this.getSF() != !this.getOF()) {
        this.setIP(this.getIP() + disp);
        this.nStepCycles -= this.cycleCounts.nOpCyclesJmpC;
        return;
    }
    this.nStepCycles -= this.cycleCounts.nOpCyclesJmpCFall;
};

/**
 * op=0x7F (JNLE disp, aka JG disp)
 *
 * @this {CPUx86}
 */
X86.opJNLE = function()
{
    let disp = this.getIPDisp();
    if (!this.getZF() && !this.getSF() == !this.getOF()) {
        this.setIP(this.getIP() + disp);
        this.nStepCycles -= this.cycleCounts.nOpCyclesJmpC;
        return;
    }
    this.nStepCycles -= this.cycleCounts.nOpCyclesJmpCFall;
};

/**
 * op=0x80/0x82 (GRP1 byte,imm8)
 *
 * @this {CPUx86}
 */
X86.opGRP1b = function()
{
    this.decodeModGrpByte.call(this, X86.aOpGrp1b, this.getIPByte);
    this.nStepCycles -= (this.regEAWrite === X86.ADDR_INVALID? 1 : this.cycleCounts.nOpCyclesArithMID);
};

/**
 * op=0x81 (GRP1 word,imm)
 *
 * @this {CPUx86}
 */
X86.opGRP1w = function()
{
    this.decodeModGrpWord.call(this, X86.aOpGrp1w, this.getIPWord);
    this.nStepCycles -= (this.regEAWrite === X86.ADDR_INVALID? 1 : this.cycleCounts.nOpCyclesArithMID);
};

/**
 * op=0x83 (GRP1 word,disp)
 *
 * WARNING: This passes getIPDisp() as the fnSrc parameter, which returns a 32-bit signed value,
 * so the worker functions (ie, the functions listed in aOpGrp1w[]) MUST mask their result with maskData,
 * to avoid setting bits beyond the current operand size.
 *
 * @this {CPUx86}
 */
X86.opGRP1sw = function()
{
    this.decodeModGrpWord.call(this, X86.aOpGrp1w, this.getIPDisp);
    this.nStepCycles -= (this.regEAWrite === X86.ADDR_INVALID? 1 : this.cycleCounts.nOpCyclesArithMID);
};

/**
 * op=0x84 (TEST reg,byte)
 *
 * @this {CPUx86}
 */
X86.opTESTrb = function()
{
    this.decodeModMemByte.call(this, X86.fnTESTb);
};

/**
 * op=0x85 (TEST reg,word)
 *
 * @this {CPUx86}
 */
X86.opTESTrw = function()
{
    this.decodeModMemWord.call(this, X86.fnTESTw);
};

/**
 * op=0x86 (XCHG reg,byte)
 *
 * NOTE: The XCHG instruction is unique in that both src and dst are both read and written;
 * see fnXCHGrb() for how we deal with this special case.
 *
 * @this {CPUx86}
 */
X86.opXCHGrb = function()
{
    /**
     * If the second operand is a register, then the ModRegByte decoder must use separate "get" and
     * "set" assignments, otherwise instructions like "XCHG DH,DL" will end up using a stale DL instead of
     * the updated DL.
     *
     * To be clear, a single assignment like this will fail:
     *
     *      opModRegByteF2: function(fn)
     *      {
     *          this.regEDX = (this.regEDX & 0xff) | (fn.call(this, this.regEDX >> 8, this.regEDX & 0xff) << 8);
     *      }
     *
     * which is why all affected decoders now use separate assignments; eg:
     *
     *      opModRegByteF2: function(fn)
     *      {
     *          let b = fn.call(this, this.regEDX >> 8, this.regEDX & 0xff);
     *          this.regEDX = (this.regEDX & 0xff) | (b << 8);
     *      }
     */
    this.decodeModRegByte.call(this, X86.fnXCHGrb);
};

/**
 * op=0x87 (XCHG reg,word)
 *
 * NOTE: The XCHG instruction is unique in that both src and dst are both read and written;
 * see fnXCHGrw() for how we deal with this special case.
 *
 * @this {CPUx86}
 */
X86.opXCHGrw = function()
{
    this.decodeModRegWord.call(this, X86.fnXCHGrw);
};

/**
 * op=0x88 (MOV byte,reg)
 *
 * @this {CPUx86}
 */
X86.opMOVmb = function()
{
    /**
     * Like other MOV operations, the destination does not need to be read, just written.
     */
    this.opFlags |= X86.OPFLAG.NOREAD;
    this.decodeModMemByte.call(this, X86.fnMOV);
};

/**
 * op=0x89 (MOV word,reg)
 *
 * @this {CPUx86}
 */
X86.opMOVmw = function()
{
    /**
     * Like other MOV operations, the destination does not need to be read, just written.
     */
    this.opFlags |= X86.OPFLAG.NOREAD;
    this.decodeModMemWord.call(this, X86.fnMOV);
};

/**
 * op=0x8A (MOV reg,byte)
 *
 * @this {CPUx86}
 */
X86.opMOVrb = function()
{
    this.decodeModRegByte.call(this, X86.fnMOV);
};

/**
 * op=0x8B (MOV reg,word)
 *
 * @this {CPUx86}
 */
X86.opMOVrw = function()
{
    this.decodeModRegWord.call(this, X86.fnMOV);
};

/**
 * op=0x8C (MOV word,sreg)
 *
 * NOTE: Since the ModRM decoders deal only with general-purpose registers, we rely on our helper
 * function (fnMOVwsr) to select the appropriate segment register and replace the decoder's src operand.
 *
 * @this {CPUx86}
 */
X86.opMOVwsr = function()
{
    /**
     * Like other MOV operations, the destination does not need to be read, just written.
     */
    this.opFlags |= X86.OPFLAG.NOREAD;
    this.decodeModMemWord.call(this, X86.fnMOVwsr);
};

/**
 * op=0x8D (LEA reg,word)
 *
 * @this {CPUx86}
 */
X86.opLEA = function()
{
    this.opFlags |= X86.OPFLAG.NOREAD;
    this.segData = this.segStack = this.segNULL;    // we can't have the EA calculation, if any, "polluted" by segment arithmetic
    this.decodeModRegWord.call(this, X86.fnLEA);
};

/**
 * op=0x8E (MOV sreg,word)
 *
 * NOTE: Since the ModRM decoders deal only with general-purpose registers, we rely on our
 * helper function (fnMOVsrw) to make a note of which general-purpose register will be overwritten,
 * so that we can restore it after moving the updated value to the correct segment register.
 *
 * @this {CPUx86}
 */
X86.opMOVsrw = function()
{
    let sel;
    this.decodeModRegWord.call(this, X86.fnMOVsrw);
    switch ((this.bModRM >> 3) & 0x7) {
    case 0x0:
        sel = this.regEAX;
        this.regEAX = this.regXX;
        this.setES(sel);
        break;
    case 0x1:
        sel = this.regECX;
        this.regECX = this.regXX;
        this.setCS(sel);
        break;
    case 0x2:
        sel = this.regEDX;
        this.regEDX = this.regXX;
        this.setSS(sel);
        break;
    case 0x3:
        sel = this.regEBX;
        this.regEBX = this.regXX;
        this.setDS(sel);
        break;
    case 0x4:
        sel = this.getSP();
        this.setSP(this.regXX);
        if (I386 && this.model >= X86.MODEL_80386) {
            this.setFS(sel);
        } else {
            this.setES(sel);
        }
        break;
    case 0x5:
        sel = this.regEBP;
        this.regEBP = this.regXX;
        if (I386 && this.model >= X86.MODEL_80386) {
            this.setGS(sel);
        } else {
            this.setCS(sel);
        }
        break;
    case 0x6:
        sel = this.regESI;
        this.regESI = this.regXX;
        this.setSS(sel);
        break;
    case 0x7:
        sel = this.regEDI;
        this.regEDI = this.regXX;
        this.setDS(sel);
        break;
    }
};

/**
 * op=0x8F (POP word)
 *
 * @this {CPUx86}
 */
X86.opPOPmw = function()
{
    /**
     * Like other MOV operations, the destination does not need to be read, just written.
     */
    this.opFlags |= X86.OPFLAG.NOREAD;

    /**
     * If the word we're about to pop FROM the stack gets popped INTO a not-present page, this
     * instruction will not be restartable unless we snapshot regLSP first.
     */
    this.opLSP = this.regLSP;

    /**
     * A "clever" instruction like this:
     *
     *      #0117:651C 67668F442408    POP      DWORD [ESP+08]
     *
     * pops the DWORD from the top of the stack and places it at ESP+08, where ESP is the value
     * AFTER the pop, not before.  We used to (incorrectly) pass "popWord" as the fnSrc parameter
     * below; we now pop the word first, saving it in regXX, and then pass "helpSRCxx" as fnSrc,
     * which simply returns the contents of regXX.
     *
     * Also, in case you're wondering, fnPUSHw() (in aOpGrp4w) is the complement to this instruction,
     * but it doesn't require a similar work-around, because a push from memory accesses that memory
     * BEFORE the push, which occurs through our normal ModRM processing.
     */
    this.regXX = this.popWord();

    this.decodeModGrpWord.call(this, X86.aOpGrpPOPw, X86.helpSRCxx);

    this.opLSP = X86.ADDR_INVALID;
};

/**
 * op=0x90 (NOP, aka XCHG AX,AX)
 *
 * @this {CPUx86}
 */
X86.opNOP = function()
{
    this.nStepCycles -= 3;                          // this form of XCHG takes 3 cycles on all CPUs
    /**
     * The following exception is not unique to LOCK NOP on the 80386, but it's the only LOCK exception
     * that seems worth worrying about this point.  See opLOCK() for further discussion.
     */
    if (I386 && (this.opPrefixes & X86.OPFLAG.LOCK) && this.model >= X86.MODEL_80386) {
        X86.helpFault.call(this, X86.EXCEPTION.UD_FAULT, 0);
        return;
    }
};

/**
 * op=0x91 (XCHG AX,CX)
 *
 * @this {CPUx86}
 */
X86.opXCHGCX = function()
{
    let temp = this.regEAX;
    this.regEAX = (I386? (this.regEAX & ~this.maskData) | (this.regECX & this.maskData) : this.regECX);
    this.regECX = (I386? (this.regECX & ~this.maskData) | (temp & this.maskData) : temp);
    if (BACKTRACK) {
        temp = this.backTrack.btiAL; this.backTrack.btiAL = this.backTrack.btiCL; this.backTrack.btiCL = temp;
        temp = this.backTrack.btiAH; this.backTrack.btiAH = this.backTrack.btiCH; this.backTrack.btiCH = temp;
    }
    this.nStepCycles -= 3;                          // this form of XCHG takes 3 cycles on all CPUs
};

/**
 * op=0x92 (XCHG AX,DX)
 *
 * @this {CPUx86}
 */
X86.opXCHGDX = function()
{
    let temp = this.regEAX;
    this.regEAX = (I386? (this.regEAX & ~this.maskData) | (this.regEDX & this.maskData) : this.regEDX);
    this.regEDX = (I386? (this.regEDX & ~this.maskData) | (temp & this.maskData) : temp);
    if (BACKTRACK) {
        temp = this.backTrack.btiAL; this.backTrack.btiAL = this.backTrack.btiDL; this.backTrack.btiDL = temp;
        temp = this.backTrack.btiAH; this.backTrack.btiAH = this.backTrack.btiDH; this.backTrack.btiDH = temp;
    }
    this.nStepCycles -= 3;                          // this form of XCHG takes 3 cycles on all CPUs
};

/**
 * op=0x93 (XCHG AX,BX)
 *
 * @this {CPUx86}
 */
X86.opXCHGBX = function()
{
    let temp = this.regEAX;
    this.regEAX = (I386? (this.regEAX & ~this.maskData) | (this.regEBX & this.maskData) : this.regEBX);
    this.regEBX = (I386? (this.regEBX & ~this.maskData) | (temp & this.maskData) : temp);
    if (BACKTRACK) {
        temp = this.backTrack.btiAL; this.backTrack.btiAL = this.backTrack.btiBL; this.backTrack.btiBL = temp;
        temp = this.backTrack.btiAH; this.backTrack.btiAH = this.backTrack.btiBH; this.backTrack.btiBH = temp;
    }
    this.nStepCycles -= 3;                          // this form of XCHG takes 3 cycles on all CPUs
};

/**
 * op=0x94 (XCHG AX,SP)
 *
 * @this {CPUx86}
 */
X86.opXCHGSP = function()
{
    let temp = this.regEAX;
    let regESP = this.getSP();
    this.regEAX = (I386? (this.regEAX & ~this.maskData) | (regESP & this.maskData) : regESP);
    this.setSP((I386? (regESP & ~this.maskData) | (temp & this.maskData) : temp));
    if (BACKTRACK) this.backTrack.btiAL = this.backTrack.btiAH = 0;
    this.nStepCycles -= 3;                          // this form of XCHG takes 3 cycles on all CPUs
};

/**
 * op=0x95 (XCHG AX,BP)
 *
 * @this {CPUx86}
 */
X86.opXCHGBP = function()
{
    let temp = this.regEAX;
    this.regEAX = (I386? (this.regEAX & ~this.maskData) | (this.regEBP & this.maskData) : this.regEBP);
    this.regEBP = (I386? (this.regEBP & ~this.maskData) | (temp & this.maskData) : temp);
    if (BACKTRACK) {
        temp = this.backTrack.btiAL; this.backTrack.btiAL = this.backTrack.btiBPLo; this.backTrack.btiBPLo = temp;
        temp = this.backTrack.btiAH; this.backTrack.btiAH = this.backTrack.btiBPHi; this.backTrack.btiBPHi = temp;
    }
    this.nStepCycles -= 3;                          // this form of XCHG takes 3 cycles on all CPUs
};

/**
 * op=0x96 (XCHG AX,SI)
 *
 * @this {CPUx86}
 */
X86.opXCHGSI = function()
{
    let temp = this.regEAX;
    this.regEAX = (I386? (this.regEAX & ~this.maskData) | (this.regESI & this.maskData) : this.regESI);
    this.regESI = (I386? (this.regESI & ~this.maskData) | (temp & this.maskData) : temp);
    if (BACKTRACK) {
        temp = this.backTrack.btiAL; this.backTrack.btiAL = this.backTrack.btiSILo; this.backTrack.btiSILo = temp;
        temp = this.backTrack.btiAH; this.backTrack.btiAH = this.backTrack.btiSIHi; this.backTrack.btiSIHi = temp;
    }
    this.nStepCycles -= 3;                          // this form of XCHG takes 3 cycles on all CPUs
};

/**
 * op=0x97 (XCHG AX,DI)
 *
 * @this {CPUx86}
 */
X86.opXCHGDI = function()
{
    let temp = this.regEAX;
    this.regEAX = (I386? (this.regEAX & ~this.maskData) | (this.regEDI & this.maskData) : this.regEDI);
    this.regEDI = (I386? (this.regEDI & ~this.maskData) | (temp & this.maskData) : temp);
    if (BACKTRACK) {
        temp = this.backTrack.btiAL; this.backTrack.btiAL = this.backTrack.btiDILo; this.backTrack.btiDILo = temp;
        temp = this.backTrack.btiAH; this.backTrack.btiAH = this.backTrack.btiDIHi; this.backTrack.btiDIHi = temp;
    }
    this.nStepCycles -= 3;                          // this form of XCHG takes 3 cycles on all CPUs
};

/**
 * op=0x98 (CBW/CWDE)
 *
 * NOTE: The 16-bit form (CBW) sign-extends AL into AX, whereas the 32-bit form (CWDE) sign-extends AX into EAX;
 * CWDE is similar to CWD, except that the destination is EAX rather than DX:AX.
 *
 * @this {CPUx86}
 */
X86.opCBW = function()
{
    if (this.sizeData == 2) {   // CBW
        this.regEAX = (this.regEAX & ~0xffff) | (((this.regEAX << 24) >> 24) & 0xffff);
        if (BACKTRACK) this.backTrack.btiAH = this.backTrack.btiAL;
    }
    else {                      // CWDE
        this.regEAX = ((this.regEAX << 16) >> 16);
    }
    this.nStepCycles -= 2;                          // CBW takes 2 cycles on all CPUs through 80286
};

/**
 * op=0x99 (CWD/CDQ)
 *
 * NOTE: The 16-bit form (CWD) sign-extends AX, producing a 32-bit result in DX:AX, while the 32-bit form (CDQ)
 * sign-extends EAX, producing a 64-bit result in EDX:EAX.
 *
 * @this {CPUx86}
 */
X86.opCWD = function()
{
    if (this.sizeData == 2) {   // CWD
        this.regEDX = (this.regEDX & ~0xffff) | ((this.regEAX & 0x8000)? 0xffff : 0);
        if (BACKTRACK) this.backTrack.btiDL = this.backTrack.btiDH = this.backTrack.btiAH;
    }
    else {                      // CDQ
        this.regEDX = (this.regEAX & (0x80000000|0))? -1 : 0;
    }
    this.nStepCycles -= this.cycleCounts.nOpCyclesCWD;
};

/**
 * op=0x9A (CALL seg:off)
 *
 * @this {CPUx86}
 */
X86.opCALLF = function()
{
    X86.helpCALLF.call(this, this.getIPWord(), this.getIPShort());
    this.nStepCycles -= this.cycleCounts.nOpCyclesCallF;
};

/**
 * op=0x9B (WAIT)
 *
 * @this {CPUx86}
 */
X86.opWAIT = function()
{
    if (!this.fpu || !this.fpu.opWAIT()) {
        this.nStepCycles -= 3;     // FPUx86.opWAIT() is required to charge some number of cycles if it returns true
    }
};

/**
 * op=0x9C (PUSHF/PUSHFD)
 *
 * @this {CPUx86}
 */
X86.opPUSHF = function()
{
    /**
     * TODO: Consider swapping out this function whenever setProtMode() changes the mode to V86-mode.
     */
    let regPS = this.getPS();
    if (I386) {
        if ((regPS & X86.PS.VM) && this.nIOPL < 3) {
            if (DEBUG) this.printf(MESSAGE.ADDR, "PUSHF in v86-mode (IOPL < 3)\n");
            X86.helpFault.call(this, X86.EXCEPTION.GP_FAULT, 0);
            return;
        }
        /**
         * It doesn't matter whether this is PUSHF or PUSHFD: the VM and RF flags are never pushed, so
         * we should always clear them.  NOTE: This contradicts what the "INTEL 80386 PROGRAMMER'S REFERENCE
         * MANUAL 1986" says on page 81 (which we assume is wrong):
         *
         *      SYSTEMS FLAGS (INCLUDING THE IOPL FIELD, AND THE VM, RF, AND IF FLAGS) ARE PUSHED AND ARE
         *      VISIBLE TO APPLICATIONS PROGRAMS. HOWEVER, WHEN AN APPLICATIONS PROGRAM POPS THE FLAGS,
         *      THESE ITEMS ARE NOT CHANGED, REGARDLESS OF THE VALUES POPPED INTO THEM.
         *
         * This does, however, beg the question: how does code running in V86-mode detect that's in V86-mode
         * and not real-mode?  By using the SMSW instruction and checking the PE (protected-mode enabled) bit.
         * The SMSW instruction returns a subset of the CR0 bits, and unlike the MOV reg,CR0 instruction, is
         * allowed in V86-mode.  See fnSMSW() for more information.
         */
        regPS &= ~(X86.PS.VM | X86.PS.RF);
    }
    this.pushWord(regPS);
    this.nStepCycles -= this.cycleCounts.nOpCyclesPushReg;
};

/**
 * op=0x9D (POPF/POPFD)
 *
 * @this {CPUx86}
 */
X86.opPOPF = function()
{
    /**
     * TODO: Consider swapping out this function whenever setProtMode() changes the mode to V86-mode.
     */
    if (I386 && (this.regPS & X86.PS.VM) && this.nIOPL < 3) {
        if (DEBUG) this.printf(MESSAGE.ADDR, "POPF in v86-mode (IOPL < 3)\n");
        X86.helpFault.call(this, X86.EXCEPTION.GP_FAULT, 0);
        return;
    }
    /**
     * Regardless of mode, VM and RF (the only defined EFLAGS bit above bit 15) are never changed by POPFD.
     */
    let newPS = this.popWord();
    if (I386) newPS = (newPS & 0xffff) | (this.regPS & ~0xffff);
    this.setPS(newPS);
    /**
     * NOTE: I'm assuming that neither POPF nor IRET are required to set NOINTR like STI does.
     */
    this.nStepCycles -= this.cycleCounts.nOpCyclesPopReg;
};

/**
 * op=0x9E (SAHF)
 *
 * @this {CPUx86}
 */
X86.opSAHF = function()
{
    /**
     * NOTE: While it make seem more efficient to do this:
     *
     *      this.setPS((this.getPS() & ~X86.PS_SAHF) | ((this.regEAX >> 8) & X86.PS_SAHF));
     *
     * getPS() forces any "cached" flags to be resolved first, and setPS() must do extra work above
     * and beyond setting the arithmetic and logical flags, so on balance, the code below may be more
     * efficient, and may also avoid unexpected side-effects of updating the entire PS register.
     */
    let ah = (this.regEAX >> 8) & 0xff;
    if (ah & X86.PS.CF) this.setCF(); else this.clearCF();
    if (ah & X86.PS.PF) this.setPF(); else this.clearPF();
    if (ah & X86.PS.AF) this.setAF(); else this.clearAF();
    if (ah & X86.PS.ZF) this.setZF(); else this.clearZF();
    if (ah & X86.PS.SF) this.setSF(); else this.clearSF();
    this.nStepCycles -= this.cycleCounts.nOpCyclesLAHF;

};

/**
 * op=0x9F (LAHF)
 *
 * @this {CPUx86}
 */
X86.opLAHF = function()
{
    /**
     * Apparently, this simply uses the low 8 bits of PS as-is (ie, we don't need to mask with PS_SAHF).
     */
    this.regEAX = (this.regEAX & ~0xff00) | (this.getPS() & 0xff) << 8;
    this.nStepCycles -= this.cycleCounts.nOpCyclesLAHF;
};

/**
 * op=0xA0 (MOV AL,mem)
 *
 * @this {CPUx86}
 */
X86.opMOVALm = function()
{
    this.regEAX = (this.regEAX & ~0xff) | this.getSOByte(this.segData, this.getIPAddr());
    if (BACKTRACK) this.backTrack.btiAL = this.backTrack.btiMem0;
    this.nStepCycles -= this.cycleCounts.nOpCyclesMovAM;
};

/**
 * op=0xA1 (MOV [E]AX,mem)
 *
 * @this {CPUx86}
 */
X86.opMOVAXm = function()
{
    this.regEAX = (this.regEAX & ~this.maskData) | this.getSOWord(this.segData, this.getIPAddr());
    if (BACKTRACK) {
        this.backTrack.btiAL = this.backTrack.btiMem0; this.backTrack.btiAH = this.backTrack.btiMem1;
    }
    this.nStepCycles -= this.cycleCounts.nOpCyclesMovAM;
};

/**
 * op=0xA2 (MOV mem,AL)
 *
 * @this {CPUx86}
 */
X86.opMOVmAL = function()
{
    if (BACKTRACK) this.backTrack.btiMem0 = this.backTrack.btiAL;
    /**
     * setSOByte() truncates the value as appropriate
     */
    this.setSOByte(this.segData, this.getIPAddr(), this.regEAX);
    this.nStepCycles -= this.cycleCounts.nOpCyclesMovMA;
};

/**
 * op=0xA3 (MOV mem,AX)
 *
 * @this {CPUx86}
 */
X86.opMOVmAX = function()
{
    if (BACKTRACK) {
        this.backTrack.btiMem0 = this.backTrack.btiAL; this.backTrack.btiMem1 = this.backTrack.btiAH;
    }
    /**
     * setSOWord() truncates the value as appropriate
     */
    this.setSOWord(this.segData, this.getIPAddr(), this.regEAX);
    this.nStepCycles -= this.cycleCounts.nOpCyclesMovMA;
};

/**
 * op=0xA4 (MOVSB)
 *
 * @this {CPUx86}
 */
X86.opMOVSb = function()
{
    let nReps = 1;
    let nDelta = 0;
    let maskAddr = this.maskAddr;

    let nCycles = this.cycleCounts.nOpCyclesMovS;
    if (this.opPrefixes & (X86.OPFLAG.REPZ | X86.OPFLAG.REPNZ)) {
        nReps = this.regECX & maskAddr;
        nDelta = 1;
        nCycles = this.cycleCounts.nOpCyclesMovSrn;
        if (!(this.opPrefixes & X86.OPFLAG.REPEAT)) this.nStepCycles -= this.cycleCounts.nOpCyclesMovSr0;
    }
    if (nReps--) {
        this.setSOByte(this.segES, this.regEDI & maskAddr, this.getSOByte(this.segData, this.regESI & maskAddr));
        /**
         * helpFault() throws exceptions now, so inline checks of X86.OPFLAG.FAULT should no longer be necessary.
         *
         *      if (this.opFlags & X86.OPFLAG.FAULT) return;
         */
        let nInc = ((this.regPS & X86.PS.DF)? -1 : 1);
        this.regESI = (this.regESI & ~maskAddr) | ((this.regESI + nInc) & maskAddr);
        this.regEDI = (this.regEDI & ~maskAddr) | ((this.regEDI + nInc) & maskAddr);
        this.nStepCycles -= nCycles;
        this.regECX = (this.regECX & ~maskAddr) | ((this.regECX - nDelta) & maskAddr);
        if (nReps) this.rewindIP(true);
    }
};

/**
 * op=0xA5 (MOVSW)
 *
 * @this {CPUx86}
 */
X86.opMOVSw = function()
{
    let nReps = 1;
    let nDelta = 0;
    let maskAddr = this.maskAddr;

    let nCycles = this.cycleCounts.nOpCyclesMovS;
    if (this.opPrefixes & (X86.OPFLAG.REPZ | X86.OPFLAG.REPNZ)) {
        nReps = this.regECX & maskAddr;
        nDelta = 1;
        nCycles = this.cycleCounts.nOpCyclesMovSrn;
        if (!(this.opPrefixes & X86.OPFLAG.REPEAT)) this.nStepCycles -= this.cycleCounts.nOpCyclesMovSr0;
    }
    if (nReps--) {
        this.setSOWord(this.segES, this.regEDI & maskAddr, this.getSOWord(this.segData, this.regESI & maskAddr));
        /**
         * helpFault() throws exceptions now, so inline checks of X86.OPFLAG.FAULT should no longer be necessary.
         *
         *      if (this.opFlags & X86.OPFLAG.FAULT) return;
         */
        let nInc = ((this.regPS & X86.PS.DF)? -this.sizeData : this.sizeData);
        this.regESI = (this.regESI & ~maskAddr) | ((this.regESI + nInc) & maskAddr);
        this.regEDI = (this.regEDI & ~maskAddr) | ((this.regEDI + nInc) & maskAddr);
        this.nStepCycles -= nCycles;
        this.regECX = (this.regECX & ~maskAddr) | ((this.regECX - nDelta) & maskAddr);
        if (nReps) this.rewindIP(true);
    }
};

/**
 * op=0xA6 (CMPSB)
 *
 * @this {CPUx86}
 */
X86.opCMPSb = function()
{
    let nReps = 1;
    let nDelta = 0;
    let maskAddr = this.maskAddr;

    let nCycles = this.cycleCounts.nOpCyclesCmpS;
    if (this.opPrefixes & (X86.OPFLAG.REPZ | X86.OPFLAG.REPNZ)) {
        nReps = this.regECX & maskAddr;
        nDelta = 1;
        nCycles = this.cycleCounts.nOpCyclesCmpSrn;
        if (!(this.opPrefixes & X86.OPFLAG.REPEAT)) this.nStepCycles -= this.cycleCounts.nOpCyclesCmpSr0;
    }
    if (nReps--) {
        let bDst = this.getEAByte(this.segData, this.regESI);
        let bSrc = this.getEAByte(this.segES, this.regEDI);
        this.regEAWrite = this.regEA;           // TODO: Is this necessary?
        /**
         * helpFault() throws exceptions now, so inline checks of X86.OPFLAG.FAULT should no longer be necessary.
         *
         *      if (this.opFlags & X86.OPFLAG.FAULT) return;
         */
        X86.fnCMPb.call(this, bDst, bSrc);
        let nInc = ((this.regPS & X86.PS.DF)? -1 : 1);
        this.regESI = (this.regESI & ~maskAddr) | ((this.regESI + nInc) & maskAddr);
        this.regEDI = (this.regEDI & ~maskAddr) | ((this.regEDI + nInc) & maskAddr);
        this.regECX = (this.regECX & ~maskAddr) | ((this.regECX - nDelta) & maskAddr);
        /**
         * NOTE: As long as we're calling fnCMPb(), all our cycle times must be reduced by nOpCyclesArithRM
         */
        this.nStepCycles -= nCycles - this.cycleCounts.nOpCyclesArithRM;
        /**
         * Repetition continues while ZF matches bit 0 of the REP prefix.  getZF() returns 0x40 if ZF is
         * set, and OP_REPZ (which represents the REP prefix whose bit 0 is set) is 0x40 as well, so when those
         * two values are equal, we must continue.
         */
        if (nReps && this.getZF() == (this.opPrefixes & X86.OPFLAG.REPZ)) this.rewindIP(true);
    }
};

/**
 * op=0xA7 (CMPSW)
 *
 * @this {CPUx86}
 */
X86.opCMPSw = function()
{
    let nReps = 1;
    let nDelta = 0;
    let maskAddr = this.maskAddr;

    let nCycles = this.cycleCounts.nOpCyclesCmpS;
    if (this.opPrefixes & (X86.OPFLAG.REPZ | X86.OPFLAG.REPNZ)) {
        nReps = this.regECX & maskAddr;
        nDelta = 1;
        nCycles = this.cycleCounts.nOpCyclesCmpSrn;
        if (!(this.opPrefixes & X86.OPFLAG.REPEAT)) this.nStepCycles -= this.cycleCounts.nOpCyclesCmpSr0;
    }
    if (nReps--) {
        let wDst = this.getEAWord(this.segData, this.regESI & maskAddr);
        let wSrc = this.getEAWord(this.segES, this.regEDI & maskAddr);
        this.regEAWrite = this.regEA;           // TODO: Is this necessary?
        /**
         * helpFault() throws exceptions now, so inline checks of X86.OPFLAG.FAULT should no longer be necessary.
         *
         *      if (this.opFlags & X86.OPFLAG.FAULT) return;
         */
        X86.fnCMPw.call(this, wDst, wSrc);
        let nInc = ((this.regPS & X86.PS.DF)? -this.sizeData : this.sizeData);
        this.regESI = (this.regESI & ~maskAddr) | ((this.regESI + nInc) & maskAddr);
        this.regEDI = (this.regEDI & ~maskAddr) | ((this.regEDI + nInc) & maskAddr);
        this.regECX = (this.regECX & ~maskAddr) | ((this.regECX - nDelta) & maskAddr);
        /**
         * NOTE: As long as we're calling fnCMPw(), all our cycle times must be reduced by nOpCyclesArithRM
         */
        this.nStepCycles -= nCycles - this.cycleCounts.nOpCyclesArithRM;
        /**
         * Repetition continues while ZF matches bit 0 of the REP prefix.  getZF() returns 0x40 if ZF is
         * set, and OP_REPZ (which represents the REP prefix whose bit 0 is set) is 0x40 as well, so when those
         * two values are equal, we must continue.
         */
        if (nReps && this.getZF() == (this.opPrefixes & X86.OPFLAG.REPZ)) this.rewindIP(true);
    }
};

/**
 * op=0xA8 (TEST AL,imm8)
 *
 * @this {CPUx86}
 */
X86.opTESTALb = function()
{
    this.setLogicResult(this.regEAX & this.getIPByte(), X86.RESULT.BYTE);
    this.nStepCycles -= this.cycleCounts.nOpCyclesAAA;
};

/**
 * op=0xA9 (TEST [E]AX,imm)
 *
 * @this {CPUx86}
 */
X86.opTESTAX = function()
{
    this.setLogicResult(this.regEAX & this.getIPWord(), this.typeData);
    this.nStepCycles -= this.cycleCounts.nOpCyclesAAA;
};

/**
 * op=0xAA (STOSB)
 *
 * NOTES: Segment overrides are ignored for this instruction, so we must use segES instead of segData.
 *
 * @this {CPUx86}
 */
X86.opSTOSb = function()
{
    let nReps = 1;
    let nDelta = 0;
    let maskAddr = this.maskAddr;

    let nCycles = this.cycleCounts.nOpCyclesStoS;
    if (this.opPrefixes & (X86.OPFLAG.REPZ | X86.OPFLAG.REPNZ)) {
        nReps = this.regECX & maskAddr;
        nDelta = 1;
        nCycles = this.cycleCounts.nOpCyclesStoSrn;
        if (!(this.opPrefixes & X86.OPFLAG.REPEAT)) this.nStepCycles -= this.cycleCounts.nOpCyclesStoSr0;
    }
    if (nReps--) {
        this.setSOByte(this.segES, this.regEDI & maskAddr, this.regEAX);
        /**
         * helpFault() throws exceptions now, so inline checks of X86.OPFLAG.FAULT should no longer be necessary.
         *
         *      if (this.opFlags & X86.OPFLAG.FAULT) return;
         */
        if (BACKTRACK) this.backTrack.btiMem0 = this.backTrack.btiAL;

        this.regECX = (this.regECX & ~maskAddr) | ((this.regECX - nDelta) & maskAddr);

        /**
         * Implement 80386 B1 Errata #7, to the extent that Windows 95 checked for it.  This test doesn't
         * detect every possible variation (for example, the ADDRESS override on the next instruction, if
         * it exists, may not be the first prefix byte), but it's adequate for our limited purpose.
         *
         * Note that this code alters maskAddr AFTER it's been used to update ECX, because in the case
         * of STOS, the errata reportedly affects only EDI.  The other instructions mentioned in the errata
         * trash different registers, so read the errata carefully.
         *
         * TODO: Extend this errata to STOSW, as well as MOVSB, MOVSW, INSB, and INSW.  Also, verify the
         * extent to which this errata existed on earlier 80386 steppings (I'm currently assuming A0-B1).
         */
        if (this.stepping >= X86.STEPPING_80386_A0 && this.stepping <= X86.STEPPING_80386_B2) {
            if (!(this.opPrefixes & X86.OPFLAG.ADDRSIZE) != (this.getByte(this.regLIP) != X86.OPCODE.AS)) {
                maskAddr ^= (0xffff0000|0);
            }
        }
        this.regEDI = (this.regEDI & ~maskAddr) | ((this.regEDI + ((this.regPS & X86.PS.DF)? -1 : 1)) & maskAddr);

        this.nStepCycles -= nCycles;
        if (nReps) this.rewindIP();
    }
};

/**
 * op=0xAB (STOSW)
 *
 * NOTES: Segment overrides are ignored for this instruction, so we must use segES instead of segData.
 *
 * @this {CPUx86}
 */
X86.opSTOSw = function()
{
    let nReps = 1;
    let nDelta = 0;
    let maskAddr = this.maskAddr;

    let nCycles = this.cycleCounts.nOpCyclesStoS;
    if (this.opPrefixes & (X86.OPFLAG.REPZ | X86.OPFLAG.REPNZ)) {
        nReps = this.regECX & maskAddr;
        nDelta = 1;
        nCycles = this.cycleCounts.nOpCyclesStoSrn;
        if (!(this.opPrefixes & X86.OPFLAG.REPEAT)) this.nStepCycles -= this.cycleCounts.nOpCyclesStoSr0;
    }
    if (nReps--) {
        this.setSOWord(this.segES, this.regEDI & maskAddr, this.regEAX);
        /**
         * helpFault() throws exceptions now, so inline checks of X86.OPFLAG.FAULT should no longer be necessary.
         *
         *      if (this.opFlags & X86.OPFLAG.FAULT) return;
         */
        if (BACKTRACK) {
            this.backTrack.btiMem0 = this.backTrack.btiAL; this.backTrack.btiMem1 = this.backTrack.btiAH;
        }
        this.regEDI = (this.regEDI & ~maskAddr) | ((this.regEDI + ((this.regPS & X86.PS.DF)? -this.sizeData : this.sizeData)) & maskAddr);
        this.regECX = (this.regECX & ~maskAddr) | ((this.regECX - nDelta) & maskAddr);
        this.nStepCycles -= nCycles;
        if (nReps) this.rewindIP();
    }
};

/**
 * op=0xAC (LODSB)
 *
 * @this {CPUx86}
 */
X86.opLODSb = function()
{
    let nReps = 1;
    let nDelta = 0;
    let maskAddr = this.maskAddr;

    let nCycles = this.cycleCounts.nOpCyclesLodS;
    if (this.opPrefixes & (X86.OPFLAG.REPZ | X86.OPFLAG.REPNZ)) {
        nReps = this.regECX & maskAddr;
        nDelta = 1;
        nCycles = this.cycleCounts.nOpCyclesLodSrn;
        if (!(this.opPrefixes & X86.OPFLAG.REPEAT)) this.nStepCycles -= this.cycleCounts.nOpCyclesLodSr0;
    }
    if (nReps--) {
        let b = this.getSOByte(this.segData, this.regESI & maskAddr);
        /**
         * helpFault() throws exceptions now, so inline checks of X86.OPFLAG.FAULT should no longer be necessary.
         *
         *      if (this.opFlags & X86.OPFLAG.FAULT) return;
         */
        this.regEAX = (this.regEAX & ~0xff) | b;
        if (BACKTRACK) this.backTrack.btiAL = this.backTrack.btiMem0;
        this.regESI = (this.regESI & ~maskAddr) | ((this.regESI + ((this.regPS & X86.PS.DF)? -1 : 1)) & maskAddr);
        this.regECX = (this.regECX & ~maskAddr) | ((this.regECX - nDelta) & maskAddr);
        this.nStepCycles -= nCycles;
        if (nReps) this.rewindIP(true);
    }
};

/**
 * op=0xAD (LODSW)
 *
 * @this {CPUx86}
 */
X86.opLODSw = function()
{
    let nReps = 1;
    let nDelta = 0;
    let maskAddr = this.maskAddr;

    let nCycles = this.cycleCounts.nOpCyclesLodS;
    if (this.opPrefixes & (X86.OPFLAG.REPZ | X86.OPFLAG.REPNZ)) {
        nReps = this.regECX & maskAddr;
        nDelta = 1;
        nCycles = this.cycleCounts.nOpCyclesLodSrn;
        if (!(this.opPrefixes & X86.OPFLAG.REPEAT)) this.nStepCycles -= this.cycleCounts.nOpCyclesLodSr0;
    }
    if (nReps--) {
        let w = this.getSOWord(this.segData, this.regESI & maskAddr);
        /**
         * helpFault() throws exceptions now, so inline checks of X86.OPFLAG.FAULT should no longer be necessary.
         *
         *      if (this.opFlags & X86.OPFLAG.FAULT) return;
         */
        this.regEAX = (this.regEAX & ~this.maskData) | w;
        if (BACKTRACK) {
            this.backTrack.btiAL = this.backTrack.btiMem0; this.backTrack.btiAH = this.backTrack.btiMem1;
        }
        this.regESI = (this.regESI & ~maskAddr) | ((this.regESI + ((this.regPS & X86.PS.DF)? -this.sizeData : this.sizeData)) & maskAddr);
        this.regECX = (this.regECX & ~maskAddr) | ((this.regECX - nDelta) & maskAddr);
        this.nStepCycles -= nCycles;
        if (nReps) this.rewindIP(true);
    }
};

/**
 * op=0xAE (SCASB)
 *
 * @this {CPUx86}
 */
X86.opSCASb = function()
{
    let nReps = 1;
    let nDelta = 0;
    let maskAddr = this.maskAddr;

    let nCycles = this.cycleCounts.nOpCyclesScaS;
    if (this.opPrefixes & (X86.OPFLAG.REPZ | X86.OPFLAG.REPNZ)) {
        nReps = this.regECX & maskAddr;
        nDelta = 1;
        nCycles = this.cycleCounts.nOpCyclesScaSrn;
        if (!(this.opPrefixes & X86.OPFLAG.REPEAT)) this.nStepCycles -= this.cycleCounts.nOpCyclesScaSr0;
    }
    if (nReps--) {
        let bDst = this.regEAX & 0xff;
        let bSrc = this.getEAByte(this.segES, this.regEDI);
        this.regEAWrite = this.regEA;           // TODO: Is this necessary?
        X86.fnCMPb.call(this, bDst, bSrc);
        /**
         * helpFault() throws exceptions now, so inline checks of X86.OPFLAG.FAULT should no longer be necessary.
         *
         *      if (this.opFlags & X86.OPFLAG.FAULT) return;
         */
        this.regEDI = (this.regEDI & ~maskAddr) | ((this.regEDI + ((this.regPS & X86.PS.DF)? -1 : 1)) & maskAddr);
        this.regECX = (this.regECX & ~maskAddr) | ((this.regECX - nDelta) & maskAddr);
        /**
         * NOTE: As long as we're calling fnCMPb(), all our cycle times must be reduced by nOpCyclesArithRM
         */
        this.nStepCycles -= nCycles - this.cycleCounts.nOpCyclesArithRM;
        /**
         * Repetition continues while ZF matches bit 0 of the REP prefix.  getZF() returns 0x40 if ZF is
         * set, and OP_REPZ (which represents the REP prefix whose bit 0 is set) is 0x40 as well, so when those
         * two values are equal, we must continue.
         */
        if (nReps && this.getZF() == (this.opPrefixes & X86.OPFLAG.REPZ)) this.rewindIP();
    }
};

/**
 * op=0xAF (SCASW)
 *
 * @this {CPUx86}
 */
X86.opSCASw = function()
{
    let nReps = 1;
    let nDelta = 0;
    let maskAddr = this.maskAddr;

    let nCycles = this.cycleCounts.nOpCyclesScaS;
    if (this.opPrefixes & (X86.OPFLAG.REPZ | X86.OPFLAG.REPNZ)) {
        nReps = this.regECX & maskAddr;
        nDelta = 1;
        nCycles = this.cycleCounts.nOpCyclesScaSrn;
        if (!(this.opPrefixes & X86.OPFLAG.REPEAT)) this.nStepCycles -= this.cycleCounts.nOpCyclesScaSr0;
    }
    if (nReps--) {
        let wDst = this.regEAX & this.maskData;
        let wSrc = this.getEAWord(this.segES, this.regEDI & maskAddr);
        this.regEAWrite = this.regEA;           // TODO: Is this necessary?
        X86.fnCMPw.call(this, wDst, wSrc);
        /**
         * helpFault() throws exceptions now, so inline checks of X86.OPFLAG.FAULT should no longer be necessary.
         *
         *      if (this.opFlags & X86.OPFLAG.FAULT) return;
         */
        this.regEDI = (this.regEDI & ~maskAddr) | ((this.regEDI + ((this.regPS & X86.PS.DF)? -this.sizeData : this.sizeData)) & maskAddr);
        this.regECX = (this.regECX & ~maskAddr) | ((this.regECX - nDelta) & maskAddr);
        /**
         * NOTE: As long as we're calling fnCMPw(), all our cycle times must be reduced by nOpCyclesArithRM
         */
        this.nStepCycles -= nCycles - this.cycleCounts.nOpCyclesArithRM;
        /**
         * Repetition continues while ZF matches bit 0 of the REP prefix.  getZF() returns 0x40 if ZF is
         * set, and OP_REPZ (which represents the REP prefix whose bit 0 is set) is 0x40 as well, so when those
         * two values are equal, we must continue.
         */
        if (nReps && this.getZF() == (this.opPrefixes & X86.OPFLAG.REPZ)) this.rewindIP();
    }
};

/**
 * op=0xB0 (MOV AL,imm8)
 *
 * @this {CPUx86}
 */
X86.opMOVALb = function()
{
    this.regEAX = (this.regEAX & ~0xff) | this.getIPByte();
    if (BACKTRACK) this.backTrack.btiAL = this.backTrack.btiMem0;
    this.nStepCycles -= this.cycleCounts.nOpCyclesLAHF;
};

/**
 * op=0xB1 (MOV CL,imm8)
 *
 * @this {CPUx86}
 */
X86.opMOVCLb = function()
{
    this.regECX = (this.regECX & ~0xff) | this.getIPByte();
    if (BACKTRACK) this.backTrack.btiCL = this.backTrack.btiMem0;
    this.nStepCycles -= this.cycleCounts.nOpCyclesLAHF;
};

/**
 * op=0xB2 (MOV DL,imm8)
 *
 * @this {CPUx86}
 */
X86.opMOVDLb = function()
{
    this.regEDX = (this.regEDX & ~0xff) | this.getIPByte();
    if (BACKTRACK) this.backTrack.btiDL = this.backTrack.btiMem0;
    this.nStepCycles -= this.cycleCounts.nOpCyclesLAHF;
};

/**
 * op=0xB3 (MOV BL,imm8)
 *
 * @this {CPUx86}
 */
X86.opMOVBLb = function()
{
    this.regEBX = (this.regEBX & ~0xff) | this.getIPByte();
    if (BACKTRACK) this.backTrack.btiBL = this.backTrack.btiMem0;
    this.nStepCycles -= this.cycleCounts.nOpCyclesLAHF;
};

/**
 * op=0xB4 (MOV AH,imm8)
 *
 * @this {CPUx86}
 */
X86.opMOVAHb = function()
{
    this.regEAX = (this.regEAX & ~0xff00) | (this.getIPByte() << 8);
    if (BACKTRACK) this.backTrack.btiAH = this.backTrack.btiMem0;
    this.nStepCycles -= this.cycleCounts.nOpCyclesLAHF;
};

/**
 * op=0xB5 (MOV CH,imm8)
 *
 * @this {CPUx86}
 */
X86.opMOVCHb = function()
{
    this.regECX = (this.regECX & ~0xff00) | (this.getIPByte() << 8);
    if (BACKTRACK) this.backTrack.btiCH = this.backTrack.btiMem0;
    this.nStepCycles -= this.cycleCounts.nOpCyclesLAHF;
};

/**
 * op=0xB6 (MOV DH,imm8)
 *
 * @this {CPUx86}
 */
X86.opMOVDHb = function()
{
    this.regEDX = (this.regEDX & ~0xff00) | (this.getIPByte() << 8);
    if (BACKTRACK) this.backTrack.btiDH = this.backTrack.btiMem0;
    this.nStepCycles -= this.cycleCounts.nOpCyclesLAHF;
};

/**
 * op=0xB7 (MOV BH,imm8)
 *
 * @this {CPUx86}
 */
X86.opMOVBHb = function()
{
    this.regEBX = (this.regEBX & ~0xff00) | (this.getIPByte() << 8);
    if (BACKTRACK) this.backTrack.btiBH = this.backTrack.btiMem0;
    this.nStepCycles -= this.cycleCounts.nOpCyclesLAHF;
};

/**
 * op=0xB8 (MOV [E]AX,imm)
 *
 * @this {CPUx86}
 */
X86.opMOVAX = function()
{
    this.regEAX = (this.regEAX & ~this.maskData) | this.getIPWord();
    if (BACKTRACK) {
        this.backTrack.btiAL = this.backTrack.btiMem0; this.backTrack.btiAH = this.backTrack.btiMem1;
    }
    this.nStepCycles -= this.cycleCounts.nOpCyclesLAHF;
};

/**
 * op=0xB9 (MOV [E]CX,imm)
 *
 * @this {CPUx86}
 */
X86.opMOVCX = function()
{
    this.regECX = (this.regECX & ~this.maskData) | this.getIPWord();
    if (BACKTRACK) {
        this.backTrack.btiCL = this.backTrack.btiMem0; this.backTrack.btiCH = this.backTrack.btiMem1;
    }
    this.nStepCycles -= this.cycleCounts.nOpCyclesLAHF;
};

/**
 * op=0xBA (MOV [E]DX,imm)
 *
 * @this {CPUx86}
 */
X86.opMOVDX = function()
{
    this.regEDX = (this.regEDX & ~this.maskData) | this.getIPWord();
    if (BACKTRACK) {
        this.backTrack.btiDL = this.backTrack.btiMem0; this.backTrack.btiDH = this.backTrack.btiMem1;
    }
    this.nStepCycles -= this.cycleCounts.nOpCyclesLAHF;
};

/**
 * op=0xBB (MOV [E]BX,imm)
 *
 * @this {CPUx86}
 */
X86.opMOVBX = function()
{
    this.regEBX = (this.regEBX & ~this.maskData) | this.getIPWord();
    if (BACKTRACK) {
        this.backTrack.btiBL = this.backTrack.btiMem0; this.backTrack.btiBH = this.backTrack.btiMem1;
    }
    this.nStepCycles -= this.cycleCounts.nOpCyclesLAHF;
};

/**
 * op=0xBC (MOV [E]SP,imm)
 *
 * @this {CPUx86}
 */
X86.opMOVSP = function()
{
    this.setSP((this.getSP() & ~this.maskData) | this.getIPWord());
    this.nStepCycles -= this.cycleCounts.nOpCyclesLAHF;
};

/**
 * op=0xBD (MOV [E]BP,imm)
 *
 * @this {CPUx86}
 */
X86.opMOVBP = function()
{
    this.regEBP = (this.regEBP & ~this.maskData) | this.getIPWord();
    if (BACKTRACK) {
        this.backTrack.btiBPLo = this.backTrack.btiMem0; this.backTrack.btiBPHi = this.backTrack.btiMem1;
    }
    this.nStepCycles -= this.cycleCounts.nOpCyclesLAHF;
};

/**
 * op=0xBE (MOV [E]SI,imm)
 *
 * @this {CPUx86}
 */
X86.opMOVSI = function()
{
    this.regESI = (this.regESI & ~this.maskData) | this.getIPWord();
    if (BACKTRACK) {
        this.backTrack.btiSILo = this.backTrack.btiMem0; this.backTrack.btiSIHi = this.backTrack.btiMem1;
    }
    this.nStepCycles -= this.cycleCounts.nOpCyclesLAHF;
};

/**
 * op=0xBF (MOV [E]DI,imm)
 *
 * @this {CPUx86}
 */
X86.opMOVDI = function()
{
    this.regEDI = (this.regEDI & ~this.maskData) | this.getIPWord();
    if (BACKTRACK) {
        this.backTrack.btiDILo = this.backTrack.btiMem0; this.backTrack.btiDIHi = this.backTrack.btiMem1;
    }
    this.nStepCycles -= this.cycleCounts.nOpCyclesLAHF;
};

/**
 * op=0xC0 (GRP2 byte,imm8) (80186/80188 and up)
 *
 * @this {CPUx86}
 */
X86.opGRP2bn = function()
{
    this.decodeModGrpByte.call(this, X86.aOpGrp2b, X86.helpSRCByte);
};

/**
 * op=0xC1 (GRP2 word,imm) (80186/80188 and up)
 *
 * @this {CPUx86}
 */
X86.opGRP2wn = function()
{
    this.decodeModGrpWord.call(this, this.sizeData == 2? X86.aOpGrp2w : X86.aOpGrp2d, X86.helpSRCByte);
};

/**
 * op=0xC2 (RET n)
 *
 * @this {CPUx86}
 */
X86.opRETn = function()
{
    let n = this.getIPShort();
    let newIP = this.popWord();
    this.setIP(newIP);
    if (n) this.setSP(this.getSP() + n);            // TODO: optimize
    this.nStepCycles -= this.cycleCounts.nOpCyclesRetn;
};

/**
 * op=0xC3 (RET)
 *
 * @this {CPUx86}
 */
X86.opRET = function()
{
    let newIP = this.popWord();
    this.setIP(newIP);
    this.nStepCycles -= this.cycleCounts.nOpCyclesRet;
};

/**
 * op=0xC4 (LES reg,word)
 *
 * This is like a "MOV reg,rm" operation, but it also loads ES from the next word.
 *
 * @this {CPUx86}
 */
X86.opLES = function()
{
    this.decodeModRegWord.call(this, X86.fnLES);
};

/**
 * op=0xC5 (LDS reg,word)
 *
 * This is like a "MOV reg,rm" operation, but it also loads DS from the next word.
 *
 * @this {CPUx86}
 */
X86.opLDS = function()
{
    this.decodeModRegWord.call(this, X86.fnLDS);
};

/**
 * op=0xC6 (MOV byte,imm8)
 *
 * @this {CPUx86}
 */
X86.opMOVb = function()
{
    /**
     * Like other MOV operations, the destination does not need to be read, just written.
     */
    this.opFlags |= X86.OPFLAG.NOREAD;
    this.decodeModGrpByte.call(this, X86.aOpGrpMOVn, this.getIPByte);
};

/**
 * op=0xC7 (MOV word,imm)
 *
 * @this {CPUx86}
 */
X86.opMOVw = function()
{
    /**
     * Like other MOV operations, the destination does not need to be read, just written.
     */
    this.opFlags |= X86.OPFLAG.NOREAD;
    this.decodeModGrpWord.call(this, X86.aOpGrpMOVn, this.getIPWord);
};

/**
 * op=0xC8 (ENTER imm16,imm8) (80186/80188 and up)
 *
 * @this {CPUx86}
 */
X86.opENTER = function()
{
    /**
     * Any operation that performs multiple stack modifications must snapshot regLSP first.
     */
    this.opLSP = this.regLSP;

    let wLocal = this.getIPShort();
    let bLevel = this.getIPByte() & 0x1f;
    /**
     * NOTE: 11 is the minimum cycle time for the 80286; the 80186/80188 has different cycle times: 15, 25 and
     * 22 + 16 * (bLevel - 1) for bLevel 0, 1 and > 1, respectively.  TODO: Fix this someday.
     */
    this.nStepCycles -= 11;
    this.pushWord(this.regEBP);
    let wFrame = this.getSP() & this.maskData;
    if (bLevel > 0) {
        this.nStepCycles -= (bLevel << 2) + (bLevel > 1? 1 : 0);
        while (--bLevel) {
            this.regEBP = (this.regEBP & ~this.maskData) | ((this.regEBP - this.sizeData) & this.maskData);
            this.pushWord(this.getSOWord(this.segSS, this.regEBP & this.maskData));
        }
        this.pushWord(wFrame);
    }
    this.regEBP = (this.regEBP & ~this.maskData) | wFrame;
    this.setSP((this.getSP() & ~this.segSS.maskAddr) | ((this.getSP() - wLocal) & this.segSS.maskAddr));

    this.opLSP = X86.ADDR_INVALID;
};

/**
 * op=0xC9 (LEAVE) (80186/80188 and up)
 *
 * @this {CPUx86}
 */
X86.opLEAVE = function()
{
    /**
     * Any operation that performs multiple stack modifications must snapshot regLSP first.
     */
    this.opLSP = this.regLSP;

    this.setSP((this.getSP() & ~this.segSS.maskAddr) | (this.regEBP & this.segSS.maskAddr));

    this.regEBP = (this.regEBP & ~this.maskData) | (this.popWord() & this.maskData);
    /**
     * NOTE: 5 is the cycle time for the 80286; the 80186/80188 has a cycle time of 8.  TODO: Fix this someday.
     */
    this.nStepCycles -= 5;

    this.opLSP = X86.ADDR_INVALID;
};

/**
 * op=0xCA (RETF n)
 *
 * @this {CPUx86}
 */
X86.opRETFn = function()
{
    X86.helpRETF.call(this, this.getIPShort());
    this.nStepCycles -= this.cycleCounts.nOpCyclesRetFn;
};

/**
 * op=0xCB (RETF)
 *
 * @this {CPUx86}
 */
X86.opRETF = function()
{
    X86.helpRETF.call(this, 0);
    this.nStepCycles -= this.cycleCounts.nOpCyclesRetF;
};

/**
 * op=0xCC (INT 3)
 *
 * @this {CPUx86}
 */
X86.opINT3 = function()
{
    /**
     * TODO: Consider swapping out this function whenever setProtMode() changes the mode to V86-mode.
     */
    if (I386 && (this.regPS & X86.PS.VM) && this.nIOPL < 3) {
        if (DEBUG) this.printf(MESSAGE.ADDR, "INT 0x03 in v86-mode (IOPL < 3)\n");
        X86.helpFault.call(this, X86.EXCEPTION.GP_FAULT, 0);
        return;
    }
    /**
     * Because INT3 is a trap, not a fault, we must use helpTrap() rather than helpFault().  Unfortunately, that
     * means you can't rely on the Debugger logic instead helpFault() to conditionally stop execution on an INT3,
     * so I've changed the Debugger's checkBreakpoint() function to stop execution on INT3 whenever both the
     * INT and HALT message bits are set; a simple "g" command allows you to continue.
     */
    X86.helpTrap.call(this, X86.EXCEPTION.BP_TRAP, 1, this.cycleCounts.nOpCyclesInt3D);
};

/**
 * op=0xCD (INT n)
 *
 * @this {CPUx86}
 */
X86.opINTn = function()
{
    let nInt = this.getIPByte();
    /**
     * TODO: Consider swapping out this function whenever setProtMode() changes the mode to V86-mode.
     */
    if (I386 && (this.regPS & X86.PS.VM) && this.nIOPL < 3) {
        if (DEBUG) this.printf(MESSAGE.ADDR, "INT %#04x in v86-mode (IOPL < 3)\n", nInt);
        X86.helpFault.call(this, X86.EXCEPTION.GP_FAULT, 0);
        return;
    }
    /**
     * checkIntNotify() checks for any notification handlers registered via addIntNotify(), calls them,
     * and returns false ONLY if a notification handler returned false (ie, requesting the interrupt be skipped).
     */
    if (this.checkIntNotify(nInt)) {
        X86.helpTrap.call(this, nInt, 2);
        return;
    }
    this.nStepCycles--;     // we don't need to assess the full cost of nOpCyclesInt, but we need to assess something...
};

/**
 * op=0xCE (INTO: INT 4 if OF set)
 *
 * @this {CPUx86}
 */
X86.opINTO = function()
{
    if (this.getOF()) {
        /**
         * TODO: Consider swapping out this function whenever setProtMode() changes the mode to V86-mode.
         */
        if (I386 && (this.regPS & X86.PS.VM) && this.nIOPL < 3) {
            if (DEBUG) this.printf(MESSAGE.ADDR, "INTO in v86-mode (IOPL < 3)\n");
            X86.helpFault.call(this, X86.EXCEPTION.GP_FAULT, 0);
            return;
        }
        X86.helpTrap.call(this, X86.EXCEPTION.OF_TRAP, 1, this.cycleCounts.nOpCyclesIntOD);
        return;
    }
    this.nStepCycles -= this.cycleCounts.nOpCyclesIntOFall;
};

/**
 * op=0xCF (IRET)
 *
 * @this {CPUx86}
 */
X86.opIRET = function()
{
    /**
     * TODO: Consider swapping out this function whenever setProtMode() changes the mode to V86-mode.
     */
    if (I386 && (this.regPS & X86.PS.VM) && this.nIOPL < 3) {
        if (DEBUG) this.printf(MESSAGE.ADDR, "IRET in v86-mode (IOPL < 3)\n");
        X86.helpFault.call(this, X86.EXCEPTION.GP_FAULT, 0);
        return;
    }
    this.opFlags |= X86.OPFLAG.IRET;
    X86.helpIRET.call(this);
};

/**
 * op=0xD0 (GRP2 byte,1)
 *
 * @this {CPUx86}
 */
X86.opGRP2b1 = function()
{
    this.decodeModGrpByte.call(this, X86.aOpGrp2b, X86.helpSRC1);
};

/**
 * op=0xD1 (GRP2 word,1)
 *
 * @this {CPUx86}
 */
X86.opGRP2w1 = function()
{
    this.decodeModGrpWord.call(this, this.sizeData == 2? X86.aOpGrp2w : X86.aOpGrp2d, X86.helpSRC1);
};

/**
 * op=0xD2 (GRP2 byte,CL)
 *
 * @this {CPUx86}
 */
X86.opGRP2bCL = function()
{
    this.decodeModGrpByte.call(this, X86.aOpGrp2b, X86.helpSRCCL);
};

/**
 * op=0xD3 (GRP2 word,CL)
 *
 * @this {CPUx86}
 */
X86.opGRP2wCL = function()
{
    this.decodeModGrpWord.call(this, this.sizeData == 2? X86.aOpGrp2w : X86.aOpGrp2d, X86.helpSRCCL);
};

/**
 * op=0xD4 0x0A (AAM)
 *
 * From "The 8086 Book":
 *
 *      1. Divide AL by 0x0A; store the quotient in AH and the remainder in AL
 *      2. Set PF, SF, and ZF based on the AL register (CF, OF, and AF are undefined)
 *
 * From "Undocumented Opcodes" (http://www.rcollins.org/secrets/opcodes/AAM.html):
 *
 *      AAM is shown as a two byte encoding used to divide AL by 10, putting the quotient in AH, and the remainder in AL.
 *      However, AAM is listed in the op code map as a single byte instruction. This leads one to wonder why a two-byte
 *      opcode is listed in the single-byte opcode map. In reality, the second byte is an undocumented operand to AAM.
 *      The operand is the divisor. In its documented incarnation, AAM is encoded as D4 0A. The operand 0A is the divisor.
 *      This divisor can be changed to any value between 0 and FF.
 *
 *      Using AAM in this manner is useful -- as it extends the CPU instruction set to include a DIV IMM8 instruction
 *      that is not available from any other form of the DIV instruction. The extended form of the AAM instruction is also
 *      useful because it sets the flags register according to the results, unlike the DIV or IDIV instruction.
 *
 *      According to Intel documentation, SF, ZF, and PF flags are set according to the result, while OF, AF, and CF
 *      are undefined. However, if AAM were used strictly as documented, then the Sign Flag (SF) could not be set under
 *      any circumstances, since anything divided by 10 will leave a remainder between 0 and 9. Obviously the remainder
 *      could never be between 128 and 255 (or -1 and -128 if you prefer) if used only as documented. Since AAM divides
 *      an 8 bit number by another 8-bit number, a carry or overflow could never occur. Therefore CF and OF always=0.
 *      Intel claims they are undefined, but my observations are consistent with my theory.
 *
 *      Contrary to documentation, AAM will generate exceptions in real mode, protected mode, and V86 mode. AAM can only
 *      generate Exception 0 -- divide by 0.
 *
 *      Finally, in the Pentium User's Manual, this heretofore undocumented form of AMM is described. Intel says:
 *
 *          Note: imm8 has the value of the instruction's second byte. The second byte under normally assembly [sic] of
 *          this instruction will be 0A, however, explicit modification of this byte will result in the operation described
 *          above and may alter results.
 *
 *      This instruction exists in this form on all Intel x86 processors. See the file [AAM.ASM](/docs/x86/ops/AAM/AAM.ASM)
 *      for diagnostics source code for this instruction.
 *
 * @this {CPUx86}
 */
X86.opAAM = function()
{
    let b = this.getIPByte();
    if (!b) {
        X86.helpDIVOverflow.call(this);
        return;
    }
    let AL = this.regEAX & 0xff;
    this.regEAX = (this.regEAX & ~0xffff) | ((AL / b) << 8) | (AL % b);
    /**
     * setLogicResult() is perfect, because it ensures that CF and OF are cleared as well (see above for why).
     */
    this.setLogicResult(this.regEAX, X86.RESULT.BYTE);
    this.nStepCycles -= this.cycleCounts.nOpCyclesAAM;
};

/**
 * op=0xD5 (AAD)
 *
 * From "The 8086 Book":
 *
 *      1. Multiply AH by 0x0A, add AH to AL, and store 0x00 in AH
 *      2. Set PF, SF, and ZF based on the AL register (CF, OF, and AF are undefined)
 *
 * From "Undocumented Opcodes" (http://www.rcollins.org/secrets/opcodes/AAD.html):
 *
 *      This instruction is the multiplication counterpart to AAM. As is the case with AAM, AAD uses the second
 *      byte as an operand. This operand is the multiplicand for AAD. Like AAM, AAD provides a way to execute a MUL
 *      IMM8 that is unavailable through any other means in the CPU.
 *
 *      Unlike MUL, or IMUL, AAD sets all of the CPU status flags according to the result. Intel states that the
 *      Overflow Flag (OF), Auxiliary carry Flag (AF), and Carry Flag (CF) are undefined. This assertion is incorrect.
 *      These flags are fully defined, and are set consistently with respect to any other integer operations.
 *
 *      And again, like AMM, beginning with the Pentium, Intel has finally acknowledged the existence of the second
 *      byte of this instruction as its operand. Intel says:
 *
 *          Note: imm8 has the value of the instruction's second byte. The second byte under normally assembly [sic]
 *          of this instruction will be 0A, however, explicit modification of this byte will result in the operation
 *          described above and may alter results.
 *
 *      This instruction exists in this form on all Intel x86 processors. See the file [AAD.ASM](/docs/x86/ops/AAD/AAD.ASM)
 *      for diagnostics source code for this instruction.
 *
 * TODO: Confirm on real hardware that flags reflect the result of the final addition (ie, that the result of the
 * intermediate multiplication is irrelevant); it also might be nice to confirm that an operand override has no effect.
 *
 * @this {CPUx86}
 */
X86.opAAD = function()
{
    let dst = (this.regEAX & 0xff);
    let src = (((this.regEAX >> 8) & 0xff) * this.getIPByte())|0;
    let result = (dst + src)|0;
    this.regEAX = (this.regEAX & ~0xffff) | (result & 0xff);
    this.setArithResult(dst, src, result, X86.RESULT.BYTE | X86.RESULT.ALL);
    this.nStepCycles -= this.cycleCounts.nOpCyclesAAD;
};

/**
 * op=0xD6 (SALC aka SETALC) (undocumented until Pentium Pro)
 *
 * Sets AL to 0xFF if CF=1, 0x00 otherwise; no flags are affected (similar to SBB AL,AL, but without side-effects)
 *
 * WARNING: I have no idea how many clocks this instruction originally required, so for now, I'm going with a minimum of 2.
 *
 * @this {CPUx86}
 */
X86.opSALC = function()
{
    this.regEAX = (this.regEAX & ~0xff) | (this.getCF()? 0xFF : 0);
    this.nStepCycles -= 2;
};

/**
 * op=0xD7 (XLAT)
 *
 * @this {CPUx86}
 */
X86.opXLAT = function()
{
    /**
     * TODO: Verify whether XLAT wraps its address calculation....
     */
    this.regEAX = (this.regEAX & ~0xff) | this.getEAByte(this.segData, (this.regEBX + (this.regEAX & 0xff)));
    this.nStepCycles -= this.cycleCounts.nOpCyclesXLAT;
};

/**
 * opESC()
 *
 * @this {CPUx86}
 * @param {number} bOpcode
 */
X86.opESC = function(bOpcode)
{
    this.bOpcode = bOpcode;
    this.decodeModRegWord.call(this, X86.fnESC);
};

/**
 * op=0xD8 (ESC0)
 *
 * @this {CPUx86}
 */
X86.opESC0 = function()
{
    X86.opESC.call(this, X86.OPCODE.ESC0);
};

/**
 * op=0xD9 (ESC1)
 *
 * @this {CPUx86}
 */
X86.opESC1 = function()
{
    X86.opESC.call(this, X86.OPCODE.ESC1);
};

/**
 * op=0xDA (ESC2)
 *
 * @this {CPUx86}
 */
X86.opESC2 = function()
{
    X86.opESC.call(this, X86.OPCODE.ESC2);
};

/**
 * op=0xDB (ESC3)
 *
 * @this {CPUx86}
 */
X86.opESC3 = function()
{
    X86.opESC.call(this, X86.OPCODE.ESC3);
};

/**
 * op=0xDC (ESC4)
 *
 * @this {CPUx86}
 */
X86.opESC4 = function()
{
    X86.opESC.call(this, X86.OPCODE.ESC4);
};

/**
 * op=0xDD (ESC5)
 *
 * @this {CPUx86}
 */
X86.opESC5 = function()
{
    X86.opESC.call(this, X86.OPCODE.ESC5);
};

/**
 * op=0xDE (ESC6)
 *
 * @this {CPUx86}
 */
X86.opESC6 = function()
{
    X86.opESC.call(this, X86.OPCODE.ESC6);
};

/**
 * op=0xDF (ESC7)
 *
 * @this {CPUx86}
 */
X86.opESC7 = function()
{
    X86.opESC.call(this, X86.OPCODE.ESC7);
};

/**
 * op=0xE0 (LOOPNZ disp)
 *
 * NOTE: All the instructions in this group (LOOPNZ, LOOPZ, LOOP, and JCXZ) actually
 * rely on the ADDRESS override setting for determining whether CX or ECX will be used,
 * even though it seems counter-intuitive; ditto for the REP prefix.
 *
 * @this {CPUx86}
 */
X86.opLOOPNZ = function()
{
    let disp = this.getIPDisp();
    let n = (this.regECX - 1) & this.maskAddr;
    this.regECX = (this.regECX & ~this.maskAddr) | n;
    if (n && !this.getZF()) {
        this.setIP(this.getIP() + disp);
        this.nStepCycles -= this.cycleCounts.nOpCyclesLoopNZ;
        return;
    }
    this.nStepCycles -= this.cycleCounts.nOpCyclesLoopFall;
};

/**
 * op=0xE1 (LOOPZ disp)
 *
 * NOTE: All the instructions in this group (LOOPNZ, LOOPZ, LOOP, and JCXZ) actually
 * rely on the ADDRESS override setting for determining whether CX or ECX will be used,
 * even though it seems counter-intuitive; ditto for the REP prefix.
 *
 * @this {CPUx86}
 */
X86.opLOOPZ = function()
{
    let disp = this.getIPDisp();
    let n = (this.regECX - 1) & this.maskAddr;
    this.regECX = (this.regECX & ~this.maskAddr) | n;
    if (n && this.getZF()) {
        this.setIP(this.getIP() + disp);
        this.nStepCycles -= this.cycleCounts.nOpCyclesLoopZ;
        return;
    }
    this.nStepCycles -= this.cycleCounts.nOpCyclesLoopZFall;
};

/**
 * op=0xE2 (LOOP disp)
 *
 * NOTE: All the instructions in this group (LOOPNZ, LOOPZ, LOOP, and JCXZ) actually
 * rely on the ADDRESS override setting for determining whether CX or ECX will be used,
 * even though it seems counter-intuitive; ditto for the REP prefix.
 *
 * @this {CPUx86}
 */
X86.opLOOP = function()
{
    let disp = this.getIPDisp();
    let n = (this.regECX - 1) & this.maskAddr;
    this.regECX = (this.regECX & ~this.maskAddr) | n;
    if (n) {
        this.setIP(this.getIP() + disp);
        this.nStepCycles -= this.cycleCounts.nOpCyclesLoop;
        return;
    }
    this.nStepCycles -= this.cycleCounts.nOpCyclesLoopFall;
};

/**
 * op=0xE3 (JCXZ/JECXZ disp)
 *
 * NOTE: All the instructions in this group (LOOPNZ, LOOPZ, LOOP, and JCXZ) actually
 * rely on the ADDRESS override setting for determining whether CX or ECX will be used,
 * even though it seems counter-intuitive; ditto for the REP prefix.
 *
 * @this {CPUx86}
 */
X86.opJCXZ = function()
{
    let disp = this.getIPDisp();
    if (!(this.regECX & this.maskAddr)) {
        this.setIP(this.getIP() + disp);
        this.nStepCycles -= this.cycleCounts.nOpCyclesLoopZ;
        return;
    }
    this.nStepCycles -= this.cycleCounts.nOpCyclesLoopZFall;
};

/**
 * op=0xE4 (IN AL,port)
 *
 * @this {CPUx86}
 */
X86.opINb = function()
{
    let port = this.getIPByte();
    if (!this.checkIOPM(port, 1, true)) return;
    this.regEAX = (this.regEAX & ~0xff) | (this.bus.checkPortInputNotify(port, 1, this.regLIP - 2) & 0xff);
    if (BACKTRACK) this.backTrack.btiAL = this.backTrack.btiIO;
    this.nStepCycles -= this.cycleCounts.nOpCyclesInP;
};

/**
 * op=0xE5 (IN AX,port)
 *
 * @this {CPUx86}
 */
X86.opINw = function()
{
    let port = this.getIPByte();
    if (!this.checkIOPM(port, this.sizeData, true)) return;
    this.regEAX = (this.regEAX & ~this.maskData) | (this.bus.checkPortInputNotify(port, this.sizeData, this.regLIP - 2) & this.maskData);
    if (BACKTRACK) {
        this.backTrack.btiAL = this.backTrack.btiIO;
        this.backTrack.btiAH = this.backTrack.btiIO;
    }
    this.nStepCycles -= this.cycleCounts.nOpCyclesInP;
};

/**
 * op=0xE6 (OUT port,AL)
 *
 * @this {CPUx86}
 */
X86.opOUTb = function()
{
    let port = this.getIPByte();
    if (!this.checkIOPM(port, 1, false)) return;
    this.bus.checkPortOutputNotify(port, 1, this.regEAX & 0xff, this.regLIP - 2);
    this.nStepCycles -= this.cycleCounts.nOpCyclesOutP;
};

/**
 * op=0xE7 (OUT port,AX)
 *
 * @this {CPUx86}
 */
X86.opOUTw = function()
{
    let port = this.getIPByte();
    if (!this.checkIOPM(port, this.sizeData, false)) return;
    this.bus.checkPortOutputNotify(port, this.sizeData, this.regEAX & this.maskData, this.regLIP - 2);
    this.nStepCycles -= this.cycleCounts.nOpCyclesOutP;
};

/**
 * op=0xE8 (CALL disp16)
 *
 * @this {CPUx86}
 */
X86.opCALL = function()
{
    let disp = this.getIPWord();
    let oldIP = this.getIP();
    let newIP = oldIP + disp;
    this.pushWord(oldIP);
    this.setIP(newIP);
    this.nStepCycles -= this.cycleCounts.nOpCyclesCall;
};

/**
 * op=0xE9 (JMP disp16)
 *
 * @this {CPUx86}
 */
X86.opJMP = function()
{
    let disp = this.getIPWord();
    this.setIP(this.getIP() + disp);
    this.nStepCycles -= this.cycleCounts.nOpCyclesJmp;
};

/**
 * op=0xEA (JMP seg:off)
 *
 * @this {CPUx86}
 */
X86.opJMPF = function()
{
    this.setCSIP(this.getIPWord(), this.getIPShort());
    this.nStepCycles -= this.cycleCounts.nOpCyclesJmpF;
};

/**
 * op=0xEB (JMP short disp8)
 *
 * @this {CPUx86}
 */
X86.opJMPs = function()
{
    let disp = this.getIPDisp();
    this.setIP(this.getIP() + disp);
    this.nStepCycles -= this.cycleCounts.nOpCyclesJmp;
};

/**
 * op=0xEC (IN AL,dx)
 *
 * @this {CPUx86}
 */
X86.opINDXb = function()
{
    let port = this.regEDX & 0xffff;
    if (!this.checkIOPM(port, 1, true)) return;
    this.regEAX = (this.regEAX & ~0xff) | (this.bus.checkPortInputNotify(port, 1, this.regLIP - 1) & 0xff);
    if (BACKTRACK) this.backTrack.btiAL = this.backTrack.btiIO;
    this.nStepCycles -= this.cycleCounts.nOpCyclesInDX;
};

/**
 * op=0xED (IN AX,dx)
 *
 * @this {CPUx86}
 */
X86.opINDXw = function()
{
    let port = this.regEDX & 0xffff;
    if (!this.checkIOPM(port, this.sizeData, true)) return;
    this.regEAX = (this.regEAX & ~this.maskData) | (this.bus.checkPortInputNotify(port, this.sizeData, this.regLIP - 1) & this.maskData);
    if (BACKTRACK) {
        this.backTrack.btiAL = this.backTrack.btiIO;
        this.backTrack.btiAH = this.backTrack.btiIO;
    }
    this.nStepCycles -= this.cycleCounts.nOpCyclesInDX;
};

/**
 * op=0xEE (OUT dx,AL)
 *
 * @this {CPUx86}
 */
X86.opOUTDXb = function()
{
    let port = this.regEDX & 0xffff;
    if (!this.checkIOPM(port, 1, false)) return;
    if (BACKTRACK) this.backTrack.btiIO = this.backTrack.btiAL;
    this.bus.checkPortOutputNotify(port, 1, this.regEAX & 0xff, this.regLIP - 1);
    this.nStepCycles -= this.cycleCounts.nOpCyclesOutDX;
};

/**
 * op=0xEF (OUT dx,AX)
 *
 * @this {CPUx86}
 */
X86.opOUTDXw = function()
{
    let port = this.regEDX & 0xffff;
    if (!this.checkIOPM(port, 2, false)) return;
    if (BACKTRACK) {
        this.backTrack.btiIO = this.backTrack.btiAL;
        this.backTrack.btiIO = this.backTrack.btiAH;
    }
    this.bus.checkPortOutputNotify(port, this.sizeData, this.regEAX & this.maskData, this.regLIP - 1);
    this.nStepCycles -= this.cycleCounts.nOpCyclesOutDX;
};

/**
 * op=0xF0 (LOCK:)
 *
 * TODO: For X86.MODEL_80286, we let the 80286 and 80287 Programmers Reference Manual speak for itself:
 *
 *      LOCK (Assert Bus Lock) is a 1-byte prefix code that causes the processor to assert
 *      the bus LOCK signal during execution of the instruction that follows. LOCK does not
 *      affect any flags. LOCK may be used only when CPL <= IOPL. A protection exception
 *      [#GP(0)] will occur if LOCK is used when CPL > IOPL.
 *
 * TODO: For X86.MODEL_80386, there is no mention of triggering a #GP(0) exception when CPL > IOPL.
 * Instead, this prefix is now allowed *only* with the following instructions:
 *
 *      BT, BTS, BTR, BTC, XCHG, ADD, OR, ADC, SBB, AND, SUB, XOR, NOT, NEG, INC, DEC
 *
 * and only when accessing memory.  Any other uses of LOCK are supposed to generate a #UD exception;
 * that includes any register-to-register forms of the above instructions, such as XCHG AX,AX (aka NOP).
 *
 * Emulating all those exception cases would be a lot of work for little if any benefit.  The only, um,
 * exception that I'm making is for NOP (see opNOP), since there are apparently some operating systems
 * that thought relying on LOCK NOP faulting was a clever thing to do.  See https://wiki.osdev.org/System_Calls.
 *
 * MINIX 1.1 performs LOCK NOP, but not to generate a fault, because it predates the 80386; instead, it had
 * something to do with the IBM PC simulator that Andrew Tanenbaum used to test MINIX.  MINIX 1.1 was designed
 * for PC ATs, so either stick with an 80286 machine, or patch the LOCK instruction with a NOP.
 * See https://www.pcjs.org/software/pcx86/sys/unix/minix/1.1/pc-at/.
 *
 * @this {CPUx86}
 */
X86.opLOCK = function()
{
    this.opFlags |= X86.OPFLAG.LOCK | X86.OPFLAG.NOINTR;
    this.nStepCycles -= this.cycleCounts.nOpCyclesPrefix;
};

/**
 * op=0xF1 (INT1; undocumented; 80386 and up)
 *
 * For the 8086/8088, we treat opcode 0xF1 as an alias for LOCK (0xF0).
 *
 * For the 80186 and 80286, and we treat it as undefined.  Starting with the 80386, this opcode is known as INT1
 * or ICEBP, since it effectively performs an INT 0x01 but is normally only performed with an ICE.
 *
 * @this {CPUx86}
 */
X86.opINT1 = function()
{
    /**
     * TODO: Verify this instruction's behavior.
     */
    X86.helpTrap.call(this, X86.EXCEPTION.DB_EXC, 1, this.cycleCounts.nOpCyclesInt3D);
};

/**
 * op=0xF2 (REPNZ:) (repeat CMPS or SCAS until NZ; repeat MOVS, LODS, or STOS unconditionally)
 *
 * @this {CPUx86}
 */
X86.opREPNZ = function()
{
    this.opFlags |= X86.OPFLAG.REPNZ | X86.OPFLAG.NOINTR;
    this.nStepCycles -= this.cycleCounts.nOpCyclesPrefix;
};

/**
 * op=0xF3 (REPZ:) (repeat CMPS or SCAS until Z; repeat MOVS, LODS, or STOS unconditionally)
 *
 * @this {CPUx86}
 */
X86.opREPZ = function()
{
    this.opFlags |= X86.OPFLAG.REPZ | X86.OPFLAG.NOINTR;
    this.nStepCycles -= this.cycleCounts.nOpCyclesPrefix;
};

/**
 * op=0xF4 (HLT)
 *
 * TODO: For X86.MODEL_80286, we let the 80286 and 80287 Programmers Reference Manual speak for itself:
 *
 *      HLT (Halt) causes the processor to suspend processing operations pending an interrupt or a system reset.
 *      This trusted instruction provides an alternative to an endless software loop in situations where a program
 *      must wait for an interrupt. The return address saved after the interrupt will point to the instruction
 *      immediately following HLT.
 *
 *      HLT is a privileged instruction. #GP(O) if the current privilege level is not O.
 *
 * On the 80386, we now throw GP_FAULT when operating in V86 mode, but we still don't check CPL on an 80286.
 *
 * @this {CPUx86}
 */
X86.opHLT = function()
{
    if (I386 && (this.regPS & X86.PS.VM)) {
        X86.helpFault.call(this, X86.EXCEPTION.GP_FAULT, 0);
        return;
    }
    /**
     * The CPU is never REALLY halted by a HLT instruction; instead, by setting X86.INTFLAG.HALT,
     * we are signalling to stepCPU() that it's free to end the current burst AND that it should not
     * execute any more instructions until checkINTR() indicates a hardware interrupt is requested.
     */
    this.intFlags |= X86.INTFLAG.HALT;
    this.nStepCycles -= 2;
    /**
     * If a Debugger is present and both the CPU and HALT message categories are enabled, then we
     * REALLY halt the CPU, on the theory that whoever's using the Debugger would like to see HLTs.
     */
    if (DEBUGGER && this.dbg && this.messageEnabled(MESSAGE.CPU + MESSAGE.HALT)) {
        this.resetIP();         // this is purely for the Debugger's benefit, to show the HLT
        this.dbg.stopCPU();
        return;
    }
    /**
     * We also REALLY halt the machine if interrupts have been disabled, since that means it's dead in
     * the water (yes, we support NMIs, but none of our devices are going to generate an NMI at this point).
     */
    if (!this.getIF()) {
        if (DEBUGGER && this.dbg) this.resetIP();
        this.stopCPU();
    }
};

/**
 * op=0xF5 (CMC)
 *
 * @this {CPUx86}
 */
X86.opCMC = function()
{
    if (this.getCF()) this.clearCF(); else this.setCF();
    this.nStepCycles -= 2;                          // CMC takes 2 cycles on all CPUs
};

/**
 * op=0xF6 (GRP3 byte)
 *
 * The MUL byte instruction is problematic in two cases:
 *
 *      0xF6 0xE0:  MUL AL
 *      0xF6 0xE4:  MUL AH
 *
 * because the OpModGrpByte decoder function will attempt to put the fnMULb() function's
 * return value back into AL or AH, undoing fnMULb's update of AX.  And since fnMULb doesn't
 * know what the target is (only the target's value), it cannot easily work around the problem.
 *
 * A simple, albeit kludgy, solution is for fnMULb to always save its result in a special
 * "register" (eg, regMDLo), which we will then put back into regEAX if it's been updated.
 * This also relieves us from having to decode any part of the ModRM byte, so maybe it's not
 * such a bad work-around after all.
 *
 * Similar issues with IMUL (and DIV and IDIV) are resolved using the same special variable(s).
 *
 * @this {CPUx86}
 */
X86.opGRP3b = function()
{
    this.fMDSet = false;
    this.decodeModGrpByte.call(this, X86.aOpGrp3b, X86.helpSRCNone);
    if (this.fMDSet) this.regEAX = (this.regEAX & ~this.maskData) | (this.regMDLo & this.maskData);
};

/**
 * op=0xF7 (GRP3 word)
 *
 * The MUL word instruction is problematic in two cases:
 *
 *      0xF7 0xE0:  MUL AX
 *      0xF7 0xE2:  MUL DX
 *
 * because the OpModGrpWord decoder function will attempt to put the fnMULw() function's
 * return value back into AX or DX, undoing fnMULw's update of DX:AX.  And since fnMULw doesn't
 * know what the target is (only the target's value), it cannot easily work around the problem.
 *
 * A simple, albeit kludgy, solution is for fnMULw to always save its result in a special
 * "register" (eg, regMDLo/regMDHi), which we will then put back into regEAX/regEDX if it's been
 * updated.  This also relieves us from having to decode any part of the ModRM byte, so maybe
 * it's not such a bad work-around after all.
 *
 * @this {CPUx86}
 */
X86.opGRP3w = function()
{
    this.fMDSet = false;
    this.decodeModGrpWord.call(this, X86.aOpGrp3w, X86.helpSRCNone);
    if (this.fMDSet) {
        this.regEAX = (this.regEAX & ~this.maskData) | (this.regMDLo & this.maskData);
        this.regEDX = (this.regEDX & ~this.maskData) | (this.regMDHi & this.maskData);
    }
};

/**
 * op=0xF8 (CLC)
 *
 * @this {CPUx86}
 */
X86.opCLC = function()
{
    this.clearCF();
    this.nStepCycles -= 2;                              // CLC takes 2 cycles on all CPUs
};

/**
 * op=0xF9 (STC)
 *
 * @this {CPUx86}
 */
X86.opSTC = function()
{
    this.setCF();
    this.nStepCycles -= 2;                              // STC takes 2 cycles on all CPUs
};

/**
 * op=0xFA (CLI)
 *
 * @this {CPUx86}
 */
X86.opCLI = function()
{
    /**
     * The following code should be sufficient for all modes, because in real-mode, CPL is always zero,
     * and in V86-mode, CPL is always 3.
     */
    if (this.nCPL > this.nIOPL) {
        if (DEBUG && (this.regPS & X86.PS.VM)) this.printf(MESSAGE.ADDR, "CLI in v86-mode (IOPL < 3)\n");
        X86.helpFault.call(this, X86.EXCEPTION.GP_FAULT, 0);
        return;
    }
    this.clearIF();
    this.nStepCycles -= this.cycleCounts.nOpCyclesCLI;  // CLI takes LONGER on an 80286
};

/**
 * op=0xFB (STI)
 *
 * @this {CPUx86}
 */
X86.opSTI = function()
{
    /**
     * The following code should be sufficient for all modes, because in real-mode, CPL is always zero,
     * and in V86-mode, CPL is always 3.
     */
    if (this.nCPL > this.nIOPL) {
        if (DEBUG && (this.regPS & X86.PS.VM)) this.printf(MESSAGE.ADDR, "STI in v86-mode (IOPL < 3)\n");
        X86.helpFault.call(this, X86.EXCEPTION.GP_FAULT, 0);
        return;
    }
    this.setIF();
    this.opFlags |= X86.OPFLAG.NOINTR;
    this.nStepCycles -= 2;                              // STI takes 2 cycles on all CPUs
};

/**
 * op=0xFC (CLD)
 *
 * @this {CPUx86}
 */
X86.opCLD = function()
{
    this.clearDF();
    this.nStepCycles -= 2;                              // CLD takes 2 cycles on all CPUs
};

/**
 * op=0xFD (STD)
 *
 * @this {CPUx86}
 */
X86.opSTD = function()
{
    this.setDF();
    this.nStepCycles -= 2;                              // STD takes 2 cycles on all CPUs
};

/**
 * op=0xFE (GRP4 byte)
 *
 * @this {CPUx86}
 */
X86.opGRP4b = function()
{
    this.decodeModGrpByte.call(this, X86.aOpGrp4b, X86.helpSRCNone);
};

/**
 * op=0xFF (GRP4 word)
 *
 * @this {CPUx86}
 */
X86.opGRP4w = function()
{
    this.decodeModGrpWord.call(this, X86.aOpGrp4w, X86.helpSRCNone);
};

/**
 * opInvalid()
 *
 * @this {CPUx86}
 */
X86.opInvalid = function()
{
    X86.helpFault.call(this, X86.EXCEPTION.UD_FAULT);
};

/**
 * opUndefined()
 *
 * @this {CPUx86}
 */
X86.opUndefined = function()
{
    this.setIP(this.opLIP - this.segCS.base);
    this.setError("Undefined opcode " + StrLib.toHexByte(this.getByte(this.regLIP)) + " at " + StrLib.toHexLong(this.regLIP));
    this.stopCPU();
};

/**
 * opTBD()
 *
 * @this {CPUx86}
 */
X86.opTBD = function()
{
    this.setIP(this.opLIP - this.segCS.base);
    this.printf(MESSAGE.NONE, "unimplemented 80386 opcode\n");
    this.stopCPU();
};

/**
 * This 256-entry array of opcode functions is at the heart of the CPU engine: stepCPU(n).
 *
 * It might be worth trying a switch() statement instead, to see how the performance compares,
 * but I suspect that would vary quite a bit across JavaScript engines; for now, I'm putting my
 * money on array lookup.
 */
X86.aOps = [
    X86.opADDmb,            X86.opADDmw,            X86.opADDrb,            X86.opADDrw,        // 0x00-0x03
    X86.opADDALb,           X86.opADDAX,            X86.opPUSHES,           X86.opPOPES,        // 0x04-0x07
    X86.opORmb,             X86.opORmw,             X86.opORrb,             X86.opORrw,         // 0x08-0x0B
    X86.opORALb,            X86.opORAX,             X86.opPUSHCS,           X86.opPOPCS,        // 0x0C-0x0F
    X86.opADCmb,            X86.opADCmw,            X86.opADCrb,            X86.opADCrw,        // 0x10-0x13
    X86.opADCALb,           X86.opADCAX,            X86.opPUSHSS,           X86.opPOPSS,        // 0x14-0x17
    X86.opSBBmb,            X86.opSBBmw,            X86.opSBBrb,            X86.opSBBrw,        // 0x18-0x1B
    X86.opSBBALb,           X86.opSBBAX,            X86.opPUSHDS,           X86.opPOPDS,        // 0x1C-0x1F
    X86.opANDmb,            X86.opANDmw,            X86.opANDrb,            X86.opANDrw,        // 0x20-0x23
    X86.opANDAL,            X86.opANDAX,            X86.opES,               X86.opDAA,          // 0x24-0x27
    X86.opSUBmb,            X86.opSUBmw,            X86.opSUBrb,            X86.opSUBrw,        // 0x28-0x2B
    X86.opSUBALb,           X86.opSUBAX,            X86.opCS,               X86.opDAS,          // 0x2C-0x2F
    X86.opXORmb,            X86.opXORmw,            X86.opXORrb,            X86.opXORrw,        // 0x30-0x33
    X86.opXORALb,           X86.opXORAX,            X86.opSS,               X86.opAAA,          // 0x34-0x37
    X86.opCMPmb,            X86.opCMPmw,            X86.opCMPrb,            X86.opCMPrw,        // 0x38-0x3B
    X86.opCMPALb,           X86.opCMPAX,            X86.opDS,               X86.opAAS,          // 0x3C-0x3F
    X86.opINCAX,            X86.opINCCX,            X86.opINCDX,            X86.opINCBX,        // 0x40-0x43
    X86.opINCSP,            X86.opINCBP,            X86.opINCSI,            X86.opINCDI,        // 0x44-0x47
    X86.opDECAX,            X86.opDECCX,            X86.opDECDX,            X86.opDECBX,        // 0x48-0x4B
    X86.opDECSP,            X86.opDECBP,            X86.opDECSI,            X86.opDECDI,        // 0x4C-0x4F
    X86.opPUSHAX,           X86.opPUSHCX,           X86.opPUSHDX,           X86.opPUSHBX,       // 0x50-0x53
    X86.opPUSHSP_8086,      X86.opPUSHBP,           X86.opPUSHSI,           X86.opPUSHDI,       // 0x54-0x57
    X86.opPOPAX,            X86.opPOPCX,            X86.opPOPDX,            X86.opPOPBX,        // 0x58-0x5B
    X86.opPOPSP,            X86.opPOPBP,            X86.opPOPSI,            X86.opPOPDI,        // 0x5C-0x5F
    /**
     * On an 8086/8088, opcodes 0x60-0x6F are aliases for the conditional jumps 0x70-0x7F.  Sometimes you'll see
     * references to these opcodes (like 0x60) being a "two-byte NOP" and using them differentiate an 8088 from newer
     * CPUs, but they're only a "two-byte NOP" if the second byte is zero, resulting in zero displacement.
     */
    X86.opJO,               X86.opJNO,              X86.opJC,               X86.opJNC,          // 0x60-0x63
    X86.opJZ,               X86.opJNZ,              X86.opJBE,              X86.opJNBE,         // 0x64-0x67
    X86.opJS,               X86.opJNS,              X86.opJP,               X86.opJNP,          // 0x68-0x6B
    X86.opJL,               X86.opJNL,              X86.opJLE,              X86.opJNLE,         // 0x6C-0x6F
    X86.opJO,               X86.opJNO,              X86.opJC,               X86.opJNC,          // 0x70-0x73
    X86.opJZ,               X86.opJNZ,              X86.opJBE,              X86.opJNBE,         // 0x74-0x77
    X86.opJS,               X86.opJNS,              X86.opJP,               X86.opJNP,          // 0x78-0x7B
    X86.opJL,               X86.opJNL,              X86.opJLE,              X86.opJNLE,         // 0x7C-0x7F
    /**
     * On all processors, opcode groups 0x80 and 0x82 perform identically (0x82 opcodes sign-extend their
     * immediate data, but since both 0x80 and 0x82 are byte operations, the sign extension has no effect).
     *
     * WARNING: Intel's "Pentium Processor User's Manual (Volume 3: Architecture and Programming Manual)" refers
     * to opcode 0x82 as a "reserved" instruction, but also cryptically refers to it as "MOVB AL,imm".  This is
     * assumed to be an error in the manual, because as far as I know, 0x82 has always mirrored 0x80.
     */
    X86.opGRP1b,            X86.opGRP1w,            X86.opGRP1b,            X86.opGRP1sw,       // 0x80-0x83
    X86.opTESTrb,           X86.opTESTrw,           X86.opXCHGrb,           X86.opXCHGrw,       // 0x84-0x87
    X86.opMOVmb,            X86.opMOVmw,            X86.opMOVrb,            X86.opMOVrw,        // 0x88-0x8B
    X86.opMOVwsr,           X86.opLEA,              X86.opMOVsrw,           X86.opPOPmw,        // 0x8C-0x8F
    X86.opNOP,              X86.opXCHGCX,           X86.opXCHGDX,           X86.opXCHGBX,       // 0x90-0x93
    X86.opXCHGSP,           X86.opXCHGBP,           X86.opXCHGSI,           X86.opXCHGDI,       // 0x94-0x97
    X86.opCBW,              X86.opCWD,              X86.opCALLF,            X86.opWAIT,         // 0x98-0x9B
    X86.opPUSHF,            X86.opPOPF,             X86.opSAHF,             X86.opLAHF,         // 0x9C-0x9F
    X86.opMOVALm,           X86.opMOVAXm,           X86.opMOVmAL,           X86.opMOVmAX,       // 0xA0-0xA3
    X86.opMOVSb,            X86.opMOVSw,            X86.opCMPSb,            X86.opCMPSw,        // 0xA4-0xA7
    X86.opTESTALb,          X86.opTESTAX,           X86.opSTOSb,            X86.opSTOSw,        // 0xA8-0xAB
    X86.opLODSb,            X86.opLODSw,            X86.opSCASb,            X86.opSCASw,        // 0xAC-0xAF
    X86.opMOVALb,           X86.opMOVCLb,           X86.opMOVDLb,           X86.opMOVBLb,       // 0xB0-0xB3
    X86.opMOVAHb,           X86.opMOVCHb,           X86.opMOVDHb,           X86.opMOVBHb,       // 0xB4-0xB7
    X86.opMOVAX,            X86.opMOVCX,            X86.opMOVDX,            X86.opMOVBX,        // 0xB8-0xBB
    X86.opMOVSP,            X86.opMOVBP,            X86.opMOVSI,            X86.opMOVDI,        // 0xBC-0xBF
    /**
     * On an 8086/8088, opcodes 0xC0 -> 0xC2, 0xC1 -> 0xC3, 0xC8 -> 0xCA and 0xC9 -> 0xCB.
     */
    X86.opRETn,             X86.opRET,              X86.opRETn,             X86.opRET,          // 0xC0-0xC3
    X86.opLES,              X86.opLDS,              X86.opMOVb,             X86.opMOVw,         // 0xC4-0xC7
    X86.opRETFn,            X86.opRETF,             X86.opRETFn,            X86.opRETF,         // 0xC8-0xCB
    X86.opINT3,             X86.opINTn,             X86.opINTO,             X86.opIRET,         // 0xCC-0xCF
    X86.opGRP2b1,           X86.opGRP2w1,           X86.opGRP2bCL,          X86.opGRP2wCL,      // 0xD0-0xD3
    /**
     * Even as of the Pentium, opcode 0xD6 is still marked as "reserved", but it's always been SALC (aka SETALC).
     */
    X86.opAAM,              X86.opAAD,              X86.opSALC,             X86.opXLAT,         // 0xD4-0xD7
    X86.opESC0,             X86.opESC1,             X86.opESC2,             X86.opESC3,         // 0xD8-0xDB
    X86.opESC4,             X86.opESC5,             X86.opESC6,             X86.opESC7,         // 0xDC-0xDF
    X86.opLOOPNZ,           X86.opLOOPZ,            X86.opLOOP,             X86.opJCXZ,         // 0xE0-0xE3
    X86.opINb,              X86.opINw,              X86.opOUTb,             X86.opOUTw,         // 0xE4-0xE7
    X86.opCALL,             X86.opJMP,              X86.opJMPF,             X86.opJMPs,         // 0xE8-0xEB
    X86.opINDXb,            X86.opINDXw,            X86.opOUTDXb,           X86.opOUTDXw,       // 0xEC-0xEF
    /**
     * On an 8086/8088, opcode 0xF1 is believed to be an alias for 0xF0; in any case, it definitely behaves like
     * a prefix on those processors, so we treat it as such.  On the 80186 and 80286, we treat it as opUndefined(),
     * and on the 80386, it becomes opINT1().
     *
     * As of the Pentium, opcode 0xF1 is still marked "reserved".
     */
    X86.opLOCK,             X86.opLOCK,             X86.opREPNZ,            X86.opREPZ,         // 0xF0-0xF3
    X86.opHLT,              X86.opCMC,              X86.opGRP3b,            X86.opGRP3w,        // 0xF4-0xF7
    X86.opCLC,              X86.opSTC,              X86.opCLI,              X86.opSTI,          // 0xF8-0xFB
    X86.opCLD,              X86.opSTD,              X86.opGRP4b,            X86.opGRP4w         // 0xFC-0xFF
];

/**
 * A word (or two) on instruction groups (eg, Grp1, Grp2), which are groups of instructions that
 * use a mod/reg/rm byte, where the reg field of that byte selects a function rather than a register.
 *
 * I start with the groupings used by Intel's "Pentium Processor User's Manual (Volume 3: Architecture
 * and Programming Manual)", but I deviate slightly, mostly by subdividing their groups with letter suffixes:
 *
 *      Opcodes     Intel       PCx86                                               PC Mag TechRef
 *      -------     -----       ----                                                --------------
 *      0x80-0x83   Grp1        Grp1b and Grp1w                                     Group A
 *      0xC0-0xC1   Grp2        Grp2b and Grp2w (opGRP2bn/wn)                       Group B
 *      0xD0-0xD3   Grp2        Grp2b and Grp2w (opGRP2b1/w1 and opGRP2bCL/wCL)     Group B
 *      0xF6-0xF7   Grp3        Grp3b and Grp3w                                     Group C
 *      0xFE        Grp4        Grp4b                                               Group D
 *      0xFF        Grp5        Grp4w                                               Group E
 *      0x0F,0x00   Grp6        Grp6 (SLDT, STR, LLDT, LTR, VERR, VERW)             Group F
 *      0x0F,0x01   Grp7        Grp7 (SGDT, SIDT, LGDT, LIDT, SMSW, LMSW, INVLPG)   Group G
 *      0x0F,0xBA   Grp8        Grp8 (BT, BTS, BTR, BTC)                            Group H
 *      0x0F,0xC7   Grp9        Grp9 (CMPXCH)                                       (N/A, 80486 and up)
 *
 * My only serious deviation is Grp5, which I refer to as Grp4w, because it contains word forms of
 * the INC and DEC instructions found in Grp4b.  Granted, Grp4w also contains versions of the CALL,
 * JMP and PUSH instructions, which are not in Grp4b, but there's nothing in Grp4b that conflicts with
 * Grp4w, so I think my nomenclature makes more sense.  To compensate, I don't use Grp5, so that the
 * remaining group numbers remain in sync with Intel's.
 *
 * To the above list, I've added a few "single-serving" groups: opcode 0x8F uses GrpPOPw, and opcodes 0xC6/0xC7
 * use GrpMOVn.  In both of these groups, the only valid (documented) instruction is where reg=0x0.
 *
 * TODO: Test what happens on real hardware when the reg field is non-zero for opcodes 0x8F and 0xC6/0xC7.
 */
X86.aOpGrp1b = [
    X86.fnADDb,             X86.fnORb,              X86.fnADCb,             X86.fnSBBb,             // 0x80/0x82(reg=0x0-0x3)
    X86.fnANDb,             X86.fnSUBb,             X86.fnXORb,             X86.fnCMPb              // 0x80/0x82(reg=0x4-0x7)
];

X86.aOpGrp1w = [
    X86.fnADDw,             X86.fnORw,              X86.fnADCw,             X86.fnSBBw,             // 0x81/0x83(reg=0x0-0x3)
    X86.fnANDw,             X86.fnSUBw,             X86.fnXORw,             X86.fnCMPw              // 0x81/0x83(reg=0x4-0x7)
];

X86.aOpGrpPOPw = [
    X86.fnPOPw,             X86.fnGRPFault,         X86.fnGRPFault,         X86.fnGRPFault,         // 0x8F(reg=0x0-0x3)
    X86.fnGRPFault,         X86.fnGRPFault,         X86.fnGRPFault,         X86.fnGRPFault          // 0x8F(reg=0x4-0x7)
];

X86.aOpGrpMOVn = [
    X86.fnMOVn,             X86.fnGRPUndefined,     X86.fnGRPUndefined,     X86.fnGRPUndefined,     // 0xC6/0xC7(reg=0x0-0x3)
    X86.fnGRPUndefined,     X86.fnGRPUndefined,     X86.fnGRPUndefined,     X86.fnGRPUndefined      // 0xC6/0xC7(reg=0x4-0x7)
];

X86.aOpGrp2b = [
    X86.fnROLb,             X86.fnRORb,             X86.fnRCLb,             X86.fnRCRb,             // 0xC0/0xD0/0xD2(reg=0x0-0x3)
    X86.fnSHLb,             X86.fnSHRb,             X86.fnGRPUndefined,     X86.fnSARb              // 0xC0/0xD0/0xD2(reg=0x4-0x7)
];

X86.aOpGrp2w = [
    X86.fnROLw,             X86.fnRORw,             X86.fnRCLw,             X86.fnRCRw,             // 0xC1/0xD1/0xD3(reg=0x0-0x3)
    X86.fnSHLw,             X86.fnSHRw,             X86.fnGRPUndefined,     X86.fnSARw              // 0xC1/0xD1/0xD3(reg=0x4-0x7)
];

X86.aOpGrp2d = [
    X86.fnROLd,             X86.fnRORd,             X86.fnRCLd,             X86.fnRCRd,             // 0xC1/0xD1/0xD3(reg=0x0-0x3)
    X86.fnSHLd,             X86.fnSHRd,             X86.fnGRPUndefined,     X86.fnSARd              // 0xC1/0xD1/0xD3(reg=0x4-0x7)
];

X86.aOpGrp3b = [
    X86.fnTESTib,           X86.fnGRPUndefined,     X86.fnNOTb,             X86.fnNEGb,             // 0xF6(reg=0x0-0x3)
    X86.fnMULb,             X86.fnIMULb,            X86.fnDIVb,             X86.fnIDIVb             // 0xF6(reg=0x4-0x7)
];

X86.aOpGrp3w = [
    X86.fnTESTiw,           X86.fnGRPUndefined,     X86.fnNOTw,             X86.fnNEGw,             // 0xF7(reg=0x0-0x3)
    X86.fnMULw,             X86.fnIMULw,            X86.fnDIVw,             X86.fnIDIVw             // 0xF7(reg=0x4-0x7)
];

X86.aOpGrp4b = [
    X86.fnINCb,             X86.fnDECb,             X86.fnGRPUndefined,     X86.fnGRPUndefined,     // 0xFE(reg=0x0-0x3)
    X86.fnGRPUndefined,     X86.fnGRPUndefined,     X86.fnGRPUndefined,     X86.fnGRPUndefined      // 0xFE(reg=0x4-0x7)
];

X86.aOpGrp4w = [
    X86.fnINCw,             X86.fnDECw,             X86.fnCALLw,            X86.fnCALLFdw,          // 0xFF(reg=0x0-0x3)
    X86.fnJMPw,             X86.fnJMPFdw,           X86.fnPUSHw,            X86.fnGRPUndefined      // 0xFF(reg=0x4-0x7)
];

/**
 * @copyright https://www.pcjs.org/machines/pcx86/modules/v2/x86op0f.js (C) 2012-2024 Jeff Parsons
 */

/**
 * op=0x0F,0x00 (GRP6 mem/reg)
 *
 * @this {CPUx86}
 */
X86.opGRP6 = function()
{
    let bModRM = this.peekIPByte();
    if ((bModRM & 0x38) < 0x10) {   // possible reg values: 0x00, 0x08, 0x10, 0x18, 0x20, 0x28, 0x30, 0x38
        this.opFlags |= X86.OPFLAG.NOREAD;
    }
    this.decodeModGrpWord.call(this, this.aOpGrp6, X86.helpSRCNone);
};

/**
 * op=0x0F,0x01 (GRP7 mem/reg)
 *
 * @this {CPUx86}
 */
X86.opGRP7 = function()
{
    let bModRM = this.peekIPByte();
    if (!(bModRM & 0x10)) {
        this.opFlags |= X86.OPFLAG.NOREAD;
    }
    this.decodeModGrpWord.call(this, X86.aOpGrp7, X86.helpSRCNone);
};

/**
 * opLAR()
 *
 * op=0x0F,0x02 (LAR reg,mem/reg)
 *
 * @this {CPUx86}
 */
X86.opLAR = function()
{
    /**
     * TODO: Consider swapping out this function whenever setProtMode() changes the mode to real-mode or V86-mode.
     */
    if (!(this.regCR0 & X86.CR0.MSW.PE) || I386 && (this.regPS & X86.PS.VM)) {
        X86.opInvalid.call(this);
        return;
    }
    this.decodeModRegWord.call(this, X86.fnLAR);
};

/**
 * opLSL()
 *
 * op=0x0F,0x03 (LSL reg,mem/reg)
 *
 * @this {CPUx86}
 */
X86.opLSL = function()
{
    /**
     * TODO: Consider swapping out this function whenever setProtMode() changes the mode to real-mode or V86-mode.
     */
    if (!(this.regCR0 & X86.CR0.MSW.PE) || I386 && (this.regPS & X86.PS.VM)) {
        X86.opInvalid.call(this);
        return;
    }
    this.decodeModRegWord.call(this, X86.fnLSL);
};

/**
 * opLOADALL286()
 *
 * op=0x0F,0x05 (LOADALL)
 *
 * From the "Undocumented iAPX 286 Test Instruction" document at http://www.pcjs.org/pubs/pc/reference/intel/80286/loadall/:
 *
 *  Physical Address (Hex)        Associated CPU Register
 *          800-805                        None
 *          806-807                        MSW
 *          808-815                        None
 *          816-817                        TR
 *          818-819                        Flag word
 *          81A-81B                        IP
 *          81C-81D                        LDT
 *          81E-81F                        DS
 *          820-821                        SS
 *          822-823                        CS
 *          824-825                        ES
 *          826-827                        DI
 *          828-829                        SI
 *          82A-82B                        BP
 *          82C-82D                        SP
 *          82E-82F                        BX
 *          830-831                        DX
 *          832-833                        CX
 *          834-835                        AX
 *          836-83B                        ES descriptor cache
 *          83C-841                        CS descriptor cache
 *          842-847                        SS descriptor cache
 *          848-84D                        DS descriptor cache
 *          84E-853                        GDTR
 *          854-859                        LDT descriptor cache
 *          85A-85F                        IDTR
 *          860-865                        TSS descriptor cache
 *
 * @this {CPUx86}
 */
X86.opLOADALL286 = function()
{
    if (this.nCPL) {
        /**
         * To use LOADALL, CPL must be zero.
         */
        X86.helpFault.call(this, X86.EXCEPTION.GP_FAULT, 0, 0, true);
        return;
    }
    this.setMSW(this.getShort(0x806));
    this.regEDI = this.getShort(0x826);
    this.regESI = this.getShort(0x828);
    this.regEBP = this.getShort(0x82A);
    this.regEBX = this.getShort(0x82E);
    this.regEDX = this.getShort(0x830);
    this.regECX = this.getShort(0x832);
    this.regEAX = this.getShort(0x834);
    this.segES.loadDesc6(0x836, this.getShort(0x824));
    this.segCS.loadDesc6(0x83C, this.getShort(0x822));
    this.segSS.loadDesc6(0x842, this.getShort(0x820));
    this.segDS.loadDesc6(0x848, this.getShort(0x81E));
    /**
     * Unlike LOADALL386, there's no requirement for calling setPS() before loading segment registers;
     * in fact, since we're not passing a CPL to setPS(), it may be preferable to have CS (and perhaps SS)
     * already loaded, so that setPS() can query the CPL.  TODO: Verify that CPL is set correctly.
     */
    this.setPS(this.getShort(0x818));
    /**
     * It's important to call setIP() and setSP() *after* the segCS and segSS loads, so that the CPU's
     * linear IP and SP registers (regLIP and regLSP) will be updated properly.  Ordinarily that would be
     * taken care of by simply using the CPU's setCS() and setSS() functions, but those functions call the
     * default descriptor load() functions, and obviously here we must use loadDesc6() instead.
     */
    this.setIP(this.getShort(0x81A));
    this.setSP(this.getShort(0x82C));
    /**
     * The bytes at 0x851 and 0x85D "should be zeroes", as per the "Undocumented iAPX 286 Test Instruction"
     * document, but the LOADALL issued by RAMDRIVE in PC-DOS 7.0 contains 0xFF in both of those bytes, resulting
     * in very large addrGDT and addrIDT values.  Obviously, we can't have that, so we load only the low byte
     * of the second word for both of those registers.
     */
    this.addrGDT = this.getShort(0x84E) | (this.getByte(0x850) << 16);
    this.addrGDTLimit = this.addrGDT + this.getShort(0x852);
    this.addrIDT = this.getShort(0x85A) | (this.getByte(0x85C) << 16);
    this.addrIDTLimit = this.addrIDT + this.getShort(0x85E);
    this.segLDT.loadDesc6(0x854, this.getShort(0x81C));
    this.segTSS.loadDesc6(0x860, this.getShort(0x816));

    /**
     * Oddly, the above Intel document gives two contradictory cycle counts for LOADALL: 190 and 195.
     * I'm going with 195, since both the PC Magazine Programmer's Technical Reference and Robert Collins
     * (http://www.rcollins.org/articles/loadall/tspec_a3_doc.html) agree.
     */
    this.nStepCycles -= 195;

    /**
     * TODO: LOADALL operation still needs to be verified in protected mode....
     */
    if (DEBUG && DEBUGGER && (this.regCR0 & X86.CR0.MSW.PE)) this.stopCPU();
};

/**
 * opCLTS()
 *
 * op=0x0F,0x06 (CLTS)
 *
 * @this {CPUx86}
 */
X86.opCLTS = function()
{
    /**
     * NOTE: The following code shouldn't need to also test X86.PS.VM, because V86-mode is CPL 3.
     */
    if (this.nCPL) {
        X86.helpFault.call(this, X86.EXCEPTION.GP_FAULT, 0);
        return;
    }
    this.regCR0 &= ~X86.CR0.MSW.TS;
    this.nStepCycles -= 2;
};

/**
 * opLOADALL386()
 *
 * op=0x0F,0x07 (LOADALL ES:[EDI])
 *
 * Excerpt from Intel Internal Correspondence on "386 LOADALL Instruction" (undated), available as part of the
 * PCjs Project at http://www.pcjs.org/pubs/pc/reference/intel/80386/loadall/
 *
 *      1.5. 386 LOADALL Memory Format
 *
 *      The following tables define the LOADALL memory format. The LOADALL instruction uses a 512-byte block of
 *      memory, where the lowest addressed byte is given in ES:[(E)DI]. The area above offset CC hex is used for
 *      processor dependent registers (temporaries, invisible registers). These are loaded into the processor,
 *      but will not affect normal program execution. All values in the memory area are read from a four byte field,
 *      to keep the memory format DWORD aligned, but it is possible to locate memory area at a non-aligned address.
 *      In this case, the execution time of LOADALL will DOUBLE For this reason, the memory dump area should always
 *      be DWORD aligned.
 *
 *         Offset         Register
 *         ------         --------
 *          0x00            CR0
 *          0x04            EFLAGS
 *          0x08            EIP
 *          0x0C            EDI
 *          0x10            ESI
 *          0x14            EBP
 *          0x18            ESP
 *          0x1C            EBX
 *          0x20            EDX
 *          0x24            ECX
 *          0x28            EAX
 *          0x2C            DR6
 *          0x30            DR7
 *          0x34            TSSR(TSSSelector-Word)
 *          0x38            LDTR(LDTSelector-Word)
 *          0x3C            GS
 *          0x40            FS
 *          0x44            DS
 *          0x48            SS
 *          0x4C            CS
 *          0x50            ES
 *          0x54            TSS(AR)
 *          0x58            TSS(BASE)
 *          0x5C            TSS(LIMIT)
 *          0x60            IDT(AR)
 *          0x64            IDT(BASE)
 *          0x68            IDT(LIMIT)
 *          0x6C            GDT(AR)
 *          0x70            GDT(BASE)
 *          0x74            GDT(LIMIT)
 *          0x78            LDT(AR)
 *          0x7C            LDT(BASE)
 *          0x80            LDT(LIMIT)
 *          0x84            GS(AR)
 *          0x88            GS(BASE)
 *          0x8C            GS(LIMIT)
 *          0x90            FS(AR)
 *          0x94            FS(BASE)
 *          0x98            FS(LIMIT)
 *          0x9C            DS(AR)
 *          0xA0            DS(BASE)
 *          0xA4            DS(LIMIT)
 *          0xA8            SS(AR)
 *          0xAC            SS(BASE)
 *          0xB0            SS(LIMIT)
 *          0xB4            CS(AR)
 *          0xB8            CS(BASE)
 *          0xBC            CS(LIMIT)
 *          0xC0            ES(AR)
 *          0xC4            ES(BASE)
 *          0xC8            ES(LIMIT)
 *
 *      Each descriptor entry consists of 3 pieces:
 *
 *          AR
 *          BASE
 *          LIMIT
 *
 *      The AR part has the same format as the second dword of a segment descriptor except that only the AR byte
 *      (bits 8-15) and the G and B/D bits (bits 23 and 22) are used. All other bits in the AR field are ignored.
 *      The BASE and LIMIT parts contain full 32-bit values, fully expanded and unscrambled from the 386 descriptor.
 *      In particular, the LIMIT field loaded for a page granular segment gives a byte granular limit, so should
 *      contain the page limit*4096 plus 4095.
 *
 * @this {CPUx86}
 */
X86.opLOADALL386 = function()
{
    if (this.nCPL) {
        /**
         * To use LOADALL, CPL must be zero.
         */
        X86.helpFault.call(this, X86.EXCEPTION.GP_FAULT, 0, 0, true);
        return;
    }
    let addr = this.segES.checkRead(this.regEDI & this.maskAddr, 0xCC);
    if (addr !== X86.ADDR_INVALID) {
        X86.helpLoadCR0.call(this, this.getLong(addr));
        /**
         * We need to call setPS() before loading any segment registers, because if the Virtual 8086 Mode (VM)
         * bit is set in EFLAGS, the segment registers need to know that.
         */
        let accSS = this.getLong(addr + 0xA8);
        let cpl = (accSS & X86.DESC.ACC.DPL.MASK) >> X86.DESC.ACC.DPL.SHIFT;
        this.setPS(this.getLong(addr + 0x04), cpl);
        /**
         * TODO: We have no use for the GDT(AR) at offset 0x6C or the IDT(AR) at offset 0x60, because
         * we don't manage them as segment registers.  Should we?
         */
        this.addrGDT = this.getLong(addr + 0x70);
        this.addrGDTLimit = this.addrGDT + this.getLong(addr + 0x74);
        this.addrIDT = this.getLong(addr + 0x64);
        this.addrIDTLimit = this.addrIDT + this.getLong(addr + 0x68);
        this.segLDT.loadDesc(this.getLong(addr + 0x38), this.getLong(addr + 0x78), this.getLong(addr + 0x7C), this.getLong(addr + 0x80));
        this.segTSS.loadDesc(this.getLong(addr + 0x34), this.getLong(addr + 0x54), this.getLong(addr + 0x58), this.getLong(addr + 0x5C));
        this.regEDI = this.getLong(addr + 0x0C);
        this.regESI = this.getLong(addr + 0x10);
        this.regEBP = this.getLong(addr + 0x14);
        this.regEBX = this.getLong(addr + 0x1C);
        this.regEDX = this.getLong(addr + 0x20);
        this.regECX = this.getLong(addr + 0x24);
        this.regEAX = this.getLong(addr + 0x28);
        this.segGS.loadDesc(this.getLong(addr + 0x3C), this.getLong(addr + 0x84), this.getLong(addr + 0x88), this.getLong(addr + 0x8C));
        this.segFS.loadDesc(this.getLong(addr + 0x40), this.getLong(addr + 0x90), this.getLong(addr + 0x94), this.getLong(addr + 0x98));
        this.segDS.loadDesc(this.getLong(addr + 0x44), this.getLong(addr + 0x9C), this.getLong(addr + 0xA0), this.getLong(addr + 0xA4));
        this.segSS.loadDesc(this.getLong(addr + 0x48), accSS,                     this.getLong(addr + 0xAC), this.getLong(addr + 0xB0));
        this.segCS.loadDesc(this.getLong(addr + 0x4C), this.getLong(addr + 0xB4), this.getLong(addr + 0xB8), this.getLong(addr + 0xBC));
        this.segES.loadDesc(this.getLong(addr + 0x50), this.getLong(addr + 0xC0), this.getLong(addr + 0xC4), this.getLong(addr + 0xC8));
        /**
         * It's important to call setIP() and setSP() *after* the segCS and segSS loads, so that the CPU's
         * linear IP and SP registers (regLIP and regLSP) will be updated properly.  Ordinarily that would be
         * taken care of by simply using the CPU's setCS() and setSS() functions, but those functions call the
         * default descriptor load() functions, and obviously here we must use loadDesc() instead.
         */
        this.setIP(this.getLong(addr + 0x08));
        this.setSP(this.getLong(addr + 0x18));
        /**
         * TODO: We need to factor out the code that updates DR6 and DR7 from X86.opMOVdr(), so that we can
         * more easily update DR6 and DR7 (which we're simply ignoring for now).
         */
    }

    /**
     * According to Robert Collins (http://www.rcollins.org/articles/loadall/tspec_a3_doc.html), the 80386 LOADALL
     * takes 122 cycles.  Also, according the above-mentioned Intel document, if the memory buffer is not DWORD aligned,
     * execution time will DOUBLE.
     */
    this.nStepCycles -= (122 << ((addr & 0x3)? 1 : 0));
};

/**
 * opMOVrc()
 *
 * op=0x0F,0x20 (MOV reg,ctlreg)
 *
 * NOTE: Since this instruction uses only 32-bit general-purpose registers, our ModRM decoders
 * are going to be more hindrance than help, so we fully decode and execute the instruction ourselves.
 *
 * From PCMag_Prog_TechRef, p.476: "The 80386 executes the MOV to/from control registers (CRn) regardless
 * of the setting of the MOD field.  The MOD field should be set to 11, but an early 80386 documentation
 * error indicated that the MOD field value was a don't care.  Early versions of the 80486 detect
 * a MOD != 11 as an illegal opcode.  This was changed in later versions to ignore the value of MOD.
 * Assemblers that generate MOD != 11 for these instructions will fail on some 80486s."
 *
 * And in fact, the COMPAQ DeskPro 386 ROM BIOS executes this instruction with MOD set to 00, so we have
 * to ignore it.
 *
 * @this {CPUx86}
 */
X86.opMOVrc = function()
{
    /**
     * NOTE: The following code shouldn't need to also test X86.PS.VM, because V86-mode is CPL 3.
     */
    if (this.nCPL) {
        /**
         * You're not allowed to read control registers if the current privilege level is not zero.
         */
        X86.helpFault.call(this, X86.EXCEPTION.GP_FAULT, 0);
        return;
    }

    let reg;
    let bModRM = this.getIPByte();
    switch((bModRM & 0x38) >> 3) {
    case 0x0:
        reg = this.regCR0;
        break;
    case 0x2:
        reg = this.regCR2;
        break;
    case 0x3:
        reg = this.regCR3;
        break;
    default:
        X86.opUndefined.call(this);
        return;
    }

    this.setReg(bModRM & 0x7, reg);

    this.nStepCycles -= 6;

    /**
     * TODO: Implement BACKTRACK for this instruction (although Control registers are not likely to be a conduit for interesting data).
     */
};

/**
 * opMOVrd()
 *
 * op=0x0F,0x21 (MOV reg,dbgreg)
 *
 * NOTE: Since this instruction uses only 32-bit general-purpose registers, our ModRM decoders
 * are going to be more hindrance than help, so we fully decode and execute the instruction ourselves.
 *
 * @this {CPUx86}
 */
X86.opMOVrd = function()
{
    /**
     * NOTE: The following code shouldn't need to also test X86.PS.VM, because V86-mode is CPL 3.
     */
    if (this.nCPL) {
        /**
         * You're not allowed to read control registers if the current privilege level is not zero.
         */
        X86.helpFault.call(this, X86.EXCEPTION.GP_FAULT, 0);
        return;
    }

    let bModRM = this.getIPByte();
    let iSrc = (bModRM & 0x38) >> 3;

    if (iSrc == 4 || iSrc == 5) {
        X86.opUndefined.call(this);
        return;
    }

    this.setReg(bModRM & 0x7, this.regDR[iSrc]);

    this.nStepCycles -= 22;

    /**
     * TODO: Implement BACKTRACK for this instruction (although Debug registers are not likely to be a conduit for interesting data).
     */
};

/**
 * opMOVcr()
 *
 * op=0x0F,0x22 (MOV ctlreg,reg)
 *
 * NOTE: Since this instruction uses only 32-bit general-purpose registers, our ModRM decoders
 * are going to be more hindrance than help, so we fully decode and execute the instruction ourselves.
 *
 * From PCMag_Prog_TechRef, p.476: "The 80386 executes the MOV to/from control registers (CRn) regardless
 * of the setting of the MOD field.  The MOD field should be set to 11, but an early 80386 documentation
 * error indicated that the MOD field value was a don't care.  Early versions of the 80486 detect
 * a MOD != 11 as an illegal opcode.  This was changed in later versions to ignore the value of MOD.
 * Assemblers that generate MOD != 11 for these instructions will fail on some 80486s."
 *
 * And in fact, the COMPAQ DeskPro 386 ROM BIOS executes this instruction with MOD set to 00, so we have
 * to ignore it.
 *
 * @this {CPUx86}
 */
X86.opMOVcr = function()
{
    /**
     * NOTE: The following code shouldn't need to also test X86.PS.VM, because V86-mode is CPL 3.
     */
    if (this.nCPL) {
        /**
         * You're not allowed to write control registers if the current privilege level is not zero.
         */
        X86.helpFault.call(this, X86.EXCEPTION.GP_FAULT, 0);
        return;
    }

    let bModRM = this.getIPByte();
    let reg = this.getReg(bModRM & 0x7);

    switch((bModRM & 0x38) >> 3) {
    case 0x0:
        X86.helpLoadCR0.call(this, reg);
        this.nStepCycles -= 10;
        break;
    case 0x2:
        this.regCR2 = reg;
        this.nStepCycles -= 4;
        break;
    case 0x3:
        X86.helpLoadCR3.call(this, reg);
        this.nStepCycles -= 5;
        break;
    default:
        X86.opUndefined.call(this);
        return;
    }

    /**
     * TODO: Implement BACKTRACK for this instruction (although Control registers are not likely to be a conduit for interesting data).
     */
};

/**
 * opMOVdr()
 *
 * op=0x0F,0x23 (MOV dbgreg,reg)
 *
 * NOTE: Since this instruction uses only 32-bit general-purpose registers, our ModRM decoders
 * are going to be more hindrance than help, so we fully decode and execute the instruction ourselves.
 *
 * @this {CPUx86}
 */
X86.opMOVdr = function()
{
    /**
     * NOTE: The following code shouldn't need to also test X86.PS.VM, because V86-mode is CPL 3.
     */
    if (this.nCPL) {
        /**
         * You're not allowed to write control registers if the current privilege level is not zero.
         */
        X86.helpFault.call(this, X86.EXCEPTION.GP_FAULT, 0);
        return;
    }

    let bModRM = this.getIPByte();
    let iDst = (bModRM & 0x38) >> 3;

    if (iDst == 4 || iDst == 5) {
        X86.opUndefined.call(this);
        return;
    }

    let regDR = this.getReg(bModRM & 0x7);

    if (regDR != this.regDR[iDst]) {
        this.checkDebugRegisters(false);
        this.regDR[iDst] = regDR;
        this.checkDebugRegisters(true);
    }

    this.nStepCycles -= (iDst < 4? 22 : 14);

    /**
     * TODO: Implement BACKTRACK for this instruction (although Debug registers are not likely to be a conduit for interesting data).
     */
};

/**
 * opMOVrt()
 *
 * op=0x0F,0x24 (MOV reg,tstreg)
 *
 * NOTE: Since this instruction uses only 32-bit general-purpose registers, our ModRM decoders
 * are going to be more hindrance than help, so we fully decode and execute the instruction ourselves.
 *
 * @this {CPUx86}
 */
X86.opMOVrt = function()
{
    /**
     * NOTE: The following code shouldn't need to also test X86.PS.VM, because V86-mode is CPL 3.
     */
    if (this.nCPL) {
        /**
         * You're not allowed to read control registers if the current privilege level is not zero.
         */
        X86.helpFault.call(this, X86.EXCEPTION.GP_FAULT, 0);
        return;
    }

    let bModRM = this.getIPByte();
    let iSrc = (bModRM & 0x38) >> 3;

    /**
     * Only TR6 and TR7 are defined, and only for the 80386 and 80486.  From the PC Magazine Prog. TechRef, p.64:
     *
     *  "The 80386 provides two 32-bit test registers, TR6 and TR7, as a mechanism for programmers to verify proper
     *   operation of the Translation Lookaside Buffer (TLB) when power is applied to the chip. The TLB is a cache used
     *   internally by the 80386 to translate linear addresses to physical addresses."
     */
    if (iSrc < 6) {
        X86.opUndefined.call(this);
        return;
    }

    this.setReg(bModRM & 0x7, this.regTR[iSrc]);
    this.nStepCycles -= 12;

    /**
     * TODO: Implement BACKTRACK for this instruction (although Test registers are not likely to be a conduit for interesting data).
     */
};

/**
 * opMOVtr()
 *
 * op=0x0F,0x26 (MOV tstreg,reg)
 *
 * NOTE: Since this instruction uses only 32-bit general-purpose registers, our ModRM decoders
 * are going to be more hindrance than help, so we fully decode and execute the instruction ourselves.
 *
 * @this {CPUx86}
 */
X86.opMOVtr = function()
{
    /**
     * NOTE: The following code shouldn't need to also test X86.PS.VM, because V86-mode is CPL 3.
     */
    if (this.nCPL) {
        /**
         * You're not allowed to write control registers if the current privilege level is not zero.
         */
        X86.helpFault.call(this, X86.EXCEPTION.GP_FAULT, 0);
        return;
    }

    let bModRM = this.getIPByte();
    let iDst = (bModRM & 0x38) >> 3;

    /**
     * Only TR6 and TR7 are defined, and only for the 80386 and 80486.  From the PC Magazine Prog. TechRef, p.64:
     *
     *  "The 80386 provides two 32-bit test registers, TR6 and TR7, as a mechanism for programmers to verify proper
     *   operation of the Translation Lookaside Buffer (TLB) when power is applied to the chip. The TLB is a cache used
     *   internally by the 80386 to translate linear addresses to physical addresses."
     */
    if (iDst < 6) {
        X86.opUndefined.call(this);
        return;
    }

    /**
     * TODO: Do something useful with the Test registers.
     */
    this.regTR[iDst] = this.getReg(bModRM & 0x7);

    this.nStepCycles -= 12;

    /**
     * TODO: Implement BACKTRACK for this instruction (although Test registers are not likely to be a conduit for interesting data).
     */
};

/**
 * NOTE: The following 16 new conditional jumps actually rely on the OPERAND override setting
 * for determining whether a signed 16-bit or 32-bit displacement will be fetched, even though
 * the ADDRESS override might seem more intuitive.  Think of them as instructions that are loading
 * a new operand into IP/EIP.
 *
 * Also, in 16-bit code, even though a signed rel16 value would seem to imply a range of -32768
 * to +32767, any location within a 64Kb code segment outside that range can be reached by choosing
 * a displacement in the opposite direction, causing the 16-bit value in EIP to underflow or overflow;
 * any underflow or overflow doesn't matter, because only the low 16 bits of EIP are updated when a
 * 16-bit OPERAND size is in effect.
 *
 * In fact, for 16-bit jumps, it's simpler to always think of rel16 as an UNSIGNED value added to
 * the current EIP, where the result is then truncated to a 16-bit value.  This is why we don't have
 * to sign-extend rel16 before adding it to the current EIP.
 */

/**
 * opJOw()
 *
 * op=0x0F,0x80 (JO rel16/rel32)
 *
 * @this {CPUx86}
 */
X86.opJOw = function()
{
    let disp = this.getIPWord();
    if (this.getOF()) {
        this.setIP(this.getIP() + disp);
        this.nStepCycles -= this.cycleCounts.nOpCyclesJmpC;
        return;
    }
    this.nStepCycles -= this.cycleCounts.nOpCyclesJmpCFall;
};

/**
 * opJNOw()
 *
 * op=0x0F,0x81 (JNO rel16/rel32)
 *
 * @this {CPUx86}
 */
X86.opJNOw = function()
{
    let disp = this.getIPWord();
    if (!this.getOF()) {
        this.setIP(this.getIP() + disp);
        this.nStepCycles -= this.cycleCounts.nOpCyclesJmpC;
        return;
    }
    this.nStepCycles -= this.cycleCounts.nOpCyclesJmpCFall;
};

/**
 * opJCw()
 *
 * op=0x0F,0x82 (JC rel16/rel32)
 *
 * @this {CPUx86}
 */
X86.opJCw = function()
{
    let disp = this.getIPWord();
    if (this.getCF()) {
        this.setIP(this.getIP() + disp);
        this.nStepCycles -= this.cycleCounts.nOpCyclesJmpC;
        return;
    }
    this.nStepCycles -= this.cycleCounts.nOpCyclesJmpCFall;
};

/**
 * opJNCw()
 *
 * op=0x0F,0x83 (JNC rel16/rel32)
 *
 * @this {CPUx86}
 */
X86.opJNCw = function()
{
    let disp = this.getIPWord();
    if (!this.getCF()) {
        this.setIP(this.getIP() + disp);
        this.nStepCycles -= this.cycleCounts.nOpCyclesJmpC;
        return;
    }
    this.nStepCycles -= this.cycleCounts.nOpCyclesJmpCFall;
};

/**
 * opJZw()
 *
 * op=0x0F,0x84 (JZ rel16/rel32)
 *
 * @this {CPUx86}
 */
X86.opJZw = function()
{
    let disp = this.getIPWord();
    if (this.getZF()) {
        this.setIP(this.getIP() + disp);
        this.nStepCycles -= this.cycleCounts.nOpCyclesJmpC;
        return;
    }
    this.nStepCycles -= this.cycleCounts.nOpCyclesJmpCFall;
};

/**
 * opJNZw()
 *
 * op=0x0F,0x85 (JNZ rel16/rel32)
 *
 * @this {CPUx86}
 */
X86.opJNZw = function()
{
    let disp = this.getIPWord();
    if (!this.getZF()) {
        this.setIP(this.getIP() + disp);
        this.nStepCycles -= this.cycleCounts.nOpCyclesJmpC;
        return;
    }
    this.nStepCycles -= this.cycleCounts.nOpCyclesJmpCFall;
};

/**
 * opJBEw()
 *
 * op=0x0F,0x86 (JBE rel16/rel32)
 *
 * @this {CPUx86}
 */
X86.opJBEw = function()
{
    let disp = this.getIPWord();
    if (this.getCF() || this.getZF()) {
        this.setIP(this.getIP() + disp);
        this.nStepCycles -= this.cycleCounts.nOpCyclesJmpC;
        return;
    }
    this.nStepCycles -= this.cycleCounts.nOpCyclesJmpCFall;
};

/**
 * opJNBEw()
 *
 * op=0x0F,0x87 (JNBE rel16/rel32)
 *
 * @this {CPUx86}
 */
X86.opJNBEw = function()
{
    let disp = this.getIPWord();
    if (!this.getCF() && !this.getZF()) {
        this.setIP(this.getIP() + disp);
        this.nStepCycles -= this.cycleCounts.nOpCyclesJmpC;
        return;
    }
    this.nStepCycles -= this.cycleCounts.nOpCyclesJmpCFall;
};

/**
 * opJSw()
 *
 * op=0x0F,0x88 (JS rel16/rel32)
 *
 * @this {CPUx86}
 */
X86.opJSw = function()
{
    let disp = this.getIPWord();
    if (this.getSF()) {
        this.setIP(this.getIP() + disp);
        this.nStepCycles -= this.cycleCounts.nOpCyclesJmpC;
        return;
    }
    this.nStepCycles -= this.cycleCounts.nOpCyclesJmpCFall;
};

/**
 * opJNSw()
 *
 * op=0x0F,0x89 (JNS rel16/rel32)
 *
 * @this {CPUx86}
 */
X86.opJNSw = function()
{
    let disp = this.getIPWord();
    if (!this.getSF()) {
        this.setIP(this.getIP() + disp);
        this.nStepCycles -= this.cycleCounts.nOpCyclesJmpC;
        return;
    }
    this.nStepCycles -= this.cycleCounts.nOpCyclesJmpCFall;
};

/**
 * opJPw()
 *
 * op=0x0F,0x8A (JP rel16/rel32)
 *
 * @this {CPUx86}
 */
X86.opJPw = function()
{
    let disp = this.getIPWord();
    if (this.getPF()) {
        this.setIP(this.getIP() + disp);
        this.nStepCycles -= this.cycleCounts.nOpCyclesJmpC;
        return;
    }
    this.nStepCycles -= this.cycleCounts.nOpCyclesJmpCFall;
};

/**
 * opJNPw()
 *
 * op=0x0F,0x8B (JNP rel16/rel32)
 *
 * @this {CPUx86}
 */
X86.opJNPw = function()
{
    let disp = this.getIPWord();
    if (!this.getPF()) {
        this.setIP(this.getIP() + disp);
        this.nStepCycles -= this.cycleCounts.nOpCyclesJmpC;
        return;
    }
    this.nStepCycles -= this.cycleCounts.nOpCyclesJmpCFall;
};

/**
 * opJLw()
 *
 * op=0x0F,0x8C (JL rel16/rel32)
 *
 * @this {CPUx86}
 */
X86.opJLw = function()
{
    let disp = this.getIPWord();
    if (!this.getSF() != !this.getOF()) {
        this.setIP(this.getIP() + disp);
        this.nStepCycles -= this.cycleCounts.nOpCyclesJmpC;
        return;
    }
    this.nStepCycles -= this.cycleCounts.nOpCyclesJmpCFall;
};

/**
 * opJNLw()
 *
 * op=0x0F,0x8D (JNL rel16/rel32)
 *
 * @this {CPUx86}
 */
X86.opJNLw = function()
{
    let disp = this.getIPWord();
    if (!this.getSF() == !this.getOF()) {
        this.setIP(this.getIP() + disp);
        this.nStepCycles -= this.cycleCounts.nOpCyclesJmpC;
        return;
    }
    this.nStepCycles -= this.cycleCounts.nOpCyclesJmpCFall;
};

/**
 * opJLEw()
 *
 * op=0x0F,0x8E (JLE rel16/rel32)
 *
 * @this {CPUx86}
 */
X86.opJLEw = function()
{
    let disp = this.getIPWord();
    if (this.getZF() || !this.getSF() != !this.getOF()) {
        this.setIP(this.getIP() + disp);
        this.nStepCycles -= this.cycleCounts.nOpCyclesJmpC;
        return;
    }
    this.nStepCycles -= this.cycleCounts.nOpCyclesJmpCFall;
};

/**
 * opJNLEw()
 *
 * op=0x0F,0x8F (JNLE rel16/rel32)
 *
 * @this {CPUx86}
 */
X86.opJNLEw = function()
{
    let disp = this.getIPWord();
    if (!this.getZF() && !this.getSF() == !this.getOF()) {
        this.setIP(this.getIP() + disp);
        this.nStepCycles -= this.cycleCounts.nOpCyclesJmpC;
        return;
    }
    this.nStepCycles -= this.cycleCounts.nOpCyclesJmpCFall;
};

/**
 * opSETO()
 *
 * op=0x0F,0x90 (SETO b)
 *
 * @this {CPUx86}
 */
X86.opSETO = function()
{
    X86.helpSETcc.call(this, X86.fnSETO);
};

/**
 * opSETNO()
 *
 * op=0x0F,0x91 (SETNO b)
 *
 * @this {CPUx86}
 */
X86.opSETNO = function()
{
    X86.helpSETcc.call(this, X86.fnSETO);
};

/**
 * opSETC()
 *
 * op=0x0F,0x92 (SETC b)
 *
 * @this {CPUx86}
 */
X86.opSETC = function()
{
    X86.helpSETcc.call(this, X86.fnSETC);
};

/**
 * opSETNC()
 *
 * op=0x0F,0x93 (SETNC b)
 *
 * @this {CPUx86}
 */
X86.opSETNC = function()
{
    X86.helpSETcc.call(this, X86.fnSETNC);
};

/**
 * opSETZ()
 *
 * op=0x0F,0x94 (SETZ b)
 *
 * @this {CPUx86}
 */
X86.opSETZ = function()
{
    X86.helpSETcc.call(this, X86.fnSETZ);
};

/**
 * opSETNZ()
 *
 * op=0x0F,0x95 (SETNZ b)
 *
 * @this {CPUx86}
 */
X86.opSETNZ = function()
{
    X86.helpSETcc.call(this, X86.fnSETNZ);
};

/**
 * opSETBE()
 *
 * op=0x0F,0x96 (SETBE b)
 *
 * @this {CPUx86}
 */
X86.opSETBE = function()
{
    X86.helpSETcc.call(this, X86.fnSETBE);
};

/**
 * opSETNBE()
 *
 * op=0x0F,0x97 (SETNBE b)
 *
 * @this {CPUx86}
 */
X86.opSETNBE = function()
{
    X86.helpSETcc.call(this, X86.fnSETNBE);
};

/**
 * opSETS()
 *
 * op=0x0F,0x98 (SETS b)
 *
 * @this {CPUx86}
 */
X86.opSETS = function()
{
    X86.helpSETcc.call(this, X86.fnSETS);
};

/**
 * opSETNS()
 *
 * op=0x0F,0x99 (SETNS b)
 *
 * @this {CPUx86}
 */
X86.opSETNS = function()
{
    X86.helpSETcc.call(this, X86.fnSETNS);
};

/**
 * opSETP()
 *
 * op=0x0F,0x9A (SETP b)
 *
 * @this {CPUx86}
 */
X86.opSETP = function()
{
    X86.helpSETcc.call(this, X86.fnSETP);
};

/**
 * opSETNP()
 *
 * op=0x0F,0x9B (SETNP b)
 *
 * @this {CPUx86}
 */
X86.opSETNP = function()
{
    X86.helpSETcc.call(this, X86.fnSETNP);
};

/**
 * opSETL()
 *
 * op=0x0F,0x9C (SETL b)
 *
 * @this {CPUx86}
 */
X86.opSETL = function()
{
    X86.helpSETcc.call(this, X86.fnSETL);
};

/**
 * opSETNL()
 *
 * op=0x0F,0x9D (SETNL b)
 *
 * @this {CPUx86}
 */
X86.opSETNL = function()
{
    X86.helpSETcc.call(this, X86.fnSETNL);
};

/**
 * opSETLE()
 *
 * op=0x0F,0x9E (SETLE b)
 *
 * @this {CPUx86}
 */
X86.opSETLE = function()
{
    X86.helpSETcc.call(this, X86.fnSETLE);
};

/**
 * opSETNLE()
 *
 * op=0x0F,0x9F (SETNLE b)
 *
 * @this {CPUx86}
 */
X86.opSETNLE = function()
{
    X86.helpSETcc.call(this, X86.fnSETNLE);
};

/**
 * opPUSHFS()
 *
 * op=0x0F,0xA0 (PUSH FS)
 *
 * @this {CPUx86}
 */
X86.opPUSHFS = function()
{
    /**
     * When the OPERAND size is 32 bits, the 80386 will decrement the stack pointer by 4, write the selector
     * into the 2 lower bytes, and leave the 2 upper bytes untouched; to properly emulate that, we must use the
     * more generic pushData() instead of pushWord().
     */
    if (!I386) {
        this.pushWord(this.segFS.sel);
    } else {
        this.pushData(this.segFS.sel, this.sizeData, 2);
    }
    this.nStepCycles -= this.cycleCounts.nOpCyclesPushSeg;
};

/**
 * opPOPFS()
 *
 * op=0x0F,0xA1 (POP FS)
 *
 * @this {CPUx86}
 */
X86.opPOPFS = function()
{
    /**
     * Any operation that modifies the stack before loading a new segment must snapshot regLSP first.
     */
    this.opLSP = this.regLSP;
    this.setFS(this.popWord());
    this.nStepCycles -= this.cycleCounts.nOpCyclesPopReg;
    this.opLSP = X86.ADDR_INVALID;
};

/**
 * opBT()
 *
 * op=0x0F,0xA3 (BT mem/reg,reg)
 *
 * @this {CPUx86}
 */
X86.opBT = function()
{
    this.decodeModMemWord.call(this, X86.fnBTMem);
    if (this.regEA !== X86.ADDR_INVALID) this.nStepCycles -= 6;
};

/**
 * opSHLDn()
 *
 * op=0x0F,0xA4 (SHLD mem/reg,reg,imm8)
 *
 * @this {CPUx86}
 */
X86.opSHLDn = function()
{
    this.decodeModMemWord.call(this, this.sizeData == 2? X86.fnSHLDwi : X86.fnSHLDdi);
    this.nStepCycles -= (this.regEA === X86.ADDR_INVALID? 3 : 7);
};

/**
 * opSHLDcl()
 *
 * op=0x0F,0xA5 (SHLD mem/reg,reg,CL)
 *
 * @this {CPUx86}
 */
X86.opSHLDcl = function()
{
    this.decodeModMemWord.call(this, this.sizeData == 2? X86.fnSHLDwCL : X86.fnSHLDdCL);
    this.nStepCycles -= (this.regEA === X86.ADDR_INVALID? 3 : 7);
};

/**
 * opXBTS()
 *
 * op=0x0F,0xA6 (XBTS reg,mem/reg,[E]AX,CL)
 *
 * @this {CPUx86}
 */
X86.opXBTS = function()
{
    this.decodeModRegWord.call(this, X86.fnXBTS);
    this.nStepCycles -= (this.regEA === X86.ADDR_INVALID? 6 : 13);
};

/**
 * opIBTS()
 *
 * op=0x0F,0xA7 (IBTS mem/reg,[E]AX,CL,reg)
 *
 * @this {CPUx86}
 */
X86.opIBTS = function()
{
    this.decodeModMemWord.call(this, X86.fnIBTS);
    this.nStepCycles -= (this.regEA === X86.ADDR_INVALID? 12 : 19);
};

/**
 * opPUSHGS()
 *
 * op=0x0F,0xA8 (PUSH GS)
 *
 * @this {CPUx86}
 */
X86.opPUSHGS = function()
{
    /**
     * When the OPERAND size is 32 bits, the 80386 will decrement the stack pointer by 4, write the selector
     * into the 2 lower bytes, and leave the 2 upper bytes untouched; to properly emulate that, we must use the
     * more generic pushData() instead of pushWord().
     */
    if (!I386) {
        this.pushWord(this.segGS.sel);
    } else {
        this.pushData(this.segGS.sel, this.sizeData, 2);
    }
    this.nStepCycles -= this.cycleCounts.nOpCyclesPushSeg;
};

/**
 * opPOPGS()
 *
 * op=0x0F,0xA9 (POP GS)
 *
 * @this {CPUx86}
 */
X86.opPOPGS = function()
{
    /**
     * Any operation that modifies the stack before loading a new segment must snapshot regLSP first.
     */
    this.opLSP = this.regLSP;
    this.setGS(this.popWord());
    this.nStepCycles -= this.cycleCounts.nOpCyclesPopReg;
    this.opLSP = X86.ADDR_INVALID;
};

/**
 * opBTS()
 *
 * op=0x0F,0xAB (BTC mem/reg,reg)
 *
 * @this {CPUx86}
 */
X86.opBTS = function()
{
    this.decodeModMemWord.call(this, X86.fnBTSMem);
    if (this.regEA !== X86.ADDR_INVALID) this.nStepCycles -= 5;
};

/**
 * opSHRDn()
 *
 * op=0x0F,0xAC (SHRD mem/reg,reg,imm8)
 *
 * @this {CPUx86}
 */
X86.opSHRDn = function()
{
    this.decodeModMemWord.call(this, this.sizeData == 2? X86.fnSHRDwi : X86.fnSHRDdi);
    this.nStepCycles -= (this.regEA === X86.ADDR_INVALID? 3 : 7);
};

/**
 * opSHRDcl()
 *
 * op=0x0F,0xAD (SHRD mem/reg,reg,CL)
 *
 * @this {CPUx86}
 */
X86.opSHRDcl = function()
{
    this.decodeModMemWord.call(this, this.sizeData == 2? X86.fnSHRDwCL : X86.fnSHRDdCL);
    this.nStepCycles -= (this.regEA === X86.ADDR_INVALID? 3 : 7);
};

/**
 * opIMUL()
 *
 * op=0x0F,0xAF (IMUL reg,mem/reg) (80386 and up)
 *
 * @this {CPUx86}
 */
X86.opIMUL = function()
{
    this.decodeModRegWord.call(this, this.sizeData == 2? X86.fnIMULrw : X86.fnIMULrd);
};

/**
 * opLSS()
 *
 * op=0x0F,0xB2 (LSS reg,word)
 *
 * This is like a "MOV reg,rm" operation, but it also loads SS from the next word.
 *
 * @this {CPUx86}
 */
X86.opLSS = function()
{
    this.decodeModRegWord.call(this, X86.fnLSS);
};

/**
 * opBTR()
 *
 * op=0x0F,0xB3 (BTC mem/reg,reg) (80386 and up)
 *
 * @this {CPUx86}
 */
X86.opBTR = function()
{
    this.decodeModMemWord.call(this, X86.fnBTRMem);
    if (this.regEA !== X86.ADDR_INVALID) this.nStepCycles -= 5;
};

/**
 * opLFS()
 *
 * op=0x0F,0xB4 (LFS reg,word)
 *
 * This is like a "MOV reg,rm" operation, but it also loads FS from the next word.
 *
 * @this {CPUx86}
 */
X86.opLFS = function()
{
    this.decodeModRegWord.call(this, X86.fnLFS);
};

/**
 * opLGS()
 *
 * op=0x0F,0xB5 (LGS reg,word)
 *
 * This is like a "MOV reg,rm" operation, but it also loads GS from the next word.
 *
 * @this {CPUx86}
 */
X86.opLGS = function()
{
    this.decodeModRegWord.call(this, X86.fnLGS);
};

/**
 * opMOVZXb()
 *
 * op=0x0F,0xB6 (MOVZX reg,byte)
 *
 * @this {CPUx86}
 */
X86.opMOVZXb = function()
{
    this.decodeModRegByte.call(this, X86.fnMOVXb);
    let reg = (this.bModRM >> 3) & 0x7;
    switch(reg) {
    case 0x0:
        this.regEAX = (this.regEAX & ~this.maskData) | (this.regEAX & 0xff);
        break;
    case 0x1:
        this.regECX = (this.regECX & ~this.maskData) | (this.regECX & 0xff);
        break;
    case 0x2:
        this.regEDX = (this.regEDX & ~this.maskData) | (this.regEDX & 0xff);
        break;
    case 0x3:
        this.regEBX = (this.regEBX & ~this.maskData) | (this.regEBX & 0xff);
        break;
    case 0x4:
        this.regESP = (this.regESP & ~this.maskData) | ((this.regEAX >> 8) & 0xff);
        this.regEAX = this.regXX;
        break;
    case 0x5:
        this.regEBP = (this.regEBP & ~this.maskData) | ((this.regECX >> 8) & 0xff);
        this.regECX = this.regXX;
        break;
    case 0x6:
        this.regESI = (this.regESI & ~this.maskData) | ((this.regEDX >> 8) & 0xff);
        this.regEDX = this.regXX;
        break;
    case 0x7:
        this.regEDI = (this.regEDI & ~this.maskData) | ((this.regEBX >> 8) & 0xff);
        this.regEBX = this.regXX;
        break;
    }
    this.nStepCycles -= (this.regEA === X86.ADDR_INVALID? 3 : 6);
};

/**
 * opMOVZXw()
 *
 * op=0x0F,0xB7 (MOVZX reg,word)
 *
 * @this {CPUx86}
 */
X86.opMOVZXw = function()
{
    this.setDataSize(2);
    this.decodeModRegWord.call(this, X86.fnMOVXw);
    switch((this.bModRM >> 3) & 0x7) {
    case 0x0:
        this.regEAX = (this.regEAX & 0xffff);
        break;
    case 0x1:
        this.regECX = (this.regECX & 0xffff);
        break;
    case 0x2:
        this.regEDX = (this.regEDX & 0xffff);
        break;
    case 0x3:
        this.regEBX = (this.regEBX & 0xffff);
        break;
    case 0x4:
        this.regESP = (this.regESP & 0xffff);
        break;
    case 0x5:
        this.regEBP = (this.regEBP & 0xffff);
        break;
    case 0x6:
        this.regESI = (this.regESI & 0xffff);
        break;
    case 0x7:
        this.regEDI = (this.regEDI & 0xffff);
        break;
    }
    this.nStepCycles -= (this.regEA === X86.ADDR_INVALID? 3 : 6);
};

/**
 * op=0x0F,0xBA (GRP8 mem/reg) (80386 and up)
 *
 * @this {CPUx86}
 */
X86.opGRP8 = function()
{
    this.decodeModGrpWord.call(this, X86.aOpGrp8, this.getIPByte);
};

/**
 * opBTC()
 *
 * op=0x0F,0xBB (BTC mem/reg,reg)
 *
 * @this {CPUx86}
 */
X86.opBTC = function()
{
    this.decodeModMemWord.call(this, X86.fnBTCMem);
    if (this.regEA !== X86.ADDR_INVALID) this.nStepCycles -= 5;
};

/**
 * opBSF()
 *
 * op=0x0F,0xBC (BSF reg,mem/reg)
 *
 * @this {CPUx86}
 */
X86.opBSF = function()
{
    this.decodeModRegWord.call(this, X86.fnBSF);
};

/**
 * opBSR()
 *
 * op=0x0F,0xBD (BSR reg,mem/reg)
 *
 * @this {CPUx86}
 */
X86.opBSR = function()
{
    this.decodeModRegWord.call(this, X86.fnBSR);
};

/**
 * opMOVSXb()
 *
 * op=0x0F,0xBE (MOVSX reg,byte)
 *
 * @this {CPUx86}
 */
X86.opMOVSXb = function()
{
    this.decodeModRegByte.call(this, X86.fnMOVXb);
    let reg = (this.bModRM >> 3) & 0x7;
    switch(reg) {
    case 0x0:
        this.regEAX = (this.regEAX & ~this.maskData) | ((((this.regEAX & 0xff) << 24) >> 24) & this.maskData);
        break;
    case 0x1:
        this.regECX = (this.regECX & ~this.maskData) | ((((this.regECX & 0xff) << 24) >> 24) & this.maskData);
        break;
    case 0x2:
        this.regEDX = (this.regEDX & ~this.maskData) | ((((this.regEDX & 0xff) << 24) >> 24) & this.maskData);
        break;
    case 0x3:
        this.regEBX = (this.regEBX & ~this.maskData) | ((((this.regEBX & 0xff) << 24) >> 24) & this.maskData);
        break;
    case 0x4:
        this.regESP = (this.regESP & ~this.maskData) | (((this.regEAX << 16) >> 24) & this.maskData);
        this.regEAX = this.regXX;
        break;
    case 0x5:
        this.regEBP = (this.regEBP & ~this.maskData) | (((this.regECX << 16) >> 24) & this.maskData);
        this.regECX = this.regXX;
        break;
    case 0x6:
        this.regESI = (this.regESI & ~this.maskData) | (((this.regEDX << 16) >> 24) & this.maskData);
        this.regEDX = this.regXX;
        break;
    case 0x7:
        this.regEDI = (this.regEDI & ~this.maskData) | (((this.regEBX << 16) >> 24) & this.maskData);
        this.regEBX = this.regXX;
        break;
    }
    this.nStepCycles -= (this.regEA === X86.ADDR_INVALID? 3 : 6);
};

/**
 * opMOVSXw()
 *
 * op=0x0F,0xBF (MOVSX reg,word)
 *
 * @this {CPUx86}
 */
X86.opMOVSXw = function()
{
    this.setDataSize(2);
    this.decodeModRegWord.call(this, X86.fnMOVXw);
    switch((this.bModRM >> 3) & 0x7) {
    case 0x0:
        this.regEAX = ((this.regEAX << 16) >> 16);
        break;
    case 0x1:
        this.regECX = ((this.regECX << 16) >> 16);
        break;
    case 0x2:
        this.regEDX = ((this.regEDX << 16) >> 16);
        break;
    case 0x3:
        this.regEBX = ((this.regEBX << 16) >> 16);
        break;
    case 0x4:
        this.regESP = ((this.regESP << 16) >> 16);
        break;
    case 0x5:
        this.regEBP = ((this.regEBP << 16) >> 16);
        break;
    case 0x6:
        this.regESI = ((this.regESI << 16) >> 16);
        break;
    case 0x7:
        this.regEDI = ((this.regEDI << 16) >> 16);
        break;
    }
    this.nStepCycles -= (this.regEA === X86.ADDR_INVALID? 3 : 6);
};

X86.aOps0F = new Array(256);

X86.aOps0F[0x00] = X86.opGRP6;
X86.aOps0F[0x01] = X86.opGRP7;
X86.aOps0F[0x02] = X86.opLAR;
X86.aOps0F[0x03] = X86.opLSL;
X86.aOps0F[0x05] = X86.opLOADALL286;
X86.aOps0F[0x06] = X86.opCLTS;

/**
 * On all processors (except the 8086/8088, of course), X86.OPCODE.UD2 (0x0F,0x0B), aka "UD2", is an
 * instruction guaranteed to raise a #UD (Invalid Opcode) exception (INT 0x06) on all post-8086 processors.
 */
X86.aOps0F[0x0B] = X86.opInvalid;

/**
 * The following 0x0F opcodes are of no consequence to us, since they were all introduced post-80386;
 * 0x0F,0xA6 and 0x0F,0xA7 were introduced on some 80486 processors (and then deprecated), while 0x0F,0xB0
 * and 0x0F,0xB1 were introduced on 80586 (aka Pentium) processors.
 *
 *      CMPXCHG r/m8,reg8           ; 0F B0 /r          [PENT]
 *      CMPXCHG r/m16,reg16         ; o16 0F B1 /r      [PENT]
 *      CMPXCHG r/m32,reg32         ; o32 0F B1 /r      [PENT]
 *      CMPXCHG486 r/m8,reg8        ; 0F A6 /r          [486,UNDOC]
 *      CMPXCHG486 r/m16,reg16      ; o16 0F A7 /r      [486,UNDOC]
 *      CMPXCHG486 r/m32,reg32      ; o32 0F A7 /r      [486,UNDOC]
 *
 * So why are we even mentioning them here? Only because some software (eg, Windows 3.00) attempts to execute
 * 0x0F,0xA6, so we need to explicitly mark it as invalid.  TODO: Purely out of curiosity, I would like to
 * eventually learn *why* Windows 3.00 does this; is it hoping to use the CMPXCHG486 opcode, or is it performing
 * a CPU/stepping check to detect/work-around some errata, or....?
 */
X86.aOps0F[0xA6] = X86.opInvalid;

/**
 * When Windows 95 Setup initializes in protected-mode, it sets a DPMI exception handler for UD_FAULT and
 * then attempts to generate that exception with undefined opcode 0x0F,0xFF.  Apparently, whoever wrote that code
 * didn't get the Intel memo regarding the preferred invalid opcode (0x0F,0x0B, aka UD2), or perhaps Intel hadn't
 * written that memo yet -- although if that's the case, then Intel should have followed Microsoft's lead and
 * selected 0x0F,0xFF instead of 0x0F,0x0B.
 *
 * In any case, this means we need to explicitly set the handler for that opcode to opInvalid(), too.
 */
X86.aOps0F[0xFF] = X86.opInvalid;

/**
 * NOTE: Any other opcode slots NOT explicitly initialized above with either a dedicated function OR opInvalid()
 * will be set to opUndefined() when initProcessor() finalizes the opcode tables.  If the processor is an 80386,
 * initProcessor() will also incorporate all the handlers listed below in aOps0F386.
 *
 * A call to opUndefined() implies something serious has occurred that merits our attention (eg, perhaps someone
 * is using an undocumented opcode that we haven't implemented yet), whereas a call to opInvalid() may or may not.
 */

if (I386) {
    X86.aOps0F386 = [];
    X86.aOps0F386[0x05] = X86.opInvalid;        // the 80286 LOADALL opcode (LOADALL286) is invalid on the 80386
    X86.aOps0F386[0x07] = X86.opLOADALL386;
    X86.aOps0F386[0x10] = X86.opMOVmb;          // see the undocumented [UMOV](/docs/x86/ops/UMOV/) instruction
    X86.aOps0F386[0x11] = X86.opMOVmw;          // see the undocumented [UMOV](/docs/x86/ops/UMOV/) instruction
    X86.aOps0F386[0x12] = X86.opMOVrb;          // see the undocumented [UMOV](/docs/x86/ops/UMOV/) instruction
    X86.aOps0F386[0x13] = X86.opMOVrw;          // see the undocumented [UMOV](/docs/x86/ops/UMOV/) instruction
    X86.aOps0F386[0x20] = X86.opMOVrc;
    X86.aOps0F386[0x21] = X86.opMOVrd;
    X86.aOps0F386[0x22] = X86.opMOVcr;
    X86.aOps0F386[0x23] = X86.opMOVdr;
    X86.aOps0F386[0x24] = X86.opMOVrt;
    X86.aOps0F386[0x26] = X86.opMOVtr;
    X86.aOps0F386[0x80] = X86.opJOw;
    X86.aOps0F386[0x81] = X86.opJNOw;
    X86.aOps0F386[0x82] = X86.opJCw;
    X86.aOps0F386[0x83] = X86.opJNCw;
    X86.aOps0F386[0x84] = X86.opJZw;
    X86.aOps0F386[0x85] = X86.opJNZw;
    X86.aOps0F386[0x86] = X86.opJBEw;
    X86.aOps0F386[0x87] = X86.opJNBEw;
    X86.aOps0F386[0x88] = X86.opJSw;
    X86.aOps0F386[0x89] = X86.opJNSw;
    X86.aOps0F386[0x8A] = X86.opJPw;
    X86.aOps0F386[0x8B] = X86.opJNPw;
    X86.aOps0F386[0x8C] = X86.opJLw;
    X86.aOps0F386[0x8D] = X86.opJNLw;
    X86.aOps0F386[0x8E] = X86.opJLEw;
    X86.aOps0F386[0x8F] = X86.opJNLEw;
    X86.aOps0F386[0x90] = X86.opSETO;
    X86.aOps0F386[0x91] = X86.opSETNO;
    X86.aOps0F386[0x92] = X86.opSETC;
    X86.aOps0F386[0x93] = X86.opSETNC;
    X86.aOps0F386[0x94] = X86.opSETZ;
    X86.aOps0F386[0x95] = X86.opSETNZ;
    X86.aOps0F386[0x96] = X86.opSETBE;
    X86.aOps0F386[0x97] = X86.opSETNBE;
    X86.aOps0F386[0x98] = X86.opSETS;
    X86.aOps0F386[0x99] = X86.opSETNS;
    X86.aOps0F386[0x9A] = X86.opSETP;
    X86.aOps0F386[0x9B] = X86.opSETNP;
    X86.aOps0F386[0x9C] = X86.opSETL;
    X86.aOps0F386[0x9D] = X86.opSETNL;
    X86.aOps0F386[0x9E] = X86.opSETLE;
    X86.aOps0F386[0x9F] = X86.opSETNLE;
    X86.aOps0F386[0xA0] = X86.opPUSHFS;
    X86.aOps0F386[0xA1] = X86.opPOPFS;
    X86.aOps0F386[0xA3] = X86.opBT;
    X86.aOps0F386[0xA4] = X86.opSHLDn;
    X86.aOps0F386[0xA5] = X86.opSHLDcl;
    X86.aOps0F386[0xA8] = X86.opPUSHGS;
    X86.aOps0F386[0xA9] = X86.opPOPGS;
    X86.aOps0F386[0xAB] = X86.opBTS;
    X86.aOps0F386[0xAC] = X86.opSHRDn;
    X86.aOps0F386[0xAD] = X86.opSHRDcl;
    X86.aOps0F386[0xAF] = X86.opIMUL;
    X86.aOps0F386[0xB2] = X86.opLSS;
    X86.aOps0F386[0xB3] = X86.opBTR;
    X86.aOps0F386[0xB4] = X86.opLFS;
    X86.aOps0F386[0xB5] = X86.opLGS;
    X86.aOps0F386[0xB6] = X86.opMOVZXb;
    X86.aOps0F386[0xB7] = X86.opMOVZXw;
    X86.aOps0F386[0xBA] = X86.opGRP8;
    X86.aOps0F386[0xBB] = X86.opBTC;
    X86.aOps0F386[0xBC] = X86.opBSF;
    X86.aOps0F386[0xBD] = X86.opBSR;
    X86.aOps0F386[0xBE] = X86.opMOVSXb;
    X86.aOps0F386[0xBF] = X86.opMOVSXw;
}

/**
 * These instruction groups are not as orthogonal as the original 8086/8088 groups (Grp1 through Grp4); some of
 * the instructions in Grp6 and Grp7 only read their dst operand (eg, LLDT), which means the ModRM helper function
 * must insure that setEAWord() is disabled, while others only write their dst operand (eg, SLDT), which means that
 * getEAWord() should be disabled *prior* to calling the ModRM helper function.  This latter case requires that
 * we decode the reg field of the ModRM byte before dispatching.
 */
X86.aOpGrp6Prot = [
    X86.fnSLDT,             X86.fnSTR,              X86.fnLLDT,             X86.fnLTR,              // 0x0F,0x00(reg=0x0-0x3)
    X86.fnVERR,             X86.fnVERW,             X86.fnGRPUndefined,     X86.fnGRPUndefined      // 0x0F,0x00(reg=0x4-0x7)
];

X86.aOpGrp6Real = [
    X86.fnGRPInvalid,       X86.fnGRPInvalid,       X86.fnGRPInvalid,       X86.fnGRPInvalid,       // 0x0F,0x00(reg=0x0-0x3)
    X86.fnGRPInvalid,       X86.fnGRPInvalid,       X86.fnGRPUndefined,     X86.fnGRPUndefined      // 0x0F,0x00(reg=0x4-0x7)
];

/**
 * Unlike Grp6, Grp7 and Grp8 do not require separate real-mode and protected-mode dispatch tables, because
 * all Grp7 and Grp8 instructions are valid in both modes.
 */
X86.aOpGrp7 = [
    X86.fnSGDT,             X86.fnSIDT,             X86.fnLGDT,             X86.fnLIDT,             // 0x0F,0x01(reg=0x0-0x3)
    X86.fnSMSW,             X86.fnGRPUndefined,     X86.fnLMSW,             X86.fnGRPUndefined      // 0x0F,0x01(reg=0x4-0x7)
];

X86.aOpGrp8 = [
    X86.fnGRPUndefined,     X86.fnGRPUndefined,     X86.fnGRPUndefined,     X86.fnGRPUndefined,     // 0x0F,0xBA(reg=0x0-0x3)
    X86.fnBT,               X86.fnBTS,              X86.fnBTR,              X86.fnBTC               // 0x0F,0xBA(reg=0x4-0x7)
];

/**
 * @copyright https://www.pcjs.org/machines/pcx86/modules/v2/chipset.js (C) 2012-2024 Jeff Parsons
 */

/** @typedef {{ countInit: Array.<number>, countStart: Array.<number>, countCurrent: Array.<number>, countLatched: Array.<number>, bcd: number, mode: number, rw: number, countIndex: number, countBytes: number, fOUT: boolean, fCountLatched: boolean, fCounting: boolean, nCyclesStart: number, bStatus: number, fStatusLatched: boolean }} */
let Timer;

/**
 * @class ChipSet
 * @unrestricted (allows the class to define properties, both dot and named, outside of the constructor)
 */
class ChipSet extends Component {
    /**
     * Ports Overview
     * --------------
     *
     * This module provides support for many of the following components (except where a separate component is noted).
     * This list is taken from p.1-8 ("System Unit") of the IBM 5160 (PC XT) Technical Reference Manual (as revised
     * April 1983), only because I didn't see a similar listing in the original 5150 Technical Reference.
     *
     *      Port(s)         Description
     *      -------         -----------
     *      000-00F         DMA Chip 8237A-5                                [see below]
     *      020-021         Interrupt 8259A                                 [see below]
     *      040-043         Timer 8253-5                                    [see below]
     *      060-063         PPI 8255A-5                                     [see below]
     *      080-083         DMA Page Registers                              [see below]
     *          0Ax [1]     NMI Mask Register                               [see below]
     *          0Cx         Reserved
     *          0Ex         Reserved
     *      200-20F         Game Control
     *      210-217         Expansion Unit
     *      220-24F         Reserved
     *      278-27F         Reserved
     *      2F0-2F7         Reserved
     *      2F8-2FF         Asynchronous Communications (Secondary)         [see the SerialPort component]
     *      300-31F         Prototype Card
     *      320-32F         Hard Drive Controller (XTC)                     [see the HDC component]
     *      378-37F         Printer
     *      380-38C [2]     SDLC Communications
     *      380-389 [2]     Binary Synchronous Communications (Secondary)
     *      3A0-3A9         Binary Synchronous Communications (Primary)
     *      3B0-3BF         IBM Monochrome Display/Printer                  [see the Video component]
     *      3C0-3CF         Reserved
     *      3D0-3DF         Color/Graphics (Motorola 6845)                  [see the Video component]
     *      3EO-3E7         Reserved
     *      3FO-3F7         Floppy Drive Controller                         [see the FDC component]
     *      3F8-3FF         Asynchronous Communications (Primary)           [see the SerialPort component]
     *
     * [1] At power-on time, NMI is masked off, perhaps because models 5150 and 5160 also tie coprocessor
     * (FPU) interrupts to NMI.  Suppressing NMI by default seems odd, because that would also suppress memory
     * parity errors.  TODO: Determine whether "power-on time" refers to the initial power-on state of the
     * NMI Mask Register or the state that the BIOS "POST" (Power-On Self-Test) sets.
     *
     * [2] These devices cannot be used together since their port addresses overlap.
     *
     *      MODEL_5170      Description
     *      ----------      -----------
     *          070 [3]     CMOS Address                                    ChipSet.CMOS.ADDR.PORT
     *          071         CMOS Data                                       ChipSet.CMOS.DATA.PORT
     *          0F0         FPU Coprocessor Clear Busy (output 0x00)
     *          0F1         FPU Coprocessor Reset (output 0x00)
     *      1F0-1F7         Hard Drive Controller (ATC)                     [see the HDC component]
     *
     * [3] Port 0x70 doubles as the NMI Mask Register: output a CMOS address with bit 7 clear to enable NMI
     * or with bit 7 set to disable NMI (apparently the inverse of the older NMI Mask Register at port 0xA0).
     * Also, apparently unlike previous models, the MODEL_5170 POST leaves NMI enabled.  And fortunately, the
     * FPU coprocessor interrupt line is no longer tied to NMI (it uses IRQ 13).
     */

    /**
     * Supported model numbers
     *
     * In general, when comparing this.model to "base" model numbers (ie, non-REV numbers), you should use
     * (this.model|0), which truncates the current model number.
     *
     * Note that there were two 5150 motherboard revisions: the "REV A" 16Kb-64Kb motherboard and the
     * "REV B" 64Kb-256Kb motherboard.  There may have been a manufacturing correlation between motherboard
     * revisions ("REV A" and "REV B") and the ROM BIOS revisions shown below, but in general, we can't assume
     * any correlation, because newer ROMs could be installed with either motherboard.
     *
     * I do know that, for "REV A" motherboards, the Apr 1984 5150 TechRef says that "To expand the memory
     * of your system beyond 544K requires your IBM Personal Computer System Unit to have a BIOS ROM module
     * dated 10/27/82 or later."  Which suggests that SW2[5] was not used until the REV3 5150 ROM BIOS.
     *
     * For now, we treat all our MODEL_5150 systems as 16Kb-64Kb motherboards; if you want a 64Kb-256Kb motherboard,
     * then step up to a MODEL_5160 system.  We use a multiplier of 16 for 5150 LOWMEM values, and a multiplier
     * of 64 for 5160 LOWMEM values.
     */
    static MODEL_S100               = 100;      // SCP (Seattle Computer Products) S-100 system
    static MODEL_4860               = 4860;     // PCjr
    static MODEL_5150               = 5150;     // used in reference to the 1st 5150 ROM BIOS, dated Apr 24, 1981
    static MODEL_5150_REV2          = 5150.2;   // used in reference to the 2nd 5150 ROM BIOS, dated Oct 19, 1981
    static MODEL_5150_REV3          = 5150.3;   // used in reference to the 3rd 5150 ROM BIOS, dated Oct 27, 1982
    static MODEL_5150_OTHER         = 5150.9;
    static MODEL_5160               = 5160;     // used in reference to the 1st 5160 ROM BIOS, dated Nov 08, 1982
    static MODEL_5160_REV2          = 5160.2;   // used in reference to the 1st 5160 ROM BIOS, dated Jan 10, 1986
    static MODEL_5160_REV3          = 5160.3;   // used in reference to the 1st 5160 ROM BIOS, dated May 09, 1986
    static MODEL_5160_OTHER         = 5160.9;
    static MODEL_5170               = 5170;     // used in reference to the 1st 5170 ROM BIOS, dated Jan 10, 1984
    static MODEL_5170_REV2          = 5170.2;   // used in reference to the 2nd 5170 ROM BIOS, dated Jun 10, 1985
    static MODEL_5170_REV3          = 5170.3;   // used in reference to the 3rd 5170 ROM BIOS, dated Nov 15, 1985
    static MODEL_5170_OTHER         = 5170.9;

    /**
     * Assorted non-IBM models (we don't put "IBM" in the IBM models, but non-IBM models should include the company name).
     */
    static MODEL_CDP_MPC1600        = 5150.101; // Columbia Data Products MPC 1600 ("Copyright Columbia Data Products 1983, ROM/BIOS Ver 4.34")
    static MODEL_COMPAQ_PORTABLE    = 5150.102; // COMPAQ Portable (COMPAQ's first PC)
    static MODEL_ATT_6300           = 5160.101; // AT&T Personal Computer 6300/Olivetti M24 ("COPYRIGHT (C) OLIVETTI 1984","04/03/86",v1.43)
    static MODEL_ZENITH_Z150        = 5160.150; // Zenith Data Systems Z-150 ("08/11/88 (C)ZDS CORP")
    static MODEL_COMPAQ_DESKPRO386  = 5180;     // COMPAQ DeskPro 386 (COMPAQ's first 80386-based PC); should be > MODEL_5170

    /**
     * Last but not least, a complete list of supported model strings, and corresponding internal model numbers.
     */
    static MODELS = {
        "100":          ChipSet.MODEL_S100,
        "4860":         ChipSet.MODEL_4860,     // IBM PCjr
        "5150":         ChipSet.MODEL_5150,     // IBM PC
        "5160":         ChipSet.MODEL_5160,     // IBM PC XT
        "5170":         ChipSet.MODEL_5170,     // IBM PC AT
        "att6300":      ChipSet.MODEL_ATT_6300,
        "mpc1600":      ChipSet.MODEL_CDP_MPC1600,
        "z150":         ChipSet.MODEL_ZENITH_Z150,
        "compaq":       ChipSet.MODEL_COMPAQ_PORTABLE,
        "other":        ChipSet.MODEL_5150_OTHER,
        "deskpro386":   ChipSet.MODEL_COMPAQ_DESKPRO386
    };

    static CONTROLS = {
        SW1:    "sw1",
        SW2:    "sw2",
        SWDESC: "swdesc"
    };

    /**
     * Values returned by getDIPVideoMonitor()
     */
    static MONITOR = {
        NONE:               0,
        TV:                 1,  // Composite monitor (lower resolution; no support)
        COLOR:              2,  // Color Display (5153)
        MONO:               3,  // Monochrome Display (5151)
        EGACOLOR:           4,  // Enhanced Color Display (5154) in High-Res Mode
        EGAEMULATION:       6,  // Enhanced Color Display (5154) in Emulation Mode
        VGACOLOR:           7   // VGA Color Display
    };

    /**
     * Switches Overview
     * -----------------
     *
     * The conventions used for the sw1 and sw2 strings are that the left-most character represents DIP switch [1],
     * the right-most character represents DIP switch [8], and "1" means the DIP switch is ON and "0" means it is OFF.
     *
     * Internally, we convert the above strings into binary values that the 8255A PPI returns, where DIP switch [1]
     * is bit 0 and DIP switch [8] is bit 7, and 0 indicates the switch is ON and 1 indicates it is OFF.
     *
     * For reference, here's how the SW1 and SW2 switches correspond to the internal 8255A PPI bit values:
     *
     *      SW1[1]    (bit 0)     "0xxxxxxx" (1):  IPL,  "1xxxxxxx" (0):  No IPL
     *      SW1[2]    (bit 1)     reserved on the 5150; OFF (1) if FPU installed in a 5160
     *      SW1[3,4]  (bits 3-2)  "xx11xxxx" (00): 16Kb, "xx01xxxx" (10): 32Kb,  "xx10xxxx" (01): 48Kb,  "xx00xxxx" (11): 64Kb
     *      SW1[5,6]  (bits 5-4)  "xxxx11xx" (00): none, "xxxx01xx" (10): tv,    "xxxx10xx" (01): color, "xxxx00xx" (11): mono
     *      SW1[7,8]  (bits 7-6)  "xxxxxx11" (00): 1 FD, "xxxxxx01" (10): 2 FD,  "xxxxxx10" (01): 3 FD,  "xxxxxx00" (11): 4 FD
     *
     * Note: FD refers to floppy drive, and IPL refers to an "Initial Program Load" floppy drive.
     *
     *      SW2[1-5]    (bits 4-0)  "NNNxxxxx": number of 32Kb blocks of I/O expansion RAM present
     *
     * For example, sw1="01110011" indicates that all SW1 DIP switches are ON, except for SW1[1], SW1[5] and SW1[6],
     * which are OFF.  Internally, the order of these bits must reversed (to 11001110) and then inverted (to 00110001)
     * to yield the value that the 8255A PPI returns.  Reading the final value right-to-left, 00110001 indicates an
     * IPL floppy drive, 1X of RAM (where X is 16Kb on a MODEL_5150 and 64Kb on a MODEL_5160), MDA, and 1 floppy drive.
     *
     * WARNING: It is possible to set SW1 to indicate more memory than the RAM component has been configured to provide.
     * This is a configuration error which will cause the machine to crash after reporting a "201" error code (memory
     * test failure), which is presumably what a real machine would do if it was similarly misconfigured.  Surprisingly,
     * the BIOS forges ahead, setting SP to the top of the memory range indicated by SW1 (via INT 0x12), but the lack of
     * a valid stack causes the system to crash after the next IRET.  The BIOS should have either halted or modified
     * the actual memory size to match the results of the memory test.
     *
     * MODEL 5150 Switches
     * -------------------
     *
     * PPI_SW bits are exposed via PPI.PORT (0x60).
     *
     * MODEL 5160 Switches
     * ------------------------
     *
     * PPI_SW bits 0-3 are exposed via PPI_C.SW if PPI_B.ENABLE_SW_HI is clear; bits 4-7 if PPI_B.ENABLE_SW_HI is set.
     *
     * AT&T 6300 Switches
     * ------------------
     *
     * Based on ATT_PC_6300_Service_Manual.pdf, there are two 8-switch blocks, DIPSW-0 and DIPSW-1, where:
     *
     *      DIPSW-0[1-4] Total RAM
     *      DIPSW-0[5] - ON if 8087 not installed, OFF if installed
     *      DIPSW-0[6] - ON if 8250 ACE serial interface present, OFF if Z-8530 SCC interface present
     *      DIPSW-0[7] - Not used
     *      DIPSW-0[8] - Type of EPROM chip for ROM 1.21 or lower, or presence of RAM in bank 1 for ROM 1.43 or higher
     *
     * and:
     *
     *      DIPSW-1[1] - Floppy Type (ON for 48TPI, OFF for 96TPI)
     *      DIPSW-1[2] - Floppy Speed (ON for slow startup, OFF for fast startup)
     *      DIPSW-1[3] - HDU ROM (ON for indigenous, OFF for external)
     *      DIPSW-1[4] - Not used (ROM 1.21 or lower) or Scroll Speed (ROM 1.43 or higher: ON for fast, OFF for slow)
     *      DIPSW-1[5-6] - Display Type (11=EGA or none, 01=color 40x25, 10=color 80x25, 00=monochrome 80x25)
     *      DIPSW-1[7-8] - Number of Floppy Drives (11=one, 01=two, 10=three, 00=four)
     *
     * For AT&T 6300 ROM 1.43 and up, DIPSW-0 supports the following RAM combinations:
     *
     *      0111xxx1: 128Kb on motherboard
     *      1011xxx0: 256Kb on motherboard
     *      1101xxx0: 256Kb on motherboard, 256Kb on expansion board (512Kb total)
     *      1110xxx1: 512Kb on motherboard
     *      0101xxx0: 256Kb on motherboard, 384Kb on expansion board (640Kb total)
     *      0100xxx0: 640Kb on motherboard (128Kb bank 0, 512Kb bank 1)
     *      0110xxx0: 640Kb on motherboard (512Kb bank 0, 128Kb bank 1)
     *
     * Inspection of the AT&T 6300 Plus ROM BIOS reveals that DIPSW-0[1-8] are obtained from bits 0-7
     * of port 0x66 ("sys_conf_a") and DIPSW-1[1-8] are obtained from bits 0-7 of port 0x67 ("sys_conf_b").
     */
    static PPI_SW = {
        FDRIVE: {
            IPL:            0x01,   // MODEL_5150: IPL ("Initial Program Load") floppy drive attached; MODEL_5160: "Loop on POST"
            ONE:            0x00,   // 1 floppy drive attached (or 0 drives if PPI_SW.FDRIVE_IPL is not set -- MODEL_5150 only)
            TWO:            0x40,   // 2 floppy drives attached
            THREE:          0x80,   // 3 floppy drives attached
            FOUR:           0xC0,   // 4 floppy drives attached
            MASK:           0xC0,
            SHIFT:          6
        },
        FPU:                0x02,   // MODEL_5150: reserved; MODEL_5160: FPU coprocessor installed
        MEMORY: {                   // MODEL_5150: "X" is 16Kb; MODEL_5160: "X" is 64Kb
            X1:             0x00,   // 16Kb or 64Kb
            X2:             0x04,   // 32Kb or 128Kb
            X3:             0x08,   // 48Kb or 192Kb
            X4:             0x0C,   // 64Kb or 256Kb
            MASK:           0x0C,
            SHIFT:          2
        },
        MONITOR: {
            TV:             0x10,
            COLOR:          0x20,
            MONO:           0x30,
            MASK:           0x30,
            SHIFT:          4
        }
    };

    /**
     * Some models have completely different DIP switch implementations from the MODEL_5150, which, being
     * the first IBM PC, was the model that we, um, modeled our DIP switch support on.  So, to support other
     * implementations, we now get and set DIP switch values according to SW_TYPE, and rely on the
     * tables that follow to define which DIP switch(es) correspond to each SW_TYPE.
     *
     * Not every model needs its own tables.  The getDIPSwitches() and setDIPSwitches() functions look first
     * for an *exact* model match, then a "truncated" model match, and failing that, they fall back to the
     * MODEL_5150 switch definitions.
     */
    static SW_TYPE = {
        FLOPNUM:    1,
        FLOPTYPE:   2,
        FPU:        3,
        MONITOR:    4,
        LOWMEM:     5,
        EXPMEM:     6
    };

    static SW_FLOPPY = {
        MASK:       0xC0,
        VALUES: {
            1:      0x00,
            2:      0x40,
            3:      0x80,
            4:      0xC0
        },
        LABEL: "Number of Floppy Drives"
    };

    static SW_FPU = {
        MASK:       0x02,
        VALUES: {
            0:      0x00,       // 0 means an FPU is NOT installed
            1:      0x02        // 1 means an FPU is installed
        },
        LABEL: "FPU"
    };

    static SW_MONITOR = {
        MASK:       0x30,
        VALUES: {
            0:      0x00,
            1:      0x10,
            2:      0x20,
            3:      0x30,
            "none": 0x00,
            "tv":   0x10,       // aka composite
            "color":0x20,
            "cga":  0x20,       // alias for color
            "mda":  0x30,       // alias for mono
            "mono": 0x30,
            "ega":  0x00,
            "vga":  0x00
        },
        LABEL: "Monitor Type"
    };

    static SW_MEMORY = {
        MASK:       0x1F,       // technically, this mask should be 0x0F for ROM revisions prior to 5150_REV3, and 0x1F on 5150_REV3
        VALUES: {
            0:      0x00,
            32:     0x01,
            64:     0x02,
            96:     0x03,
            128:    0x04,
            160:    0x05,
            192:    0x06,
            224:    0x07,
            256:    0x08,
            288:    0x09,
            320:    0x0A,
            352:    0x0B,
            384:    0x0C,
            416:    0x0D,
            448:    0x0E,
            480:    0x0F,
            512:    0x10,
            544:    0x11,
            576:    0x12
            /**
             * Obviously, more bit combinations are possible here (up to 0x1F), but assuming a minimum of 64Kb already on
             * the motherboard, any amount of expansion memory above 576Kb would break the 640Kb barrier.  Yes, if you used
             * only MDA or CGA video cards, you could go as high as 704Kb in a real system.  But in our happy little world,
             * this is where we stop.
             *
             * TODO: A value larger than 0x12 usually comes from a misconfigured machine (ie, it forgot to leave SW2[5] ON).
             * To compensate, when getDIPMemorySize() gets null back from its EXPMEM request, perhaps it should try truncating
             * the DIP switch value.  However, that would introduce a machine-specific hack into a function that's supposed
             * be machine-independent now.
             */
        },
        LABEL: "Expansion Memory (32Kb Increments)"
    };

    static DIPSW = {
        [ChipSet.MODEL_5150]: [
            {
                [ChipSet.SW_TYPE.FLOPNUM]:  ChipSet.SW_FLOPPY,
                /**
                 * Notes on the 8087 Math Coprocessor (FPU)
                 *
                 * The August 1981 Technical Reference Manual lists SW1[2] as "RESERVED" and also says that SW1[2]
                 * "MUST BE ON (RESERVED FOR CO-PROCESSOR)" (p. 2-28), suggesting that the math coprocessor wasn't
                 * quite ready for the initial release of the IBM PC.
                 *
                 * The April 1983 TechRef adds a section on the "IBM Personal Computer Math Coprocessor" (p. 1-33)
                 * and makes it clearer that SW1[2] must be OFF when a math coprocessor is installed, but then it
                 * muddies the waters in a new appendix of switch tables, where it erroneously claims that SW1[2]
                 * must be ON when using a coprocessor (p. G-7).
                 *
                 * The April 1984 TechRef eliminates the confusion by eliminating the appendix (actually, it was
                 * simply corrected and moved to the 1984 Guide to Operations; see p. 5-10).  Early magazine articles
                 * discussing 8087 support also indicated that switch SW1[2] must OFF when a coprocessor is installed.
                 *
                 * While the August 1981 TechRef makes almost no mention of coprocessor support, the April 1984 TechRef
                 * discusses it in a fair bit of detail, including the fact that 8087 exceptions generate an NMI,
                 * despite Intel's warning in their iAPX 86,88 User's Manual, p. S-27, that "[t]he 8087 should not be
                 * tied to the CPU's NMI (non-maskable interrupt) line."
                 */
                [ChipSet.SW_TYPE.FPU]:      ChipSet.SW_FPU,
                [ChipSet.SW_TYPE.MONITOR]:  ChipSet.SW_MONITOR,
                [ChipSet.SW_TYPE.LOWMEM]: {
                    MASK:       0x0C,
                    VALUES: {
                        16:     0x00,
                        32:     0x04,
                        48:     0x08,
                        64:     0x0C
                    },
                    LABEL: "Base Memory (16Kb Increments)"
                }
            },
            {
                [ChipSet.SW_TYPE.EXPMEM]:   ChipSet.SW_MEMORY
            }
        ],
        [ChipSet.MODEL_5160]: [
            {
                [ChipSet.SW_TYPE.FLOPNUM]:  ChipSet.SW_FLOPPY,
                [ChipSet.SW_TYPE.FPU]:      ChipSet.SW_FPU,
                [ChipSet.SW_TYPE.MONITOR]:  ChipSet.SW_MONITOR,
                [ChipSet.SW_TYPE.LOWMEM]: {
                    MASK:       0x0C,
                    VALUES: {
                        64:     0x00,
                        128:    0x04,
                        192:    0x08,
                        256:    0x0C
                    },
                    LABEL: "Base Memory (64Kb Increments)"
                }
            },
            {
                [ChipSet.SW_TYPE.EXPMEM]:   ChipSet.SW_MEMORY
            }
        ],
        [ChipSet.MODEL_ATT_6300]: [
            {
                [ChipSet.SW_TYPE.LOWMEM]: {
                    MASK:       0x8F,
                    VALUES: {
                        128:    0x01,   // "0111xxx1"
                        256:    0x82,   // "1011xxx0"
                        512:    0x08,   // "1110xxx1"
                        640:    0x8D    // "0100xxx0"
                    },
                    LABEL: "Base Memory (128Kb Increments)"
                },
                [ChipSet.SW_TYPE.FPU]: {
                    MASK:       0x10,
                    VALUES: {
                        0:      0x00,
                        1:      0x10
                    },
                    LABEL: "FPU"
                }
            },
            {
                [ChipSet.SW_TYPE.FLOPTYPE]: {
                    MASK:       0x01,
                    VALUES: {
                        0:      0x00,
                        1:      0x01
                    },
                    LABEL: "Floppy Type"
                },
                [ChipSet.SW_TYPE.FLOPNUM]: ChipSet.SW_FLOPPY,
                [ChipSet.SW_TYPE.MONITOR]: ChipSet.SW_MONITOR
            }
        ]
    };

    /**
     *  8237A DMA Controller (DMAC) I/O ports
     *
     *  MODEL_5150 and up uses DMA channel 0 for memory refresh cycles and channel 2 for the FDC.
     *
     *  MODEL_5160 and up uses DMA channel 3 for HDC transfers (XTC only).
     *
     *  DMA0 refers to the original DMA controller found on all models, and DMA1 refers to the additional
     *  controller found on MODEL_5170 and up; channel 4 on DMA1 is used to "cascade" channels 0-3 from DMA0,
     *  so only channels 5-7 are available on DMA1.
     *
     *  For FDC DMA notes, refer to http://wiki.osdev.org/ISA_DMA
     *  For general DMA notes, refer to http://www.freebsd.org/doc/en/books/developers-handbook/dma.html
     *
     *  TODO: Determine why the MODEL_5150 ROM BIOS sets the DMA channel 1 page register (port 0x83) to zero.
     */
    static DMA0 = {
        INDEX:              0,
        PORT: {
            CH0_ADDR:       0x00,   // OUT: starting address        IN: current address
            CH0_COUNT:      0x01,   // OUT: starting word count     IN: remaining word count
            CH1_ADDR:       0x02,   // OUT: starting address        IN: current address
            CH1_COUNT:      0x03,   // OUT: starting word count     IN: remaining word count
            CH2_ADDR:       0x04,   // OUT: starting address        IN: current address
            CH2_COUNT:      0x05,   // OUT: starting word count     IN: remaining word count
            CH3_ADDR:       0x06,   // OUT: starting address        IN: current address
            CH3_COUNT:      0x07,   // OUT: starting word count     IN: remaining word count
            CMD_STATUS:     0x08,   // OUT: command register        IN: status register
            REQUEST:        0x09,
            MASK:           0x0A,
            MODE:           0x0B,
            RESET_FF:       0x0C,   // reset flip-flop
            MASTER_CLEAR:   0x0D,   // OUT: master clear            IN: temporary register
            MASK_CLEAR:     0x0E,   // TODO: Provide handlers
            MASK_ALL:       0x0F,   // TODO: Provide handlers
            CH2_PAGE:       0x81,   // OUT: DMA channel 2 page register
            CH3_PAGE:       0x82,   // OUT: DMA channel 3 page register
            CH1_PAGE:       0x83,   // OUT: DMA channel 1 page register
            CH0_PAGE:       0x87    // OUT: DMA channel 0 page register (unusable; See "The Inside Out" book, p.246)
        }
    };

    static DMA1 = {
        INDEX:              1,
        PORT: {
            CH6_PAGE:       0x89,   // OUT: DMA channel 6 page register (MODEL_5170)
            CH7_PAGE:       0x8A,   // OUT: DMA channel 7 page register (MODEL_5170)
            CH5_PAGE:       0x8B,   // OUT: DMA channel 5 page register (MODEL_5170)
            CH4_PAGE:       0x8F,   // OUT: DMA channel 4 page register (MODEL_5170; unusable; aka "Refresh" page register?)
            CH4_ADDR:       0xC0,   // OUT: starting address        IN: current address
            CH4_COUNT:      0xC2,   // OUT: starting word count     IN: remaining word count
            CH5_ADDR:       0xC4,   // OUT: starting address        IN: current address
            CH5_COUNT:      0xC6,   // OUT: starting word count     IN: remaining word count
            CH6_ADDR:       0xC8,   // OUT: starting address        IN: current address
            CH6_COUNT:      0xCA,   // OUT: starting word count     IN: remaining word count
            CH7_ADDR:       0xCC,   // OUT: starting address        IN: current address
            CH7_COUNT:      0xCE,   // OUT: starting word count     IN: remaining word count
            CMD_STATUS:     0xD0,   // OUT: command register        IN: status register
            REQUEST:        0xD2,
            MASK:           0xD4,
            MODE:           0xD6,
            RESET_FF:       0xD8,   // reset flip-flop
            MASTER_CLEAR:   0xDA,   // master clear
            MASK_CLEAR:     0xDC,   // TODO: Provide handlers
            MASK_ALL:       0xDE    // TODO: Provide handlers
        }
    };

    static DMA_CMD = {
        M2M_ENABLE:         0x01,
        CH0HOLD_ENABLE:     0x02,
        CTRL_DISABLE:       0x04,
        COMP_TIMING:        0x08,
        ROT_PRIORITY:       0x10,
        EXT_WRITE_SEL:      0x20,
        DREQ_ACTIVE_LO:     0x40,
        DACK_ACTIVE_HI:     0x80
    };

    static DMA_STATUS = {
        CH0_TC:             0x01,   // Channel 0 has reached Terminal Count (TC)
        CH1_TC:             0x02,   // Channel 1 has reached Terminal Count (TC)
        CH2_TC:             0x04,   // Channel 2 has reached Terminal Count (TC)
        CH3_TC:             0x08,   // Channel 3 has reached Terminal Count (TC)
        ALL_TC:             0x0f,   // all TC bits are cleared whenever DMA_STATUS is read
        CH0_REQ:            0x10,   // Channel 0 DMA requested
        CH1_REQ:            0x20,   // Channel 1 DMA requested
        CH2_REQ:            0x40,   // Channel 2 DMA requested
        CH3_REQ:            0x80    // Channel 3 DMA requested
    };

    static DMA_MASK = {
        CHANNEL:            0x03,
        CHANNEL_SET:        0x04
    };

    static DMA_MODE = {
        CHANNEL:            0x03,   // bits 0-1 select 1 of 4 possible channels
        TYPE:               0x0C,   // bits 2-3 select 1 of 3 valid (4 possible) transfer types
        TYPE_VERIFY:        0x00,   // pseudo transfer (generates addresses, responds to EOP, but nothing is moved)
        TYPE_WRITE:         0x04,   // write to memory (move data FROM an I/O device; eg, reading a sector from a disk)
        TYPE_READ:          0x08,   // read from memory (move data TO an I/O device; eg, writing a sector to a disk)
        AUTOINIT:           0x10,
        DECREMENT:          0x20,   // clear for INCREMENT
        MODE:               0xC0,   // bits 6-7 select 1 of 4 possible transfer modes
        MODE_DEMAND:        0x00,
        MODE_SINGLE:        0x40,
        MODE_BLOCK:         0x80,
        MODE_CASCADE:       0xC0
    };

    static DMA_REFRESH    = 0x00;   // DMA channel assigned to memory refresh
    static DMA_FDC        = 0x02;   // DMA channel assigned to the Floppy Drive Controller (FDC)
    static DMA_HDC        = 0x03;   // DMA channel assigned to the Hard Drive Controller (HDC; XTC only)

    /**
     * 8259A Programmable Interrupt Controller (PIC) I/O ports
     *
     * Internal registers:
     *
     *      ICW1    Initialization Command Word 1 (sent to port ChipSet.PIC_LO)
     *      ICW2    Initialization Command Word 2 (sent to port ChipSet.PIC_HI)
     *      ICW3    Initialization Command Word 3 (sent to port ChipSet.PIC_HI)
     *      ICW4    Initialization Command Word 4 (sent to port ChipSet.PIC_HI)
     *      IMR     Interrupt Mask Register
     *      IRR     Interrupt Request Register
     *      ISR     Interrupt Service Register
     *      IRLow   (IR having lowest priority; IR+1 will have highest priority; default is 7)
     *
     * Note that ICW2 effectively contains the starting IDT vector number (ie, for IRQ 0),
     * which must be multiplied by 4 to calculate the vector offset, since every vector is 4 bytes long.
     *
     * Also, since the low 3 bits of ICW2 are ignored in 8086/8088 mode (ie, they are effectively
     * treated as zeros), this means that the starting IDT vector can only be a multiple of 8.
     *
     * So, if ICW2 is set to 0x08, the starting vector number (ie, for IRQ 0) will be 0x08, and the
     * 4-byte address for the corresponding ISR will be located at offset 0x20 in the real-mode IDT.
     *
     * ICW4 is typically set to 0x09, indicating 8086 mode, non-automatic EOI, buffered/slave mode.
     *
     * TODO: Determine why the original ROM BIOS chose buffered/slave over buffered/master.
     * Did it simply not matter in pre-AT systems with only one PIC, or am I misreading something?
     *
     * TODO: Consider support for level-triggered PIC interrupts, even though the original IBM PCs
     * (up through MODEL_5170) used only edge-triggered interrupts.
     */
    static PIC0 = {                 // all models: the "master" PIC
        INDEX:              0,
        PORT:               0x20
    };

    static PIC1 = {                 // MODEL_5170 and up: the "slave" PIC
        INDEX:              1,
        PORT:               0xA0
    };

    static PIC_LO = {               // ChipSet.PIC0.PORT+0 or ChipSet.PIC1.PORT+0
        ICW1:               0x10,   // set means ICW1
        ICW1_ICW4:          0x01,   // ICW4 needed (otherwise ICW4 must be sent)
        ICW1_SNGL:          0x02,   // single PIC (and therefore no ICW3; otherwise there is another "cascaded" PIC)
        ICW1_ADI:           0x04,   // call address interval is 4 (otherwise 8; presumably ignored in 8086/8088 mode)
        ICW1_LTIM:          0x08,   // level-triggered interrupt mode (otherwise edge-triggered mode, which is what PCs use)
        OCW2:               0x00,   // bit 3 (PIC_LO.OCW3) and bit 4 (ChipSet.PIC_LO.ICW1) are clear in an OCW2 command byte
        OCW2_IR_LVL:        0x07,
        OCW2_OP_MASK:       0xE0,   // of the following valid OCW2 operations, the first 4 are EOI commands (all have ChipSet.PIC_LO.OCW2_EOI set)
        OCW2_EOI:           0x20,   // non-specific EOI (end-of-interrupt)
        OCW2_EOI_SPEC:      0x60,   // specific EOI
        OCW2_EOI_ROT:       0xA0,   // rotate on non-specific EOI
        OCW2_EOI_ROTSPEC:   0xE0,   // rotate on specific EOI
        OCW2_SET_ROTAUTO:   0x80,   // set rotate in automatic EOI mode
        OCW2_CLR_ROTAUTO:   0x00,   // clear rotate in automatic EOI mode
        OCW2_SET_PRI:       0xC0,   // bits 0-2 specify the lowest priority interrupt
        OCW3:               0x08,   // bit 3 (PIC_LO.OCW3) is set and bit 4 (PIC_LO.ICW1) clear in an OCW3 command byte (bit 7 should be clear, too)
        OCW3_READ_IRR:      0x02,   // read IRR register
        OCW3_READ_ISR:      0x03,   // read ISR register
        OCW3_READ_CMD:      0x03,
        OCW3_POLL_CMD:      0x04,   // poll
        OCW3_SMM_RESET:     0x40,   // special mask mode: reset
        OCW3_SMM_SET:       0x60,   // special mask mode: set
        OCW3_SMM_CMD:       0x60
    };

    static PIC_HI = {               // ChipSet.PIC0.PORT+1 or ChipSet.PIC1.PORT+1
        ICW2_VECTOR:        0xF8,   // starting vector number (bits 0-2 are effectively treated as zeros in 8086/8088 mode)
        ICW4_8086:          0x01,
        ICW4_AUTO_EOI:      0x02,
        ICW4_MASTER:        0x04,
        ICW4_BUFFERED:      0x08,
        ICW4_FULLY_NESTED:  0x10,
        OCW1_IMR:           0xFF
    };

    /**
     * The priorities of IRQs 0-7 are normally high to low, unless the master PIC has been reprogrammed.
     * Also, if a slave PIC is present, the priorities of IRQs 8-15 fall between the priorities of IRQs 1 and 3.
     *
     * As the MODEL_5170 TechRef states:
     *
     *      "Interrupt requests are prioritized, with IRQ9 through IRQ12 and IRQ14 through IRQ15 having the
     *      highest priority (IRQ9 is the highest) and IRQ3 through IRQ7 having the lowest priority (IRQ7 is
     *      the lowest).
     *
     *      Interrupt 13 (IRQ.FPU) is used on the system board and is not available on the I/O channel.
     *      Interrupt 8 (IRQ.RTC) is used for the real-time clock."
     *
     * This priority scheme is a byproduct of IRQ8 through IRQ15 (slave PIC interrupts) being tied to IRQ2 of
     * the master PIC.  As a result, the two other system board interrupts, IRQ0 and IRQ1, continue to have the
     * highest priority, by default.
     */
    static IRQ = {
        TIMER0:             0x00,
        KBD:                0x01,
        VID:                0x02,   // EGA vertical retrace (arrives via IRQ 9 on MODEL_5170)
        SLAVE:              0x02,   // MODEL_5170
        COM2:               0x03,
        COM1:               0x04,
        XTC:                0x05,   // MODEL_5160 uses IRQ 5 for HDC (XTC version)
        LPT2:               0x05,   // MODEL_5170 uses IRQ 5 for LPT2
        FDC:                0x06,
        LPT1:               0x07,
        RTC:                0x08,   // MODEL_5170
        IRQ2:               0x09,   // MODEL_5170
        FPU:                0x0D,   // MODEL_5170
        ATC1:               0x0E,   // MODEL_5170 uses IRQ 14 for primary ATC controller interrupts
        ATC2:               0x0F    // MODEL_5170 *can* use IRQ 15 for secondary ATC controller interrupts
    };

    /**
     * 8253 Programmable Interval Timer (PIT) I/O ports
     *
     * Although technically, a PIT provides 3 "counters" rather than 3 "timers", we have
     * adopted IBM's TechRef nomenclature, which refers to the PIT's counters as TIMER0,
     * TIMER1, and TIMER2.  For machines with a second PIT (eg, the DeskPro 386), we refer
     * to those additional counters as TIMER3, TIMER4, and TIMER5.
     *
     * In addition, if there's a need to refer to a specific PIT, use PIT0 for the first PIT
     * and PIT1 for the second.  This mirrors how we refer to multiple DMA controllers
     * (eg, DMA0 and DMA1) and multiple PICs (eg, PIC0 and PIC1).
     *
     * This differs from COMPAQ's nomenclature, which used "Timer 1" to refer to the first
     * PIT, and "Timer 2" for the second PIT, and then referred to "Counter 0", "Counter 1",
     * and "Counter 2" within each PIT.
     */
    static PIT0 = {
        PORT:               0x40,
        INDEX:              0,
        TIMER0:             0,      // used for time-of-day (prior to MODEL_5170)
        TIMER1:             1,      // used for memory refresh
        TIMER2:             2       // used for speaker tone generation
    };

    static PIT1 = {
        PORT:               0x48,   // MODEL_COMPAQ_DESKPRO386 only
        INDEX:              1,
        TIMER3:             0,      // used for fail-safe clock
        TIMER4:             1,      // N/A
        TIMER5:             2       // used for refresher request extend/speed control
    };

    static PIT_CTRL = {
        PORT1:              0x43,   // write-only control register (use the Read-Back command to get status)
        PORT2:              0x4B,   // write-only control register (use the Read-Back command to get status)
        BCD:                0x01,
        MODE:               0x0E,
        MODE0:              0x00,   // interrupt on Terminal Count (TC)
        MODE1:              0x02,   // programmable one-shot
        MODE2:              0x04,   // rate generator
        MODE3:              0x06,   // square wave generator
        MODE4:              0x08,   // software-triggered strobe
        MODE5:              0x0A,   // hardware-triggered strobe
        RW:                 0x30,
        RW_LATCH:           0x00,
        RW_LSB:             0x10,
        RW_MSB:             0x20,
        RW_BOTH:            0x30,
        SC:                 0xC0,
        SC_CTR0:            0x00,
        SC_CTR1:            0x40,
        SC_CTR2:            0x80,
        SC_BACK:            0xC0,
        SC_SHIFT:           6,
        RB_CTR0:            0x02,
        RB_CTR1:            0x04,
        RB_CTR2:            0x08,
        RB_STATUS:          0x10,   // if this bit is CLEAR, then latch the current status of the selected counter(s)
        RB_COUNTS:          0x20,   // if this bit is CLEAR, then latch the current count(s) of the selected counter(s)
        RB_NULL:            0x40,   // bit set in Read-Back status byte if the counter has not been "fully loaded" yet
        RB_OUT:             0x80    // bit set in Read-Back status byte if fOUT is true
    };

    static TIMER_TICKS_PER_SEC = 1193181;

    /**
     * 8255A Programmable Peripheral Interface (PPI) I/O ports, for Cassette/Speaker/Keyboard/SW1/etc
     *
     * Normally, 0x99 is written to PPI_CTRL.PORT, indicating that PPI.PORT and PPI_C.PORT are INPUT ports
     * and PPI_B.PORT is an OUTPUT port.
     *
     * However, the MODEL_5160 ROM BIOS initially writes 0x89 instead, making PPI.PORT an OUTPUT port.
     * I'm guessing that's just part of some "diagnostic mode", because all it writes to PPI.PORT are a series
     * of "checkpoint" values (ie, 0x01, 0x02, and 0x03) before updating PPI_CTRL.PORT with the usual 0x99.
     */
    static PPI = {                  // this.bPPIA (port 0x60)
        PORT:               0x60    // INPUT: keyboard scan code (PPI_B.CLEAR_KBD must be clear)
    };

    static PPI_B = {                // this.bPPIB (port 0x61)
        PORT:               0x61,   // OUTPUT (although it has to be treated as INPUT, too; the keyboard interrupt handler reads it, OR's PPI_B.CLEAR_KBD, writes it, and then rewrites the original read value)
        CLK_TIMER2:         0x01,   // ALL: set to enable clock to TIMER2
        SPK_TIMER2:         0x02,   // ALL: set to connect output of TIMER2 to speaker (MODEL_5150: clear for cassette)
        ENABLE_SW2:         0x04,   // MODEL_5150: set to enable SW2[1-4] through PPI_C.PORT, clear to enable SW2[5]; MODEL_5160: unused (there is no SW2 switch block on the MODEL_5160 motherboard)
        CASS_MOTOR_OFF:     0x08,   // MODEL_5150: cassette motor off
        ENABLE_SW_HI:       0x08,   // MODEL_5160: clear to read SW1[1-4], set to read SW1[5-8]
        DISABLE_RW_MEM:     0x10,   // ALL: clear to enable RAM parity check, set to disable
        DISABLE_IO_CHK:     0x20,   // ALL: clear to enable I/O channel check, set to disable
        CLK_KBD:            0x40,   // ALL: clear to force keyboard clock low
        CLEAR_KBD:          0x80    // ALL: clear to enable keyboard scan codes (MODEL_5150: set to enable SW1 through PPI.PORT)
    };

    static PPI_C = {                // this.bPPIC (port 0x62)
        PORT:               0x62,   // INPUT (see below)
        KBD_LATCH:          0x01,   // MODEL_4860 only (set if keyboard data latched)
        NO_MODEM:           0x02,   // MODEL_4860 only (set if no Internal Model Card installed)
        NO_DISKETTE:        0x04,   // MODEL_4860 only (set if no Diskette Drive Adapter installed)
        NO_MEMEXP:          0x08,   // MODEL_4860 only (set if no 64Kb Memory Expansion installed)
        SW:                 0x0F,   // MODEL_5150: SW2[1-4] or SW2[5], depending on whether PPI_B.ENABLE_SW2 is set or clear; MODEL_5160: SW1[1-4] or SW1[5-8], depending on whether PPI_B.ENABLE_SW_HI is clear or set
        CASS_DATA_IN:       0x10,   // MODEL_4860 and MODEL_5150
        TIMER2_OUT:         0x20,   // MODEL_4860 and up (timer 2 output)
        KBD_DATA:           0x40,   // MODEL_4860 only: data from either the keyboard cable or the IR receiver
        NO_KBD_CABLE:       0x80,   // MODEL_4860 only: (set if keyboard cable not connected)
        IO_CHANNEL_CHK:     0x40,   // used by NMI handler to detect I/O channel errors
        RW_PARITY_CHK:      0x80    // used by NMI handler to detect R/W memory parity errors
    };

    static PPI_CTRL = {             // this.bPPICtrl (port 0x63)
        PORT:               0x63,   // OUTPUT: initialized to 0x99, defining PPI and PPI_C as INPUT and PPI_B as OUTPUT
        A_IN:               0x10,
        B_IN:               0x02,
        C_IN_LO:            0x01,
        C_IN_HI:            0x08,
        B_MODE:             0x04,
        A_MODE:             0x60
    };

    /**
     * 8041 Keyboard Controller I/O ports (MODEL_ATT_6300)
     *
     * The AT&T 6300 uses an 8041 for its Keyboard Controller, which has the following ports:
     *
     *      Port    Description
     *      ----    -----------
     *      0x60    Keyboard Scan Code (input)
     *      0x61    Keyboard Control Port (output)
     *      0x64    Keyboard Status Port (input)
     *
     * And the Keyboard Control Port (0x61) has the following bit definitions:
     *
     *      0x01    Speaker gate to 8253 (counter 2)
     *      0x02    Speaker data
     *      0x0C    Not used
     *      0x10    RAM Parity (NMI) Enable
     *      0x20    I/O Channel (NMI) Enable
     *      0x40    Keyboard Clock Reset
     *      0x80    Reset Interrupt Pending
     */
    static C8041 = {
        PORT:               0x60
    };

    /**
     * 8042 Keyboard Controller I/O ports (MODEL_5170)
     *
     * On the MODEL_5170, port 0x60 is designated C8042.DATA rather than PPI, although the BIOS also refers to it
     * as "PORT_A: 8042 KEYBOARD SCAN/DIAG OUTPUTS").  This is the 8042's output buffer and should be read only when
     * C8042.STATUS.OUTBUFF_FULL is set.
     *
     * Similarly, port 0x61 is designated C8042.RWREG rather than PPI_B; the BIOS also refers to it as "PORT_B: 8042
     * READ WRITE REGISTER", but it is not otherwise discussed in the MODEL_5170 TechRef's 8042 documentation.
     *
     * There are brief references to bits 0 and 1 (C8042.RWREG.CLK_TIMER2 and C8042.RWREG.SPK_TIMER2), and the BIOS sets
     * bits 2-7 to "DISABLE PARITY CHECKERS" (principally C8042.RWREG.DISABLE_NMI, which are bits 2 and 3); why the BIOS
     * also sets bits 4-7 (or if those bits are even settable) is unclear, since it uses 11111100b rather than defined
     * constants.
     *
     * The bottom line: on a MODEL_5170, port 0x61 is still used for speaker control and parity checking, so we use
     * the same register (bPPIB) but install different I/O handlers.  It's also bi-directional: at one point, the BIOS
     * reads C8042.RWREG.REFRESH_BIT (bit 4) to verify that it's alternating.
     *
     * PPI_C and PPI_CTRL don't seem to be documented or used by the MODEL_5170 BIOS, so I'm assuming they're obsolete.
     *
     * NOTE: For more information on the 8042 Controller, including information on undocumented commands, refer to the
     * documents in /devices/pc/keyboard, as well as the following websites:
     *
     *      http://halicery.com/8042/8042_INTERN_TXT.htm
     *      http://www.os2museum.com/wp/ibm-pcat-8042-keyboard-controller-commands/
     */
    static C8042 = {
        PORT:               0x60,
        DATA: {                     // this.b8042OutBuff (PPI on previous models, still referred to as "PORT A" by the MODEL_5170 BIOS)
            PORT:           0x60,
            CMD: {                  // this.b8042CmdData (C8042.DATA.CMD "data bytes" written to port 0x60, after writing a C8042.CMD byte to port 0x64)
                INT_ENABLE: 0x01,   // generate an interrupt when the controller places data in the output buffer
                SYS_FLAG:   0x04,   // this value is propagated to ChipSet.C8042.STATUS.SYS_FLAG
                NO_INHIBIT: 0x08,   // disable inhibit function
                NO_CLOCK:   0x10,   // disable keyboard by driving "clock" line low
                PC_MODE:    0x20,
                PC_COMPAT:  0x40    // generate IBM PC-compatible scan codes
            },
            SELF_TEST: {            // result of ChipSet.C8042.CMD.SELF_TEST command (0xAA)
                OK:         0x55
            },
            INTF_TEST: {            // result of ChipSet.C8042.CMD.INTF_TEST command (0xAB)
                OK:         0x00,   // no error
                CLOCK_LO:   0x01,   // keyboard clock line stuck low
                CLOCK_HI:   0x02,   // keyboard clock line stuck high
                DATA_LO:    0x03,   // keyboard data line stuck low
                DATA_HI:    0x04    // keyboard data line stuck high
            }
        },
        INPORT: {                   // this.b8042InPort
            COMPAQ_50MHZ:   0x01,   // 50Mhz system clock enabled (0=48Mhz); see COMPAQ 386/25 TechRef p2-106
            UNDEFINED:      0x02,   // undefined
            COMPAQ_NO80387: 0x04,   // 80387 coprocessor NOT installed; see COMPAQ 386/25 TechRef p2-106
            COMPAQ_NOWEITEK:0x08,   // Weitek coprocessor NOT installed; see COMPAQ 386/25 TechRef p2-106
            ENABLE_256KB:   0x10,   // enable 2nd 256Kb of system board RAM
            COMPAQ_HISPEED: 0x10,   // high-speed enabled (0=AUTO, 1=HIGH); see COMPAQ 386/25 TechRef p2-106
            MFG_OFF:        0x20,   // manufacturing jumper not installed
            COMPAQ_DIP5OFF: 0x20,   // system board DIP switch #5 OFF (0=ON); see COMPAQ 386/25 TechRef p2-106
            MONO:           0x40,   // monochrome monitor is primary display
            COMPAQ_NONDUAL: 0x40,   // COMPAQ Dual-Mode monitor NOT installed; see COMPAQ 386/25 TechRef p2-106
            KBD_UNLOCKED:   0x80    // keyboard not inhibited (in COMPAQ parlance: security lock is unlocked)
        },
        OUTPORT: {                  // this.b8042OutPort
            NO_RESET:       0x01,   // set by default
            A20_ON:         0x02,   // set by default
            COMPAQ_SLOWD:   0x08,   // SL0WD* NOT asserted (refer to timer 2, counter 2); see COMPAQ 386/25 TechRef p2-105
            OUTBUFF_FULL:   0x10,   // output buffer full
            INBUFF_EMPTY:   0x20,   // input buffer empty
            KBD_CLOCK:      0x40,   // keyboard clock (output)
            KBD_DATA:       0x80    // keyboard data (output)
        },
        TESTPORT: {                 // generated "on the fly"
            KBD_CLOCK:      0x01,   // keyboard clock (input)
            KBD_DATA:       0x02    // keyboard data (input)
        },
        RWREG: {                    // this.bPPIB (since CLK_TIMER2 and SPK_TIMER2 are in both PPI_B and RWREG)
            PORT:           0x61,
            CLK_TIMER2:     0x01,   // set to enable clock to TIMER2 (R/W)
            SPK_TIMER2:     0x02,   // set to connect output of TIMER2 to speaker (R/W)
            COMPAQ_FSNMI:   0x04,   // set to disable RAM/FS NMI (R/W, DESKPRO386)
            COMPAQ_IONMI:   0x08,   // set to disable IOCHK NMI (R/W, DESKPRO386)
            DISABLE_NMI:    0x0C,   // set to disable IOCHK and RAM/FS NMI, clear to enable (R/W)
            REFRESH_BIT:    0x10,   // 0 if RAM refresh occurring, 1 if RAM not in refresh cycle (R/O)
            OUT_TIMER2:     0x20,   // state of TIMER2 output signal (R/O, DESKPRO386)
            IOCHK_NMI:      0x40,   // IOCHK NMI (R/O); to reset, pulse bit 3 (0x08)
            RAMFS_NMI:      0x80,   // RAM/FS (parity or fail-safe) NMI (R/O); to reset, pulse bit 2 (0x04)
            NMI_ERROR:      0xC0
        },
        CMD: {                      // this.b8042InBuff (on write to port 0x64, interpret this as a CMD)
            PORT:           0x64,
            READ_CMD:       0x20,   // sends the current CMD byte (this.b8042CmdData) to C8042.PORT
            WRITE_CMD:      0x60,   // followed by a command byte written to C8042.PORT (see C8042.DATA.CMD)
            COMPAQ_SLOWD:   0xA3,   // enable system slow down; see COMPAQ 386/25 TechRef p2-111
            COMPAQ_TOGGLE:  0xA4,   // toggle speed-control bit; see COMPAQ 386/25 TechRef p2-111
            COMPAQ_SREAD2:  0xA5,   // special read of "port 2"; see COMPAQ 386/25 TechRef p2-111
            SELF_TEST:      0xAA,   // self-test (C8042.DATA.SELF_TEST.OK is placed in the output buffer if no errors)
            INTF_TEST:      0xAB,   // interface test
            DIAG_DUMP:      0xAC,   // diagnostic dump
            DISABLE_KBD:    0xAD,   // disable keyboard
            ENABLE_KBD:     0xAE,   // enable keyboard
            READ_INPORT:    0xC0,   // read input port and place data in output buffer (use only if output buffer empty)
            READ_OUTPORT:   0xD0,   // read output port and place data in output buffer (use only if output buffer empty)
            WRITE_OUTPORT:  0xD1,   // next byte written to C8042.PORT (port 0x60) is placed in the output port (see C8042.OUTPORT)
            READ_TEST:      0xE0,
            PULSE_OUTPORT:  0xF0    // this is the 1st of 16 commands (0xF0-0xFF) that pulse bits 0-3 of the output port
        },
        STATUS: {                   // this.b8042Status (on read from port 0x64)
            PORT:           0x64,
            OUTBUFF_FULL:   0x01,
            INBUFF_FULL:    0x02,   // set if the controller has received but not yet read data from the input buffer (not normally set)
            SYS_FLAG:       0x04,
            CMD_FLAG:       0x08,   // set on write to C8042.CMD (port 0x64), clear on write to C8042.DATA (port 0x60)
            NO_INHIBIT:     0x10,   // (in COMPAQ parlance: security lock not engaged)
            XMT_TIMEOUT:    0x20,
            RCV_TIMEOUT:    0x40,
            PARITY_ERR:     0x80,   // last byte of data received had EVEN parity (ODD parity is normally expected)
            OUTBUFF_DELAY:  0x100
        }
    };

    /**
     * MC146818A RTC/CMOS Ports (MODEL_5170)
     *
     * Write a CMOS address to ChipSet.CMOS.ADDR.PORT, then read/write data from/to ChipSet.CMOS.DATA.PORT.
     *
     * The ADDR port also controls NMI: write an address with bit 7 clear to enable NMI or set to disable NMI.
     */
    static CMOS = {
        ADDR: {                     // this.bCMOSAddr
            PORT:           0x70,
            RTC_SEC:        0x00,
            RTC_SEC_ALARM:  0x01,
            RTC_MIN:        0x02,
            RTC_MIN_ALARM:  0x03,
            RTC_HOUR:       0x04,
            RTC_HOUR_ALARM: 0x05,
            RTC_WEEK_DAY:   0x06,
            RTC_MONTH_DAY:  0x07,
            RTC_MONTH:      0x08,
            RTC_YEAR:       0x09,   // 2-digit year (eg, 0x82 for 1982 if BCD mode)
            STATUSA:        0x0A,
            STATUSB:        0x0B,
            STATUSC:        0x0C,
            STATUSD:        0x0D,
            DIAG:           0x0E,
            SHUTDOWN:       0x0F,
            FDRIVE:         0x10,
            HDRIVE:         0x12,   // bits 4-7 contain type of drive 0, bits 0-3 contain type of drive 1 (type 0 means none)
            EQUIP:          0x14,
            BASEMEM_LO:     0x15,
            BASEMEM_HI:     0x16,   // the BASEMEM values indicate the total Kb of base memory, up to 0x280 (640Kb)
            EXTMEM_LO:      0x17,
            EXTMEM_HI:      0x18,   // the EXTMEM values indicate the total Kb of extended memory, up to 0x3C00 (15Mb)
            EXTHDRIVE0:     0x19,   // if bits 4-7 of HDRIVE contains 15, then the type of drive 0 is stored here (16-255)
            EXTHDRIVE1:     0x1A,   // if bits 0-3 of HDRIVE contains 15, then the type of drive 1 is stored here (16-255)
            CHKSUM_HI:      0x2E,
            CHKSUM_LO:      0x2F,   // CMOS bytes included in the checksum calculation: 0x10-0x2D
            EXTMEM2_LO:     0x30,
            EXTMEM2_HI:     0x31,
            CENTURY_DATE:   0x32,   // 2-digit century value in BCD (eg, 0x19 for 20th century, 0x20 for 21st century)
            BOOT_INFO:      0x33,   // 0x80 if 128Kb expansion memory installed, 0x40 if Setup Utility wants an initial setup message
            MASK:           0x3F,
            TOTAL:          0x40,
            NMI_DISABLE:    0x80
        },
        DATA: {                     // this.abCMOSData
            PORT:           0x71
        },
        STATUSA: {                  // abCMOSData[ChipSet.CMOS.ADDR.STATUSA]
            UIP:            0x80,   // bit 7: 1 indicates Update-In-Progress, 0 indicates date/time ready to read
            DV:             0x70,   // bits 6-4 (DV2-DV0) are programmed to 010 to select a 32.768Khz time base
            RS:             0x0F    // bits 3-0 (RS3-RS0) are programmed to 0110 to select a 976.562us interrupt rate
        },
        STATUSB: {                  // abCMOSData[ChipSet.CMOS.ADDR.STATUSB]
            SET:            0x80,   // bit 7: 1 to set any/all of the 14 time-bytes
            PIE:            0x40,   // bit 6: 1 for Periodic Interrupt Enable
            AIE:            0x20,   // bit 5: 1 for Alarm Interrupt Enable
            UIE:            0x10,   // bit 4: 1 for Update Interrupt Enable
            SQWE:           0x08,   // bit 3: 1 for Square Wave Enabled (as set by the STATUSA rate selection bits)
            BINARY:         0x04,   // bit 2: 1 for binary Date Mode, 0 for BCD Date Mode
            HOUR24:         0x02,   // bit 1: 1 for 24-hour mode, 0 for 12-hour mode
            DST:            0x01    // bit 0: 1 for Daylight Savings Time enabled
        },
        STATUSC: {                  // abCMOSData[ChipSet.CMOS.ADDR.STATUSC]
            IRQF:           0x80,   // bit 7: 1 indicates one or more of the following bits (PF, AF, UF) are set
            PF:             0x40,   // bit 6: 1 indicates Periodic Interrupt
            AF:             0x20,   // bit 5: 1 indicates Alarm Interrupt
            UF:             0x10,   // bit 4: 1 indicates Update Interrupt
            RESERVED:       0x0F
        },
        STATUSD: {                  // abCMOSData[ChipSet.CMOS.ADDR.STATUSD]
            VRB:            0x80,   // bit 7: 1 indicates Valid RAM Bit (0 implies power was and/or is lost)
            RESERVED:       0x7F
        },
        DIAG: {                     // abCMOSData[ChipSet.CMOS.ADDR.DIAG]
            RTCFAIL:        0x80,   // bit 7: 1 indicates RTC lost power
            CHKSUMFAIL:     0x40,   // bit 6: 1 indicates bad CMOS checksum
            CONFIGFAIL:     0x20,   // bit 5: 1 indicates bad CMOS configuration info
            MEMSIZEFAIL:    0x10,   // bit 4: 1 indicates memory size miscompare
            HDRIVEFAIL:     0x08,   // bit 3: 1 indicates hard drive controller or drive init failure
            TIMEFAIL:       0x04,   // bit 2: 1 indicates time failure
            RESERVED:       0x03
        },
        FDRIVE: {                   // abCMOSData[ChipSet.CMOS.ADDR.FDRIVE]
            D0_MASK:        0xF0,   // Drive 0 type in high nibble
            D1_MASK:        0x0F,   // Drive 1 type in lower nibble
            NONE:           0,      // no drive
            /**
             * There's at least one floppy drive type that IBM didn't bother defining a CMOS drive type for:
             * single-sided drives that were only capable of storing 160Kb (or 180Kb when using 9 sectors/track).
             * So, as you can see in getDIPFloppyDriveType(), we lump all standard diskette capacities <= 360Kb
             * into the FD360 bucket.
             */
            FD360:          1,      // 5.25-inch double-sided double-density (DSDD 48TPI) drive: 40 tracks, 9 sectors/track, 360Kb max
            FD1200:         2,      // 5.25-inch double-sided high-density (DSHD 96TPI) drive: 80 tracks, 15 sectors/track, 1200Kb max
            FD720:          3,      // 3.5-inch drive capable of storing 80 tracks and up to 9 sectors/track, 720Kb max
            FD1440:         4       // 3.5-inch drive capable of storing 80 tracks and up to 18 sectors/track, 1440Kb max
        },
        /**
         * HDRIVE types are defined by table in the HDC component, which uses setCMOSDriveType() to update the CMOS
         */
        HDRIVE: {                   // abCMOSData[ChipSet.CMOS.ADDR.HDRIVE]
            D0_MASK:        0xF0,   // Drive 0 type in high nibble
            D1_MASK:        0x0F    // Drive 1 type in lower nibble
        },
        /**
         * The CMOS equipment flags use the same format as the older PPI equipment flags
         */
        EQUIP: {                    // abCMOSData[ChipSet.CMOS.ADDR.EQUIP]
            MONITOR:        ChipSet.PPI_SW.MONITOR,         // PPI_SW.MONITOR.MASK == 0x30
            FPU:            ChipSet.PPI_SW.FPU,             // PPI_SW.FPU == 0x02
            FDRIVE:         ChipSet.PPI_SW.FDRIVE           // PPI_SW.FDRIVE.IPL == 0x01 and PPI_SW.FDRIVE.MASK = 0xC0
        }
    };

    /**
     * DMA Page Registers
     *
     * The MODEL_5170 TechRef lists 0x80-0x9F as the range for DMA page registers, but that may be a bit
     * overbroad.  There are a total of 8 (7 usable) DMA channels on the MODEL_5170, each of which has the
     * following assigned DMA page registers:
     *
     *      Channel #   Page Reg
     *      ---------   --------
     *          0         0x87
     *          1         0x83
     *          2         0x81
     *          3         0x82
     *          4         0x8F (not usable; the 5170 TechRef refers to this as the "Refresh" page register)
     *          5         0x8B
     *          6         0x89
     *          7         0x8A
     *
     * That leaves 0x80, 0x84, 0x85, 0x86, 0x88, 0x8C, 0x8D and 0x8E unaccounted for in the range 0x80-0x8F.
     * (I'm saving the question of what, if anything, is available in the range 0x90-0x9F for another day.)
     *
     * As for port 0x80, the TechRef says:
     *
     *      "I/O address hex 080 is used as a diagnostic-checkpoint port or register.
     *      This port corresponds to a read/write register in the DMA page register (74LS612)."
     *
     * so I used to have dedicated handlers and storage (bMFGData) for the register at port 0x80, but I've since
     * appended it to abDMAPageSpare, an 8-element array that captures all I/O to the 8 unassigned (aka "spare")
     * DMA page registers.  The 5170 BIOS uses 0x80 as a "checkpoint" register, and the DESKPRO386 uses 0x84 in a
     * similar fashion.  The 5170 also contains "MFG_TST" code that uses other unassigned DMA page registers as
     * scratch registers, which come in handy when RAM hasn't been tested/initialized yet.
     *
     * Here's our mapping of entries in the abDMAPageSpare array to the unassigned ("spare") DMA page registers:
     *
     *      Index #     Page Reg
     *      --------    --------
     *          0         0x84
     *          1         0x85
     *          2         0x86
     *          3         0x88
     *          4         0x8C
     *          5         0x8D
     *          6         0x8E
     *          7         0x80
     *
     * The only reason port 0x80 is out of sequence (ie, at the end of the array, at index 7 instead of index 0) is
     * because it was added the array later, and the entire array gets written to our save/restore data structures, so
     * reordering the elements would be a bad idea.
     */

    /**
     * NMI Mask Register (port 0xA0)
     *
     * On the MODEL_5150 and MODEL_5160, this is a write-only register, and the only valid bit is ENABLE.
     *
     * On the MODEL_4860, this is a read-write register; the following bit definitions apply to writes, whereas
     * reads are defined as merely clearing the PCjr's keyboard NMI latch (which we maintain here in bit 0).
     */
    static NMI = {                  // this.bNMI
        PORT:               0xA0,   //
        ENABLE:             0x80,   // enables NMI
        IRTEST:             0x40,   // enables 8253 timer 2 output into an IR diode on the IR receiver board
        SELCLK1:            0x20,   // selects timer 0 output to be used as CLK input to timer 1
        DISHRQ:             0x10,   // not implemented on the system board; for use with external bus-master devices
        KBD_LATCH:          0x01,   // keyboard latch (we maintain it here for convenience; it gets propagated to PPI_C bit 0)
        RESET:              0x00    // default value on reset (TODO: Is NMI really disabled by default on reset?)
    };

    /**
     * FPU Coprocessor Control Registers (MODEL_5170)
     */
    static FPU = {                  // TODO: Define a variable for this?
        PORT_CLEAR:         0xF0,   // clear the FPU's "busy" state
        PORT_RESET:         0xF1    // reset the FPU
    };

    /**
     * ChipSet(parmsChipSet)
     *
     * The ChipSet component has the following component-specific (parmsChipSet) properties:
     *
     *      model:          eg, "5150", "5160", "5170", "deskpro386" (should be a member of ChipSet.MODELS)
     *      sw1:            8-character binary string representing the SW1 DIP switches (SW1[1-8]); see Switches Overview
     *      sw2:            8-character binary string representing the SW2 DIP switches (SW2[1-8]) (MODEL_5150 only)
     *      sound:          true (or non-zero) to enable sounds (default), false (or 0) to disable; number used as initial volume
     *      scaleTimers:    true to divide timer cycle counts by the CPU's cycle multiplier (default is false)
     *      floppies:       array of floppy drive sizes in Kb (default is "[360, 360]" if no sw1 value provided)
     *      monitor:        none|tv|color|mono|ega|vga (if no sw1 value provided, default is "ega" for 5170, "mono" otherwise)
     *      dateRTC:        optional RTC date/time (in GMT) to use on reset; use the ISO 8601 format; eg: "2014-10-01T08:00:00"
     *
     * TODO: As support for IBM-compatible machines grows, we should refrain from adding new model strings (eg, "att6300")
     * and corresponding model checks, and instead add more ChipSet configuration properties, such as:
     *
     *      portPIT1:       0x48 to enable PIT1 at base port 0x48 (as used by COMPAQ_DESKPRO386); default to undefined
     *      chipKBD:        8041 to select 8041 emulation (eg, for ATT_6300); default to 8255 for MODEL_5150/MODEL_5160, 8042 for MODEL_5170
     *
     * @this {ChipSet}
     * @param {Object} parmsChipSet
     */
    constructor(parmsChipSet)
    {
        super("ChipSet", parmsChipSet, MESSAGE.CHIPSET);

        let model = parmsChipSet['model'];

        /**
         * this.model is a numeric version of the 'model' string; when comparing this.model to standard IBM
         * model numbers, you should generally compare (this.model|0) to the target value, which truncates it.
         */
        if (model && !ChipSet.MODELS[model]) {
            Component.printf(MESSAGE.NOTICE, "Unrecognized ChipSet model: %s\n", model);
        }

        this.model = ChipSet.MODELS[model] || ChipSet.MODEL_5150_OTHER;

        let bSwitches;
        this.aDIPSwitches = [];

        this.aDMAControllerInit = [0, null, null, 0, new Array(4), 0];
        this.aDMAChannelInit = [true, [0,0], [0,0], [0,0], [0,0]];
        this.aPICInit = [0, new Array(4)];
        this.aTimerInit = [[0,0], [0,0], [0,0], [0,0]];

        /**
         * SW1 describes the number of floppy drives, the amount of base memory, the primary monitor type,
         * and (on the MODEL_5160) whether or not a coprocessor is installed.  If no SW1 settings are provided,
         * we look for individual 'floppies' and 'monitor' settings and build a default SW1 value.
         *
         * The defaults below select max memory, monochrome monitor (EGA monitor for MODEL_5170), and two floppies.
         * Don't get too excited about "max memory" either: on a MODEL_5150, the max was 64Kb, and on a MODEL_5160,
         * the max was 256Kb.  However, the RAM component is free to install as much base memory as it likes,
         * overriding the SW1 memory setting.
         *
         * Given that the ROM BIOS is hard-coded to load boot sectors @0000:7C00, the minimum amount of system RAM
         * required to boot is therefore 32Kb.  Whether that's actually enough to run any or all versions of PC-DOS is
         * a separate question.  FYI, with only 16Kb, the ROM BIOS will still try to boot, and fail miserably.
         */
        bSwitches = this.parseDIPSwitches(parmsChipSet[ChipSet.CONTROLS.SW1]);
        this.aDIPSwitches[0] = [bSwitches, bSwitches];

        if (bSwitches == null) {
            this.aFloppyDrives = [360, 360];
            let aFloppyDrives = parmsChipSet['floppies'];
            if (typeof aFloppyDrives == "string") {
                aFloppyDrives = JSON.parse(aFloppyDrives);
            }
            if (aFloppyDrives && aFloppyDrives.length) this.aFloppyDrives = aFloppyDrives;
            this.setDIPSwitches(ChipSet.SW_TYPE.FLOPNUM, this.aFloppyDrives.length);

            let sMonitor = parmsChipSet['monitor'] || (this.model < ChipSet.MODEL_5170? "mono" : "ega");
            this.setDIPSwitches(ChipSet.SW_TYPE.MONITOR, sMonitor);
        }

        /**
         * SW2 describes the number of 32Kb blocks of I/O expansion RAM that's present in the system. The MODEL_5150
         * ROM BIOS only checked/supported the first four switches, so the maximum amount of additional RAM specifiable
         * was 15 * 32Kb, or 480Kb.  So with a 16Kb-64Kb motherboard, the MODEL_5150 ROM BIOS could support a grand
         * total of 544Kb.  With the 64Kb-256Kb motherboard revision, a 5150 could use the first FIVE SW2 switches,
         * allowing for a grand total as high as 640Kb.
         *
         * For MODEL_5160 (PC XT) and up, memory expansion cards had their own switches, and the motherboard
         * SW2 switches for I/O expansion RAM were eliminated.  Instead, the ROM BIOS scans the entire address space
         * (up to 0xA0000) looking for additional memory.  As a result, the only mechanism we provide for adding RAM
         * (above the maximum of 256Kb supported on the motherboard) is the "size" parameter of the RAM component.
         *
         * NOTE: If you use the "size" parameter, you will not be able to dynamically alter the memory configuration;
         * the RAM component will ignore any changes to SW1.
         */
        bSwitches = this.parseDIPSwitches(parmsChipSet[ChipSet.CONTROLS.SW2]);
        this.aDIPSwitches[1] = [bSwitches, bSwitches];

        this.sCellClass = CSSCLASS + "-bitCell";

        this.cDMACs = 0;
        if (this.model >= ChipSet.MODEL_5150) {
            this.cDMACs++;
        }
        if (this.model >= ChipSet.MODEL_5170) {
            this.cDMACs++;
        }

        this.cPICs = 1;
        if (this.model == ChipSet.MODEL_S100 || this.model >= ChipSet.MODEL_5170) {
            this.cPICs++;
        }

        this.fScaleTimers = parmsChipSet['scaleTimers'] || false;
        this.sDateRTC = parmsChipSet['dateRTC'];

        /**
         * Here, I'm finally getting around to trying the WebLib Audio API.  Fortunately, based on what little
         * I know about sound generation, using the API to make the same noises as the IBM PC speaker seems
         * straightforward.
         *
         * To start, we create an audio context, unless the 'sound' parameter has been explicitly set to false
         * or 0; the boolean value true (along with any illegal number) now defaults to 0.5 instead of 1.0.
         */
        this.volumeInit = 0;
        let sound = parmsChipSet['sound'];
        if (sound) {
            this.volumeInit = (typeof sound != "number" || sound < 0 || sound > 1)? 0.5 : sound;
            this.classAudio = this.contextAudio = null;
            this.classAudio = globals.window['AudioContext'] || globals.window['webkitAudioContext'];
            if (this.classAudio) {
                this.contextAudio = new this.classAudio();
            } else {
                if (DEBUG) this.printf(MESSAGE.LOG, "AudioContext not available");
            }
        }
        /**
         * fSpeakerEnabled indicates whether the speaker is *logically* on, whereas fSpeakerOn indicates
         * whether we have ACTUALLY turned the speaker on.  And finally, fUserSound is set to true only after
         * we have have created the audio oscillator in the context of a user event (a requirement for most
         * browsers before they'll actually emit any sound).
         */
        this.fSpeakerEnabled = this.fSpeakerOn = this.fUserSound = false;

        /**
         * I used to defer ChipSet's reset() to powerUp(), which then gave us the option of doing either
         * reset() OR restore(), instead of both.  However, on MODEL_5170 machines, the initial CMOS data
         * needs to be created earlier, so that when other components are initializing their state (eg, when
         * HDC calls setCMOSDriveType() or RAM calls addCMOSMemory()), the CMOS will be ready to take their calls.
         */
        this.reset(true);
    }

    /**
     * initBus(cmp, bus, cpu, dbg)
     *
     * @this {ChipSet}
     * @param {Computer} cmp
     * @param {Busx86} bus
     * @param {CPUx86} cpu
     * @param {Debuggerx86} dbg
     */
    initBus(cmp, bus, cpu, dbg)
    {
        this.bus = bus;
        this.cpu = cpu;
        this.dbg = dbg;
        this.cmp = cmp;

        this.fpuActive = null;
        this.setDIPSwitches(ChipSet.SW_TYPE.FPU, this.cmp.fpu? 1 : 0, true);

        this.kbd = cmp.getMachineComponent("Keyboard");

        let sound = cmp.getMachineParm('sound');
        if (sound != null) {
            let volume = +sound || 0;
            this.volumeInit = (sound == "true" || volume < 0 || volume > 1? 0.5 : volume);
        }
        if (!this.volumeInit) this.printf(MESSAGE.NONE, "note: speaker disabled\n");

        /**
         * This divisor is invariant, so we calculate it as soon as we're able to query the CPU's base speed.
         */
        this.nTicksDivisor = (cpu.getBaseCyclesPerSecond() / ChipSet.TIMER_TICKS_PER_SEC);

        let aPortInput = ChipSet.aPortInput;
        let aPortOutput = ChipSet.aPortOutput;
        if (this.model == ChipSet.MODEL_S100) {
            aPortInput = {
                [this.portPIC0+0]: ChipSet.aPortInput[ChipSet.PIC0.PORT+0],
                [this.portPIC0+1]: ChipSet.aPortInput[ChipSet.PIC0.PORT+1],
                [this.portPIC1+0]: ChipSet.aPortInput5170[ChipSet.PIC1.PORT+0],
                [this.portPIC1+1]: ChipSet.aPortInput5170[ChipSet.PIC1.PORT+1]
            };
            aPortOutput = {
                [this.portPIC0+0]: ChipSet.aPortOutput[ChipSet.PIC0.PORT+0],
                [this.portPIC0+1]: ChipSet.aPortOutput[ChipSet.PIC0.PORT+1],
                [this.portPIC1+0]: ChipSet.aPortOutput5170[ChipSet.PIC1.PORT+0],
                [this.portPIC1+1]: ChipSet.aPortOutput5170[ChipSet.PIC1.PORT+1]
            };
        }

        bus.addPortInputTable(this, aPortInput);
        bus.addPortOutputTable(this, aPortOutput);
        if (this.model == ChipSet.MODEL_4860) {
            bus.addPortInputTable(this, ChipSet.aPortInput4860);
            bus.addPortOutputTable(this, ChipSet.aPortOutput4860);
        }
        else if (this.model >= ChipSet.MODEL_5150) {
            bus.addPortInputTable(this, ChipSet.aPortInput51xx);
            bus.addPortOutputTable(this, ChipSet.aPortOutput51xx);
            if (this.model < ChipSet.MODEL_5170) {
                if (this.model == ChipSet.MODEL_ATT_6300) {
                    bus.addPortInputTable(this, ChipSet.aPortInput6300);
                    bus.addPortOutputTable(this, ChipSet.aPortOutput6300);
                } else {
                    bus.addPortInputTable(this, ChipSet.aPortInput5150);
                    bus.addPortOutputTable(this, ChipSet.aPortOutput5150);
                }
            } else {
                bus.addPortInputTable(this, ChipSet.aPortInput5170);
                bus.addPortOutputTable(this, ChipSet.aPortOutput5170);
                if (DESKPRO386 && (this.model|0) == ChipSet.MODEL_COMPAQ_DESKPRO386) {
                    bus.addPortInputTable(this, ChipSet.aPortInputDeskPro386);
                    bus.addPortOutputTable(this, ChipSet.aPortOutputDeskPro386);
                }
            }
        }
        if (DEBUGGER) {
            if (dbg) {
                let chipset = this;
                /**
                 * TODO: Add more "dumpers" (eg, for DMA, RTC, 8042, etc)
                 */
                dbg.messageDump(MESSAGE.PIC, function onDumpPIC() {
                    chipset.dumpPIC();
                });
                dbg.messageDump(MESSAGE.TIMER, function onDumpTimer(asArgs) {
                    chipset.dumpTimer(asArgs);
                });
                if (this.model >= ChipSet.MODEL_5170) {
                    dbg.messageDump(MESSAGE.CMOS, function onDumpCMOS() {
                        chipset.dumpCMOS();
                    });
                }
            }
            cpu.addIntNotify(Interrupts.TIMER, this.intBIOSTimer.bind(this));
        }
        this.setReady();
    }

    /**
     * setBinding(sHTMLType, sBinding, control, sValue)
     *
     * @this {ChipSet}
     * @param {string} sHTMLType is the type of the HTML control (eg, "button", "list", "text", "submit", "textarea", "canvas")
     * @param {string} sBinding is the value of the 'binding' parameter stored in the HTML control's "data-value" attribute (eg, "sw1")
     * @param {HTMLElement} control is the HTML control DOM object (eg, HTMLButtonElement)
     * @param {string} [sValue] optional data value
     * @returns {boolean} true if binding was successful, false if unrecognized binding request
     */
    setBinding(sHTMLType, sBinding, control, sValue)
    {
        switch (sBinding) {

        case ChipSet.CONTROLS.SW1:
            this.bindings[sBinding] = control;
            this.addDIPSwitches(0, sBinding);
            return true;

        case ChipSet.CONTROLS.SW2:
            if ((this.model|0) == ChipSet.MODEL_5150 || this.model == ChipSet.MODEL_ATT_6300) {
                this.bindings[sBinding] = control;
                this.addDIPSwitches(1, sBinding);
                return true;
            }
            break;

        case ChipSet.CONTROLS.SWDESC:
            this.bindings[sBinding] = control;
            return true;

        default:
            break;
        }
        return false;
    }

    /**
     * powerUp(data, fRepower)
     *
     * @this {ChipSet}
     * @param {Object|null} data
     * @param {boolean} [fRepower]
     * @returns {boolean} true if successful, false if failure
     */
    powerUp(data, fRepower)
    {
        if (!fRepower) {
            if (!data) {
                this.reset();
            } else {
                if (!this.restore(data)) return false;
            }
            if (this.cpu) {
                this.fpuActive = this.cpu.fpuActive;
            }
        }
        return true;
    }

    /**
     * powerDown(fSave, fShutdown)
     *
     * @this {ChipSet}
     * @param {boolean} [fSave]
     * @param {boolean} [fShutdown]
     * @returns {Object|boolean} component state if fSave; otherwise, true if successful, false if failure
     */
    powerDown(fSave, fShutdown)
    {
        return fSave? this.save() : true;
    }

    /**
     * reset(fHard)
     *
     * @this {ChipSet}
     * @param {boolean} [fHard] true on the initial reset (not a normal "soft" reset)
     */
    reset(fHard)
    {
        /**
         * We propagate the initial DIP switch values to the current DIP switch values on reset;
         * the user is only allowed to tweak the initial values, which require a reset to take effect.
         */
        let i;
        this.updateDIPSwitches();

        /**
         * If the CPU is reset first, its resetFPU() function call to getDIPCoprocessor() may return
         * stale information, so now that DIP switches have been updated, we call resetFPU() from here as well.
         */
        if (this.cpu) this.cpu.resetFPU();

        /**
         * DMA (Direct Memory Access) Controller initialization
         */
        this.aDMACs = new Array(this.cDMACs);
        for (i = 0; i < this.cDMACs; i++) {
            this.initDMAController(i);
        }

        /**
         * PIC (Programmable Interrupt Controller) initialization
         */
        this.aPICs = new Array(this.cPICs);
        this.portPIC0 = ChipSet.PIC0.PORT;
        this.portPIC1 = ChipSet.PIC1.PORT;
        if (this.model == ChipSet.MODEL_S100) {
            const ports = [0xF0, 0x70, 0xB0, 0x30, 0xD0, 0x50, 0x90, 0x10, 0xE0, 0x60, 0xA0, 0x20, 0xC0, 0x40, 0x80, 0x00];
            this.portPIC0 = ports[this.aDIPSwitches[0][0] & 0xf];
            this.portPIC1 = this.portPIC0 + 2;
        }
        this.initPIC(ChipSet.PIC0.INDEX, this.portPIC0);
        if (this.cPICs > 1) {
            this.initPIC(ChipSet.PIC1.INDEX, this.portPIC1);
        }

        /**
         * PIT (Programmable Interval Timer) initialization
         *
         * Although the DeskPro 386 refers to the timers in the first PIT as "Timer 1, Counter 0",
         * "Timer 1, Counter 1" and "Timer 1, Counter 2", we're sticking with IBM's nomenclature:
         * TIMER0, TIMER1 and TIMER2.  Which means that we refer to the "counters" in the second PIT
         * as TIMER3, TIMER4 and TIMER5; that numbering also matches their indexes in the aTimers array.
         */
        this.bPIT0Ctrl = null;          // tracks writes to port 0x43
        this.bPIT1Ctrl = null;          // tracks writes to port 0x4B (MODEL_COMPAQ_DESKPRO386 only)

        this.aTimers = /** @type {Array.<Timer>} */ (new Array((this.model|0) == ChipSet.MODEL_COMPAQ_DESKPRO386? 6 : 3));
        for (i = 0; i < this.aTimers.length; i++) {
            this.initTimer(i);
        }

        /**
         * PPI and other misc ports
         */
        this.bPPIA = null;              // tracks writes to port 0x60, in case PPI_CTRL.A_IN is not set
        this.bPPIB = null;              // tracks writes to port 0x61, in case PPI_CTRL.B_IN is not set
        this.bPPIC = null;              // tracks writes to port 0x62, in case PPI_CTRL.C_IN_LO or PPI_CTRL.C_IN_HI is not set
        this.bPPICtrl = null;           // tracks writes to port 0x63 (eg, 0x99); read-only
        this.bNMI = ChipSet.NMI.RESET;  // tracks writes to the NMI Mask Register
        this.bKbdData = 0;              // records last byte received via receiveKbdData(); for machines without an 8042 (eg, PC/PC XT/PCjr)

        if (this.model == ChipSet.MODEL_ATT_6300) {
            this.b8041Status = 0;       // similar to b8042Status (but apparently only bits 0 and 1 are used)
        }

        /**
         * ChipSet state introduced by the MODEL_5170
         */
        if (this.model >= ChipSet.MODEL_5170) {
            /**
             * The 8042 input buffer is treated as a "command byte" when written via port 0x64 and as a "data byte"
             * when written via port 0x60.  So, whenever the C8042.CMD.WRITE_CMD "command byte" is written to the input
             * buffer, the subsequent command data byte is saved in b8042CmdData.  Similarly, for C8042.CMD.WRITE_OUTPORT,
             * the subsequent data byte is saved in b8042OutPort.
             *
             * TODO: Consider a UI for the Keyboard INHIBIT switch.  By default, our keyboard is never inhibited
             * (ie, locked).  Also, note that the hardware changes this bit only when new data is sent to b8042OutBuff.
             */
            this.b8042Status = ChipSet.C8042.STATUS.NO_INHIBIT;
            this.b8042InBuff = 0;
            this.b8042CmdData = ChipSet.C8042.DATA.CMD.NO_CLOCK;
            this.b8042OutBuff = 0;

            /**
             * TODO: Provide more control over these 8042 "Input Port" bits (eg, the keyboard lock)
             */
            this.b8042InPort = ChipSet.C8042.INPORT.MFG_OFF | ChipSet.C8042.INPORT.KBD_UNLOCKED;

            if (this.getDIPMemorySize() >= 512) {
                this.b8042InPort |= ChipSet.C8042.INPORT.ENABLE_256KB;
            }

            if (this.getDIPVideoMonitor() == ChipSet.MONITOR.MONO) {
                this.b8042InPort |= ChipSet.C8042.INPORT.MONO;
            }

            if (DESKPRO386 && (this.model|0) == ChipSet.MODEL_COMPAQ_DESKPRO386) {
                this.b8042InPort |= ChipSet.C8042.INPORT.COMPAQ_NO80387 | ChipSet.C8042.INPORT.COMPAQ_NOWEITEK;
            }

            this.b8042OutPort = ChipSet.C8042.OUTPORT.NO_RESET | ChipSet.C8042.OUTPORT.A20_ON;

            this.abDMAPageSpare = new Array(8);

            this.bCMOSAddr = 0;         // NMI is enabled, since the ChipSet.CMOS.ADDR.NMI_DISABLE bit is not set in bCMOSAddr

            /**
             * Now that we call reset() from the ChipSet constructor, enabling other components to update
             * their own CMOS information as needed, we must distinguish between the initial ("hard") reset
             * and any later ("soft") resets (eg, from powerUp() calls), and make sure the latter preserves
             * existing CMOS information.
             */
            if (fHard) {
                this.abCMOSData = new Array(ChipSet.CMOS.ADDR.TOTAL);
            }

            this.initRTCTime(this.sDateRTC);

            /**
             * initCMOSData() will initialize a variety of "legacy" CMOS bytes, but it will NOT overwrite any memory
             * size or hard drive type information that might have been set, via addCMOSMemory() or setCMOSDriveType().
             */
            this.initCMOSData();
        }

        if (DEBUGGER && MAXDEBUG) {
            /**
             * Arrays for interrupt counts (one count per IRQ) and timer data
             */
            this.acInterrupts = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
            this.acTimersFired = [0, 0, 0];
            this.acTimer0Counts = [];
        }
    }

    /**
     * initRTCTime(sDate)
     *
     * Initialize the RTC portion of the CMOS registers to match the specified date/time (or if none is specified,
     * the current date/time).  The date/time should be expressed in the ISO 8601 format; eg: "2011-10-10T14:48:00".
     *
     * NOTE: There are two approaches we could take here: always store the RTC bytes in binary, and convert them
     * to/from BCD on-demand (ie, as the simulation reads/writes the CMOS RTC registers); or init/update them in the
     * format specified by CMOS.STATUSB.BINARY (1 for binary, 0 for BCD).  Both approaches require BCD conversion
     * functions, but the former seems more efficient, in part because the periodic calls to updateRTCTime() won't
     * require any conversions.
     *
     * We take the same approach with the CMOS.STATUSB.HOUR24 setting: internally, we always operate in 24-hour mode,
     * but externally, we convert the RTC hour values to the 12-hour format as needed.
     *
     * Thus, all I/O to the RTC bytes must be routed through the getRTCByte() and setRTCByte() functions, to ensure
     * that all the necessary on-demand conversions occur.
     *
     * @this {ChipSet}
     * @param {string} [sDate]
     * @returns {number} (programmed number of seconds since midnight)
     */
    initRTCTime(sDate)
    {
        /**
         * NOTE: I've already been burned once by a JavaScript library function that did NOT treat an undefined
         * parameter (ie, a parameter === undefined) the same as an omitted parameter (eg, the async parameter in
         * xmlHTTP.open() in IE), so I'm taking no chances here: if sDate is undefined, then explicitly call Date()
         * with no parameters.
         */
        let date = sDate? new Date(sDate) : new Date();

        /**
         * Example of a valid Date string:
         *
         *      2014-10-01T08:00:00 (interpreted as GMT, resulting in "Wed Oct 01 2014 01:00:00 GMT-0700 (PDT)")
         *
         * Examples of INVALID Date strings:
         *
         *      2014-10-01T08:00:00PST
         *      2014-10-01T08:00:00-0700 (actually, this DOES work in Chrome, but NOT in Safari)
         *
         * In the case of INVALID Date strings, the Date object is invalid, but there's no obvious test for an "invalid"
         * object, so I've adapted the following test from StackOverflow.
         *
         * See http://stackoverflow.com/questions/1353684/detecting-an-invalid-date-date-instance-in-javascript
         */
        if (Object.prototype.toString.call(date) !== "[object Date]" || isNaN(date.getTime())) {
            date = new Date();
            this.printf(MESSAGE.NONE, "CMOS date invalid (%s), using %T\n", sDate, date);
        } else if (sDate) {
            this.printf(MESSAGE.NONE, "CMOS date: %T\n", date);
        }

        let h, m, s;
        this.abCMOSData[ChipSet.CMOS.ADDR.RTC_SEC] = s = date.getSeconds();
        this.abCMOSData[ChipSet.CMOS.ADDR.RTC_SEC_ALARM] = 0;
        this.abCMOSData[ChipSet.CMOS.ADDR.RTC_MIN] = m = date.getMinutes();
        this.abCMOSData[ChipSet.CMOS.ADDR.RTC_MIN_ALARM] = 0;
        this.abCMOSData[ChipSet.CMOS.ADDR.RTC_HOUR] = h = date.getHours();
        this.abCMOSData[ChipSet.CMOS.ADDR.RTC_HOUR_ALARM] = 0;
        this.abCMOSData[ChipSet.CMOS.ADDR.RTC_WEEK_DAY] = date.getDay() + 1;
        this.abCMOSData[ChipSet.CMOS.ADDR.RTC_MONTH_DAY] = date.getDate();
        this.abCMOSData[ChipSet.CMOS.ADDR.RTC_MONTH] = date.getMonth() + 1;
        let nYear = date.getFullYear();
        this.abCMOSData[ChipSet.CMOS.ADDR.RTC_YEAR] = nYear % 100;
        let nCentury = (nYear / 100);
        this.abCMOSData[ChipSet.CMOS.ADDR.CENTURY_DATE] = (nCentury % 10) | ((nCentury / 10) << 4);

        this.abCMOSData[ChipSet.CMOS.ADDR.STATUSA] = 0x26;                          // hard-coded default; refer to ChipSet.CMOS.STATUSA.DV and ChipSet.CMOS.STATUSA.RS
        this.abCMOSData[ChipSet.CMOS.ADDR.STATUSB] = ChipSet.CMOS.STATUSB.HOUR24;   // default to BCD mode (ChipSet.CMOS.STATUSB.BINARY not set)
        this.abCMOSData[ChipSet.CMOS.ADDR.STATUSC] = 0x00;
        this.abCMOSData[ChipSet.CMOS.ADDR.STATUSD] = ChipSet.CMOS.STATUSD.VRB;

        this.nRTCCyclesLastUpdate = this.nRTCCyclesNextUpdate = 0;
        this.nRTCPeriodsPerSecond = this.nRTCCyclesPerPeriod = null;

        /**
         * Return the number of seconds since midnight that have been programmed into the RTC, so that the
         * caller can easily convert that into TIMER_LOW/TIMER_HIGH values for the ROM BIOS data area, if needed.
         */
        return h * 3600 + m * 60 + s;
    }

    /**
     * getRTCByte(iRTC)
     *
     * @param {number} iRTC
     * @returns {number} b
     */
    getRTCByte(iRTC)
    {


        let b = this.abCMOSData[iRTC];

        if (iRTC < ChipSet.CMOS.ADDR.STATUSA) {
            let f12HourValue = false;
            if (iRTC == ChipSet.CMOS.ADDR.RTC_HOUR || iRTC == ChipSet.CMOS.ADDR.RTC_HOUR_ALARM) {
                if (!(this.abCMOSData[ChipSet.CMOS.ADDR.STATUSB] & ChipSet.CMOS.STATUSB.HOUR24)) {
                    if (b < 12) {
                        b = (!b? 12 : b);
                    } else {
                        b -= 12;
                        b = (!b? 0x8c : b + 0x80);
                    }
                    f12HourValue = true;
                }
            }
            if (!(this.abCMOSData[ChipSet.CMOS.ADDR.STATUSB] & ChipSet.CMOS.STATUSB.BINARY)) {
                /**
                 * We're in BCD mode, so we must convert b from BINARY to BCD.  But first:
                 *
                 *      If b is a 12-hour value (ie, we're in 12-hour mode) AND the hour is a PM value
                 *      (ie, in the range 0x81-0x8C), then it must be adjusted to yield 81-92 in BCD.
                 *
                 *      AM hour values (0x01-0x0C) need no adjustment; they naturally convert to 01-12 in BCD.
                 */
                if (f12HourValue && b > 0x80) {
                    b -= (0x81 - 81);
                }
                b = (b % 10) | ((b / 10) << 4);
            }
        } else {
            if (iRTC == ChipSet.CMOS.ADDR.STATUSA) {
                /**
                 * Make sure that the "Update-In-Progress" bit we set in updateRTCTime() doesn't stay set for
                 * more than one read.
                 */
                this.abCMOSData[iRTC] &= ~ChipSet.CMOS.STATUSA.UIP;
            }
        }
        return b;
    }

    /**
     * setRTCByte(iRTC, b)
     *
     * @param {number} iRTC
     * @param {number} b proposed byte to write
     * @returns {number} actual byte to write
     */
    setRTCByte(iRTC, b)
    {


        if (iRTC < ChipSet.CMOS.ADDR.STATUSA) {
            let fBCD = false;
            if (!(this.abCMOSData[ChipSet.CMOS.ADDR.STATUSB] & ChipSet.CMOS.STATUSB.BINARY)) {
                /**
                 * We're in BCD mode, so we must convert b from BCD to BINARY (we assume it's valid
                 * BCD; ie, that both nibbles contain only 0-9, not A-F).
                 */
                b = (b >> 4) * 10 + (b & 0xf);
                fBCD = true;
            }
            if (iRTC == ChipSet.CMOS.ADDR.RTC_HOUR || iRTC == ChipSet.CMOS.ADDR.RTC_HOUR_ALARM) {
                if (fBCD) {
                    /**
                     * If the original BCD hour was 0x81-0x92, then the previous BINARY-to-BCD conversion
                     * transformed it to 0x51-0x5C, so we must add 0x30.
                     */
                    if (b > 23) {

                        b += 0x30;
                    }
                }
                if (!(this.abCMOSData[ChipSet.CMOS.ADDR.STATUSB] & ChipSet.CMOS.STATUSB.HOUR24)) {
                    if (b <= 12) {
                        b = (b == 12? 0 : b);
                    } else {
                        b -= (0x80 - 12);
                        b = (b == 24? 12 : b);
                    }
                }
            }
        }
        return b;
    }

    /**
     * calcRTCCyclePeriod()
     *
     * This should be called whenever the timings in STATUSA may have changed.
     *
     * TODO: 1024 is a hard-coded number of periods per second based on the default interrupt rate of 976.562us
     * (ie, 1000000 / 976.562).  Calculate the actual number based on the values programmed in the STATUSA register.
     *
     * @this {ChipSet}
     */
    calcRTCCyclePeriod()
    {
        this.nRTCCyclesLastUpdate = this.cpu.getCycles(this.fScaleTimers);
        this.nRTCPeriodsPerSecond = 1024;
        this.nRTCCyclesPerPeriod = Math.floor(this.cpu.getBaseCyclesPerSecond() / this.nRTCPeriodsPerSecond);
        this.setRTCCycleLimit();
    }

    /**
     * getRTCCycleLimit(nCycles)
     *
     * This is called by the CPU to determine the maximum number of cycles it can process for the current burst.
     *
     * @this {ChipSet}
     * @param {number} nCycles desired
     * @returns {number} maximum number of cycles (<= nCycles)
     */
    getRTCCycleLimit(nCycles)
    {
        if (this.abCMOSData && this.abCMOSData[ChipSet.CMOS.ADDR.STATUSB] & ChipSet.CMOS.STATUSB.PIE) {
            let nCyclesUpdate = this.nRTCCyclesNextUpdate - this.cpu.getCycles(this.fScaleTimers);
            if (nCyclesUpdate > 0) {
                if (nCycles > nCyclesUpdate) {
                    if (DEBUG) this.printf(MESSAGE.RTC, "getRTCCycleLimit(%d): reduced to %d cycles\n", nCycles, nCyclesUpdate);
                    nCycles = nCyclesUpdate;
                } else {
                    if (DEBUG) this.printf(MESSAGE.RTC, "getRTCCycleLimit(%d): already less than %d cycles\n", nCycles, nCyclesUpdate);
                }
            } else {
                if (DEBUG) this.printf(MESSAGE.RTC, "RTC next update has passed by %d cycles\n", nCyclesUpdate);
            }
        }
        return nCycles;
    }

    /**
     * setRTCCycleLimit()
     *
     * This should be called when PIE becomes set in STATUSB (and whenever PF is cleared in STATUSC while PIE is still set).
     *
     * @this {ChipSet}
     */
    setRTCCycleLimit()
    {
        let nCycles = this.nRTCCyclesPerPeriod;
        this.nRTCCyclesNextUpdate = this.cpu.getCycles(this.fScaleTimers) + nCycles;
        if (this.abCMOSData[ChipSet.CMOS.ADDR.STATUSB] & ChipSet.CMOS.STATUSB.PIE) {
            this.cpu.setBurstCycles(nCycles);
        }
    }

    /**
     * updateRTCTime()
     *
     * @this {ChipSet}
     */
    updateRTCTime()
    {
        let nCyclesPerSecond = this.cpu.getBaseCyclesPerSecond();
        let nCyclesUpdate = this.cpu.getCycles(this.fScaleTimers);

        /**
         * We must arrange for the very first calcRTCCyclePeriod() call to occur here, on the very first
         * updateRTCTime() call, because this is the first point we can be guaranteed that CPU cycle counts
         * are initialized (the CPU is the last component to be powered up/restored).
         *
         * TODO: A side-effect of this is that it undermines the save/restore code's preservation of last
         * and next RTC cycle counts, which may affect when the next RTC event is delivered.
         */
        if (this.nRTCCyclesPerPeriod == null) this.calcRTCCyclePeriod();

        /**
         * Step 1: Deal with Periodic Interrupts
         */
        if (nCyclesUpdate >= this.nRTCCyclesNextUpdate) {
            let bPrev = this.abCMOSData[ChipSet.CMOS.ADDR.STATUSC];
            this.abCMOSData[ChipSet.CMOS.ADDR.STATUSC] |= ChipSet.CMOS.STATUSC.PF;
            if (this.abCMOSData[ChipSet.CMOS.ADDR.STATUSB] & ChipSet.CMOS.STATUSB.PIE) {
                /**
                 * When PIE is set, setBurstCycles() should be getting called as needed to ensure
                 * that updateRTCTime() is called more frequently, so let's assert that we don't have
                 * an excess of cycles and thus possibly some missed Periodic Interrupts.
                 */
                if (DEBUG) {
                    if (nCyclesUpdate - this.nRTCCyclesNextUpdate > this.nRTCCyclesPerPeriod) {
                        if (bPrev & ChipSet.CMOS.STATUSC.PF) {
                            this.printf(MESSAGE.RTC, "RTC interrupt handler failed to clear STATUSC\n");
                        } else {
                            this.printf(MESSAGE.RTC, "CPU took too long trigger new RTC periodic interrupt\n");
                        }
                    }
                }
                this.abCMOSData[ChipSet.CMOS.ADDR.STATUSC] |= ChipSet.CMOS.STATUSC.IRQF;
                this.setIRR(ChipSet.IRQ.RTC);
                /**
                 * We could also call setRTCCycleLimit() at this point, but I don't think there's any
                 * benefit until the interrupt had been acknowledged and STATUSC has been read, thereby
                 * clearing the way for another Periodic Interrupt; it seems to me that when STATUSC
                 * is read, that's the more appropriate time to call setRTCCycleLimit().
                 */
            }
            this.nRTCCyclesNextUpdate = nCyclesUpdate + this.nRTCCyclesPerPeriod;
        }

        /**
         * Step 2: Deal with Alarm Interrupts
         */
        if (this.abCMOSData[ChipSet.CMOS.ADDR.RTC_SEC] == this.abCMOSData[ChipSet.CMOS.ADDR.RTC_SEC_ALARM]) {
            if (this.abCMOSData[ChipSet.CMOS.ADDR.RTC_MIN] == this.abCMOSData[ChipSet.CMOS.ADDR.RTC_MIN_ALARM]) {
                if (this.abCMOSData[ChipSet.CMOS.ADDR.RTC_HOUR] == this.abCMOSData[ChipSet.CMOS.ADDR.RTC_HOUR_ALARM]) {
                    this.abCMOSData[ChipSet.CMOS.ADDR.STATUSC] |= ChipSet.CMOS.STATUSC.AF;
                    if (this.abCMOSData[ChipSet.CMOS.ADDR.STATUSB] & ChipSet.CMOS.STATUSB.AIE) {
                        this.abCMOSData[ChipSet.CMOS.ADDR.STATUSC] |= ChipSet.CMOS.STATUSC.IRQF;
                        this.setIRR(ChipSet.IRQ.RTC);
                    }
                }
            }
        }

        /**
         * Step 3: Update the RTC date/time and deal with Update Interrupts
         */
        let nCyclesDelta = nCyclesUpdate - this.nRTCCyclesLastUpdate;
        // DEBUG:
        let nSecondsDelta = Math.floor(nCyclesDelta / nCyclesPerSecond);

        /**
         * We trust that updateRTCTime() is being called as part of updateAllTimers(), and is therefore
         * being called often enough to ensure that nSecondsDelta will never be greater than one.  In fact,
         * it would always be LESS than one if it weren't also for the fact that we plow any "unused" cycles
         * (nCyclesDelta % nCyclesPerSecond) back into nRTCCyclesLastUpdate, so that we will eventually
         * see a one-second delta.
         */
        // DEBUG:

        /**
         * Make sure that CMOS.STATUSB.SET isn't set; if it is, then the once-per-second RTC updates must be
         * disabled so that software can write new RTC date/time values without interference.
         */
        if (nSecondsDelta && !(this.abCMOSData[ChipSet.CMOS.ADDR.STATUSB] & ChipSet.CMOS.STATUSB.SET)) {
            while (nSecondsDelta--) {
                if (++this.abCMOSData[ChipSet.CMOS.ADDR.RTC_SEC] >= 60) {
                    this.abCMOSData[ChipSet.CMOS.ADDR.RTC_SEC] = 0;
                    if (++this.abCMOSData[ChipSet.CMOS.ADDR.RTC_MIN] >= 60) {
                        this.abCMOSData[ChipSet.CMOS.ADDR.RTC_MIN] = 0;
                        if (++this.abCMOSData[ChipSet.CMOS.ADDR.RTC_HOUR] >= 24) {
                            this.abCMOSData[ChipSet.CMOS.ADDR.RTC_HOUR] = 0;
                            this.abCMOSData[ChipSet.CMOS.ADDR.RTC_WEEK_DAY] = (this.abCMOSData[ChipSet.CMOS.ADDR.RTC_WEEK_DAY] % 7) + 1;
                            let nDayMax = UsrLib.getMonthDays(this.abCMOSData[ChipSet.CMOS.ADDR.RTC_MONTH], this.abCMOSData[ChipSet.CMOS.ADDR.RTC_YEAR]);
                            if (++this.abCMOSData[ChipSet.CMOS.ADDR.RTC_MONTH_DAY] > nDayMax) {
                                this.abCMOSData[ChipSet.CMOS.ADDR.RTC_MONTH_DAY] = 1;
                                if (++this.abCMOSData[ChipSet.CMOS.ADDR.RTC_MONTH] > 12) {
                                    this.abCMOSData[ChipSet.CMOS.ADDR.RTC_MONTH] = 1;
                                    this.abCMOSData[ChipSet.CMOS.ADDR.RTC_YEAR] = (this.abCMOSData[ChipSet.CMOS.ADDR.RTC_YEAR] + 1) % 100;
                                }
                            }
                        }
                    }
                }
            }

            /**
             * Obviously, setting the "Update-In-Progress" bit now might seem rather pointless, since we just
             * updated the RTC "atomically" as far as the machine is concerned; however, the bit must be set at
             * at some point, in order to make the MODEL_5170 BIOS ("POST2_RTCUP") happy.
             */
            this.abCMOSData[ChipSet.CMOS.ADDR.STATUSA] |= ChipSet.CMOS.STATUSA.UIP;

            this.abCMOSData[ChipSet.CMOS.ADDR.STATUSC] |= ChipSet.CMOS.STATUSC.UF;
            if (this.abCMOSData[ChipSet.CMOS.ADDR.STATUSB] & ChipSet.CMOS.STATUSB.UIE) {
                this.abCMOSData[ChipSet.CMOS.ADDR.STATUSC] |= ChipSet.CMOS.STATUSC.IRQF;
                this.setIRR(ChipSet.IRQ.RTC);
            }
        }

        this.nRTCCyclesLastUpdate = nCyclesUpdate - (nCyclesDelta % nCyclesPerSecond);
    }

    /**
     * initCMOSData()
     *
     * Initialize all the CMOS configuration bytes in the range 0x0E-0x2F (TODO: Decide what to do about 0x30-0x3F)
     *
     * Note that the MODEL_5170 "SETUP" utility is normally what sets all these bytes, including the checksum, and then
     * the BIOS verifies it, but since we want our machines to pass BIOS verification "out of the box", we go the extra
     * mile here, even though it's not really our responsibility.
     *
     * @this {ChipSet}
     */
    initCMOSData()
    {
        /**
         * On all reset() calls, the RAM component(s) will (re)add their totals, so we have to make sure that
         * the addition always starts with 0.  That also means that ChipSet must always be initialized before RAM.
         */
        let iCMOS;
        for (iCMOS = ChipSet.CMOS.ADDR.BASEMEM_LO; iCMOS <= ChipSet.CMOS.ADDR.EXTMEM_HI; iCMOS++) {
            this.abCMOSData[iCMOS] = 0;
        }

        /**
         * Make sure all the "checksummed" CMOS bytes are initialized (not just the handful we set below) to ensure
         * that the checksum will be valid.
         */
        for (iCMOS = ChipSet.CMOS.ADDR.DIAG; iCMOS < ChipSet.CMOS.ADDR.CHKSUM_HI; iCMOS++) {
            if (this.abCMOSData[iCMOS] === undefined) this.abCMOSData[iCMOS] = 0;
        }

        /**
         * We propagate all compatible "legacy" SW1 bits to the CMOS.EQUIP byte using the old SW masks, but any further
         * access to CMOS.ADDR.EQUIP should use the new CMOS_EQUIP flags (eg, CMOS.EQUIP.FPU, CMOS.EQUIP.MONITOR.CGA80, etc).
         */
        this.abCMOSData[ChipSet.CMOS.ADDR.EQUIP] = this.getDIPLegacyBits(0);
        this.abCMOSData[ChipSet.CMOS.ADDR.FDRIVE] = (this.getDIPFloppyDriveType(0) << 4) | this.getDIPFloppyDriveType(1);

        /**
         * The final step is calculating the CMOS checksum, which we then store into the CMOS as a courtesy, so that the
         * user doesn't get unnecessary CMOS errors.
         */
        this.updateCMOSChecksum();
    }

    /**
     * setCMOSByte(iCMOS, b)
     *
     * This is ONLY for use by components that need to update CMOS configuration bytes to match their internal configuration.
     *
     * @this {ChipSet}
     * @param {number} iCMOS
     * @param {number} b
     * @returns {boolean} true if successful, false if not (eg, CMOS not initialized yet, or no CMOS on this machine)
     */
    setCMOSByte(iCMOS, b)
    {
        if (this.abCMOSData) {

            this.abCMOSData[iCMOS] = b;
            this.updateCMOSChecksum();
            return true;
        }
        return false;
    }

    /**
     * addCMOSMemory(addr, size)
     *
     * For use by the RAM component, to dynamically update the CMOS memory configuration.
     *
     * @this {ChipSet}
     * @param {number} addr (if 0, BASEMEM_LO/BASEMEM_HI is updated; if >= 0x100000, then EXTMEM_LO/EXTMEM_HI is updated)
     * @param {number} size (in bytes; we convert to Kb)
     * @returns {boolean} true if successful, false if not (eg, CMOS not initialized yet, or no CMOS on this machine)
     */
    addCMOSMemory(addr, size)
    {
        if (this.abCMOSData) {
            let iCMOS = (addr < 0x100000? ChipSet.CMOS.ADDR.BASEMEM_LO : ChipSet.CMOS.ADDR.EXTMEM_LO);
            let wKb = this.abCMOSData[iCMOS] | (this.abCMOSData[iCMOS+1] << 8);
            wKb += (size >> 10);
            this.abCMOSData[iCMOS] = wKb & 0xff;
            this.abCMOSData[iCMOS+1] = wKb >> 8;
            this.updateCMOSChecksum();
            return true;
        }
        return false;
    }

    /**
     * setCMOSDriveType(iDrive, bType)
     *
     * For use by the HDC component, to update the CMOS drive configuration to match HDC's internal configuration.
     *
     * TODO: Consider extending this to support FDC drive updates, so that the FDC can specify diskette drive types
     * (ie, FD360 or FD1200) in the same way that HDC does.  However, historically, the ChipSet has been responsible for
     * floppy drive configuration, at least in terms of *number* of drives, through the use of SW1 settings, and we've
     * continued that tradition with the addition of the ChipSet 'floppies' parameter, which allows both the number *and*
     * capacity of drives to be specified with a simple array (eg, [360, 360] for two 360Kb drives).
     *
     * @this {ChipSet}
     * @param {number} iDrive (0 or 1)
     * @param {number} bType (0 for none, 1-14 for original drive type, 16-255 for extended drive type; 15 reserved)
     * @returns {boolean} true if successful, false if not (eg, CMOS not initialized yet, or no CMOS on this machine)
     */
    setCMOSDriveType(iDrive, bType)
    {
        if (this.abCMOSData) {
            let bExt = null, iExt;
            let bOrig = this.abCMOSData[ChipSet.CMOS.ADDR.HDRIVE];
            if (bType > 15) {
                bExt = bType;  bType = 15;
            }
            if (iDrive) {
                bOrig = (bOrig & ChipSet.CMOS.HDRIVE.D0_MASK) | bType;
                iExt = ChipSet.CMOS.ADDR.EXTHDRIVE1;
            } else {
                bOrig = (bOrig & ChipSet.CMOS.HDRIVE.D1_MASK) | (bType << 4);
                iExt = ChipSet.CMOS.ADDR.EXTHDRIVE0;
            }
            this.setCMOSByte(ChipSet.CMOS.ADDR.HDRIVE, bOrig);
            if (bExt != null) this.setCMOSByte(iExt, bExt);
            return true;
        }
        return false;
    }

    /**
     * syncRTCTime()
     *
     * On a normal startup, obviously the ROM will take care of initializing BIOS data area TIMER_LOW/TIMER_HIGH
     * values to match the RTC values.  If we're restoring a machine state, that initialization will be bypassed,
     * but if it was a *full* restore, all values would still be synced.  However, if we've decided to override the
     * machine's date/time with the current date/time, they will be out of sync.
     *
     * In that case, nRTCSeconds will be set, and we must sync the BIOS data area with that value.
     *
     * Moreover, that sync must occur not only after the RAM component has been initialized but also after RAM contents
     * have been restored; otherwise, the sync'ed value will be overwritten.  Since the CPU's restore() function is
     * when RAM finally gets restored, that's where you'll find the call to syncRTCTime().
     *
     * @this {ChipSet}
     */
    syncRTCTime()
    {
        if (this.nRTCSeconds != undefined) {
            /**
             * The 8254 ("PIT") is wired to a clock with a frequency of 1.193182MHz, and the PIT is configured
             * to divide that by 65536, which gives us 18.2065 interrupts ("ticks") per second.
             */
            let ticks = this.nRTCSeconds * 18.2065;
            this.bus.setShort(ROMx86.BIOS.TIMER_LOW, ticks & 0xffff);
            this.bus.setShort(ROMx86.BIOS.TIMER_HIGH, ticks >>> 16);
            this.bus.setByte(ROMx86.BIOS.TIMER_OFL, 0);
            this.nRTCSeconds = undefined;
        }
    }

    /**
     * updateCMOSChecksum()
     *
     * This sums all the CMOS bytes from 0x10-0x2D, creating a 16-bit checksum.  That's a total of 30 (unsigned) 8-bit
     * values which could sum to at most 30*255 or 7650 (0x1DE2).  Since there's no way that can overflow 16 bits, we don't
     * worry about masking it with 0xffff.
     *
     * WARNING: The IBM PC AT TechRef, p.1-53 (p.75) claims that the checksum is on bytes 0x10-0x20, but that's simply wrong.
     *
     * @this {ChipSet}
     */
    updateCMOSChecksum()
    {
        let wChecksum = 0;
        for (let iCMOS = ChipSet.CMOS.ADDR.FDRIVE; iCMOS < ChipSet.CMOS.ADDR.CHKSUM_HI; iCMOS++) {
            wChecksum += this.abCMOSData[iCMOS];
        }
        this.abCMOSData[ChipSet.CMOS.ADDR.CHKSUM_LO] = wChecksum & 0xff;
        this.abCMOSData[ChipSet.CMOS.ADDR.CHKSUM_HI] = wChecksum >> 8;
    }

    /**
     * save()
     *
     * This implements save support for the ChipSet component.
     *
     * @this {ChipSet}
     * @returns {Object}
     */
    save()
    {
        let state = new State(this);
        state.set(0, [this.aDIPSwitches]);
        state.set(1, [this.saveDMAControllers()]);
        state.set(2, [this.savePICs()]);
        state.set(3, [this.bPIT0Ctrl, this.saveTimers(), this.bPIT1Ctrl]);
        state.set(4, [this.bPPIA, this.bPPIB, this.bPPIC, this.bPPICtrl, this.bNMI]);
        if (this.model >= ChipSet.MODEL_5170) {
            state.set(5, [this.b8042Status, this.b8042InBuff, this.b8042CmdData,
                          this.b8042OutBuff, this.b8042InPort, this.b8042OutPort]);
            state.set(6, [this.abDMAPageSpare[7], this.abDMAPageSpare, this.bCMOSAddr, this.abCMOSData, this.nRTCCyclesLastUpdate, this.nRTCCyclesNextUpdate]);
        }
        return state.data();
    }

    /**
     * restore(data)
     *
     * This implements restore support for the ChipSet component.
     *
     * @this {ChipSet}
     * @param {Object} data
     * @returns {boolean} true if successful, false if failure
     */
    restore(data)
    {
        let a, i;
        a = data[0];

        if (Array.isArray(a[0])) {
            this.aDIPSwitches = a[0];
        } else {
            this.aDIPSwitches[0][0] = a[0];
            this.aDIPSwitches[1][0] = a[1] & 0x0F;  // we do honor SW2[5] now, but it was erroneously set on some machines
            this.aDIPSwitches[0][1] = a[2];
            this.aDIPSwitches[1][1] = a[3] & 0x0F;  // we do honor SW2[5] now, but it was erroneously set on some machines
        }
        this.updateDIPSwitches();

        a = data[1];
        for (i = 0; i < this.cDMACs; i++) {
            this.initDMAController(i, a.length == 1? a[0][i] : a);
        }

        a = data[2];
        for (i = 0; i < this.cPICs; i++) {
            this.initPIC(i, i === 0? this.portPIC0 : this.portPIC1, a[0][i]);
        }

        a = data[3];
        this.bPIT0Ctrl = a[0];
        this.bPIT1Ctrl = a[2];
        for (i = 0; i < this.aTimers.length; i++) {
            this.initTimer(i, a[1][i]);
        }

        a = data[4];
        this.bPPIA = a[0];
        this.bPPIB = a[1];
        this.bPPIC = a[2];
        this.bPPICtrl = a[3];
        this.bNMI  = a[4];

        a = data[5];
        if (a) {

            this.b8042Status = a[0];
            this.b8042InBuff = a[1];
            this.b8042CmdData = a[2];
            this.b8042OutBuff = a[3];
            this.b8042InPort = a[4];
            this.b8042OutPort = a[5];
        }

        a = data[6];
        if (a) {

            this.abDMAPageSpare = a[1];
            this.abDMAPageSpare[7] = a[0];  // formerly bMFGData
            this.bCMOSAddr = a[2];
            this.abCMOSData = a[3];
            this.nRTCCyclesLastUpdate = a[4];
            this.nRTCCyclesNextUpdate = a[5];
            /**
             * TODO: Decide whether restore() should faithfully preserve the RTC date/time that save() saved,
             * or always reinitialize the date/time, or give the user (or the machine configuration) the option.
             *
             * For now, we're always reinitializing the RTC date.  Alternatively, we could selectively update
             * the CMOS bytes above, instead of overwriting them all, in which case this extra call to initRTCTime()
             * could be avoided.
             */
            this.nRTCSeconds = this.initRTCTime();
        }
        return true;
    }

    /**
     * start()
     *
     * Notification from the Computer that it's starting.
     *
     * @this {ChipSet}
     */
    start()
    {
        /**
         * Currently, all we do with this notification is allow the speaker to make noise.
         */
        this.setSpeaker();
    }

    /**
     * stop()
     *
     * Notification from the Computer that it's stopping.
     *
     * @this {ChipSet}
     */
    stop()
    {
        /**
         * Currently, all we do with this notification is prevent the speaker from making noise.
         */
        this.setSpeaker();
    }

    /**
     * initDMAController(iDMAC, aState)
     *
     * @this {ChipSet}
     * @param {number} iDMAC
     * @param {Array} [aState]
     */
    initDMAController(iDMAC, aState)
    {
        let controller = this.aDMACs[iDMAC];
        if (!controller) {

            controller = {
                aChannels: new Array(4)
            };
        }
        let a = aState && aState.length >= 5? aState : this.aDMAControllerInit;
        controller.bStatus = a[0];
        controller.bCmd = a[1];
        controller.bReq = a[2];
        controller.bIndex = a[3];
        controller.nChannelBase = iDMAC << 2;
        for (let iChannel = 0; iChannel < controller.aChannels.length; iChannel++) {
            this.initDMAChannel(controller, iChannel, a[4][iChannel]);
        }
        controller.bTemp = a[5] || 0;       // not present in older states
        this.aDMACs[iDMAC] = controller;
    }

    /**
     * initDMAChannel(controller, iChannel, aState)
     *
     * @this {ChipSet}
     * @param {Object} controller
     * @param {number} iChannel
     * @param {Array} [aState]
     */
    initDMAChannel(controller, iChannel, aState)
    {
        let channel = controller.aChannels[iChannel];
        if (!channel) {

            channel = {
                addrInit: [0,0],
                countInit: [0,0],
                addrCurrent: [0,0],
                countCurrent: [0,0]
            };
        }
        let a = aState && aState.length == 8? aState : this.aDMAChannelInit;
        channel.masked = a[0];
        channel.addrInit[0] = a[1][0]; channel.addrInit[1] = a[1][1];
        channel.countInit[0] = a[2][0];  channel.countInit[1] = a[2][1];
        channel.addrCurrent[0] = a[3][0]; channel.addrCurrent[1] = a[3][1];
        channel.countCurrent[0] = a[4][0]; channel.countCurrent[1] = a[4][1];
        channel.mode = a[5];
        channel.bPage = a[6];
        // a[7] is deprecated
        channel.controller = controller;
        channel.iChannel = iChannel;
        this.initDMAFunction(channel, a[8], a[9]);
        controller.aChannels[iChannel] = channel;
    }

    /**
     * initDMAFunction(channel)
     *
     * @param {Object} channel
     * @param {Component|string} [component]
     * @param {string} [sFunction]
     * @param {Object} [obj]
     * @returns {*}
     */
    initDMAFunction(channel, component, sFunction, obj)
    {
        if (typeof component == "string") {
            component = Component.getComponentByID(component);
        }
        if (component) {
            channel.done = null;
            channel.sDevice = component.id;
            channel.sFunction = sFunction;
            channel.component = component;
            channel.fnTransfer = component[sFunction];
            channel.obj = obj;
        }
        return channel.fnTransfer;
    }

    /**
     * saveDMAControllers()
     *
     * @this {ChipSet}
     * @returns {Array}
     */
    saveDMAControllers()
    {
        let data = [];
        for (let iDMAC = 0; iDMAC < this.aDMACs; iDMAC++) {
            let controller = this.aDMACs[iDMAC];
            data[iDMAC] = [
                controller.bStatus,
                controller.bCmd,
                controller.bReq,
                controller.bIndex,
                this.saveDMAChannels(controller),
                controller.bTemp
            ];
        }
        return data;
    }

    /**
     * saveDMAChannels(controller)
     *
     * @this {ChipSet}
     * @param {Object} controller
     * @returns {Array}
     */
    saveDMAChannels(controller)
    {
        let data = [];
        for (let iChannel = 0; iChannel < controller.aChannels.length; iChannel++) {
            let channel = controller.aChannels[iChannel];
            data[iChannel] = [
                channel.masked,
                channel.addrInit,
                channel.countInit,
                channel.addrCurrent,
                channel.countCurrent,
                channel.mode,
                channel.bPage,
                channel.sDevice,
                channel.sFunction
            ];
        }
        return data;
    }

    /**
     * initPIC(iPIC, port, aState)
     *
     * @this {ChipSet}
     * @param {number} iPIC
     * @param {number} port
     * @param {Array} [aState]
     */
    initPIC(iPIC, port, aState)
    {
        let pic = this.aPICs[iPIC];
        if (!pic) {
            pic = {
                aICW: [null,null,null,null]
            };
        }
        let a = aState && aState.length == 8? aState : this.aPICInit;
        pic.port = port;
        pic.nIRQBase = iPIC << 3;
        pic.nDelay = a[0];
        pic.aICW[0] = a[1][0]; pic.aICW[1] = a[1][1]; pic.aICW[2] = a[1][2]; pic.aICW[3] = a[1][3];
        pic.nICW = a[2];
        pic.bIMR = a[3];
        pic.bIRR = a[4];
        pic.bISR = a[5];
        pic.bIRLow = a[6];
        pic.bOCW3 = a[7];
        this.aPICs[iPIC] = pic;
    }

    /**
     * savePICs()
     *
     * @this {ChipSet}
     * @returns {Array}
     */
    savePICs()
    {
        let data = [];
        for (let iPIC = 0; iPIC < this.aPICs.length; iPIC++) {
            let pic = this.aPICs[iPIC];
            data[iPIC] = [
                pic.nDelay,
                pic.aICW,
                pic.nICW,
                pic.bIMR,
                pic.bIRR,
                pic.bISR,
                pic.bIRLow,
                pic.bOCW3
            ];
        }
        return data;
    }

    /**
     * initTimer(iTimer, aState)
     *
     * @this {ChipSet}
     * @param {number} iTimer
     * @param {Array} [aState]
     */
    initTimer(iTimer, aState)
    {
        let timer = this.aTimers[iTimer];
        if (!timer) {
            timer = {
                countInit: [0,0],
                countStart: [0,0],
                countCurrent: [0,0],
                countLatched: [0,0]
            };
        }
        let a = aState && aState.length >= 13? aState : this.aTimerInit;
        timer.countInit[0] = a[0][0]; timer.countInit[1] = a[0][1];
        timer.countStart[0] = a[1][0]; timer.countStart[1] = a[1][1];
        timer.countCurrent[0] = a[2][0]; timer.countCurrent[1] = a[2][1];
        timer.countLatched[0] = a[3][0]; timer.countLatched[1] = a[3][1];
        timer.bcd = a[4];
        timer.mode = a[5];
        timer.rw = a[6];
        timer.countIndex = a[7];
        timer.countBytes = a[8];
        timer.fOUT = a[9];
        timer.fCountLatched = a[10];
        timer.fCounting = a[11];
        timer.nCyclesStart = a[12];
        timer.bStatus = a[13] || 0;
        timer.fStatusLatched = a[14] || false;
        this.aTimers[iTimer] = timer;
    }

    /**
     * saveTimers()
     *
     * @this {ChipSet}
     * @returns {Array}
     */
    saveTimers()
    {
        let data = [];
        for (let iTimer = 0; iTimer < this.aTimers.length; iTimer++) {
            let timer = this.aTimers[iTimer];
            data[iTimer] = [
                timer.countInit,
                timer.countStart,
                timer.countCurrent,
                timer.countLatched,
                timer.bcd,
                timer.mode,
                timer.rw,
                timer.countIndex,
                timer.countBytes,
                timer.fOUT,
                timer.fCountLatched,
                timer.fCounting,
                timer.nCyclesStart,
                timer.bStatus,
                timer.fStatusLatched
            ];
        }
        return data;
    }

    /**
     * addDIPSwitches(iDIP, sBinding)
     *
     * @this {ChipSet}
     * @param {number} iDIP (0 or 1)
     * @param {string} sBinding is the name of the control
     */
    addDIPSwitches(iDIP, sBinding)
    {
        let sHTML = "";
        let control = this.bindings[sBinding];
        for (let i = 1; i <= 8; i++) {
            let sCellClasses = this.sCellClass;
            if (!i) sCellClasses += " " + this.sCellClass + "Left";
            let sCellID = sBinding + "-" + i;
            sHTML += "<div id=\"" + sCellID + "\" class=\"" + sCellClasses + "\" data-value=\"0\">" + i + "</div>\n";
        }
        control.innerHTML = sHTML;
        this.updateDIPSwitchControls(iDIP, sBinding, true);
    }

    /**
     * findDIPSwitch(iDIP, iSwitch)
     *
     * @this {ChipSet}
     * @param {number} iDIP
     * @param {number} iSwitch
     * @returns {Object|null} DIPSW switchGroup containing the DIP switch's MASK, VALUES, and LABEL, or null if none
     */
    findDIPSwitch(iDIP, iSwitch)
    {
        let switchDIPs = ChipSet.DIPSW[this.model|0];
        let switchTypes = switchDIPs && switchDIPs[iDIP];
        if (switchTypes) {
            for (let iType in switchTypes) {
                let switchGroup = switchTypes[iType];
                if (switchGroup.MASK & (1 << iSwitch)) {
                    return switchGroup;
                }
            }
        }
        return null;
    }

    /**
     * getDIPLegacyBits(iDIP)
     *
     * @this {ChipSet}
     * @param {number} iDIP
     * @returns {number|undefined}
     */
    getDIPLegacyBits(iDIP)
    {
        let b;
        if (!iDIP) {
            b = 0;
            b |= (this.getDIPVideoMonitor() << ChipSet.PPI_SW.MONITOR.SHIFT) & ChipSet.PPI_SW.MONITOR.MASK;
            b |= (this.getDIPCoprocessor()? ChipSet.PPI_SW.FPU : 0);
            let nDrives = this.getDIPFloppyDrives();
            b |= (nDrives? ((((nDrives - 1) << ChipSet.PPI_SW.FDRIVE.SHIFT) & ChipSet.PPI_SW.FDRIVE.MASK) | ChipSet.PPI_SW.FDRIVE.IPL) : 0);
        }
        return b;
    }

    /**
     * getDIPSwitches(iType, fInit)
     *
     * @this {ChipSet}
     * @param {number} iType
     * @param {boolean} [fInit] is true for initial switch value, current value otherwise
     * @returns {string|null}
     */
    getDIPSwitches(iType, fInit)
    {
        let value = null;
        let switchDIPs = ChipSet.DIPSW[this.model] || ChipSet.DIPSW[this.model|0] || ChipSet.DIPSW[ChipSet.MODEL_5150];
        for (let iDIP = 0; iDIP < switchDIPs.length; iDIP++) {
            let switchTypes = switchDIPs[iDIP];
            if (switchTypes) {
                let switchGroup = switchTypes[iType];
                if (switchGroup) {
                    let bits = this.aDIPSwitches[iDIP][fInit?0:1] & switchGroup.MASK;
                    for (let v in switchGroup.VALUES) {
                        if (switchGroup.VALUES[v] == bits) {
                            value = v;
                            /**
                             * We prefer numeric properties, and all switch definitions must provide them
                             * if their helper functions (eg, getDIPVideoMonitor()) expect numeric properties.
                             */
                            if (typeof +value == 'number') break;
                        }
                    }
                    break;
                }
            }
        }
        return value;
    }

    /**
     * getDIPSwitchRange(iType)
     *
     * @this {ChipSet}
     * @param {number} iType
     * @returns {Array.<number>} [minimum value, maximum value]
     */
    getDIPSwitchRange(iType)
    {
        let values = [-1, -1];          // none of our switches should have negative values
        let switchDIPs = ChipSet.DIPSW[this.model] || ChipSet.DIPSW[this.model|0] || ChipSet.DIPSW[ChipSet.MODEL_5150];
        for (let iDIP = 0; iDIP < switchDIPs.length; iDIP++) {
            let switchTypes = switchDIPs[iDIP];
            if (switchTypes) {
                let switchGroup = switchTypes[iType];
                if (switchGroup) {
                    for (let v in switchGroup.VALUES) {
                        if (values[0] < 0 || values[0] > +v) values[0] = +v;
                        if (values[1] < 0 || values[1] < +v) values[1] = +v;
                    }
                }
            }
        }
        return values;
    }

    /**
     * getDIPCoprocessor(fInit)
     *
     * @this {ChipSet}
     * @param {boolean} [fInit] is true for init switch value(s) only, current value(s) otherwise
     * @returns {number} 1 if installed, 0 if not
     */
    getDIPCoprocessor(fInit)
    {
        return +this.getDIPSwitches(ChipSet.SW_TYPE.FPU, fInit);
    }

    /**
     * getDIPFloppyDrives(fInit)
     *
     * @this {ChipSet}
     * @param {boolean} [fInit] is true for init switch value(s) only, current value(s) otherwise
     * @returns {number} number of floppy drives specified by SW1 (range is 0 to 4)
     */
    getDIPFloppyDrives(fInit)
    {
        return +this.getDIPSwitches(ChipSet.SW_TYPE.FLOPNUM, fInit);
    }

    /**
     * getDIPFloppyDriveType(iDrive)
     *
     * @this {ChipSet}
     * @param {number} iDrive (0-based)
     * @returns {number} one of the ChipSet.CMOS.FDRIVE.FD* values (FD360, FD1200, etc)
     */
    getDIPFloppyDriveType(iDrive)
    {
        if (iDrive < this.getDIPFloppyDrives()) {
            if (!this.aFloppyDrives) {
                return ChipSet.CMOS.FDRIVE.FD360;
            }
            if (iDrive < this.aFloppyDrives.length) {
                switch(this.aFloppyDrives[iDrive]) {
                case 160:
                case 180:
                case 320:
                case 360:
                    return ChipSet.CMOS.FDRIVE.FD360;
                case 720:
                    return ChipSet.CMOS.FDRIVE.FD720;
                case 1200:
                    return ChipSet.CMOS.FDRIVE.FD1200;
                case 1440:
                    return ChipSet.CMOS.FDRIVE.FD1440;
                }
            }

        }
        return ChipSet.CMOS.FDRIVE.NONE;
    }

    /**
     * getDIPFloppyDriveSize(iDrive)
     *
     * @this {ChipSet}
     * @param {number} iDrive (0-based)
     * @returns {number} capacity of drive in Kb (eg, 360, 1200, 1440, etc), or 0 if none
     */
    getDIPFloppyDriveSize(iDrive)
    {
        if (iDrive < this.getDIPFloppyDrives()) {
            if (!this.aFloppyDrives) {
                return 360;
            }
            if (iDrive < this.aFloppyDrives.length) {
                return this.aFloppyDrives[iDrive];
            }

        }
        return 0;
    }

    /**
     * getDIPMemorySize(fInit)
     *
     * @this {ChipSet}
     * @param {boolean} [fInit] is true for init switch value(s) only, current value(s) otherwise
     * @returns {number} number of Kb of specified memory (NOT necessarily the same as installed memory; see RAM component)
     */
    getDIPMemorySize(fInit)
    {
        let nKBLow = this.getDIPSwitches(ChipSet.SW_TYPE.LOWMEM, fInit);
        let nKBExp = this.getDIPSwitches(ChipSet.SW_TYPE.EXPMEM, fInit);
        return +nKBLow + +nKBExp;
    }

    /**
     * setDIPMemorySize(nKB)
     *
     * @this {ChipSet}
     * @param {number} nKB
     * @returns {boolean} true if successful, false if out of range
     */
    setDIPMemorySize(nKB)
    {
        let rangeKBLow = this.getDIPSwitchRange(ChipSet.SW_TYPE.LOWMEM);
        if (nKB <= rangeKBLow[1]) {
            if (this.setDIPSwitches(ChipSet.SW_TYPE.LOWMEM, nKB) && this.setDIPSwitches(ChipSet.SW_TYPE.EXPMEM, 0)) {
                return true;
            }
        }
        let rangeKBExp = this.getDIPSwitchRange(ChipSet.SW_TYPE.EXPMEM);
        if (nKB <= rangeKBLow[1] + rangeKBExp[1]) {
            nKB -= rangeKBLow[1];
            if (this.setDIPSwitches(ChipSet.SW_TYPE.LOWMEM, rangeKBLow[1]) && this.setDIPSwitches(ChipSet.SW_TYPE.EXPMEM, nKB)) {
                return true;
            }
        }
        return false;
    }

    /**
     * getDIPVideoMonitor(fInit)
     *
     * @this {ChipSet}
     * @param {boolean} [fInit] is true for init switch value(s) only, current value(s) otherwise
     * @returns {number} one of ChipSet.MONITOR.*
     */
    getDIPVideoMonitor(fInit)
    {
        return +this.getDIPSwitches(ChipSet.SW_TYPE.MONITOR, fInit);
    }

    /**
     * parseDIPSwitches(sBits, bDefault)
     *
     * @this {ChipSet}
     * @param {string} sBits describing switch settings
     * @param {number} [bDefault]
     * @returns {number|undefined}
     */
    parseDIPSwitches(sBits, bDefault)
    {
        let b = bDefault;
        if (sBits) {
            /**
             * NOTE: We can't use parseInt() with a base of 2, because both bit order and bit sense are reversed.
             */
            b = 0;
            let bit = 0x1;
            for (let i = 0; i < sBits.length; i++) {
                if (sBits.charAt(i) == "0") b |= bit;
                bit <<= 1;
            }
        }
        return b;
    }

    /**
     * setDIPSwitches(iType, value, fInit)
     *
     * @this {ChipSet}
     * @param {number} iType
     * @param {*} value
     * @param {boolean} [fInit]
     * @returns {boolean} true if successful, false if unrecognized type and/or value
     */
    setDIPSwitches(iType, value, fInit)
    {
        let switchDIPs = ChipSet.DIPSW[this.model] || ChipSet.DIPSW[this.model|0] || ChipSet.DIPSW[ChipSet.MODEL_5150];
        for (let iDIP = 0; iDIP < switchDIPs.length; iDIP++) {
            let switchTypes = switchDIPs[iDIP];
            if (switchTypes) {
                let switchGroup = switchTypes[iType];
                if (switchGroup) {
                    for (let v in switchGroup.VALUES) {
                        if (v == value) {
                            this.aDIPSwitches[iDIP][fInit?0:1] &= ~switchGroup.MASK;
                            this.aDIPSwitches[iDIP][fInit?0:1] |= switchGroup.VALUES[v];
                            return true;
                        }
                    }
                }
            }
        }
        return false;
    }

    /**
     * getDIPSwitchControl(control)
     *
     * @this {ChipSet}
     * @param {HTMLElement} control is an HTML control DOM object
     * @returns {boolean} true if the switch represented by e is "on", false if "off"
     */
    getDIPSwitchControl(control)
    {
        return control.getAttribute("data-value") == "1";
    }

    /**
     * setDIPSwitchControl(control, f)
     *
     * @this {ChipSet}
     * @param {HTMLElement} control is an HTML control DOM object
     * @param {boolean} f is true if the switch represented by control should be "on", false if "off"
     */
    setDIPSwitchControl(control, f)
    {
        control.setAttribute("data-value", f? "1" : "0");
        control.style.color = (f? "#ffffff" : "#000000");
        control.style.backgroundColor = (f? "#000000" : "#ffffff");
    }

    /**
     * toggleDIPSwitchControl(control)
     *
     * @this {ChipSet}
     * @param {HTMLElement} control is an HTML control DOM object
     */
    toggleDIPSwitchControl(control)
    {
        let f = !this.getDIPSwitchControl(control);
        this.setDIPSwitchControl(control, f);
        let sID = control.getAttribute("id");
        let asParts = sID.split("-");
        let b = (0x1 << (+asParts[1] - 1));
        switch (asParts[0]) {
        case ChipSet.CONTROLS.SW1:
            this.aDIPSwitches[0][0] = (this.aDIPSwitches[0][0] & ~b) | (f? 0 : b);
            break;
        case ChipSet.CONTROLS.SW2:
            this.aDIPSwitches[1][0] = (this.aDIPSwitches[1][0] & ~b) | (f? 0 : b);
            break;
        default:
            break;
        }
        this.updateDIPSwitchDescriptions();
    }

    /**
     * updateDIPSwitches()
     *
     * @this {ChipSet}
     */
    updateDIPSwitches()
    {
        this.updateDIPSwitchControls(0, ChipSet.CONTROLS.SW1);
        this.updateDIPSwitchControls(1, ChipSet.CONTROLS.SW2);
        this.updateDIPSwitchDescriptions();
    }

    /**
     * updateDIPSwitchControls(iDIP, sBinding, fInit)
     *
     * @this {ChipSet}
     * @param {number} iDIP (0 or 1)
     * @param {string} sBinding is the name of the control
     * @param {boolean} [fInit]
     */
    updateDIPSwitchControls(iDIP, sBinding, fInit)
    {
        let control = this.bindings[sBinding];
        if (control) {
            let v;
            if (fInit) {
                v = this.aDIPSwitches[iDIP][0];
            } else {
                v = this.aDIPSwitches[iDIP][1] = this.aDIPSwitches[iDIP][0];
            }
            let aeCells = Component.getElementsByClass(this.sCellClass, "", control);
            for (let i = 0; i < aeCells.length; i++) {
                let switchGroup = this.findDIPSwitch(iDIP, i);
                let sLabel = switchGroup && switchGroup.LABEL || "Reserved";
                aeCells[i].setAttribute("title", sLabel);
                this.setDIPSwitchControl(aeCells[i], !(v & (0x1 << i)));
                aeCells[i].onclick = function(chipset, eSwitch) {
                    /**
                     * If we define the onclick handler below as "function(e)" instead of simply "function()", then we will
                     * also receive an Event object; however, IE reportedly requires that we examine a global (window.event)
                     * instead.  If that's true, and if we ever care to get more details about the click event, then define
                     * a local var; eg:
                     *
                     *      let event = window.event || e;
                     */
                    return function onClickSwitch() {
                        chipset.toggleDIPSwitchControl(eSwitch);
                    };
                }(this, aeCells[i]);
            }
        }
    }

    /**
     * updateDIPSwitchDescriptions()
     *
     * @this {ChipSet}
     */
    updateDIPSwitchDescriptions()
    {
        let controlDesc = this.bindings[ChipSet.CONTROLS.SWDESC];
        if (controlDesc != null) {
            let sText = "";
            /**
             * TODO: Monitor type 0 used to be "None" (ie, "No Monitor"), which was correct in a pre-EGA world,
             * but in the post-EGA world, it depends.  We should ask the Video component for a definitive answer.
             */
            let asMonitorTypes = {
                0: "Enhanced Color",
                1: "TV",
                2: "Color",
                3: "Monochrome"
            };
            sText += this.getDIPMemorySize(true) + "K";
            sText += ", " + (+this.getDIPCoprocessor(true)? "" : "No ") + "FPU";
            sText += ", " + asMonitorTypes[this.getDIPVideoMonitor(true)] + " Monitor";
            sText += ", " + this.getDIPFloppyDrives(true) + " Floppy Drives";
            if (this.aDIPSwitches[0][1] != null && this.aDIPSwitches[0][1] != this.aDIPSwitches[0][0] ||
                this.aDIPSwitches[1][1] != null && this.aDIPSwitches[1][1] != this.aDIPSwitches[1][0]) {
                sText += " (Reset required)";
            }
            controlDesc.textContent = sText;
        }
    }

    /**
     * dumpPIC()
     *
     * @this {ChipSet}
     */
    dumpPIC()
    {
        if (DEBUGGER) {
            for (let iPIC = 0; iPIC < this.aPICs.length; iPIC++) {
                let pic = this.aPICs[iPIC];
                let sDump = "PIC" + iPIC + ":";
                for (let i = 0; i < pic.aICW.length; i++) {
                    let b = pic.aICW[i];
                    sDump += " IC" + (i + 1) + '=' + StrLib.toHexByte(b);
                }
                sDump += " IMR=" + StrLib.toHexByte(pic.bIMR) + " IRR=" + StrLib.toHexByte(pic.bIRR) + " ISR=" + StrLib.toHexByte(pic.bISR) + " DELAY=" + pic.nDelay + "\n";
                this.print(sDump);
            }
        }
    }

    /**
     * dumpTimer(asArgs)
     *
     * Use "d timer" to dump all timers, or "d timer n" to dump only timer n.
     *
     * @this {ChipSet}
     * @param {Array.<string>} asArgs
     */
    dumpTimer(asArgs)
    {
        if (DEBUGGER) {
            let sParm = asArgs[0];
            let nTimer = (sParm? +sParm : null);
            for (let iTimer = 0; iTimer < this.aTimers.length; iTimer++) {
                if (nTimer != null && iTimer != nTimer) continue;
                this.updateTimer(iTimer);
                let timer = this.aTimers[iTimer];
                let sDump = "TIMER" + iTimer + ":";
                let count = 0;
                if (timer.countBytes != null) {
                    for (let i = 0; i <= timer.countBytes; i++) {
                        count |= (timer.countCurrent[i] << (i * 8));
                    }
                }
                sDump += " mode=" + (timer.mode >> 1) + " bytes=" + timer.countBytes + " count=" + StrLib.toHexWord(count) + "\n";
                this.print(sDump);
            }
        }
    }

    /**
     * dumpCMOS()
     *
     * @this {ChipSet}
     */
    dumpCMOS()
    {
        if (DEBUGGER) {
            let sDump = "";
            for (let iCMOS = 0; iCMOS < ChipSet.CMOS.ADDR.TOTAL; iCMOS++) {
                let b = (iCMOS <= ChipSet.CMOS.ADDR.STATUSD? this.getRTCByte(iCMOS) : this.abCMOSData[iCMOS]);
                if (sDump) sDump += '\n';
                sDump += "CMOS[" + StrLib.toHexByte(iCMOS) + "]: " + StrLib.toHexByte(b) + "\n";
            }
            this.print(sDump);
        }
    }

    /**
     * inDMAChannelAddr(iDMAC, iChannel, port, addrFrom)
     *
     * @this {ChipSet}
     * @param {number} iDMAC
     * @param {number} iChannel
     * @param {number} port (0x00, 0x02, 0x04, 0x06 for DMAC 0, 0xC0, 0xC4, 0xC8, 0xCC for DMAC 1)
     * @param {number} [addrFrom] (not defined if the Debugger is trying to read the specified port)
     * @returns {number} simulated port value
     */
    inDMAChannelAddr(iDMAC, iChannel, port, addrFrom)
    {
        let controller = this.aDMACs[iDMAC];
        let channel = controller.aChannels[iChannel];
        let b = channel.addrCurrent[controller.bIndex];
        if (this.messageEnabled(MESSAGE.DMA + MESSAGE.PORT)) {
            this.printIO(port, undefined, addrFrom, "DMA" + iDMAC + ".CHANNEL" + iChannel + ".ADDR[" + controller.bIndex + "]", b, true);
        }
        controller.bIndex ^= 0x1;
        /**
         * Technically, aTimers[1].fOut is what drives DMA requests for DMA channel 0 (ChipSet.DMA_REFRESH),
         * every 15us, once the BIOS has initialized the channel's "mode" with MODE_SINGLE, INCREMENT, AUTOINIT,
         * and TYPE_READ (0x58) and initialized TIMER1 appropriately.
         *
         * However, we don't need to be that particular.  Simply simulate an ever-increasing address after every
         * read of the full DMA channel 0 address.
         */
        if (!iDMAC && iChannel == ChipSet.DMA_REFRESH && !controller.bIndex) {
            channel.addrCurrent[0]++;
            if (channel.addrCurrent[0] > 0xff) {
                channel.addrCurrent[0] = 0;
                channel.addrCurrent[1]++;
                if (channel.addrCurrent[1] > 0xff) {
                    channel.addrCurrent[1] = 0;
                }
            }
        }
        return b;
    }

    /**
     * outDMAChannelAddr(iDMAC, iChannel, port, bOut, addrFrom)
     *
     * @this {ChipSet}
     * @param {number} iDMAC
     * @param {number} iChannel
     * @param {number} port (0x00, 0x02, 0x04, 0x06 for DMAC 0, 0xC0, 0xC4, 0xC8, 0xCC for DMAC 1)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined if the Debugger is trying to read the specified port)
     */
    outDMAChannelAddr(iDMAC, iChannel, port, bOut, addrFrom)
    {
        let controller = this.aDMACs[iDMAC];
        if (this.messageEnabled(MESSAGE.DMA + MESSAGE.PORT)) {
            this.printIO(port, bOut, addrFrom, "DMA" + iDMAC + ".CHANNEL" + iChannel + ".ADDR[" + controller.bIndex + "]", undefined, true);
        }
        let channel = controller.aChannels[iChannel];
        channel.addrCurrent[controller.bIndex] = channel.addrInit[controller.bIndex] = bOut;
        controller.bIndex ^= 0x1;
    }

    /**
     * inDMAChannelCount(iDMAC, iChannel, port, addrFrom)
     *
     * @this {ChipSet}
     * @param {number} iDMAC
     * @param {number} iChannel
     * @param {number} port (0x01, 0x03, 0x05, 0x07 for DMAC 0, 0xC2, 0xC6, 0xCA, 0xCE for DMAC 1)
     * @param {number} [addrFrom] (not defined if the Debugger is trying to read the specified port)
     * @returns {number} simulated port value
     */
    inDMAChannelCount(iDMAC, iChannel, port, addrFrom)
    {
        let controller = this.aDMACs[iDMAC];
        let channel = controller.aChannels[iChannel];
        let b = channel.countCurrent[controller.bIndex];
        if (this.messageEnabled(MESSAGE.DMA + MESSAGE.PORT)) {
            this.printIO(port, undefined, addrFrom, "DMA" + iDMAC + ".CHANNEL" + iChannel + ".COUNT[" + controller.bIndex + "]", b, true);
        }
        controller.bIndex ^= 0x1;
        /**
         * Technically, aTimers[1].fOut is what drives DMA requests for DMA channel 0 (ChipSet.DMA_REFRESH),
         * every 15us, once the BIOS has initialized the channel's "mode" with MODE_SINGLE, INCREMENT, AUTOINIT,
         * and TYPE_READ (0x58) and initialized TIMER1 appropriately.
         *
         * However, we don't need to be that particular.  Simply simulate an ever-decreasing count after every
         * read of the full DMA channel 0 count.
         */
        if (!iDMAC && iChannel == ChipSet.DMA_REFRESH && !controller.bIndex) {
            channel.countCurrent[0]--;
            if (channel.countCurrent[0] < 0) {
                channel.countCurrent[0] = 0xff;
                channel.countCurrent[1]--;
                if (channel.countCurrent[1] < 0) {
                    channel.countCurrent[1] = 0xff;
                    /**
                     * This is the logical point to indicate Terminal Count (TC), but again, there's no need to be
                     * so particular; inDMAStatus() has its own logic for periodically signalling TC.
                     */
                }
            }
        }
        return b;
    }

    /**
     * outDMAChannelCount(iDMAC, iChannel, port, bOut, addrFrom)
     *
     * @this {ChipSet}
     * @param {number} iDMAC
     * @param {number} iChannel (ports 0x01, 0x03, 0x05, 0x07)
     * @param {number} port (0x01, 0x03, 0x05, 0x07 for DMAC 0, 0xC2, 0xC6, 0xCA, 0xCE for DMAC 1)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined if the Debugger is trying to read the specified port)
     */
    outDMAChannelCount(iDMAC, iChannel, port, bOut, addrFrom)
    {
        let controller = this.aDMACs[iDMAC];
        if (this.messageEnabled(MESSAGE.DMA + MESSAGE.PORT)) {
            this.printIO(port, bOut, addrFrom, "DMA" + iDMAC + ".CHANNEL" + iChannel + ".COUNT[" + controller.bIndex + "]", undefined, true);
        }
        let channel = controller.aChannels[iChannel];
        channel.countCurrent[controller.bIndex] = channel.countInit[controller.bIndex] = bOut;
        controller.bIndex ^= 0x1;
    }

    /**
     * inDMAStatus(iDMAC, port, addrFrom)
     *
     * From the 8237A spec:
     *
     * "The Status register is available to be read out of the 8237A by the microprocessor.
     * It contains information about the status of the devices at this point. This information includes
     * which channels have reached Terminal Count (TC) and which channels have pending DMA requests.
     *
     * Bits 0â3 are set every time a TC is reached by that channel or an external EOP is applied.
     * These bits are cleared upon Reset and on each Status Read.
     *
     * Bits 4â7 are set whenever their corresponding channel is requesting service."
     *
     * TRIVIA: This hook wasn't installed when I was testing with the MODEL_5150 ROM BIOS, and it
     * didn't matter, but the MODEL_5160 ROM BIOS checks it several times, including @F000:E156, where
     * it verifies that TIMER1 didn't request service on channel 0.
     *
     * @this {ChipSet}
     * @param {number} iDMAC
     * @param {number} port (0x08 for DMAC 0, 0xD0 for DMAC 1)
     * @param {number} [addrFrom] (not defined if the Debugger is trying to read the specified port)
     * @returns {number} simulated port value
     */
    inDMAStatus(iDMAC, port, addrFrom)
    {
        /**
         * HACK: Unlike the MODEL_5150, the MODEL_5160 ROM BIOS checks DMA channel 0 for TC (@F000:E4DF)
         * after running a number of unrelated tests, since enough time would have passed for channel 0 to
         * have reached TC at least once.  So I simply OR in a hard-coded TC bit for channel 0 every time
         * status is read.
         */
        let controller = this.aDMACs[iDMAC];
        let b = controller.bStatus | ChipSet.DMA_STATUS.CH0_TC;
        controller.bStatus &= ~ChipSet.DMA_STATUS.ALL_TC;
        if (this.messageEnabled(MESSAGE.DMA + MESSAGE.PORT)) {
            this.printIO(port, undefined, addrFrom, "DMA" + iDMAC + ".STATUS", b, true);
        }
        return b;
    }

    /**
     * outDMACmd(iDMAC, port, bOut, addrFrom)
     *
     * @this {ChipSet}
     * @param {number} iDMAC
     * @param {number} port (0x08 for DMAC 0, 0xD0 for DMAC 1)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined if the Debugger is trying to read the specified port)
     */
    outDMACmd(iDMAC, port, bOut, addrFrom)
    {
        if (this.messageEnabled(MESSAGE.DMA + MESSAGE.PORT)) {
            this.printIO(port, bOut, addrFrom, "DMA" + iDMAC + ".CMD", undefined, true);
        }
        this.aDMACs[iDMAC].bCmd = bOut;
    }

    /**
     * outDMAReq(iDMAC, port, bOut, addrFrom)
     *
     * From the 8237A spec:
     *
     * "The 8237A can respond to requests for DMA service which are initiated by software as well as by a DREQ.
     * Each channel has a request bit associated with it in the 4-bit Request register. These are non-maskable and subject
     * to prioritization by the Priority Encoder network. Each register bit is set or reset separately under software
     * control or is cleared upon generation of a TC or external EOP. The entire register is cleared by a Reset.
     *
     * To set or reset a bit the software loads the proper form of the data word.... In order to make a software request,
     * the channel must be in Block Mode."
     *
     * @this {ChipSet}
     * @param {number} iDMAC
     * @param {number} port (0x09 for DMAC 0, 0xD2 for DMAC 1)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined if the Debugger is trying to read the specified port)
     */
    outDMAReq(iDMAC, port, bOut, addrFrom)
    {
        let controller = this.aDMACs[iDMAC];
        if (this.messageEnabled(MESSAGE.DMA + MESSAGE.PORT)) {
            this.printIO(port, bOut, addrFrom, "DMA" + iDMAC + ".REQ", undefined, true);
        }
        /**
         * Bits 0-1 contain the channel number
         */
        let iChannel = (bOut & 0x3);
        /**
         * Bit 2 is the request bit (0 to reset, 1 to set), which must be propagated to the corresponding bit (4-7) in the status register
         */
        let iChannelBit = ((bOut & 0x4) << (iChannel + 2));
        controller.bStatus = (controller.bStatus & ~(0x10 << iChannel)) | iChannelBit;
        controller.bReq = bOut;
    }

    /**
     * outDMAMask(iDMAC, port, bOut, addrFrom)
     *
     * @this {ChipSet}
     * @param {number} iDMAC
     * @param {number} port (0x0A for DMAC 0, 0xD4 for DMAC 1)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined if the Debugger is trying to read the specified port)
     */
    outDMAMask(iDMAC, port, bOut, addrFrom)
    {
        let controller = this.aDMACs[iDMAC];
        if (this.messageEnabled(MESSAGE.DMA + MESSAGE.PORT)) {
            this.printIO(port, bOut, addrFrom, "DMA" + iDMAC + ".MASK", undefined, true);
        }
        let iChannel = bOut & ChipSet.DMA_MASK.CHANNEL;
        let channel = controller.aChannels[iChannel];
        channel.masked = !!(bOut & ChipSet.DMA_MASK.CHANNEL_SET);
        if (!channel.masked) this.requestDMA(controller.nChannelBase + iChannel);
    }

    /**
     * outDMAMode(iDMAC, port, bOut, addrFrom)
     *
     * @this {ChipSet}
     * @param {number} iDMAC
     * @param {number} port (0x0B for DMAC 0, 0xD6 for DMAC 1)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined if the Debugger is trying to read the specified port)
     */
    outDMAMode(iDMAC, port, bOut, addrFrom)
    {
        if (this.messageEnabled(MESSAGE.DMA + MESSAGE.PORT)) {
            this.printIO(port, bOut, addrFrom, "DMA" + iDMAC + ".MODE", undefined, true);
        }
        let iChannel = bOut & ChipSet.DMA_MODE.CHANNEL;
        this.aDMACs[iDMAC].aChannels[iChannel].mode = bOut;
    }

    /**
     * outDMAResetFF(iDMAC, port, bOut, addrFrom)
     *
     * @this {ChipSet}
     * @param {number} iDMAC
     * @param {number} port (0x0C for DMAC 0, 0xD8 for DMAC 1)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined if the Debugger is trying to read the specified port)
     *
     * Any write to this port simply resets the controller's "first/last flip-flop", which determines whether
     * the even or odd byte of a DMA address or count register will be accessed next.
     */
    outDMAResetFF(iDMAC, port, bOut, addrFrom)
    {
        if (this.messageEnabled(MESSAGE.DMA + MESSAGE.PORT)) {
            this.printIO(port, bOut, addrFrom, "DMA" + iDMAC + ".RESET_FF", undefined, true);
        }
        this.aDMACs[iDMAC].bIndex = 0;
    }

    /**
     * inDMATemp(iDMAC, port, addrFrom)
     *
     * From the 8237A spec:
     *
     * "The Temporary register is used to hold data during memory-to-memory transfers  Following the
     * completion of the transfers, the last word moved can be read by the microprocessor in the Program Condition.
     * The Temporary register always contains the last byte transferred in the previous memory-to-memory operation,
     * unless cleared by a Reset."
     *
     * TRIVIA: This hook wasn't installed when I was testing with ANY of the IBM ROMs, but it's required
     * by the AT&T 6300 (aka Olivetti M24) ROM.
     *
     * TODO: When support is added for memory-to-memory transfers, bTemp needs to be updated according to spec.
     *
     * @this {ChipSet}
     * @param {number} iDMAC
     * @param {number} port (0x0D for DMAC 0, 0xDA for DMAC 1)
     * @param {number} [addrFrom] (not defined if the Debugger is trying to read the specified port)
     * @returns {number} simulated port value
     */
    inDMATemp(iDMAC, port, addrFrom)
    {
        let controller = this.aDMACs[iDMAC];
        let b = controller.bTemp;
        if (this.messageEnabled(MESSAGE.DMA + MESSAGE.PORT)) {
            this.printIO(port, undefined, addrFrom, "DMA" + iDMAC + ".TEMP", b, true);
        }
        return b;
    }

    /**
     * outDMAMasterClear(iDMAC, port, bOut, addrFrom)
     *
     * @this {ChipSet}
     * @param {number} iDMAC
     * @param {number} port (0x0D for DMAC 0, 0xDA for DMAC 1)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined if the Debugger is trying to read the specified port)
     */
    outDMAMasterClear(iDMAC, port, bOut, addrFrom)
    {
        if (this.messageEnabled(MESSAGE.DMA + MESSAGE.PORT)) {
            this.printIO(port, bOut, addrFrom, "DMA" + iDMAC + ".MASTER_CLEAR", undefined, true);
        }
        /**
         * The value written to this port doesn't matter; any write triggers a "master clear" operation
         *
         * TODO: Can't we just call initDMAController(), which would also take care of clearing controller.bStatus?
         */
        let controller = this.aDMACs[iDMAC];
        for (let i = 0; i < controller.aChannels.length; i++) {
            this.initDMAChannel(controller, i);
        }
    }

    /**
     * inDMAPageReg(iDMAC, iChannel, port, addrFrom)
     *
     * @this {ChipSet}
     * @param {number} iDMAC
     * @param {number} iChannel
     * @param {number} port
     * @param {number} [addrFrom] (not defined if the Debugger is trying to read the specified port)
     * @returns {number} simulated port value
     */
    inDMAPageReg(iDMAC, iChannel, port, addrFrom)
    {
        let bIn = this.aDMACs[iDMAC].aChannels[iChannel].bPage;
        if (this.messageEnabled(MESSAGE.DMA + MESSAGE.PORT)) {
            this.printIO(port, undefined, addrFrom, "DMA" + iDMAC + ".CHANNEL" + iChannel + ".PAGE", bIn, true);
        }
        return bIn;
    }

    /**
     * outDMAPageReg(iDMAC, iChannel, port, bOut, addrFrom)
     *
     * @this {ChipSet}
     * @param {number} iDMAC
     * @param {number} iChannel
     * @param {number} port
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined if the Debugger is trying to read the specified port)
     */
    outDMAPageReg(iDMAC, iChannel, port, bOut, addrFrom)
    {
        if (this.messageEnabled(MESSAGE.DMA + MESSAGE.PORT)) {
            this.printIO(port, bOut, addrFrom, "DMA" + iDMAC + ".CHANNEL" + iChannel + ".PAGE", undefined, true);
        }
        this.aDMACs[iDMAC].aChannels[iChannel].bPage = bOut;
    }

    /**
     * inDMAPageSpare(iSpare, port, addrFrom)
     *
     * @this {ChipSet}
     * @param {number} iSpare
     * @param {number} port
     * @param {number} [addrFrom] (not defined if the Debugger is trying to read the specified port)
     * @returns {number} simulated port value
     */
    inDMAPageSpare(iSpare, port, addrFrom)
    {
        let bIn = this.abDMAPageSpare[iSpare];
        if (this.messageEnabled(MESSAGE.DMA + MESSAGE.PORT)) {
            this.printIO(port, undefined, addrFrom, "DMA.SPARE" + iSpare + ".PAGE", bIn, true);
        }
        return bIn;
    }

    /**
     * outDMAPageSpare(iSpare, port, bOut, addrFrom)
     *
     * @this {ChipSet}
     * @param {number} iSpare
     * @param {number} port
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined if the Debugger is trying to read the specified port)
     */
    outDMAPageSpare(iSpare, port, bOut, addrFrom)
    {
        /**
         * TODO: Remove this DEBUG-only DESKPRO386 code once we're done debugging DeskPro 386 ROMs;
         * it enables logging of all DeskPro 386 ROM checkpoint I/O to port 0x84.
         */
        if (this.messageEnabled(MESSAGE.DMA + MESSAGE.PORT) /* || DEBUG && (this.model|0) == ChipSet.MODEL_COMPAQ_DESKPRO386 */) {
            this.printIO(port, bOut, addrFrom, "DMA.SPARE" + iSpare + ".PAGE", undefined, true);
        }
        this.abDMAPageSpare[iSpare] = bOut;
    }

    /**
     * getDMAState(iDMAChannel)
     *
     * @param {number} iDMAChannel
     * @returns {Array} (current transfer address at [0], current count at [1]; may be used by the FDC for bootstrapping tests)
     */
    getDMAState(iDMAChannel)
    {
        let iDMAC = iDMAChannel >> 2;
        let controller = this.aDMACs[iDMAC];

        let iChannel = iDMAChannel & 0x3;
        let channel = controller.aChannels[iChannel];

        return [(channel.bPage << 16) | (channel.addrCurrent[1] << 8) | channel.addrCurrent[0], (channel.countCurrent[1] << 8) | channel.countCurrent[0]];
    }

    /**
     * connectDMA(iDMAChannel, component, sFunction, obj)
     *
     * @param {number} iDMAChannel
     * @param {Component|string} component
     * @param {string} sFunction
     * @param {Object} obj (eg, when the HDC connects, it passes a drive object)
     */
    connectDMA(iDMAChannel, component, sFunction, obj)
    {
        let iDMAC = iDMAChannel >> 2;
        let controller = this.aDMACs[iDMAC];

        let iChannel = iDMAChannel & 0x3;
        let channel = controller.aChannels[iChannel];

        this.initDMAFunction(channel, component, sFunction, obj);
    }

    /**
     * requestDMA(iDMAChannel, done)
     *
     * @this {ChipSet}
     * @param {number} iDMAChannel
     * @param {function(boolean)} [done]
     *
     * For DMA_MODE.TYPE_WRITE transfers, fnTransfer(-1) must return bytes as long as we request them (although it may
     * return -1 if it runs out of bytes prematurely).
     *
     * Similarly, for DMA_MODE.TYPE_READ transfers, fnTransfer(b) must accept bytes as long as we deliver them (although
     * it is certainly free to ignore bytes it no longer wants).
     */
    requestDMA(iDMAChannel, done)
    {
        let iDMAC = iDMAChannel >> 2;
        let controller = this.aDMACs[iDMAC];

        let iChannel = iDMAChannel & 0x3;
        let channel = controller.aChannels[iChannel];

        if (!channel.component || !channel.fnTransfer || !channel.obj) {
            if (DEBUG) this.printf(MESSAGE.DMA + MESSAGE.DATA, "requestDMA(%d): not connected to a component\n", iDMAChannel);
            if (done) done(true);
            return;
        }

        /**
         * We can't simply slam done into channel.done; that would be fine if requestDMA() was called only by functions
         * like HDC.doRead() and HDC.doWrite(), but we're also called whenever a DMA channel is unmasked, and in those cases,
         * we need to preserve whatever handler may have been previously set.
         *
         * However, in an effort to ensure we don't end up with stale done handlers, connectDMA() will reset channel.done.
         */
        if (done) channel.done = done;

        if (channel.masked) {
            if (DEBUG) this.printf(MESSAGE.DMA + MESSAGE.DATA, "requestDMA(%d): channel masked, request queued\n", iDMAChannel);
            return;
        }

        /**
         * Let's try to do async DMA without asking the CPU for help...
         *
         *      this.cpu.setDMA(true);
         */
        this.advanceDMA(channel, true);
    }

    /**
     * advanceDMA(channel, fInit)
     *
     * @this {ChipSet}
     * @param {Object} channel
     * @param {boolean} [fInit]
     */
    advanceDMA(channel, fInit)
    {
        if (fInit) {
            channel.count = (channel.countCurrent[1] << 8) | channel.countCurrent[0];
            channel.type = (channel.mode & ChipSet.DMA_MODE.TYPE);
            channel.fWarning = channel.fError = false;
            if (DEBUG && DEBUGGER) {
                channel.cbDebug = channel.count + 1;
                channel.sAddrDebug = (DEBUG && DEBUGGER? null : undefined);
            }
        }
        /**
         * To support async DMA without requiring help from the CPU (ie, without relying upon cpu.setDMA()), we require that
         * the data transfer functions provide an fAsync parameter to their callbacks; fAsync must be true if the callback was
         * truly asynchronous (ie, it had to wait for a remote I/O request to finish), or false if the data was already available
         * and the callback was performed synchronously.
         *
         * Whenever a callback is issued asynchronously, we will immediately daisy-chain another pair of updateDMA()/advanceDMA()
         * calls, which will either finish the DMA operation if no more remote I/O requests are required, or will queue up another
         * I/O request, which will in turn trigger another async callback.  Thus, the DMA request keeps itself going without
         * requiring any special assistance from the CPU via setDMA().
         */
        let bto = null;
        let chipset = this;
        let fAsyncRequest = false;
        let controller = channel.controller;
        let iDMAChannel = controller.nChannelBase + channel.iChannel;

        while (true) {
            if (channel.count >= 0) {
                let b;
                let addr = (channel.bPage << 16) | (channel.addrCurrent[1] << 8) | channel.addrCurrent[0];
                if (DEBUG && DEBUGGER && channel.sAddrDebug === null) {
                    channel.sAddrDebug = StrLib.toHex(addr >> 4, 4) + ":" + StrLib.toHex(addr & 0xf, 4);
                    if (channel.type != ChipSet.DMA_MODE.TYPE_WRITE && this.messageEnabled(this.messageBitsDMA(iDMAChannel))) {
                        this.printf(MESSAGE.DMA, "advanceDMA(%d) transferring %d bytes from %s\n", iDMAChannel, channel.cbDebug, channel.sAddrDebug);
                        this.dbg.doDump(["db", channel.sAddrDebug, "l" + channel.cbDebug]);
                    }
                }
                if (channel.type == ChipSet.DMA_MODE.TYPE_WRITE) {
                    fAsyncRequest = true;
                    (function advanceDMAWrite(addrCur) {
                        channel.fnTransfer.call(channel.component, channel.obj, -1, function onTransferDMA(b, fAsync, obj, off) {
                            if (b < 0) {
                                if (!channel.fWarning) {
                                    if (DEBUG) chipset.printf(MESSAGE.DMA, "advanceDMAWrite(%d) ran out of data, assuming 0xff\n", iDMAChannel);
                                    channel.fWarning = true;
                                }
                                /**
                                 * TODO: Determine whether to abort, as we do for DMA_MODE.TYPE_READ.
                                 */
                                b = 0xff;
                            }
                            if (!channel.masked && !channel.fError) {
                                chipset.bus.setByte(addrCur, b);
                                /**
                                 * WARNING: Do NOT assume that obj is valid; if the sector data was not found, there will be no obj.
                                 */
                                if (BACKTRACK && obj) {
                                    if (!off && obj.file) {
                                        chipset.printf(MESSAGE.DISK, "loading %s[%#0X] at %%%0X\n", obj.file.path, obj.offFile, addrCur);
                                        /**
                                        if (obj.file.path == "\\SYSBAS.EXE" && obj.offFile == 512) {
                                            chipset.cpu.stopCPU();
                                        }
                                        */
                                    }
                                    bto = chipset.bus.addBackTrackObject(obj, bto, off);
                                    chipset.bus.writeBackTrackObject(addrCur, bto, off);
                                }
                            }
                            fAsyncRequest = fAsync;
                            if (fAsync) {
                                setTimeout(function() {
                                    if (!chipset.updateDMA(channel)) chipset.advanceDMA(channel);
                                }, 0);
                            }
                        });
                    }(addr));
                }
                else if (channel.type == ChipSet.DMA_MODE.TYPE_READ) {
                    /**
                     * TODO: Determine whether we should support async dmaWrite() functions (currently not required)
                     */
                    b = chipset.bus.getByte(addr);
                    if (channel.fnTransfer.call(channel.component, channel.obj, b) < 0) {
                        /**
                         * In this case, I think I have no choice but to terminate the DMA operation in response to a failure,
                         * because the ROM BIOS FDC.REG_DATA.CMD.FORMAT_TRACK command specifies a count that is MUCH too large
                         * (a side-effect of the ROM BIOS using the same "DMA_SETUP" code for reads, writes AND formats).
                         */
                        channel.fError = true;
                    }
                }
                else if (channel.type == ChipSet.DMA_MODE.TYPE_VERIFY) {
                    /**
                     * Originally, we did nothing here and just fell into updateDMA(); however, we actually need to probe for
                     * data even though we're not going to do anything with it, so that any data errors get flagged by the FDC.
                     *
                     * This resolves the copy-protection check on "Life & Death II (Disk 1)", and it should also resolve a
                     * similar problem with COMPAQ DeskPro 386 machines configured with 1.2M drives (where the BIOS would
                     * attempt to verify sector 16 after reading the boot sector from a 15 sector/track diskette and expect
                     * an error in order to confirm the CMOS drive type).  This will make disk type/drive type errors more
                     * common on those machines (eg, loading a 1.44M diskette in a 1.2M drive), but that should just be a more
                     * accurate reflection of historical reality.
                     */
                    (function advanceDMAVerify(addrCur) {
                        channel.fnTransfer.call(channel.component, channel.obj, -1, function onTransferDMA(b, fAsync, obj, off) {
                            if (b < 0) {
                                if (!channel.fWarning) {
                                    if (DEBUG) chipset.printf(MESSAGE.DMA, "advanceDMAVerify(%d) ran out of data\n", iDMAChannel);
                                    channel.fWarning = true;
                                }
                                /**
                                 * TODO: Determine whether to abort, as we do for DMA_MODE.TYPE_READ.
                                 */
                            }
                        });
                    }(addr));
                }
                else {
                    if (DEBUG) this.printf(MESSAGE.DMA + MESSAGE.WARNING, "advanceDMA(%d) unsupported transfer type %#06X\n", iDMAChannel, channel.type);
                    channel.fError = true;
                }
            }
            if (fAsyncRequest || this.updateDMA(channel)) break;
        }
    }

    /**
     * updateDMA(channel)
     *
     * @this {ChipSet}
     * @param {Object} channel
     * @returns {boolean} true if DMA operation complete, false if not
     */
    updateDMA(channel)
    {
        if (!channel.fError && --channel.count >= 0) {
            if (channel.mode & ChipSet.DMA_MODE.DECREMENT) {
                channel.addrCurrent[0]--;
                if (channel.addrCurrent[0] < 0) {
                    channel.addrCurrent[0] = 0xff;
                    channel.addrCurrent[1]--;
                    if (channel.addrCurrent[1] < 0) channel.addrCurrent[1] = 0xff;
                }
            } else {
                channel.addrCurrent[0]++;
                if (channel.addrCurrent[0] > 0xff) {
                    channel.addrCurrent[0] = 0x00;
                    channel.addrCurrent[1]++;
                    if (channel.addrCurrent[1] > 0xff) channel.addrCurrent[1] = 0x00;
                }
            }
            /**
             * In situations where an HDC DMA operation took too long, the Fixed Disk BIOS would give up, but the DMA operation would continue.
             *
             * TODO: Verify that the Fixed Disk BIOS shuts down (ie, re-masks) a DMA channel for failed requests, and that this handles those failures.
             */
            if (!channel.masked) return false;
        }

        let controller = channel.controller;
        let iDMAChannel = controller.nChannelBase + channel.iChannel;
        controller.bStatus = (controller.bStatus & ~(0x10 << channel.iChannel)) | (0x1 << channel.iChannel);

        /**
         * EOP is supposed to automatically (re)mask the channel, unless it's set for auto-initialize.
         */
        if (!(channel.mode & ChipSet.DMA_MODE.AUTOINIT)) {
            channel.masked = true;
            channel.component = channel.obj = null;
        }

        if (DEBUG && channel.type == ChipSet.DMA_MODE.TYPE_WRITE && channel.sAddrDebug && this.messageEnabled(this.messageBitsDMA(iDMAChannel))) {
            this.printf(MESSAGE.DMA, "updateDMA(%d) transferred %d bytes to %s\n", iDMAChannel, channel.cbDebug, channel.sAddrDebug);
            this.dbg.doDump(["db", channel.sAddrDebug, "l" + channel.cbDebug]);
        }

        if (channel.done) {
            channel.done(!channel.fError);
            channel.done = null;
        }

        /**
         * While it might make sense to call cpu.setDMA() here, it's simpler to let the CPU issue one more call
         * to chipset.checkDMA() and let the CPU update INTR.DMA on its own, based on the return value from checkDMA().
         */
        return true;
    }

    /**
     * inPICLo(iPIC, addrFrom)
     *
     * @this {ChipSet}
     * @param {number} iPIC
     * @param {number} [addrFrom] (not defined if the Debugger is trying to read the specified port)
     * @returns {number} simulated port value
     */
    inPICLo(iPIC, addrFrom)
    {
        let b = 0;
        let pic = this.aPICs[iPIC];
        if (pic.bOCW3 != null) {
            let bReadReg = pic.bOCW3 & ChipSet.PIC_LO.OCW3_READ_CMD;
            switch (bReadReg) {
                case ChipSet.PIC_LO.OCW3_READ_IRR:
                    b = pic.bIRR;
                    break;
                case ChipSet.PIC_LO.OCW3_READ_ISR:
                    b = pic.bISR;
                    break;
                default:
                    break;
            }
        }
        if (this.messageEnabled(MESSAGE.PIC + MESSAGE.PORT)) {
            this.printIO(pic.port, undefined, addrFrom, "PIC" + iPIC, b, true);
        }
        return b;
    }

    /**
     * outPICLo(iPIC, bOut, addrFrom)
     *
     * @this {ChipSet}
     * @param {number} iPIC
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined if the Debugger is trying to read the specified port)
     */
    outPICLo(iPIC, bOut, addrFrom)
    {
        let pic = this.aPICs[iPIC];
        if (this.messageEnabled(MESSAGE.PIC + MESSAGE.PORT)) {
            this.printIO(pic.port, bOut, addrFrom, "PIC" + iPIC, undefined, true);
        }
        if (bOut & ChipSet.PIC_LO.ICW1) {
            /**
             * This must be an ICW1...
             */
            pic.nICW = 0;
            pic.aICW[pic.nICW++] = bOut;
            /**
             * I used to do the rest of this initialization in outPICHi(), once all the ICW commands had been received,
             * but a closer reading of the 8259A spec indicates that that should happen now, on receipt on ICW1.
             *
             * Also, on p.10 of that spec, it says "The Interrupt Mask Register is cleared".  I originally took that to
             * mean that all interrupts were masked, but based on what MS-DOS 4.0M expects to happen after this code runs:
             *
             *      0070:44C6 B013          MOV      AL,13
             *      0070:44C8 E620          OUT      20,AL
             *      0070:44CA B050          MOV      AL,50
             *      0070:44CC E621          OUT      21,AL
             *      0070:44CE B009          MOV      AL,09
             *      0070:44D0 E621          OUT      21,AL
             *
             * (ie, it expects its next call to INT 0x13 will still generate an interrupt), I've decided the spec
             * must be read literally, meaning that all IMR bits must be zeroed.  Unmasking all possible interrupts by
             * default seems unwise to me, but who am I to judge....
             */
            pic.bIMR = 0x00;
            pic.bIRLow = 7;
            /**
             * TODO: I'm also zeroing both IRR and ISR, even though that's not actually mentioned as part of the ICW
             * sequence, because they need to be (re)initialized at some point.  However, if some component is currently
             * requesting an interrupt, what should I do about that?  Originally, I had decided to clear them ONLY if they
             * were still undefined, but that change appeared to break the ROM BIOS handling of CTRL-ALT-DEL, so I'm back
             * to unconditionally zeroing them.
             */
            pic.bIRR = pic.bISR = 0;
            /**
             * The spec also says that "Special Mask Mode is cleared and Status Read is set to IRR".  I attempt to insure
             * the latter, but as for special mask mode... well, that mode isn't supported yet.
             */
            pic.bOCW3 = ChipSet.PIC_LO.OCW3 | ChipSet.PIC_LO.OCW3_READ_IRR;
        }
        else if (!(bOut & ChipSet.PIC_LO.OCW3)) {
            /**
             * This must be an OCW2...
             */
            let bOCW2 = bOut & ChipSet.PIC_LO.OCW2_OP_MASK;
            if (bOCW2 & ChipSet.PIC_LO.OCW2_EOI) {
                /**
                 * This OCW2 must be an EOI command...
                 */
                let nIRL;
                let bIREnd = 0;
                if ((bOCW2 & ChipSet.PIC_LO.OCW2_EOI_SPEC) == ChipSet.PIC_LO.OCW2_EOI_SPEC) {
                    /**
                     * More "specifically", a specific EOI command...
                     */
                    nIRL = bOut & ChipSet.PIC_LO.OCW2_IR_LVL;
                    bIREnd = 1 << nIRL;
                } else {
                    /**
                     * Less "specifically", a non-specific EOI command.  The search for the highest priority in-service
                     * interrupt must start with whichever interrupt is opposite the lowest priority interrupt (normally 7,
                     * but technically whatever bIRLow is currently set to).  For example:
                     *
                     *      If bIRLow is 7, then the priority order is: 0, 1, 2, 3, 4, 5, 6, 7.
                     *      If bIRLow is 6, then the priority order is: 7, 0, 1, 2, 3, 4, 5, 6.
                     *      If bIRLow is 5, then the priority order is: 6, 7, 0, 1, 2, 3, 4, 5.
                     *      etc.
                     */
                    nIRL = pic.bIRLow + 1;
                    while (true) {
                        nIRL &= 0x7;
                        let bIR = 1 << nIRL;
                        if (pic.bISR & bIR) {
                            bIREnd = bIR;
                            break;
                        }
                        if (nIRL++ == pic.bIRLow) break;
                    }
                    if (DEBUG && !bIREnd) nIRL = null;      // for unexpected non-specific EOI commands, there's no IRQ to report
                }
                let nIRQ = (nIRL == null? undefined : pic.nIRQBase + nIRL);
                if (pic.bISR & bIREnd) {
                    if (DEBUG && this.dbg) this.printf(this.messageBitsIRQ(nIRQ), "outPIC%d(%#04X): IRQ %d ending @%s stack=%s\n",  iPIC, pic.port, nIRQ, this.dbg.toHexOffset(this.cpu.getIP(), this.cpu.getCS()), this.dbg.toHexOffset(this.cpu.getSP(), this.cpu.getSS()));
                    pic.bISR &= ~bIREnd;
                    this.checkIRR();
                } else {
                    if (DEBUG) {
                        this.printf(MESSAGE.PIC + MESSAGE.WARNING + MESSAGE.ADDR, "outPIC%d(%#04X): unexpected EOI for IRQ %d\n", iPIC, pic.port, nIRQ);
                        if (MAXDEBUG && this.dbg) this.dbg.stopCPU();
                    }
                }
                /**
                 * TODO: Support EOI commands with automatic rotation (eg, ChipSet.PIC_LO.OCW2_EOI_ROT and ChipSet.PIC_LO.OCW2_EOI_ROTSPEC)
                 */
                if (bOCW2 & ChipSet.PIC_LO.OCW2_SET_ROTAUTO) {
                    this.printf(MESSAGE.PIC + MESSAGE.WARNING + MESSAGE.ADDR, "outPIC%d(%#04X): unsupported OCW2 rotate %#04X\n", iPIC, pic.port, bOut);
                }
            }
            else  if (bOCW2 == ChipSet.PIC_LO.OCW2_SET_PRI) {
                /**
                 * This OCW2 changes the lowest priority interrupt to the specified level (the default is 7)
                 */
                pic.bIRLow = bOut & ChipSet.PIC_LO.OCW2_IR_LVL;
            }
            else {
                /**
                 * TODO: Remaining commands to support: ChipSet.PIC_LO.OCW2_SET_ROTAUTO and ChipSet.PIC_LO.OCW2_CLR_ROTAUTO
                 */
                this.printf(MESSAGE.PIC + MESSAGE.WARNING + MESSAGE.ADDR, "outPIC%d(%#04X): unsupported OCW2 automatic rotate %#04X\n", iPIC, pic.port, bOut);
            }
        } else {
            /**
             * This must be an OCW3 request. If it's a "Read Register" command (PIC_LO.OCW3_READ_CMD), inPICLo() will take care it.
             *
             * TODO: If OCW3 specified a "Poll" command (PIC_LO.OCW3_POLL_CMD) or a "Special Mask Mode" command (PIC_LO.OCW3_SMM_CMD),
             * that's unfortunate, because I don't support them yet.
             */
            if (bOut & (ChipSet.PIC_LO.OCW3_POLL_CMD | ChipSet.PIC_LO.OCW3_SMM_CMD)) {
                this.printf(MESSAGE.PIC + MESSAGE.WARNING + MESSAGE.ADDR, "outPIC%d(%#04X): unsupported OCW3 %#04X\n", iPIC, pic.port, bOut);
            }
            pic.bOCW3 = bOut;
        }
    }

    /**
     * inPICHi(iPIC, addrFrom)
     *
     * @this {ChipSet}
     * @param {number} iPIC
     * @param {number} [addrFrom] (not defined if the Debugger is trying to read the specified port)
     * @returns {number} simulated port value
     */
    inPICHi(iPIC, addrFrom)
    {
        let pic = this.aPICs[iPIC];
        let b = pic.bIMR;
        if (this.messageEnabled(MESSAGE.PIC + MESSAGE.PORT)) {
            this.printIO(pic.port+1, undefined, addrFrom, "PIC" + iPIC, b, true);
        }
        return b;
    }

    /**
     * outPICHi(iPIC, bOut, addrFrom)
     *
     * @this {ChipSet}
     * @param {number} iPIC
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined if the Debugger is trying to read the specified port)
     */
    outPICHi(iPIC, bOut, addrFrom)
    {
        let pic = this.aPICs[iPIC];
        if (this.messageEnabled(MESSAGE.PIC + MESSAGE.PORT)) {
            this.printIO(pic.port+1, bOut, addrFrom, "PIC" + iPIC, undefined, true);
        }
        if (pic.nICW < pic.aICW.length) {
            pic.aICW[pic.nICW++] = bOut;
            if (pic.nICW == 2 && (pic.aICW[0] & ChipSet.PIC_LO.ICW1_SNGL)) {
                pic.nICW++;
            }
            if (pic.nICW == 3 && !(pic.aICW[0] & ChipSet.PIC_LO.ICW1_ICW4)) {
                pic.nICW++;
            }
        }
        else {
            /**
             * We have all our ICW "words" (ie, bytes), so this must be an OCW1 write (which is simply an IMR write)
             */
            pic.bIMR = bOut;
            /**
             * See the CPU's delayINTR() function for an explanation of why this explicit delay is necessary.
             */
            this.cpu.delayINTR();
            /**
             * Alas, we need a longer delay for the MODEL_5170's "KBD_RESET" function (F000:17D2), which must drop
             * into a loop and decrement CX at least once after unmasking the KBD IRQ.  The "KBD_RESET" function on
             * previous models could be handled with a 4-instruction delay provided by the Keyboard.resetDevice() call
             * to setIRR(), but the MODEL_5170 needs a roughly 6-instruction delay after it unmasks the KBD IRQ.
             */
            this.checkIRR(!iPIC && bOut == 0xFD? 6 : 0);
        }
    }

    /**
     * checkIMR(nIRQ)
     *
     * @this {ChipSet}
     * @param {number} nIRQ
     * @returns {boolean} true if the specified IRQ is masked, false if not
     */
    checkIMR(nIRQ)
    {
        let iPIC = nIRQ >> 3;
        let nIRL = nIRQ & 0x7;
        let pic = this.aPICs[iPIC];
        return !!(pic.bIMR & (0x1 << nIRL));
    }

    /**
     * setIRR(nIRQ, nDelay)
     *
     * @this {ChipSet}
     * @param {number} nIRQ (IRQ 0-7 implies iPIC 0, and IRQ 8-15 implies iPIC 1)
     * @param {number} [nDelay] is an optional number of instructions to delay acknowledgment of the IRQ (see getIRRVector)
     */
    setIRR(nIRQ, nDelay)
    {
        /**
         * Whenever the Video component needs to signal a vertical retrace interrupt, it specifies ChipSet.IRQ.VID
         * (aka IRQ 2) and it is blissfully ignorant of whether the machine has one or two PICs; unfortunately, in the
         * case of two PICs (master and slave), its interrupt is supposed to come through IRQ 9 on the slave, since
         * IRQ 2 has now been reserved for the slave PIC.  We take care of that here, so that Video can remain blissful.
         */
        if (nIRQ == ChipSet.IRQ.SLAVE && this.cPICs == 2) {     // IRQ.SLAVE conflicts with IRQ.VID
            nIRQ = ChipSet.IRQ.IRQ2;                            // aka IRQ 9
        }
        let iPIC = nIRQ >> 3;
        let nIRL = nIRQ & 0x7;
        let pic = this.aPICs[iPIC];
        let bIRR = (1 << nIRL);
        if (!(pic.bIRR & bIRR)) {
            pic.bIRR |= bIRR;
            this.printf(this.messageBitsIRQ(nIRQ), "set IRQ %d\n", nIRQ);
            pic.nDelay = nDelay || 0;
            this.checkIRR();
        }
    }

    /**
     * clearIRR(nIRQ)
     *
     * @this {ChipSet}
     * @param {number} nIRQ (IRQ 0-7 implies iPIC 0, and IRQ 8-15 implies iPIC 1)
     */
    clearIRR(nIRQ)
    {
        let iPIC = nIRQ >> 3;
        let nIRL = nIRQ & 0x7;
        let pic = this.aPICs[iPIC];
        let bIRR = (1 << nIRL);
        if (pic.bIRR & bIRR) {
            pic.bIRR &= ~bIRR;
            this.printf(this.messageBitsIRQ(nIRQ), "clear IRQ %d\n", nIRQ);
            this.checkIRR();
        }
    }

    /**
     * checkIRR(nDelay)
     *
     * @this {ChipSet}
     * @param {number} [nDelay] is an optional number of instructions to delay acknowledgment of a pending interrupt
     */
    checkIRR(nDelay)
    {
        /**
         * Look for any IRR bits that aren't masked and aren't already in service; in theory, all we'd have to
         * check is the master PIC (which is the *only* PIC on pre-5170 models), because when any IRQs are set or
         * cleared on the slave, that would automatically be reflected in IRQ.SLAVE on the master; that's what
         * setIRR() and clearIRR() used to do.
         *
         * Unfortunately, despite setIRR() and clearIRR()'s efforts, whenever a slave interrupt is acknowledged,
         * getIRRVector() ends up clearing the IRR bits for BOTH the slave's IRQ and the master's IRQ.SLAVE.
         * So if another lower-priority slave IRQ is waiting to be dispatched, that fact is no longer reflected
         * in IRQ.SLAVE.
         *
         * Since checkIRR() is called on every EOI, we can resolve that problem here, by first checking the slave
         * PIC for any unmasked, unserviced interrupts and updating the master's IRQ.SLAVE.
         *
         * And since this is ALSO called by both setIRR() and clearIRR(), those functions no longer need to perform
         * their own IRQ.SLAVE updates.  This function consolidates the propagation of slave interrupts to the master.
         */
        let pic;
        let bIR = -1;

        if (this.cPICs > 1) {
            pic = this.aPICs[1];
            bIR = ~(pic.bISR | pic.bIMR) & pic.bIRR;
        }

        pic = this.aPICs[0];

        if (bIR >= 0) {
            if (bIR) {
                pic.bIRR |= (1 << ChipSet.IRQ.SLAVE);
            } else {
                pic.bIRR &= ~(1 << ChipSet.IRQ.SLAVE);
            }
        }

        bIR = ~(pic.bISR | pic.bIMR) & pic.bIRR;

        this.cpu.updateINTR(!!bIR);

        if (bIR && nDelay) pic.nDelay = nDelay;
    }

    /**
     * getIRRVector()
     *
     * getIRRVector() is called by the CPU whenever PS_IF is set and OP_NOINTR is clear.  Ordinarily, an immediate
     * response would seem perfectly reasonable, but unfortunately, there are places in the original ROM BIOS like
     * "KBD_RESET" (F000:E688) that enable interrupts but still expect nothing to happen for several more instructions.
     *
     * So, in addition to the two normal responses (an IDT vector #, or -1 indicating no pending interrupts), we must
     * support a third response (-2) that basically means: don't change the CPU interrupt state, just keep calling until
     * we return one of the first two responses.  The number of times we delay our normal response is determined by the
     * component that originally called setIRR with an optional delay parameter.
     *
     * @this {ChipSet}
     * @param {number} [iPIC]
     * @returns {number} IDT vector # of the next highest-priority interrupt, -1 if none, or -2 for "please try your call again later"
     */
    getIRRVector(iPIC)
    {
        if (iPIC === undefined) iPIC = 0;

        /**
         * Look for any IRR bits that aren't masked and aren't already in service...
         */
        let nIDT = -1;
        let pic = this.aPICs[iPIC];
        if (!pic.nDelay) {
            let bIR = pic.bIRR & ((pic.bISR | pic.bIMR) ^ 0xff);
            /**
             * The search for the next highest priority requested interrupt (that's also not in-service and not masked)
             * must start with whichever interrupt is opposite the lowest priority interrupt (normally 7, but technically
             * whatever bIRLow is currently set to).  For example:
             *
             *      If bIRLow is 7, then the priority order is: 0, 1, 2, 3, 4, 5, 6, 7.
             *      If bIRLow is 6, then the priority order is: 7, 0, 1, 2, 3, 4, 5, 6.
             *      If bIRLow is 5, then the priority order is: 6, 7, 0, 1, 2, 3, 4, 5.
             *      etc.
             *
             * This process is similar to the search performed by non-specific EOIs, except those apply only to a single
             * PIC (which is why a slave interrupt must be EOI'ed twice: once for the slave PIC and again for the master),
             * whereas here we must search across all PICs.
             */
            let nIRL = pic.bIRLow + 1;
            while (true) {

                nIRL &= 0x7;
                let bIRNext = 1 << nIRL;

                /**
                 * If we encounter an interrupt that's still in-service BEFORE we encounter a requested interrupt,
                 * then we're done; we must allow a higher priority in-service interrupt to finish before acknowledging
                 * any lower priority interrupts.
                 */
                if (pic.bISR & bIRNext) break;

                if (bIR & bIRNext) {

                    if (!iPIC && nIRL == ChipSet.IRQ.SLAVE && this.aPICs.length > 1) {
                        /**
                         * Slave interrupts are tied to the master PIC on IRQ2; query the slave PIC for the vector #
                         */
                        nIDT = this.getIRRVector(1);
                    } else {
                        /**
                         * Get the starting IDT vector # from ICW2 and add the IR level to obtain the target IDT vector #
                         */
                        nIDT = pic.aICW[1] + nIRL;
                    }

                    if (nIDT >= 0) {
                        pic.bISR |= bIRNext;

                        /**
                         * Setting the ISR implies clearing the IRR, but clearIRR() has side-effects we don't want
                         * (eg, clearing the slave IRQ, notifying the CPU, etc), so we clear the IRR ourselves.
                         */
                        pic.bIRR &= ~bIRNext;

                        let nIRQ = pic.nIRQBase + nIRL;
                        if (DEBUG && this.dbg) this.printf(this.messageBitsIRQ(nIRQ) + MESSAGE.ADDR, "getIRRVector(): IRQ %d interrupting stack %s\n", nIRQ, this.dbg.toHexOffset(this.cpu.getSP(), this.cpu.getSS()));
                        if (MAXDEBUG && DEBUGGER) this.acInterrupts[nIRQ]++;
                    }
                    break;
                }

                if (nIRL++ == pic.bIRLow) break;
            }
        } else {
            nIDT = -2;
            pic.nDelay--;
        }
        return nIDT;
    }

    /**
     * setFPUInterrupt()
     *
     * @this {ChipSet}
     */
    setFPUInterrupt()
    {
        if (this.model >= ChipSet.MODEL_5170) {
            this.setIRR(ChipSet.IRQ.FPU);
        } else {
            /**
             * TODO: Determine whether we need to maintain an "Active NMI" state; ie, if NMI.DISABLE is cleared
             * later, and the FPU coprocessor is still indicating an error condition, should we then generate an NMI?
             */
            if (this.bNMI & ChipSet.NMI.ENABLE) {
                X86.helpInterrupt.call(this.cpu, X86.EXCEPTION.NMI);
            }
        }
    }

    /**
     * clearFPUInterrupt(fSet)
     *
     * @this {ChipSet}
     */
    clearFPUInterrupt()
    {
        if (this.model >= ChipSet.MODEL_5170) {
            this.clearIRR(ChipSet.IRQ.FPU);
        } else {
            /**
             * TODO: If we maintain an "Active NMI" state, then we will need code here to clear that state, as well
             * as code in outNMI() to clear that state and generate an NMI as needed.
             */
        }
    }

    /**
     * inTimer(iPIT, iPITTimer, addrFrom)
     *
     * @this {ChipSet}
     * @param {number} iPIT (0 or 1)
     * @param {number} iPITTimer (0, 1, or 2)
     * @param {number} port (0x40, 0x41, 0x42, etc)
     * @param {number} [addrFrom] (not defined if the Debugger is trying to read the specified port)
     * @returns {number} simulated port value
     */
    inTimer(iPIT, iPITTimer, port, addrFrom)
    {
        let b;
        let iBaseTimer = (iPIT? 3 : 0);
        let timer = this.aTimers[iBaseTimer + iPITTimer];

        if (timer.fStatusLatched) {
            b = timer.bStatus;
            timer.fStatusLatched = false;
        }
        else {
            if (timer.countIndex == timer.countBytes) {
                this.resetTimerIndex(iBaseTimer + iPITTimer);
            }
            if (timer.fCountLatched) {
                b = timer.countLatched[timer.countIndex++];
                if (timer.countIndex == timer.countBytes) {
                    timer.fCountLatched = false;
                }
            }
            else {
                this.updateTimer(iBaseTimer + iPITTimer);
                b = timer.countCurrent[timer.countIndex++];
            }
        }
        if (this.messageEnabled(MESSAGE.TIMER + MESSAGE.PORT)) {
            this.printIO(port, undefined, addrFrom, "PIT" + iPIT + ".TIMER" + iPITTimer, b, true);
        }
        return b;
    }

    /**
     * outTimer(iPIT, iPITTimer, port, bOut, addrFrom)
     *
     * We now rely EXCLUSIVELY on setBurstCycles() to address situations where quick timer interrupt turn-around
     * is expected; eg, by the ROM BIOS POST when it sets TIMER0 to a low test count (0x16); since we typically
     * don't update any of the timers until after we've finished a burst of CPU cycles, we must reduce the current
     * burst cycle count, so that the current instruction burst will end at the same time a timer interrupt is expected.
     *
     * @this {ChipSet}
     * @param {number} iPIT (0 or 1)
     * @param {number} iPITTimer (0, 1, or 2)
     * @param {number} port (0x40, 0x41, 0x42, etc)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined if the Debugger is trying to read the specified port)
     */
    outTimer(iPIT, iPITTimer, port, bOut, addrFrom)
    {
        if (this.messageEnabled(MESSAGE.TIMER + MESSAGE.PORT)) {
            this.printIO(port, bOut, addrFrom, "PIT" + iPIT + ".TIMER" + iPITTimer, undefined, true);
        }

        let iBaseTimer = (iPIT? 3 : 0);
        let timer = this.aTimers[iBaseTimer + iPITTimer];

        if (timer.countIndex == timer.countBytes) {
            this.resetTimerIndex(iBaseTimer + iPITTimer);
        }

        timer.countInit[timer.countIndex++] = bOut;

        if (timer.countIndex == timer.countBytes) {
            /**
             * In general, writing a new count to a timer that's already counting isn't supposed to affect the current
             * count, with the notable exceptions of MODE0 and MODE4.
             */
            if (!timer.fCounting || timer.mode == ChipSet.PIT_CTRL.MODE0 || timer.mode == ChipSet.PIT_CTRL.MODE4) {
                timer.fCountLatched = false;
                timer.countCurrent[0] = timer.countStart[0] = timer.countInit[0];
                timer.countCurrent[1] = timer.countStart[1] = timer.countInit[1];
                timer.nCyclesStart = this.cpu.getCycles(this.fScaleTimers);
                timer.fCounting = true;

                /**
                 * I believe MODE0 is the only mode where OUT (fOUT) starts out low (false); for the rest of the modes,
                 * OUT (fOUT) starts high (true).  It's also my understanding that the way edge-triggered interrupts work
                 * on the original PC is that an interrupt is requested only when the corresponding OUT transitions from
                 * low to high.
                 */
                timer.fOUT = (timer.mode != ChipSet.PIT_CTRL.MODE0);

                if (iPIT == ChipSet.PIT0.INDEX && iPITTimer == ChipSet.PIT0.TIMER0) {
                    /**
                     * TODO: Determine if there are situations/modes where I should NOT automatically clear IRQ0 on behalf of TIMER0.
                     */
                    this.clearIRR(ChipSet.IRQ.TIMER0);
                    let countInit = this.getTimerInit(ChipSet.PIT0.TIMER0);
                    let nCyclesRemain = (countInit * this.nTicksDivisor) | 0;
                    if (timer.mode == ChipSet.PIT_CTRL.MODE3) nCyclesRemain >>= 1;
                    this.cpu.setBurstCycles(nCyclesRemain);
                }
            }

            if (iPIT == ChipSet.PIT0.INDEX && iPITTimer == ChipSet.PIT0.TIMER2) this.setSpeaker();
        }
    }

    /**
     * inTimerCtrl(iPIT, port, addrFrom)
     *
     * @this {ChipSet}
     * @param {number} iPIT (0 or 1)
     * @param {number} port (0x43 or 0x4B)
     * @param {number} [addrFrom] (not defined if the Debugger is trying to read the specified port)
     * @returns {number|null} simulated port value
     */
    inTimerCtrl(iPIT, port, addrFrom)
    {
        this.printIO(port, undefined, addrFrom, "PIT" + iPIT + ".CTRL", undefined, MESSAGE.TIMER);
        /**
         * NOTE: Even though reads to port 0x43 are undefined (I think), I'm going to "define" it
         * as returning the last value written, purely for the Debugger's benefit.
         */
        return iPIT? this.bPIT1Ctrl : this.bPIT0Ctrl;
    }

    /**
     * outTimerCtrl(iPIT, port, bOut, addrFrom)
     *
     * @this {ChipSet}
     * @param {number} iPIT (0 or 1)
     * @param {number} port (0x43)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined if the Debugger is trying to read the specified port)
     */
    outTimerCtrl(iPIT, port, bOut, addrFrom)
    {
        this.printIO(port, bOut, addrFrom, "PIT" + iPIT + ".CTRL", undefined, MESSAGE.TIMER);

        /**
         * Extract the SC (Select Counter) bits.
         */
        let iBaseTimer = 0;
        let iPITTimer = (bOut & ChipSet.PIT_CTRL.SC);
        if (!iPIT) {
            this.bPIT0Ctrl = bOut;
        } else {
            iBaseTimer = 3;
            this.bPIT1Ctrl = bOut;
        }

        /**
         * Check for the Read-Back command and process as needed.
         */
        if (iPITTimer == ChipSet.PIT_CTRL.SC_BACK) {
            if (!(bOut & ChipSet.PIT_CTRL.RB_STATUS)) {
                for (iPITTimer = 0; iPITTimer <= 2; iPITTimer++) {
                    if (bOut & (ChipSet.PIT_CTRL.RB_CTR0 << iPITTimer)) {
                        this.latchTimerStatus(iBaseTimer + iPITTimer);
                    }
                }
            }
            if (!(bOut & ChipSet.PIT_CTRL.RB_COUNTS)) {
                for (iPITTimer = 0; iPITTimer <= 2; iPITTimer++) {
                    if (bOut & (ChipSet.PIT_CTRL.RB_CTR0 << iPITTimer)) {
                        this.latchTimerCount(iBaseTimer + iPITTimer);
                    }
                }
            }
            return;
        }

        /**
         * Convert the SC (Select Counter) bits into an iPITTimer index (0-2).
         */
        iPITTimer >>= ChipSet.PIT_CTRL.SC_SHIFT;

        /**
         * Extract BCD (bit 0), MODE (bits 1-3), and RW (bits 4-5), which we simply store as-is (see setTimerMode).
         */
        let bcd = (bOut & ChipSet.PIT_CTRL.BCD);
        let mode = (bOut & ChipSet.PIT_CTRL.MODE);
        let rw = (bOut & ChipSet.PIT_CTRL.RW);

        if (rw == ChipSet.PIT_CTRL.RW_LATCH) {
            /**
             * Of all the RW bit combinations, this is the only one that "countermands" normal control register
             * processing (the BCD and MODE bits are "don't care").
             */
            this.latchTimerCount(iBaseTimer + iPITTimer);
        }
        else {
            this.setTimerMode(iBaseTimer + iPITTimer, bcd, mode, rw);

            /**
             * The 5150 ROM BIOS code @F000:E285 ("TEST.7") would fail after a warm boot (eg, after a CTRL-ALT-DEL) because
             * it assumed that no TIMER0 interrupt would occur between the point it unmasked the TIMER0 interrupt and the
             * point it started reprogramming TIMER0.
             *
             * Similarly, the 5160 ROM BIOS @F000:E35D ("8253 TIMER CHECKOUT") would fail after initializing the EGA BIOS,
             * because the EGA BIOS uses TIMER0 during its diagnostics; as in the previous example, by the time the 8253
             * test code runs later, there's now a pending TIMER0 interrupt, which triggers an interrupt as soon as IRQ0 is
             * unmasked @F000:E364.
             *
             * After looking at this problem at bit more closely the second time around (while debugging the EGA BIOS),
             * it turns out I missed an important 8253 feature: whenever a new MODE0 control word OR a new MODE0 count
             * is written, fOUT (which is what drives IRQ0) goes low.  So, by simply adding an appropriate clearIRR() call
             * both here and in outTimer(), this annoying problem seems to be gone.
             *
             * TODO: Determine if there are situations/modes where I should NOT automatically clear IRQ0 on behalf of TIMER0.
             */
            if (iPIT == ChipSet.PIT0.INDEX && iPITTimer == ChipSet.PIT0.TIMER0) this.clearIRR(ChipSet.IRQ.TIMER0);

            /**
             * Another TIMER0 HACK: The "CASSETTE DATA WRAP TEST" @F000:E51E occasionally reports an error when the second of
             * two TIMER0 counts it latches is greater than the first.  You would think the ROM BIOS would expect this, since
             * TIMER0 can reload its count at any time.  Is the ROM BIOS assuming that TIMER0 was initialized sufficiently
             * recently that this should never happen?  I'm not sure, but for now, let's try resetting TIMER0's count immediately
             * after TIMER2 has been reprogrammed for the test in question (ie, when interrupts are masked and PPIB is set as
             * shown below).
             *
             * FWIW, I believe the cassette hardware was discontinued after MODEL_5150, and even if the test fails, it's non-fatal;
             * the ROM BIOS displays an error (131) and moves on.
             */
            if (iPIT == ChipSet.PIT0.INDEX && iPITTimer == ChipSet.PIT0.TIMER2) {
                let pic = this.aPICs[0];
                if (pic.bIMR == 0xff && this.bPPIB == (ChipSet.PPI_B.CLK_TIMER2 | ChipSet.PPI_B.ENABLE_SW2 | ChipSet.PPI_B.CASS_MOTOR_OFF | ChipSet.PPI_B.CLK_KBD)) {
                    let timer = this.aTimers[0];
                    timer.countStart[0] = timer.countInit[0];
                    timer.countStart[1] = timer.countInit[1];
                    timer.nCyclesStart = this.cpu.getCycles(this.fScaleTimers);
                    if (DEBUG) this.printf(MESSAGE.TIMER, "PIT0.TIMER0 count reset @%d cycles\n", timer.nCyclesStart);
                }
            }
        }
    }

    /**
     * getTimerInit(iTimer)
     *
     * @this {ChipSet}
     * @param {number} iTimer
     * @returns {number} initial timer count
     */
    getTimerInit(iTimer)
    {
        let timer = this.aTimers[iTimer];
        let countInit = (timer.countInit[1] << 8) | timer.countInit[0];
        if (!countInit) countInit = (timer.countBytes == 1? 0x100 : 0x10000);
        return countInit;
    }

    /**
     * getTimerStart(iTimer)
     *
     * @this {ChipSet}
     * @param {number} iTimer
     * @returns {number} starting timer count (from the initial timer count for the current countdown)
     */
    getTimerStart(iTimer)
    {
        let timer = this.aTimers[iTimer];
        let countStart = (timer.countStart[1] << 8) | timer.countStart[0];
        if (!countStart) countStart = (timer.countBytes == 1? 0x100 : 0x10000);
        return countStart;
    }

    /**
     * getTimerCycleLimit(iTimer, nCycles)
     *
     * This is called by the CPU to determine the maximum number of cycles it can process for the current burst.
     * It's presumed that no instructions have been executed since the last updateTimer(iTimer) call.
     *
     * @this {ChipSet}
     * @param {number} iTimer
     * @param {number} nCycles desired
     * @returns {number} maximum number of cycles remaining for the specified timer (<= nCycles)
     */
    getTimerCycleLimit(iTimer, nCycles)
    {
        let timer = this.aTimers[iTimer];
        if (timer.fCounting) {
            let nCyclesUpdate = this.cpu.getCycles(this.fScaleTimers);
            let ticksElapsed = ((nCyclesUpdate - timer.nCyclesStart) / this.nTicksDivisor) | 0;
            // DEBUG:
            let countStart = this.getTimerStart(iTimer);
            let count = countStart - ticksElapsed;
            if (timer.mode == ChipSet.PIT_CTRL.MODE3) count -= ticksElapsed;
            // DEBUG:
            let nCyclesRemain = (count * this.nTicksDivisor) | 0;
            if (timer.mode == ChipSet.PIT_CTRL.MODE3) nCyclesRemain >>= 1;
            if (nCycles > nCyclesRemain) nCycles = nCyclesRemain;
        }
        return nCycles;
    }

    /**
     * latchTimerCount(iTimer)
     *
     * @this {ChipSet}
     * @param {number} iTimer
     */
    latchTimerCount(iTimer)
    {
        /**
         * Update the timer's current count.
         */
        this.updateTimer(iTimer);

        /**
         * Now we can latch it.
         */
        let timer = this.aTimers[iTimer];
        timer.countLatched[0] = timer.countCurrent[0];
        timer.countLatched[1] = timer.countCurrent[1];
        timer.fCountLatched = true;

        /**
         * VERIFY: That a latch request resets the timer index.
         */
        this.resetTimerIndex(iTimer);
    }

    /**
     * latchTimerStatus(iTimer)
     *
     * @this {ChipSet}
     * @param {number} iTimer
     */
    latchTimerStatus(iTimer)
    {
        let timer = this.aTimers[iTimer];
        if (!timer.fStatusLatched) {
            this.updateTimer(iTimer);
            timer.bStatus = timer.bcd | timer.mode | timer.rw | (timer.countIndex < timer.countBytes? ChipSet.PIT_CTRL.RB_NULL : 0) | (timer.fOUT? ChipSet.PIT_CTRL.RB_OUT : 0);
            timer.fStatusLatched = true;
        }
    }

    /**
     * setTimerMode(iTimer, bcd, mode, rw)
     *
     * FYI: After setting a timer's mode, the CPU must set the timer's count before it becomes operational;
     * ie, before fCounting becomes true.
     *
     * @this {ChipSet}
     * @param {number} iTimer
     * @param {number} bcd
     * @param {number} mode
     * @param {number} rw
     */
    setTimerMode(iTimer, bcd, mode, rw)
    {
        let timer = this.aTimers[iTimer];
        timer.rw = rw;
        timer.mode = mode;
        timer.bcd = bcd;
        timer.countInit = [0, 0];
        timer.countCurrent = [0, 0];
        timer.countLatched = [0, 0];
        timer.fOUT = false;
        timer.fCountLatched = false;
        timer.fCounting = false;
        timer.fStatusLatched = false;
        this.resetTimerIndex(iTimer);
    }

    /**
     * resetTimerIndex(iTimer)
     *
     * @this {ChipSet}
     * @param {number} iTimer
     */
    resetTimerIndex(iTimer)
    {
        let timer = this.aTimers[iTimer];
        timer.countIndex = (timer.rw == ChipSet.PIT_CTRL.RW_MSB? 1 : 0);
        timer.countBytes = (timer.rw == ChipSet.PIT_CTRL.RW_BOTH? 2 : 1);
    }

    /**
     * updateTimer(iTimer, fCycleReset)
     *
     * updateTimer() calculates and updates a timer's current count purely on an "on-demand" basis; we don't
     * actually adjust timer counters every 4 CPU cycles on a 4.77Mhz PC, since updating timers that frequently
     * would be prohibitively slow.  If you're single-stepping the CPU, then yes, updateTimer() will be called
     * after every stepCPU(), via updateAllTimers(), but if we're doing our job correctly here, the frequency
     * of calls to updateTimer() should not affect timer counts across otherwise identical runs.
     *
     * TODO: Implement support for all TIMER modes, and verify that all the modes currently implemented are
     * "up to spec"; they're close enough to make the ROM BIOS happy, but beyond that, I've done very little.
     *
     * @this {ChipSet}
     * @param {number} iTimer
     *      0: Time-of-Day interrupt (~18.2 interrupts/second)
     *      1: DMA refresh
     *      2: Sound/Cassette
     * @param {boolean} [fCycleReset] is true if a cycle-count reset is about to occur
     * @returns {Timer}
     */
    updateTimer(iTimer, fCycleReset)
    {
        let timer = this.aTimers[iTimer];

        /**
         * Every timer's counting state is gated by its own fCounting flag; TIMER2 is further gated by PPI_B's
         * CLK_TIMER2 bit.
         */
        if (timer.fCounting && (iTimer != ChipSet.PIT0.TIMER2 || (this.bPPIB & ChipSet.PPI_B.CLK_TIMER2))) {
            /**
             * We determine the current timer count based on how many instruction cycles have elapsed since we started
             * the timer.  Timers are supposed to be "ticking" at a rate of 1193181.8181 times per second, which is
             * the system clock of 14.31818Mhz, divided by 12.
             *
             * Similarly, for an 8088, there are supposed to be 4.77Mhz instruction cycles per second, which comes from
             * the system clock of 14.31818Mhz, divided by 3.
             *
             * If we divide 4,772,727 CPU cycles per second by 1,193,181 ticks per second, we get 4 cycles per tick,
             * which agrees with the ratio of the clock divisors: 12 / 3 == 4.
             *
             * However, if getCycles() is being called with fScaleTimers == true AND the CPU is running faster than its
             * base cycles-per-second setting, then getCycles() will divide the cycle count by the CPU's cycle multiplier,
             * so that the timers fire with the same real-world frequency that the user expects.  However, that will
             * break any code (eg, the ROM BIOS diagnostics) that assumes that the timers are ticking once every 4 cycles
             * (or more like every 5 cycles on a 6Mhz 80286).
             *
             * So, when using a machine with the ChipSet "scaleTimers" property set, make sure you reset the machine's
             * speed prior to rebooting, otherwise you're likely to see ROM BIOS errors.  Ditto for any application code
             * that makes similar assumptions about the relationship between CPU and timer speeds.
             *
             * In general, you're probably better off NOT using the "scaleTimers" property, and simply allowing the timers
             * to tick faster as you increase CPU speed (which is why fScaleTimers defaults to false).
             */
            let nCycles = this.cpu.getCycles(this.fScaleTimers);

            /**
             * Instead of maintaining partial tick counts, we calculate a fresh countCurrent from countStart every
             * time we're called, using the cycle count recorded when the timer was initialized.  countStart is set
             * to countInit when fCounting is first set, and then it is refreshed from countInit at the expiration of
             * every count, so that if someone loaded a new countInit in the meantime (eg, BASICA), we'll pick it up.
             *
             * For the original MODEL_5170, the number of cycles per tick is approximately 6,000,000 / 1,193,181,
             * or 5.028575, so we can no longer always divide cycles by 4 with a simple right-shift by 2.  The proper
             * divisor (eg, 4 for MODEL_5150 and MODEL_5160, 5 for MODEL_5170, etc) is nTicksDivisor, which initBus()
             * calculates using the base CPU speed returned by cpu.getBaseCyclesPerSecond().
             */
            let ticksElapsed = ((nCycles - timer.nCyclesStart) / this.nTicksDivisor) | 0;

            if (ticksElapsed < 0) {
                if (DEBUG) this.printf(MESSAGE.TIMER, "updateTimer(%d): negative tick count (%d)\n", iTimer, ticksElapsed);
                timer.nCyclesStart = nCycles;
                ticksElapsed = 0;
            }

            let countInit = this.getTimerInit(iTimer);
            let countStart = this.getTimerStart(iTimer);

            let fFired = false;
            let count = countStart - ticksElapsed;

            /**
             * NOTE: This mode is used by ROM BIOS test code that wants to verify timer interrupts are arriving
             * neither too slowly nor too quickly.  As a result, I've had to add some corresponding trickery
             * in outTimer() to force interrupt simulation immediately after a low initial count (0x16) has been set.
             */
            if (timer.mode == ChipSet.PIT_CTRL.MODE0) {
                if (count <= 0) count = 0;
                if (DEBUG) this.printf(MESSAGE.TIMER, "updateTimer(%d): MODE0 timer count=%d\n" + iTimer, count);
                if (!count) {
                    timer.fOUT = true;
                    timer.fCounting = false;
                    if (!iTimer) {
                        fFired = true;
                        this.setIRR(ChipSet.IRQ.TIMER0);
                        if (MAXDEBUG && DEBUGGER) this.acTimersFired[iTimer]++;
                    }
                }
            }
            /**
             * Early implementation of this mode was minimal because when using this mode, the ROM BIOS simply wanted
             * to see the count changing; it wasn't looking for interrupts.  See ROM BIOS "TEST.03" code @F000:E0DE,
             * where TIMER1 is programmed for MODE2, LSB (the same settings, incidentally, used immediately afterward
             * for TIMER1 in conjunction with DMA channel 0 memory refreshes).
             *
             * Now this mode generates interrupts.  Note that OUT goes low when the count reaches 1, then high
             * one tick later, at which point the count is reloaded and counting continues.
             *
             * Chances are, we will often miss the exact point at which the count becomes 1 (or more importantly,
             * one tick later, when the count *would* become 0, since that's when OUT transitions from low to high),
             * but as with MODE3, hopefully no one will mind.
             *
             * FYI, technically, it appears that the count is never supposed to reach 0, and that an initial count of 1
             * is "illegal", whatever that means.
             */
            else if (timer.mode == ChipSet.PIT_CTRL.MODE2) {
                timer.fOUT = (count != 1);          // yes, this line does seem rather pointless....
                if (count <= 0) {
                    count = countInit + count;
                    if (count <= 0) {
                        /**
                         * TODO: Consider whether we ever care about TIMER1 or TIMER2 underflow
                         */
                        if (DEBUG && !iTimer) this.printf(MESSAGE.TIMER, "updateTimer(%d): mode=2, underflow=%d\n", iTimer, count);
                        count = countInit;
                    }
                    timer.countStart[0] = count & 0xff;
                    timer.countStart[1] = (count >> 8) & 0xff;
                    timer.nCyclesStart = nCycles;
                    if (!iTimer && timer.fOUT) {
                        fFired = true;
                        this.setIRR(ChipSet.IRQ.TIMER0);
                        if (MAXDEBUG && DEBUGGER) this.acTimersFired[iTimer]++;
                    }
                }
            }
            /**
             * NOTE: This is the normal mode for TIMER0, which the ROM BIOS uses to generate h/w interrupts roughly
             * 18.2 times per second.  In this mode, the count must be decremented twice as fast (hence the extra ticks
             * subtraction below, in addition to the subtraction above), but IRQ_TIMER0 is raised only on alternate
             * iterations; ie, only when fOUT transitions to true ("high").  The equal alternating fOUT states is why
             * this mode is referred to as "square wave" mode.
             *
             * TODO: Implement the correct behavior for this mode when the count is ODD.  In that case, fOUT is supposed
             * to be "high" for (N + 1) / 2 ticks and "low" for (N - 1) / 2 ticks.
             */
            else if (timer.mode == ChipSet.PIT_CTRL.MODE3) {
                count -= ticksElapsed;
                if (count <= 0) {
                    timer.fOUT = !timer.fOUT;
                    count = countInit + count;
                    if (count <= 0) {
                        /**
                         * TODO: Consider whether we ever care about TIMER1 or TIMER2 underflow
                         */
                        if (DEBUG && !iTimer) this.printf(MESSAGE.TIMER, "updateTimer(%d): mode=3, underflow=%d\n", iTimer, count);
                        count = countInit;
                    }
                    if (MAXDEBUG && DEBUGGER && !iTimer) {
                        let nCycleDelta = 0;
                        if (this.acTimer0Counts.length > 0) nCycleDelta = nCycles - this.acTimer0Counts[0][1];
                        this.acTimer0Counts.push([count, nCycles, nCycleDelta]);
                    }
                    timer.countStart[0] = count & 0xff;
                    timer.countStart[1] = (count >> 8) & 0xff;
                    timer.nCyclesStart = nCycles;
                    if (!iTimer && timer.fOUT) {
                        fFired = true;
                        this.setIRR(ChipSet.IRQ.TIMER0);
                        if (MAXDEBUG && DEBUGGER) this.acTimersFired[iTimer]++;
                    }
                }
            }

            if (MAXDEBUG) {
                this.printf(MESSAGE.TIMER + MESSAGE.WARNING, "TIMER%d count: %d, ticks: %d, fired: %b\n", iTimer, count, ticksElapsed, fFired);
            }

            timer.countCurrent[0] = count & 0xff;
            timer.countCurrent[1] = (count >> 8) & 0xff;
            if (fCycleReset) this.nCyclesStart = 0;
        }
        return timer;
    }

    /**
     * updateAllTimers(fCycleReset)
     *
     * @this {ChipSet}
     * @param {boolean} [fCycleReset] is true if a cycle-count reset is about to occur
     */
    updateAllTimers(fCycleReset)
    {
        for (let iTimer = 0; iTimer < this.aTimers.length; iTimer++) {
            this.updateTimer(iTimer, fCycleReset);
        }
        if (this.model >= ChipSet.MODEL_5170) this.updateRTCTime();
    }

    /**
     * outMFGTest(port, bOut, addrFrom)
     *
     * This is test port on the PCjr (MODEL_4860) only.
     *
     * @this {ChipSet}
     * @param {number} port (0x10)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined if the Debugger is trying to read the specified port)
     */
    outMFGTest(port, bOut, addrFrom)
    {
        this.printIO(port, bOut, addrFrom, "MFG_TEST");
    }

    /**
     * inPPIA(port, addrFrom)
     *
     * @this {ChipSet}
     * @param {number} port (0x60)
     * @param {number} [addrFrom] (not defined if the Debugger is trying to read the specified port)
     * @returns {number} simulated port value
     */
    inPPIA(port, addrFrom)
    {
        let b = this.bPPIA;
        if (this.bPPICtrl & ChipSet.PPI_CTRL.A_IN) {
            if (this.bPPIB & ChipSet.PPI_B.CLEAR_KBD) {
                b = this.aDIPSwitches[0][1];
            } else {
                b = this.bKbdData;
                this.printIO(port, undefined, addrFrom, "PPI_A", b, MESSAGE.KBD);
                return b;
            }
        }
        this.printIO(port, undefined, addrFrom, "PPI_A", b);
        return b;
    }

    /**
     * outPPIA(port, bOut, addrFrom)
     *
     * @this {ChipSet}
     * @param {number} port (0x60)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined if the Debugger is trying to read the specified port)
     */
    outPPIA(port, bOut, addrFrom)
    {
        this.printIO(port, bOut, addrFrom, "PPI_A");
        this.bPPIA = bOut;
    }

    /**
     * inPPIB(port, addrFrom)
     *
     * @this {ChipSet}
     * @param {number} port (0x61)
     * @param {number} [addrFrom] (not defined if the Debugger is trying to read the specified port)
     * @returns {number} simulated port value
     */
    inPPIB(port, addrFrom)
    {
        let b = this.bPPIB;
        this.printIO(port, undefined, addrFrom, "PPI_B", b);
        return b;
    }

    /**
     * outPPIB(port, bOut, addrFrom)
     *
     * This is the original (MODEL_5150 and MODEL_5160) handler for port 0x61.  Functionality common
     * to all models must be placed in updatePPIB().
     *
     * @this {ChipSet}
     * @param {number} port (0x61)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined if the Debugger is trying to read the specified port)
     */
    outPPIB(port, bOut, addrFrom)
    {
        this.printIO(port, bOut, addrFrom, "PPI_B");
        this.updatePPIB(bOut);
    }

    /**
     * updatePPIB(bOut)
     *
     * On MODEL_5170 and up, this updates the "simulated" PPI_B.  The only common (and well-documented) PPI_B bits
     * across all models are PPI_B.CLK_TIMER2 and PPI_B.SPK_TIMER2, so its possible that this function may need to
     * limit its updates to just those bits, and move any model-specific requirements back into the appropriate I/O
     * handlers (PPIB or 8042RWReg).  We'll see.
     *
     * UPDATE: The WOLF3D keyboard interrupt handler toggles the CLEAR_KBD bit of port 0x61 (ie, it sets and then
     * clears the bit) after reading the scan code from port 0x60; assuming that they use the same interrupt handler
     * for all machine models (which I haven't verified), the clear implication is that updatePPIB() also needs to
     * support CLEAR_KBD and CLK_KBD, so I've moved that code from outPPIB() to updatePPIB().
     *
     * @this {ChipSet}
     * @param {number} bOut
     */
    updatePPIB(bOut)
    {
        let toggled = (bOut ^ this.bPPIB);
        if (toggled & ChipSet.PPI_B.CLK_TIMER2) {
            /**
             * If TIMER2 is about to be "declocked", then we should update the timer NOW, because any attempt to read
             * timer's count AFTER it has been declocked will not trigger an update.  This was a problem for the following
             * code in SUPERPCK.EXE from DR DOS 6.00:
             *
             *      &10AE:C863 E461             IN       AL,61
             *      &10AE:C865 24FC             AND      AL,FC
             *      &10AE:C867 8AE0             MOV      AH,AL
             *      &10AE:C869 E661             OUT      61,AL              ; PPI_B: disable CLK_TIMER2 and SPK_TIMER2
             *      &10AE:C86B B0B4             MOV      AL,B4
             *      &10AE:C86D E643             OUT      43,AL              : PIT_CTRL: MODE2, RW_BOTH, SC_CTR2
             *      &10AE:C86F 32C0             XOR      AL,AL
             *      &10AE:C871 E642             OUT      42,AL
             *      &10AE:C873 EB00             JMP      C875 (SUPERPCK.EXE+0x745B)
             *      &10AE:C875 E642             OUT      42,AL
             *      &10AE:C877 B90010           MOV      CX,1000
             *      &10AE:C87A 8AC4             MOV      AL,AH
             *      &10AE:C87C 0C01             OR       AL,01
             *      &10AE:C87E E661             OUT      61,AL              ; PPI_B: enable CLK_TIMER2
             *      &10AE:C880 E2FE             LOOP     C880 (SUPERPCK.EXE+0x7469)
             *      &10AE:C882 8AC4             MOV      AL,AH
             *      &10AE:C884 E661             OUT      61,AL              ; PPI_B: disable CLK_TIMER2 again
             *      &10AE:C886 E442             IN       AL,42              ; PIT_TIMER2: read count (without, um, latching)
             *      &10AE:C888 8AE0             MOV      AH,AL
             *      &10AE:C88A E442             IN       AL,42
             *      &10AE:C88C 86C4             XCHG     AL,AH
             *      &10AE:C88E F7D8             NEG      AX
             *      &10AE:C890 8BD8             MOV      BX,AX
             *      &10AE:C892 B80010           MOV      AX,1000
             *      &10AE:C895 33D2             XOR      DX,DX
             *      &10AE:C897 F7F3             DIV      BX                 ; potential divide-by-zero if TIMER2 count was zero
             *
             * Another interesting but unrelated problem is that DR DOS's divide-by-zero exception handler was pointing
             * to 0F71:258C at this point, which contained invalid code.  The code was valid when the handler was first set,
             * but it was later discarded or relocated and then overwritten.
             */
            if (!(bOut & ChipSet.PPI_B.CLK_TIMER2)) {
                this.updateTimer(ChipSet.PIT0.TIMER2);
            }
        }
        this.bPPIB = bOut;
        if (toggled & ChipSet.PPI_B.SPK_TIMER2) {
            /**
             * Originally, this code didn't catch the "ERROR_BEEP" case @F000:EC34, which first turns both PPI_B.CLK_TIMER2 (0x01)
             * and PPI_B.SPK_TIMER2 (0x02) off, then turns on only PPI_B.SPK_TIMER2 (0x02), then restores the original port value.
             *
             * So, when the ROM BIOS keyboard buffer got full, we didn't issue a BEEP alert.  I've fixed that by limiting the test
             * to PPI_B.SPK_TIMER2 and ignoring PPI_B.CLK_TIMER2.
             */
            this.setSpeaker(bOut & ChipSet.PPI_B.SPK_TIMER2);
        }
        if (this.kbd) this.kbd.setEnabled(!(bOut & ChipSet.PPI_B.CLEAR_KBD), !!(bOut & ChipSet.PPI_B.CLK_KBD));
    }

    /**
     * inPPIC(port, addrFrom)
     *
     * @this {ChipSet}
     * @param {number} port (0x62)
     * @param {number} [addrFrom] (not defined if the Debugger is trying to read the specified port)
     * @returns {number} simulated port value
     */
    inPPIC(port, addrFrom)
    {
        let b = 0;

        /**
         * If you ever wanted to simulate I/O channel errors or R/W memory parity errors, you could
         * add either PPI_C.IO_CHANNEL_CHK (0x40) or PPI_C.RW_PARITY_CHK (0x80) to the return value (b).
         */
        if ((this.model|0) == ChipSet.MODEL_4860) {
            b |= this.bNMI & ChipSet.NMI.KBD_LATCH;
            /**
             * We're going to hard-code the rest of the PCjr settings for now, including NOT setting the NO_KBD_CABLE
             * bit, on the theory that if we don't have to deal with IR hardware emulation, so much the better.
             */
            b |= ChipSet.PPI_C.NO_MODEM | ChipSet.PPI_C.NO_DISKETTE | ChipSet.PPI_C.NO_MEMEXP;
            /**
             * I'm just guessing at how keyboard data is "clocked" into the the KBD_DATA bit; this will be revisited.
             */
            b |= (this.bKbdData & 0x1)? ChipSet.PPI_C.KBD_DATA : 0;
            this.bKbdData >>>= 1;
        }
        else if ((this.model|0) == ChipSet.MODEL_5150) {
            if (this.bPPIB & ChipSet.PPI_B.ENABLE_SW2) {
                b |= this.aDIPSwitches[1][1] & ChipSet.PPI_C.SW;
            } else {
                b |= (this.aDIPSwitches[1][1] >> 4) & 0x1;
            }
        } else {
            if (this.bPPIB & ChipSet.PPI_B.ENABLE_SW_HI) {
                b |= this.aDIPSwitches[0][1] >> 4;
            } else {
                b |= this.aDIPSwitches[0][1] & 0xf;
            }
        }

        if (this.bPPIB & ChipSet.PPI_B.CLK_TIMER2) {
            let timer = this.updateTimer(ChipSet.PIT0.TIMER2);
            if (timer.fOUT) {
                if (this.bPPIB & ChipSet.PPI_B.SPK_TIMER2) {
                    b |= ChipSet.PPI_C.TIMER2_OUT;
                } else {
                    b |= ChipSet.PPI_C.CASS_DATA_IN;
                }
            }
        }

        /**
         * The ROM BIOS polls this port incessantly during its memory tests, checking for memory parity errors
         * (which of course we never report), so you must use both MESSAGE.PORT and MESSAGE.CHIPSET.
         */
        this.printIO(port, undefined, addrFrom, "PPI_C", b, MESSAGE.CHIPSET);
        return b;
    }

    /**
     * outPPIC(port, bOut, addrFrom)
     *
     * @this {ChipSet}
     * @param {number} port (0x62)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined if the Debugger is trying to read the specified port)
     */
    outPPIC(port, bOut, addrFrom)
    {
        this.printIO(port, bOut, addrFrom, "PPI_C");
        this.bPPIC = bOut;
    }

    /**
     * inPPICtrl(port, addrFrom)
     *
     * @this {ChipSet}
     * @param {number} port (0x63)
     * @param {number} [addrFrom] (not defined if the Debugger is trying to read the specified port)
     * @returns {number} simulated port value
     */
    inPPICtrl(port, addrFrom)
    {
        let b = this.bPPICtrl;
        this.printIO(port, undefined, addrFrom, "PPI_CTRL", b);
        return b;
    }

    /**
     * outPPICtrl(port, bOut, addrFrom)
     *
     * @this {ChipSet}
     * @param {number} port (0x63)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined if the Debugger is trying to write the specified port)
     */
    outPPICtrl(port, bOut, addrFrom)
    {
        this.printIO(port, bOut, addrFrom, "PPI_CTRL");
        this.bPPICtrl = bOut;
    }

    /**
     * in8041Kbd(port, addrFrom)
     *
     * @this {ChipSet}
     * @param {number} port (0x60)
     * @param {number} [addrFrom] (not defined if the Debugger is trying to read the specified port)
     * @returns {number} simulated port value
     */
    in8041Kbd(port, addrFrom)
    {
        let b = this.bKbdData;
        this.printIO(port, undefined, addrFrom, "8041_KBD", b, MESSAGE.KBD);
        this.b8041Status &= ~ChipSet.C8042.STATUS.OUTBUFF_FULL;
        return b;
    }

    /**
     * out8041Kbd(port, bOut, addrFrom)
     *
     * @this {ChipSet}
     * @param {number} port (0x60)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined if the Debugger is trying to read the specified port)
     */
    out8041Kbd(port, bOut, addrFrom)
    {
        this.printIO(port, bOut, addrFrom, "8041_KBD");
        // if (this.kbd) this.kbd.receiveCmd(bOut);
    }

    /**
     * in8041Ctrl(port, addrFrom)
     *
     * @this {ChipSet}
     * @param {number} port (0x61)
     * @param {number} [addrFrom] (not defined if the Debugger is trying to read the specified port)
     * @returns {number} simulated port value
     */
    in8041Ctrl(port, addrFrom)
    {
        let b = this.bPPIB;
        this.printIO(port, undefined, addrFrom, "8041_CTRL", b);
        return b;
    }

    /**
     * out8041Ctrl(port, bOut, addrFrom)
     *
     * @this {ChipSet}
     * @param {number} port (0x61)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined if the Debugger is trying to read the specified port)
     */
    out8041Ctrl(port, bOut, addrFrom)
    {
        this.printIO(port, bOut, addrFrom, "8041_CTRL");
        this.updatePPIB(bOut);
    }

    /**
     * in8041Status(port, addrFrom)
     *
     * @this {ChipSet}
     * @param {number} port (0x64)
     * @param {number} [addrFrom] (not defined if the Debugger is trying to read the specified port)
     * @returns {number} simulated port value
     */
    in8041Status(port, addrFrom)
    {
        let b = this.b8041Status;
        this.printIO(port, undefined, addrFrom, "8041_STATUS", b);
        return b;
    }

    /**
     * in8042OutBuff(port, addrFrom)
     *
     * Return the contents of the OUTBUFF register and clear the OUTBUFF_FULL status bit.
     *
     * Moreover, we also call kbd.checkBuffer() to let the Keyboard know that we just pulled
     * data, so that it can reset its internal timer controlling the delivery of additional data.
     *
     * Note that there are applications like BASICA that install a keyboard interrupt handler
     * that reads OUTBUFF, does some scan code preprocessing, and then passes control on to the
     * ROM's interrupt handler.  As a result, OUTBUFF is read multiple times during a single
     * interrupt, so we need to avoid filling it with new data after every read; otherwise,
     * scan codes will get dropped.
     *
     * The safest thing to do is to wait until kbd.setEnabled() is called, and let that call supply
     * more data to receiveKbdData().  That will happen as soon as the ROM re-enables the controller,
     * and is why C8042.CMD.ENABLE_KBD processing ends with a call to kbd.checkBuffer().  However,
     * not all software (eg, Xenix 286, and the Windows 95 VMM) does that, so we have to rely on
     * the Keyboard's internal timer.
     *
     * Also note that, the foregoing notwithstanding, I still clear the OUTBUFF_FULL bit here
     * (as I believe I should); fortunately, none of the interrupt handlers I've seen rely on
     * OUTBUFF_FULL as a prerequisite for reading OUTBUFF (certainly not BASICA or the ROM).
     * The assumption seems to be that if an interrupt occurred, OUTBUFF must contain data,
     * regardless of the state of OUTBUFF_FULL.
     *
     * @this {ChipSet}
     * @param {number} port (0x60)
     * @param {number} [addrFrom] (not defined if the Debugger is trying to read the specified port)
     * @returns {number} simulated port value
     */
    in8042OutBuff(port, addrFrom)
    {
        let b = this.b8042OutBuff;
        this.printIO(port, undefined, addrFrom, "8042_OUTBUFF", b, MESSAGE.C8042);
        this.b8042Status &= ~(ChipSet.C8042.STATUS.OUTBUFF_FULL | ChipSet.C8042.STATUS.OUTBUFF_DELAY);
        if (this.kbd) this.kbd.checkBuffer(b);
        return b;
    }

    /**
     * out8042InBuffData(port, bOut, addrFrom)
     *
     * This writes to the 8042's input buffer; using this port (ie, 0x60 instead of 0x64) designates the
     * the byte as a C8042.DATA.CMD "data byte".  Before clearing C8042.STATUS.CMD_FLAG, however, we see if it's set,
     * and then based on the previous C8042.CMD "command byte", we do whatever needs to be done with this "data byte".
     *
     * @this {ChipSet}
     * @param {number} port (0x60)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined if the Debugger is trying to write the specified port)
     */
    out8042InBuffData(port, bOut, addrFrom)
    {
        this.printIO(port, bOut, addrFrom, "8042_INBUF.DATA", undefined, MESSAGE.C8042);

        if (this.b8042Status & ChipSet.C8042.STATUS.CMD_FLAG) {

            switch (this.b8042InBuff) {

            case ChipSet.C8042.CMD.WRITE_CMD:
                this.set8042CmdData(bOut);
                break;

            case ChipSet.C8042.CMD.WRITE_OUTPORT:
                this.set8042OutPort(bOut);
                break;

            /**
             * This case is reserved for command bytes that the 8042 is not expecting, which should therefore be passed
             * on to the Keyboard itself.
             *
             * Here's some relevant MODEL_5170 ROM BIOS code, "XMIT_8042" (missing from the original MODEL_5170 ROM BIOS
             * listing), which sends a command code in AL to the Keyboard and waits for a response, returning it in AL.
             * Note that the only "success" exit path from this function involves LOOPing 64K times before finally reading
             * the Keyboard's response; either the hardware and/or this code seems a bit brain-damaged if that's REALLY
             * what you had to do to ensure a valid response....
             *
             *      F000:1B25 86E0          XCHG     AH,AL
             *      F000:1B27 2BC9          SUB      CX,CX
             *      F000:1B29 E464          IN       AL,64
             *      F000:1B2B A802          TEST     AL,02      ; WAIT FOR INBUFF_FULL TO BE CLEAR
             *      F000:1B2D E0FA          LOOPNZ   1B29
             *      F000:1B2F E334          JCXZ     1B65       ; EXIT WITH ERROR (CX == 0)
             *      F000:1B31 86E0          XCHG     AH,AL
             *      F000:1B33 E660          OUT      60,AL      ; SAFE TO WRITE KEYBOARD CMD TO INBUFF NOW
             *      F000:1B35 2BC9          SUB      CX,CX
             *      F000:1B37 E464          IN       AL,64
             *      F000:1B39 8AE0          MOV      AH,AL
             *      F000:1B3B A801          TEST     AL,01
             *      F000:1B3D 7402          JZ       1B41
             *      F000:1B3F E460          IN       AL,60      ; READ PORT 0x60 IF OUTBUFF_FULL SET ("FLUSH"?)
             *      F000:1B41 F6C402        TEST     AH,02
             *      F000:1B44 E0F1          LOOPNZ   1B37
             *      F000:1B46 751D          JNZ      1B65       ; EXIT WITH ERROR (CX == 0)
             *      F000:1B48 B306          MOV      BL,06
             *      F000:1B4A 2BC9          SUB      CX,CX
             *      F000:1B4C E464          IN       AL,64
             *      F000:1B4E A801          TEST     AL,01
             *      F000:1B50 E1FA          LOOPZ    1B4C
             *      F000:1B52 7508          JNZ      1B5C       ; PROCEED TO EXIT NOW THAT OUTBUFF_FULL IS SET
             *      F000:1B54 FECB          DEC      BL
             *      F000:1B56 75F4          JNZ      1B4C
             *      F000:1B58 FEC3          INC      BL
             *      F000:1B5A EB09          JMP      1B65       ; EXIT WITH ERROR (CX == 0)
             *      F000:1B5C 2BC9          SUB      CX,CX
             *      F000:1B5E E2FE          LOOP     1B5E       ; LOOOOOOPING....
             *      F000:1B60 E460          IN       AL,60
             *      F000:1B62 83E901        SUB      CX,0001    ; EXIT WITH SUCCESS (CX != 0)
             *      F000:1B65 C3            RET
             *
             * But WAIT, the FUN doesn't end there.  After this function returns, "KBD_RESET" waits for a Keyboard
             * interrupt to occur, hoping for scan code 0xAA as the Keyboard's final response.  "KBD_RESET" also returns
             * CX to the caller, and the caller ("TEST.21") assumes there was no interrupt if CX is zero.
             *
             *              MOV     AL,0FDH
             *              OUT     INTA01,AL
             *              MOV     INTR_FLAG,0
             *              STI
             *              MOV     BL,10
             *              SUB     CX,CX
             *      G11:    TEST    [1NTR_FLAG],02H
             *              JNZ     G12
             *              LOOP    G11
             *              DEC     BL
             *              JNZ     G11
             *              ...
             *
             * However, if [INTR_FLAG] is set immediately, the above code will exit immediately, without ever decrementing
             * CX.  CX can be zero not only if the loop exhausted it, but also if no looping was required; the latter is not
             * an error, but "TEST.21" assumes that it is.
             */
            default:
                this.set8042CmdData(this.b8042CmdData & ~ChipSet.C8042.DATA.CMD.NO_CLOCK);
                if (this.kbd) this.set8042OutBuff(this.kbd.receiveCmd(bOut));
                break;
            }
        }
        this.b8042InBuff = bOut;
        this.b8042Status &= ~ChipSet.C8042.STATUS.CMD_FLAG;
    }

    /**
     * in8042RWReg(port, addrFrom)
     *
     * @this {ChipSet}
     * @param {number} port (0x61)
     * @param {number} [addrFrom] (not defined if the Debugger is trying to read the specified port)
     * @returns {number} simulated port value
     */
    in8042RWReg(port, addrFrom)
    {
        /**
         * Normally, we return whatever was last written to this port, but we do need to mask the
         * two upper-most bits (C8042.RWREG.NMI_ERROR), as those are output-only bits used to signal
         * parity errors.
         *
         * Also, "TEST.09" of the MODEL_5170 BIOS expects the REFRESH_BIT to alternate, so we used to
         * do this:
         *
         *      this.bPPIB ^= ChipSet.C8042.RWREG.REFRESH_BIT;
         *
         * However, the MODEL_5170_REV3 BIOS not only checks REFRESH_BIT in "TEST.09", but includes
         * an additional test right before "TEST.11A", which requires the bit change "a bit less"
         * frequently.  This new test sets CX to zero, and at the end of the test (@F000:05B8), CX
         * must be in the narrow range of 0xF600 through 0xF9FD.
         *
         * In fact, the new "WAITF" function @F000:1A3A tells us exactly how frequently REFRESH_BIT
         * is expected to change now.  That function performs a "FIXED TIME WAIT", where CX is a
         * "COUNT OF 15.085737us INTERVALS TO WAIT".
         *
         * So we now tie the state of the REFRESH_BIT to bit 6 of the current CPU cycle count,
         * effectively toggling the bit after every 64 cycles.  On an 8Mhz CPU that can do 8 cycles
         * in 1us, 64 cycles represents 8us, so that might be a bit fast for "WAITF", but bit 6
         * is the only choice that also satisfies the pre-"TEST.11A" test as well.
         */
        let b = this.bPPIB & ~(ChipSet.C8042.RWREG.NMI_ERROR | ChipSet.C8042.RWREG.REFRESH_BIT) | ((this.cpu.getCycles() & 0x40)? ChipSet.C8042.RWREG.REFRESH_BIT : 0);
        /**
         * Thanks to the WAITF function, this has become a very "busy" port, so if this generates too
         * many messages, try adding MESSAGE.WARNING to the criteria.
         */
        this.printIO(port, undefined, addrFrom, "8042_RWREG", b, MESSAGE.C8042 + MESSAGE.WARNING);
        return b;
    }

    /**
     * out8042RWReg(port, bOut, addrFrom)
     *
     * @this {ChipSet}
     * @param {number} port (0x61)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined if the Debugger is trying to read the specified port)
     */
    out8042RWReg(port, bOut, addrFrom)
    {
        this.printIO(port, bOut, addrFrom, "8042_RWREG", undefined, MESSAGE.C8042);
        this.updatePPIB(bOut);
    }

    /**
     * in8042Status(port, addrFrom)
     *
     * @this {ChipSet}
     * @param {number} port (0x64)
     * @param {number} [addrFrom] (not defined if the Debugger is trying to read the specified port)
     * @returns {number} simulated port value
     */
    in8042Status(port, addrFrom)
    {
        this.printIO(port, undefined, addrFrom, "8042_STATUS", this.b8042Status, MESSAGE.C8042);
        let b = this.b8042Status & 0xff;
        /**
         * There's code in the 5170 BIOS (F000:03BF) that writes an 8042 command (0xAA), waits for
         * C8042.STATUS.INBUFF_FULL to go clear (which it always is, because we always accept commands
         * immediately), then checks C8042.STATUS.OUTBUFF_FULL and performs a "flush" on port 0x60 if
         * it's set, then waits for C8042.STATUS.OUTBUFF_FULL *again*.  Unfortunately, the "flush" throws
         * away our response if we respond immediately.
         *
         * So now when out8042InBuffCmd() has a response, it sets C8042.STATUS.OUTBUFF_DELAY instead
         * (which is outside the 0xff range of bits we return); when we see C8042.STATUS.OUTBUFF_DELAY,
         * we clear it and set C8042.STATUS.OUTBUFF_FULL, which will be returned on the next read.
         *
         * This provides a single poll delay, so that the aforementioned "flush" won't toss our response.
         * If longer delays are needed down the road, we may need to set a delay count in the upper (unused)
         * bits of b8042Status, instead of using a single delay bit.
         */
        if (this.b8042Status & ChipSet.C8042.STATUS.OUTBUFF_DELAY) {
            this.b8042Status |= ChipSet.C8042.STATUS.OUTBUFF_FULL;
            this.b8042Status &= ~ChipSet.C8042.STATUS.OUTBUFF_DELAY;
        }
        /**
         * I added this for Windows 95's VMM keyboard driver for DOS sessions, which differs from the keyboard
         * driver for protected-mode applications (see the keyboard's setEnabled() function for more details).
         *
         * The Windows 95 VMM driver doesn't do what EITHER the ROM or the protected-mode driver typically does
         * after receiving a scan code (ie, toggle the keyboard's enable state).  Instead, the VMM simply checks
         * this status port one more time, perhaps to confirm that the OUTBUFF_FULL bit is clear.  It then
         * expects another keyboard interrupt to arrive when the next scan code is available.  Very minimalistic.
         */
        if (!(this.b8042Status & ChipSet.C8042.STATUS.OUTBUFF_FULL) && this.kbd) {
            this.kbd.checkBuffer();
        }
        return b;
    }

    /**
     * out8042InBuffCmd(port, bOut, addrFrom)
     *
     * This writes to the 8042's input buffer; using this port (ie, 0x64 instead of 0x60) designates the
     * the byte as a "command byte".  We immediately set C8042.STATUS.CMD_FLAG, and then see if we can act upon
     * the command immediately (some commands requires us to wait for a "data byte").
     *
     * @this {ChipSet}
     * @param {number} port (0x64)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined if the Debugger is trying to write the specified port)
     */
    out8042InBuffCmd(port, bOut, addrFrom)
    {
        this.printIO(port, bOut, addrFrom, "8042_INBUFF.CMD", undefined, MESSAGE.C8042);

        this.b8042InBuff = bOut;

        this.b8042Status |= ChipSet.C8042.STATUS.CMD_FLAG;

        let bPulseBits = 0;
        if (this.b8042InBuff >= ChipSet.C8042.CMD.PULSE_OUTPORT) {
            bPulseBits = (this.b8042InBuff ^ 0xf);
            /**
             * Now that we have isolated the bit(s) to pulse, map all pulse commands to C8042.CMD.PULSE_OUTPORT
             */
            this.b8042InBuff = ChipSet.C8042.CMD.PULSE_OUTPORT;
        }

        switch (this.b8042InBuff) {
        case ChipSet.C8042.CMD.READ_CMD:        // 0x20
            this.set8042OutBuff(this.b8042CmdData);
            break;

        case ChipSet.C8042.CMD.WRITE_CMD:       // 0x60
            /**
             * No further action required for this command; more data is expected via out8042InBuffData()
             */
            break;

        case ChipSet.C8042.CMD.DISABLE_KBD:     // 0xAD
            this.set8042CmdData(this.b8042CmdData | ChipSet.C8042.DATA.CMD.NO_CLOCK);
            if (!COMPILED) this.printf(MESSAGE.KBD + MESSAGE.PORT, "keyboard disabled\n");
            /**
             * NOTE: The MODEL_5170 BIOS calls "KBD_RESET" (F000:17D2) while the keyboard interface is disabled,
             * yet we must still deliver the Keyboard's CMDRES.BAT_OK response code?  Seems like an odd thing for
             * a "disabled interface" to do.
             */
            break;

        case ChipSet.C8042.CMD.ENABLE_KBD:      // 0xAE
            this.set8042CmdData(this.b8042CmdData & ~ChipSet.C8042.DATA.CMD.NO_CLOCK);
            if (!COMPILED) this.printf(MESSAGE.KBD + MESSAGE.PORT, "keyboard re-enabled\n");
            if (this.kbd) this.kbd.checkBuffer();
            break;

        case ChipSet.C8042.CMD.SELF_TEST:       // 0xAA
            if (this.kbd) this.kbd.flushBuffer();
            this.set8042CmdData(this.b8042CmdData | ChipSet.C8042.DATA.CMD.NO_CLOCK);
            if (!COMPILED) this.printf(MESSAGE.KBD + MESSAGE.PORT, "keyboard disabled on reset\n");
            this.set8042OutBuff(ChipSet.C8042.DATA.SELF_TEST.OK);
            this.set8042OutPort(ChipSet.C8042.OUTPORT.NO_RESET | ChipSet.C8042.OUTPORT.A20_ON);
            break;

        case ChipSet.C8042.CMD.INTF_TEST:       // 0xAB
            /**
             * TODO: Determine all the side-effects of the Interface Test, if any.
             */
            this.set8042OutBuff(ChipSet.C8042.DATA.INTF_TEST.OK);
            break;

        case ChipSet.C8042.CMD.READ_INPORT:     // 0xC0
            this.set8042OutBuff(this.b8042InPort);
            break;

        case ChipSet.C8042.CMD.READ_OUTPORT:    // 0xD0
            this.set8042OutBuff(this.b8042OutPort);
            break;

        case ChipSet.C8042.CMD.WRITE_OUTPORT:   // 0xD1
            /**
             * No further action required for this command; more data is expected via out8042InBuffData()
             */
            break;

        case ChipSet.C8042.CMD.READ_TEST:       // 0xE0
            this.set8042OutBuff((this.b8042CmdData & ChipSet.C8042.DATA.CMD.NO_CLOCK)? 0 : ChipSet.C8042.TESTPORT.KBD_CLOCK);
            break;

        case ChipSet.C8042.CMD.PULSE_OUTPORT:   // 0xF0-0xFF
            if (bPulseBits & 0x1) {
                /**
                 * Bit 0 of the 8042's output port is connected to RESET.  If it's pulsed, the processor resets.
                 * We don't want to clear *all* CPU state (eg, cycle counts), so we call cpu.resetRegs() instead
                 * of cpu.reset().
                 */
                this.cpu.resetRegs();
            }
            break;

        default:
            if (!COMPILED) {
                this.printf(MESSAGE.LOG, "unrecognized 8042 command: %#04X\n", this.b8042InBuff);
                // if (this.dbg) this.dbg.stopCPU();
            }
            break;
        }
    }

    /**
     * set8042CmdData(b)
     *
     * @this {ChipSet}
     * @param {number} b
     */
    set8042CmdData(b)
    {
        this.b8042CmdData = b;

        this.b8042Status = (this.b8042Status & ~ChipSet.C8042.STATUS.SYS_FLAG) | (b & ChipSet.C8042.DATA.CMD.SYS_FLAG);
        if (this.kbd) {
            /**
             * This seems to be what the doctor ordered for the MODEL_5170_REV3 BIOS @F000:0A6D, where it
             * sends ChipSet.C8042.CMD.WRITE_CMD to port 0x64, followed by 0x4D to port 0x60, which clears NO_CLOCK
             * and enables the keyboard.  The BIOS then waits for OUTBUFF_FULL to be set, at which point it seems
             * to be anticipating an 0xAA response in the output buffer.
             *
             * And indeed, if we call the original MODEL_5150/MODEL_5160 setEnabled() Keyboard interface here,
             * and both the data and clock lines have transitioned high (ie, both parameters are true), then it
             * will call resetDevice(), generating a Keyboard.CMDRES.BAT_OK response.
             *
             * This agrees with my understanding of what happens when the 8042 toggles the clock line high
             * (ie, clears NO_CLOCK): the TechRef's "Basic Assurance Test" section says that when the Keyboard is
             * powered on, it performs the BAT, and then when the clock and data lines go high, the keyboard sends
             * a completion code (eg, 0xAA for success, or 0xFC or something else for failure).
             */
            this.kbd.setEnabled(!!(b & ChipSet.C8042.DATA.CMD.NO_INHIBIT), !(b & ChipSet.C8042.DATA.CMD.NO_CLOCK));
        }
    }

    /**
     * set8042OutBuff(b, fNoDelay)
     *
     * The 5170 ROM BIOS assumed there would be a slight delay after certain 8042 commands, like SELF_TEST
     * (0xAA), before there was an OUTBUFF response; in fact, there is BIOS code that will fail without such
     * a delay.  This is discussed in greater detail in in8042Status().
     *
     * So we default to a "single poll" delay, setting OUTBUFF_DELAY instead of OUTBUFF_FULL, unless the caller
     * explicitly asks for no delay.  The fNoDelay parameter was added later, so that receiveKbdData() could
     * request immediate delivery of keyboard scan codes, because some operating systems (eg, Microport's 1986
     * version of Unix for PC AT machines) poll the status port only once, immediately giving up if no data is
     * available.
     *
     * TODO: Determine if we should invert the fNoDelay default (from false to true) and delay only in specific
     * cases; ie, perhaps only the SELF_TEST command required a delay.
     *
     * @this {ChipSet}
     * @param {number} b
     * @param {boolean} [fNoDelay]
     */
    set8042OutBuff(b, fNoDelay)
    {
        if (b >= 0) {
            this.b8042OutBuff = b;
            if (fNoDelay) {
                this.b8042Status |= ChipSet.C8042.STATUS.OUTBUFF_FULL;
            } else {
                this.b8042Status &= ~ChipSet.C8042.STATUS.OUTBUFF_FULL;
                this.b8042Status |= ChipSet.C8042.STATUS.OUTBUFF_DELAY;
            }
            if (!COMPILED) this.printf(MESSAGE.KBD + MESSAGE.PORT, "chipset.set8042OutBuff(%#04X,delay=%b)\n", b, !fNoDelay);
        }
    }

    /**
     * set8042OutPort(b)
     *
     * When ChipSet.C8042.CMD.WRITE_OUTPORT (0xD1) is written to port 0x64, the next byte written to port 0x60 comes here,
     * to the KBC's OUTPORT.  One of the most important bits in the OUTPORT is the A20_ON bit (0x02): set it to turn A20 on,
     * clear it to turn A20 off.
     *
     * @this {ChipSet}
     * @param {number} b
     */
    set8042OutPort(b)
    {
        this.b8042OutPort = b;

        this.bus.setA20(!!(b & ChipSet.C8042.OUTPORT.A20_ON));

        if (!(b & ChipSet.C8042.OUTPORT.NO_RESET)) {
            /**
             * Bit 0 of the 8042's output port is connected to RESET.  Normally, it's "pulsed" with the
             * C8042.CMD.PULSE_OUTPORT command, so if a RESET is detected via this command, we should try to
             * determine if that's what the caller intended.
             */
            if (!COMPILED) {
                this.printf(MESSAGE.NONE, "unexpected 8042 output port reset: %#04X\n", b);
                if (this.dbg) this.dbg.stopCPU();
            }
            this.cpu.resetRegs();
        }
    }

    /**
     * receiveKbdData(b)
     *
     * In the old days of PCx86, the Keyboard component would simply call setIRR() when it had some data for the
     * keyboard controller.  However, the Keyboard's sole responsibility is to emulate an actual keyboard and call
     * receiveKbdData() whenever it has some data; it's not allowed to mess with IRQ lines.
     *
     * If there's an 8042, we check (this.b8042CmdData & ChipSet.C8042.DATA.CMD.NO_CLOCK); if NO_CLOCK is clear,
     * we can raise the IRQ immediately.  Well, not quite immediately....
     *
     * Notes regarding the MODEL_5170 (eg, /devices/pc/machine/5170/ega/1152kb/rev3/machine.xml):
     *
     * The "Rev3" BIOS, dated 11-Nov-1985, contains the following code in the keyboard interrupt handler at K26A:
     *
     *      F000:3704 FA            CLI
     *      F000:3705 B020          MOV      AL,20
     *      F000:3707 E620          OUT      20,AL
     *      F000:3709 B0AE          MOV      AL,AE
     *      F000:370B E88D02        CALL     SHIP_IT
     *      F000:370E FA            CLI                     <-- window of opportunity
     *      F000:370F 07            POP      ES
     *      F000:3710 1F            POP      DS
     *      F000:3711 5F            POP      DI
     *      F000:3712 5E            POP      SI
     *      F000:3713 5A            POP      DX
     *      F000:3714 59            POP      CX
     *      F000:3715 5B            POP      BX
     *      F000:3716 58            POP      AX
     *      F000:3717 5D            POP      BP
     *      F000:3718 CF            IRET
     *
     * and SHIP_IT looks like this:
     *
     *      F000:399B 50            PUSH     AX
     *      F000:399C FA            CLI
     *      F000:399D 2BC9          SUB      CX,CX
     *      F000:399F E464          IN       AL,64
     *      F000:39A1 A802          TEST     AL,02
     *      F000:39A3 E0FA          LOOPNZ   399F
     *      F000:39A5 58            POP      AX
     *      F000:39A6 E664          OUT      64,AL
     *      F000:39A8 FB            STI
     *      F000:39A9 C3            RET
     *
     * This code *appears* to be trying to ensure that another keyboard interrupt won't occur until after the IRET,
     * but sadly, it looks to me like the CLI following the call to SHIP_IT is too late.  SHIP_IT should have been
     * written with PUSHF/CLI and POPF intro/outro sequences, thereby honoring the first CLI at the top of K26A and
     * eliminating the need for the second CLI (@F000:370E).
     *
     * Of course, in "real life", this was probably never a problem, because the 8042 probably wasn't fast enough to
     * generate another interrupt so soon after receiving the ChipSet.C8042.CMD.ENABLE_KBD command.  In my case, I ran
     * into this problem by 1) turning on "kbd" Debugger messages and 2) rapidly typing lots of keys.  The Debugger
     * messages bogged the machine down enough for me to hit the "window of opportunity", generating this message in
     * PC-DOS 3.20:
     *
     *      "FATAL: Internal Stack Failure, System Halted."
     *
     * and halting the system @0070:0923 (JMP 0923).
     *
     * That wasn't the only spot in the BIOS where I hit this problem; here's another "window of opportunity":
     *
     *      F000:3975 FA            CLI
     *      F000:3976 B020          MOV      AL,20
     *      F000:3978 E620          OUT      20,AL
     *      F000:397A B0AE          MOV      AL,AE
     *      F000:397C E81C00        CALL     SHIP_IT
     *      F000:397F B80291        MOV      AX,9102        <-- window of opportunity
     *      F000:3982 CD15          INT      15
     *      F000:3984 80269600FC    AND      [0096],FC
     *      F000:3989 E982FD        JMP      370E
     *
     * In this second, lengthier, example, I counted about 60 instructions being executed from the EOI @F000:3978 to
     * the final IRET @F000:3718, most of them in the INT 0x15 handler.  So, I'm going to double that count to 120
     * instructions, just to be safe, and pass that along to every setIRR() call we make here.
     *
     * @this {ChipSet}
     * @param {number} b
     * @returns {boolean} (true if data accepted, false if declined)
     */
    receiveKbdData(b)
    {
        if (!COMPILED) this.printf(MESSAGE.KBD + MESSAGE.PORT, "chipset.receiveKbdData(%#04X)\n", b);
        if (this.model == ChipSet.MODEL_4860) {
            if (!(this.bNMI & ChipSet.NMI.KBD_LATCH)) {
                this.bNMI |= ChipSet.NMI.KBD_LATCH;
                this.bKbdData = b;
                if (b && (this.bNMI & ChipSet.NMI.ENABLE)) {
                    X86.helpInterrupt.call(this.cpu, X86.EXCEPTION.NMI);
                }
                return true;
            }
            return false;
        }
        if (this.model < ChipSet.MODEL_5170) {
            if (this.bPPIB & ChipSet.PPI_B.CLK_KBD) {
                this.bKbdData = b;
                if (b) {
                    this.setIRR(ChipSet.IRQ.KBD, 120);
                    this.b8041Status |= ChipSet.C8042.STATUS.OUTBUFF_FULL;
                }
                return true;
            }
            return false;
        }
        if (b) {
            if (!(this.b8042CmdData & ChipSet.C8042.DATA.CMD.NO_CLOCK)) {
                /**
                 * The next in8042OutBuff() will clear both of these bits and call kbd.checkBuffer(),
                 * which will call receiveKbdData() again if there's still keyboard data to process.
                 */
                if (!(this.b8042Status & (ChipSet.C8042.STATUS.OUTBUFF_FULL | ChipSet.C8042.STATUS.OUTBUFF_DELAY))) {
                    this.set8042OutBuff(b, true);
                    /**
                     * A delay of 4 instructions was originally requested as part of the the Keyboard's resetDevice()
                     * response, but a larger delay (120) is now needed for MODEL_5170 machines, per the discussion above.
                     */
                    this.setIRR(ChipSet.IRQ.KBD, 120);
                    return true;
                }
                if (!COMPILED) this.printf(MESSAGE.KBD + MESSAGE.PORT, "chipset.receiveKbdData(%#04X): output buffer full\n", b);
                return false;
            }
            if (!COMPILED) this.printf(MESSAGE.KBD + MESSAGE.PORT, "chipset.receiveKbdData(%#04X): disabled\n", b);
        }
        return false;
    }

    /**
     * in6300DIPSwitches(iDIP, port, addrFrom)
     *
     * @this {ChipSet}
     * @param {number} iDIP (0 or 1)
     * @param {number} port (0x66 or 0x67)
     * @param {number} [addrFrom] (not defined if the Debugger is trying to read the specified port)
     * @returns {number} simulated port value
     */
    in6300DIPSwitches(iDIP, port, addrFrom)
    {
        let b = this.aDIPSwitches[iDIP][1];
        this.printIO(port, undefined, addrFrom, "DIPSW-" + iDIP, b, MESSAGE.CHIPSET);
        return b;
    }

    /**
     * inCMOSAddr(port, addrFrom)
     *
     * @this {ChipSet}
     * @param {number} port (0x70)
     * @param {number} [addrFrom] (not defined if the Debugger is trying to read the specified port)
     * @returns {number} simulated port value
     */
    inCMOSAddr(port, addrFrom)
    {
        this.printIO(port, undefined, addrFrom, "CMOS.ADDR", this.bCMOSAddr, MESSAGE.CMOS);
        return this.bCMOSAddr;
    }

    /**
     * outCMOSAddr(port, bOut, addrFrom)
     *
     * @this {ChipSet}
     * @param {number} port (0x70)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined if the Debugger is trying to write the specified port)
     */
    outCMOSAddr(port, bOut, addrFrom)
    {
        this.printIO(port, bOut, addrFrom, "CMOS.ADDR", undefined, MESSAGE.CMOS);
        this.bCMOSAddr = bOut;
        this.bNMI = (this.bNMI & ~ChipSet.NMI.ENABLE) | ((bOut & ChipSet.CMOS.ADDR.NMI_DISABLE)? 0 : ChipSet.NMI.ENABLE);
    }

    /**
     * inCMOSData(port, addrFrom)
     *
     * @this {ChipSet}
     * @param {number} port (0x71)
     * @param {number} [addrFrom] (not defined if the Debugger is trying to read the specified port)
     * @returns {number} simulated port value
     */
    inCMOSData(port, addrFrom)
    {
        let bAddr = this.bCMOSAddr & ChipSet.CMOS.ADDR.MASK;
        let bIn = (bAddr <= ChipSet.CMOS.ADDR.STATUSD? this.getRTCByte(bAddr) : this.abCMOSData[bAddr]);
        if (this.messageEnabled(MESSAGE.CMOS + MESSAGE.PORT)) {
            this.printIO(port, undefined, addrFrom, "CMOS.DATA[" + StrLib.toHexByte(bAddr) + "]", bIn, true);
        }
        if (addrFrom != null) {
            if (bAddr == ChipSet.CMOS.ADDR.STATUSC) {
                /**
                 * When software reads the STATUSC port, all interrupt bits (PF, AF, and UF) are automatically
                 * cleared, which in turn clears the IRQF bit, which in turn clears the IRQ.
                 */
                this.abCMOSData[bAddr] &= ChipSet.CMOS.STATUSC.RESERVED;
                if (bIn & ChipSet.CMOS.STATUSC.IRQF) this.clearIRR(ChipSet.IRQ.RTC);
                /**
                 * If we just cleared PF, and PIE is still set, then we need to make sure the next Periodic Interrupt
                 * occurs in a timely manner, too.
                 */
                if ((bIn & ChipSet.CMOS.STATUSC.PF) && (this.abCMOSData[ChipSet.CMOS.ADDR.STATUSB] & ChipSet.CMOS.STATUSB.PIE)) {
                    if (!COMPILED) this.printf(MESSAGE.RTC, "RTC periodic interrupt cleared\n");
                    this.setRTCCycleLimit();
                }
            }
        }
        return bIn;
    }

    /**
     * outCMOSData(port, bOut, addrFrom)
     *
     * @this {ChipSet}
     * @param {number} port (0x71)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined if the Debugger is trying to write the specified port)
     */
    outCMOSData(port, bOut, addrFrom)
    {
        let bAddr = this.bCMOSAddr & ChipSet.CMOS.ADDR.MASK;
        if (this.messageEnabled(MESSAGE.CMOS + MESSAGE.PORT)) {
            this.printIO(port, bOut, addrFrom, "CMOS.DATA[" + StrLib.toHexByte(bAddr) + "]", undefined, true);
        }
        let bDelta = bOut ^ this.abCMOSData[bAddr];
        this.abCMOSData[bAddr] = (bAddr <= ChipSet.CMOS.ADDR.STATUSD? this.setRTCByte(bAddr, bOut) : bOut);
        if (bAddr == ChipSet.CMOS.ADDR.STATUSB && (bDelta & ChipSet.CMOS.STATUSB.PIE)) {
            if (bOut & ChipSet.CMOS.STATUSB.PIE) {
                if (!COMPILED) this.printf(MESSAGE.RTC, "RTC periodic interrupts enabled\n");
                this.setRTCCycleLimit();
            } else {
                if (!COMPILED) this.printf(MESSAGE.RTC, "RTC periodic interrupts disabled\n");
            }
        }
    }

    /**
     * inNMI(port, addrFrom)
     *
     * This handler is installed only for models before MODEL_5170; technically, this port is not readable,
     * except on the MODEL_4860, and even there, all a read is required to do is clear KBD_LATCH, but we go ahead
     * and return all the bits.
     *
     * @this {ChipSet}
     * @param {number} port (0xA0)
     * @param {number} [addrFrom] (not defined if the Debugger is trying to read the specified port)
     * @returns {number} simulated port value
     */
    inNMI(port, addrFrom)
    {
        let bIn = this.bNMI;
        this.printIO(port, undefined, addrFrom, "NMI", bIn);
        this.bNMI &= ~ChipSet.NMI.KBD_LATCH;
        return bIn;
    }

    /**
     * outNMI(port, bOut, addrFrom)
     *
     * This handler is installed only for models before MODEL_5170.
     *
     * @this {ChipSet}
     * @param {number} port (0xA0)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined if the Debugger is trying to write the specified port)
     */
    outNMI(port, bOut, addrFrom)
    {
        this.printIO(port, bOut, addrFrom, "NMI");
        this.bNMI = bOut;
    }

    /**
     * outFPUClear(port, bOut, addrFrom)
     *
     * This handler is installed only for MODEL_5170.
     *
     * @this {ChipSet}
     * @param {number} port (0xF0)
     * @param {number} bOut (0x00 is the only expected output)
     * @param {number} [addrFrom] (not defined if the Debugger is trying to write the specified port)
     */
    outFPUClear(port, bOut, addrFrom)
    {
        this.printIO(port, bOut, addrFrom, "FPU.CLEAR");

        if (this.fpuActive) this.fpuActive.clearBusy();
    }

    /**
     * outFPUReset(port, bOut, addrFrom)
     *
     * This handler is installed only for MODEL_5170.
     *
     * @this {ChipSet}
     * @param {number} port (0xF1)
     * @param {number} bOut (0x00 is the only expected output)
     * @param {number} [addrFrom] (not defined if the Debugger is trying to write the specified port)
     */
    outFPUReset(port, bOut, addrFrom)
    {
        this.printIO(port, bOut, addrFrom, "FPU.RESET");

        if (this.fpuActive) this.fpuActive.resetFPU();
    }

    /**
     * intBIOSTimer(addr)
     *
     * INT 0x1A Quick Reference:
     *
     *      AH
     *      ----
     *      0x00    Get current clock count in CX:DX
     *      0x01    Set current clock count from CX:DX
     *      0x02    Get real-time clock using BCD (CH=hours, CL=minutes, DH=seconds)
     *      0x03    Set real-time clock using BCD (CH=hours, CL=minutes, DH=seconds, DL=1 if Daylight Savings Time option)
     *      0x04    Get real-time date using BCD (CH=century, CL=year, DH=month, DL=day)
     *      0x05    Set real-time date using BCD (CH=century, CL=year, DH=month, DL=day)
     *      0x06    Set alarm using BCD (CH=hours, CL=minutes, DH=seconds)
     *      0x07    Reset alarm
     *
     * @this {ChipSet}
     * @param {number} addr
     * @returns {boolean} true to proceed with the INT 0x1A software interrupt, false to skip
     */
    intBIOSTimer(addr)
    {
        if (DEBUGGER) {
            if (this.messageEnabled(MESSAGE.INT) && this.dbg.messageInt(Interrupts.TIMER, addr)) {
                /**
                 * By computing AH now, we get the incoming AH value; if we computed it below, along with
                 * the rest of the register values, we'd get the outgoing AH value, which is not what we want.
                 */
                let chipset = this;
                let AH = this.cpu.regEAX >> 8;
                let nCycles = this.cpu.getCycles();
                this.cpu.addIntReturn(addr, function onBIOSRTCReturn(nLevel) {
                    let sResult;
                    let CL = chipset.cpu.regEDX & 0xff;
                    let CH = chipset.cpu.regEDX >> 8;
                    let DL = chipset.cpu.regEDX & 0xff;
                    let DH = chipset.cpu.regEDX >> 8;
                    if (AH == 0x02 || AH == 0x03) {
                        sResult = " CH(hour)=" + StrLib.toHexWord(CH) + " CL(min)=" + StrLib.toHexByte(CL) + " DH(sec)=" + StrLib.toHexByte(DH);
                    } else if (AH == 0x04 || AH == 0x05) {
                        sResult = " CX(year)=" + StrLib.toHexWord(chipset.cpu.regECX) + " DH(month)=" + StrLib.toHexByte(DH) + " DL(day)=" + StrLib.toHexByte(DL);
                    }
                    let nCyclesDelta = -nCycles + (nCycles = chipset.cpu.getCycles());
                    chipset.dbg.messageIntReturn(Interrupts.TIMER, nLevel, nCyclesDelta, sResult);
                });
            }
        }
        return true;
    }

    /**
     * setSpeaker(enable)
     *
     * @this {ChipSet}
     * @param {number} [enable] (non-zero to enable speaker, zero to disable it; otherwise, update as appropriate)
     */
    setSpeaker(enable)
    {
        let fOn;
        if (enable !== undefined) {
            fOn = !!enable;
            if (fOn != this.fSpeakerEnabled) {
                //
                // Yielding doesn't seem to help the simulation of sound via rapid speaker toggling.
                //
                // if (this.cpu) {
                //     this.cpu.yieldCPU();
                // }
                this.fSpeakerEnabled = fOn;
            }
        } else {
            fOn = !!(this.fSpeakerEnabled && this.cpu && this.cpu.isRunning());
        }
        let freq = Math.round(ChipSet.TIMER_TICKS_PER_SEC / this.getTimerInit(ChipSet.PIT0.TIMER2));
        if (freq < 20 || freq > 20000) {
            /**
             * Treat frequencies outside the normal hearing range (below 20hz or above 20Khz) as a clever
             * attempt to turn sound off.
             */
            fOn = false;
        }
        if (this.contextAudio) {
            if (fOn && this.startAudio()) {
                /**
                 * Instead of setting the frequency's 'value' property directly, as we used to do, we use the
                 * setValueAtTime() method, with a time of zero, as a work-around to avoid the "easing" (aka
                 * "de-zippering") of the frequency that browsers like to do.  Supposedly de-zippering is an
                 * attempt to avoid "pops" if the frequency is altered while the wave is still rising or falling.
                 *
                 * Ditto for the gain's 'value'.
                 */
                // this.oscillatorAudio['frequency']['value'] = freq;
                this.oscillatorAudio['frequency']['setValueAtTime'](freq, 0);
                // this.volumeAudio['gain']['value'] = this.volumeInit;
                this.volumeAudio['gain']['setValueAtTime'](this.volumeInit, 0);
                this.printf(MESSAGE.SPEAKER, "speaker on at  %dhz\n", freq);
            } else if (this.volumeAudio) {
                this.volumeAudio['gain']['setValueAtTime'](0, 0);
                this.printf(MESSAGE.SPEAKER, "speaker off at %dhz\n", freq);
            }
        } else if (fOn && this.fSpeakerOn != fOn) {
            this.printf(MESSAGE.SPEAKER, "BEEP\n");
        }
        this.fSpeakerOn = fOn;
    }

    /**
     * startAudio(event)
     *
     * NOTE: We currently use named properties rather than "dot" properties to access all the AudioContext
     * properties and methods, because we don't have any built-in declarations or externs for them, so neither
     * WebStorm nor the Closure Compiler recognize them.  We could live with the WebStorm inspection warnings,
     * but we definitely can't have the Closure Compiler renaming any of the properties -- and since it
     * automatically converts them all to "dot" properties, there's no incentive for us to do anything more.
     *
     * @this {ChipSet}
     * @param {Event} [event] object from a 'touch' event, if any
     * @returns {boolean}
     */
    startAudio(event)
    {
        if (this.contextAudio) {
            /**
             * NOTE: If the machine happened to enable its speaker *before* the user generated an event
             * (eg, touchstart) that resulted in a call here, then we're too late -- at least as far as iOS
             * devices are concerned, because those devices require the oscillator's start() method to be
             * called in the context of a user-initiated event.
             *
             * So, for the benefit of iOS devices, when we finally receive a user-generated call, we will
             * simply recreate the oscillator.  This is a one-time work-around for the life of the machine.
             *
             * TODO: Consider adding a "Sound On/Off" button to all machines (probably in the top right corner,
             * where "Full Screen" and "Lock Pointer" buttons typically appear), at least on iOS devices.
             */
            if (event) {
                if (this.fUserSound) return true;
                this.oscillatorAudio = null;
                this.fUserSound = true;
            }
            if (this.oscillatorAudio) return true;
            try {
                this.oscillatorAudio = this.contextAudio['createOscillator']();
                if ('start' in this.oscillatorAudio) {  // early versions of WebLib Audio used noteOn() instead of start()
                    this.volumeAudio = this.contextAudio['createGain']();
                    this.oscillatorAudio['connect'](this.volumeAudio);
                    this.volumeAudio['connect'](this.contextAudio['destination']);
                    this.volumeAudio['gain']['setValueAtTime'](0, 0);
                    this.oscillatorAudio['type'] = "square";
                    this.oscillatorAudio['start'](0);
                    return true;
                }
            } catch(e) {
                this.printf(MESSAGE.NOTICE, "AudioContext exception: %s\n", e.message);
                this.contextAudio = null;
            }
        }
        return false;
    }

    /**
     * messageBitsDMA(iChannel)
     *
     * @this {ChipSet}
     * @param {number} [iChannel] if the message is associated with a particular IRQ #
     * @returns {number}
     */
    messageBitsDMA(iChannel)
    {
        let bitsMessage = 0;
        if (DEBUG) {
            bitsMessage = MESSAGE.DATA;
            if (iChannel == ChipSet.DMA_FDC) {
                bitsMessage += MESSAGE.FDC;
            } else if (iChannel == ChipSet.DMA_HDC) {
                bitsMessage += MESSAGE.HDC;
            }
        }
        return bitsMessage;
    }

    /**
     * messageBitsIRQ(nIRQ)
     *
     * @this {ChipSet}
     * @param {number|undefined} [nIRQ] if the message is associated with a particular IRQ #
     * @returns {number}
     */
    messageBitsIRQ(nIRQ)
    {
        let bitsMessage = MESSAGE.IRQ;
        if (nIRQ == ChipSet.IRQ.TIMER0) {       // IRQ 0
            bitsMessage |= MESSAGE.TIMER;
        } else if (nIRQ == ChipSet.IRQ.KBD) {   // IRQ 1
            bitsMessage |= MESSAGE.KBD;
        } else if (nIRQ == ChipSet.IRQ.SLAVE) { // IRQ 2
            bitsMessage |= MESSAGE.NONE;       // (we're not really interested in IRQ 2 itself, just the slaves)
        } else if (nIRQ == ChipSet.IRQ.COM1 || nIRQ == ChipSet.IRQ.COM2) {
            bitsMessage |= MESSAGE.SERIAL;
        } else if (nIRQ == ChipSet.IRQ.XTC) {   // IRQ 5 (MODEL_5160)
            bitsMessage |= MESSAGE.HDC;
        } else if (nIRQ == ChipSet.IRQ.FDC) {   // IRQ 6
            bitsMessage |= MESSAGE.FDC;
        } else if (nIRQ == ChipSet.IRQ.RTC) {   // IRQ 8 (MODEL_5170 and up)
            bitsMessage |= MESSAGE.RTC;
        } else if (nIRQ == ChipSet.IRQ.ATC1 || nIRQ == ChipSet.IRQ.ATC2) {      // IRQ 14 or 15 (MODEL_5170 and up)
            bitsMessage |= MESSAGE.HDC;
        }
        return bitsMessage;
    }

    /**
     * checkDMA()
     *
     * Called by the CPU whenever INTR.DMA is set.
     *
     * @returns {boolean} true if one or more async DMA channels are still active (unmasked), false to reset INTR.DMA
     *
     checkDMA()
     {
         let fActive = false;
         for (let iDMAC = 0; iDMAC < this.aDMACs; iDMAC++) {
             let controller = this.aDMACs[iDMAC];
             for (let iChannel = 0; iChannel < controller.aChannels.length; iChannel++) {
                 let channel = controller.aChannels[iChannel];
                 if (!channel.masked) {
                     this.advanceDMA(channel);
                     if (!channel.masked) fActive = true;
                 }
             }
         }
         return fActive;
     }
     */

    /**
     * ChipSet.init()
     *
     * This function operates on every HTML element of class "chipset", extracting the
     * JSON-encoded parameters for the ChipSet constructor from the element's "data-value"
     * attribute, invoking the constructor to create a ChipSet component, and then binding
     * any associated HTML controls to the new component.
     */
    static init()
    {
        let aeChipSet = Component.getElementsByClass(APPCLASS, "chipset");
        for (let iChip = 0; iChip < aeChipSet.length; iChip++) {
            let eChipSet = aeChipSet[iChip];
            let parmsChipSet = Component.getComponentParms(eChipSet);
            let chipset = new ChipSet(parmsChipSet);
            Component.bindComponentControls(chipset, eChipSet, APPCLASS);
            chipset.updateDIPSwitchDescriptions();
        }
    }

    /**
     * Port input notification tables, starting with the one that's common to all models (aPortInput)
     */
    static aPortInput = {
        [ChipSet.PIC0.PORT+0]: /** @this {ChipSet} */ function inPort20(port, addrFrom) { return this.inPICLo(ChipSet.PIC0.INDEX, addrFrom); },
        [ChipSet.PIC0.PORT+1]: /** @this {ChipSet} */ function inPort21(port, addrFrom) { return this.inPICHi(ChipSet.PIC0.INDEX, addrFrom); },
        [ChipSet.PIT0.PORT+0]: /** @this {ChipSet} */ function inPort40(port, addrFrom) { return this.inTimer(ChipSet.PIT0.INDEX, ChipSet.PIT0.TIMER0, port, addrFrom); },
        [ChipSet.PIT0.PORT+1]: /** @this {ChipSet} */ function inPort41(port, addrFrom) { return this.inTimer(ChipSet.PIT0.INDEX, ChipSet.PIT0.TIMER1, port, addrFrom); },
        [ChipSet.PIT0.PORT+2]: /** @this {ChipSet} */ function inPort42(port, addrFrom) { return this.inTimer(ChipSet.PIT0.INDEX, ChipSet.PIT0.TIMER2, port, addrFrom); },
        [ChipSet.PIT0.PORT+3]: /** @this {ChipSet} */ function inPort43(port, addrFrom) { return this.inTimerCtrl(ChipSet.PIT0.INDEX, port, addrFrom); },
    };

    static aPortInput4860 = {
        [ChipSet.PPI.PORT+0]: ChipSet.prototype.inPPIA,
        [ChipSet.PPI.PORT+1]: ChipSet.prototype.inPPIB,
        [ChipSet.PPI.PORT+2]: ChipSet.prototype.inPPIC,
        [ChipSet.PPI.PORT+3]: ChipSet.prototype.inPPICtrl,  // technically, not actually readable, but I want the Debugger to be able to read it
        [ChipSet.NMI.PORT]:   ChipSet.prototype.inNMI
    };

    static aPortInput5150 = {
        [ChipSet.PPI.PORT+0]: ChipSet.prototype.inPPIA,
        [ChipSet.PPI.PORT+1]: ChipSet.prototype.inPPIB,
        [ChipSet.PPI.PORT+2]: ChipSet.prototype.inPPIC,
        [ChipSet.PPI.PORT+3]: ChipSet.prototype.inPPICtrl,  // technically, not actually readable, but I want the Debugger to be able to read it
    };

    static aPortInput51xx = {
        [ChipSet.DMA0.PORT.CH0_ADDR]:     /** @this {ChipSet} */ function inPort00(port, addrFrom) { return this.inDMAChannelAddr(ChipSet.DMA0.INDEX, 0, port, addrFrom); },
        [ChipSet.DMA0.PORT.CH0_COUNT]:    /** @this {ChipSet} */ function inPort01(port, addrFrom) { return this.inDMAChannelCount(ChipSet.DMA0.INDEX, 0, port, addrFrom); },
        [ChipSet.DMA0.PORT.CH1_ADDR]:     /** @this {ChipSet} */ function inPort02(port, addrFrom) { return this.inDMAChannelAddr(ChipSet.DMA0.INDEX, 1, port, addrFrom); },
        [ChipSet.DMA0.PORT.CH1_COUNT]:    /** @this {ChipSet} */ function inPort03(port, addrFrom) { return this.inDMAChannelCount(ChipSet.DMA0.INDEX, 1, port, addrFrom); },
        [ChipSet.DMA0.PORT.CH2_ADDR]:     /** @this {ChipSet} */ function inPort04(port, addrFrom) { return this.inDMAChannelAddr(ChipSet.DMA0.INDEX, 2, port, addrFrom); },
        [ChipSet.DMA0.PORT.CH2_COUNT]:    /** @this {ChipSet} */ function inPort05(port, addrFrom) { return this.inDMAChannelCount(ChipSet.DMA0.INDEX, 2, port, addrFrom); },
        [ChipSet.DMA0.PORT.CH3_ADDR]:     /** @this {ChipSet} */ function inPort06(port, addrFrom) { return this.inDMAChannelAddr(ChipSet.DMA0.INDEX, 3, port, addrFrom); },
        [ChipSet.DMA0.PORT.CH3_COUNT]:    /** @this {ChipSet} */ function inPort07(port, addrFrom) { return this.inDMAChannelCount(ChipSet.DMA0.INDEX, 3, port, addrFrom); },
        [ChipSet.DMA0.PORT.CMD_STATUS]:   /** @this {ChipSet} */ function inPort08(port, addrFrom) { return this.inDMAStatus(ChipSet.DMA0.INDEX, port, addrFrom); },
        [ChipSet.DMA0.PORT.MASTER_CLEAR]: /** @this {ChipSet} */ function inPort0D(port, addrFrom) { return this.inDMATemp(ChipSet.DMA0.INDEX, port, addrFrom); },
        [ChipSet.DMA0.PORT.CH2_PAGE]:     /** @this {ChipSet} */ function inPort81(port, addrFrom) { return this.inDMAPageReg(ChipSet.DMA0.INDEX, 2, port, addrFrom); },
        [ChipSet.DMA0.PORT.CH3_PAGE]:     /** @this {ChipSet} */ function inPort82(port, addrFrom) { return this.inDMAPageReg(ChipSet.DMA0.INDEX, 3, port, addrFrom); },
        [ChipSet.DMA0.PORT.CH1_PAGE]:     /** @this {ChipSet} */ function inPort83(port, addrFrom) { return this.inDMAPageReg(ChipSet.DMA0.INDEX, 1, port, addrFrom); },
        [ChipSet.DMA0.PORT.CH0_PAGE]:     /** @this {ChipSet} */ function inPort87(port, addrFrom) { return this.inDMAPageReg(ChipSet.DMA0.INDEX, 0, port, addrFrom); }
    };

    static aPortInput5170 = {
        [ChipSet.C8042.PORT+0]: ChipSet.prototype.in8042OutBuff,
        [ChipSet.C8042.PORT+1]: ChipSet.prototype.in8042RWReg,
        [ChipSet.C8042.PORT+4]: ChipSet.prototype.in8042Status,
        0x70: ChipSet.prototype.inCMOSAddr,
        0x71: ChipSet.prototype.inCMOSData,
        0x80: /** @this {ChipSet} */ function inPort80(port, addrFrom) { return this.inDMAPageSpare(7, port, addrFrom); },
        0x84: /** @this {ChipSet} */ function inPort84(port, addrFrom) { return this.inDMAPageSpare(0, port, addrFrom); },
        0x85: /** @this {ChipSet} */ function inPort85(port, addrFrom) { return this.inDMAPageSpare(1, port, addrFrom); },
        0x86: /** @this {ChipSet} */ function inPort86(port, addrFrom) { return this.inDMAPageSpare(2, port, addrFrom); },
        0x88: /** @this {ChipSet} */ function inPort88(port, addrFrom) { return this.inDMAPageSpare(3, port, addrFrom); },
        [ChipSet.DMA1.PORT.CH6_PAGE]: /** @this {ChipSet} */ function inPort89(port, addrFrom) { return this.inDMAPageReg(ChipSet.DMA1.INDEX, 2, port, addrFrom); },
        [ChipSet.DMA1.PORT.CH7_PAGE]: /** @this {ChipSet} */ function inPort8A(port, addrFrom) { return this.inDMAPageReg(ChipSet.DMA1.INDEX, 3, port, addrFrom); },
        [ChipSet.DMA1.PORT.CH5_PAGE]: /** @this {ChipSet} */ function inPort8B(port, addrFrom) { return this.inDMAPageReg(ChipSet.DMA1.INDEX, 1, port, addrFrom); },
        0x8C: /** @this {ChipSet} */ function inPort8C(port, addrFrom) { return this.inDMAPageSpare(4, port, addrFrom); },
        0x8D: /** @this {ChipSet} */ function inPort8D(port, addrFrom) { return this.inDMAPageSpare(5, port, addrFrom); },
        0x8E: /** @this {ChipSet} */ function inPort8E(port, addrFrom) { return this.inDMAPageSpare(6, port, addrFrom); },
        [ChipSet.DMA1.PORT.CH4_PAGE]: /** @this {ChipSet} */ function inPort8F(port, addrFrom) { return this.inDMAPageReg(ChipSet.DMA1.INDEX, 0, port, addrFrom); },
        [ChipSet.PIC1.PORT+0]: /** @this {ChipSet} */ function inPortA0(port, addrFrom) { return this.inPICLo(ChipSet.PIC1.INDEX, addrFrom); },
        [ChipSet.PIC1.PORT+1]: /** @this {ChipSet} */ function inPortA1(port, addrFrom) { return this.inPICHi(ChipSet.PIC1.INDEX, addrFrom); },
        [ChipSet.DMA1.PORT.CH4_ADDR]:     /** @this {ChipSet} */ function inPortC0(port, addrFrom) { return this.inDMAChannelAddr(ChipSet.DMA1.INDEX, 0, port, addrFrom); },
        [ChipSet.DMA1.PORT.CH4_COUNT]:    /** @this {ChipSet} */ function inPortC2(port, addrFrom) { return this.inDMAChannelCount(ChipSet.DMA1.INDEX, 0, port, addrFrom); },
        [ChipSet.DMA1.PORT.CH5_ADDR]:     /** @this {ChipSet} */ function inPortC4(port, addrFrom) { return this.inDMAChannelAddr(ChipSet.DMA1.INDEX, 1, port, addrFrom); },
        [ChipSet.DMA1.PORT.CH5_COUNT]:    /** @this {ChipSet} */ function inPortC6(port, addrFrom) { return this.inDMAChannelCount(ChipSet.DMA1.INDEX, 1, port, addrFrom); },
        [ChipSet.DMA1.PORT.CH6_ADDR]:     /** @this {ChipSet} */ function inPortC8(port, addrFrom) { return this.inDMAChannelAddr(ChipSet.DMA1.INDEX, 2, port, addrFrom); },
        [ChipSet.DMA1.PORT.CH6_COUNT]:    /** @this {ChipSet} */ function inPortCA(port, addrFrom) { return this.inDMAChannelCount(ChipSet.DMA1.INDEX, 2, port, addrFrom); },
        [ChipSet.DMA1.PORT.CH7_ADDR]:     /** @this {ChipSet} */ function inPortCC(port, addrFrom) { return this.inDMAChannelAddr(ChipSet.DMA1.INDEX, 3, port, addrFrom); },
        [ChipSet.DMA1.PORT.CH7_COUNT]:    /** @this {ChipSet} */ function inPortCE(port, addrFrom) { return this.inDMAChannelCount(ChipSet.DMA1.INDEX, 3, port, addrFrom); },
        [ChipSet.DMA1.PORT.CMD_STATUS]:   /** @this {ChipSet} */ function inPortD0(port, addrFrom) { return this.inDMAStatus(ChipSet.DMA1.INDEX, port, addrFrom); },
        [ChipSet.DMA1.PORT.MASTER_CLEAR]: /** @this {ChipSet} */ function inPortDA(port, addrFrom) { return this.inDMATemp(ChipSet.DMA1.INDEX, port, addrFrom); }
    };

    static aPortInput6300 = {
        [ChipSet.C8041.PORT+0]: ChipSet.prototype.in8041Kbd,
        [ChipSet.C8041.PORT+1]: ChipSet.prototype.in8041Ctrl,
        [ChipSet.C8041.PORT+4]: ChipSet.prototype.in8041Status,
        0x66: /** @this {ChipSet} */ function inPort66(port, addrFrom) { return this.in6300DIPSwitches(0, port, addrFrom); },
        0x67: /** @this {ChipSet} */ function inPort67(port, addrFrom) { return this.in6300DIPSwitches(1, port, addrFrom); }
    };

    static aPortInputDeskPro386 = {
        [ChipSet.PIT1.PORT+0]: /** @this {ChipSet} */ function inPort48(port, addrFrom) { return this.inTimer(ChipSet.PIT1.INDEX, ChipSet.PIT1.TIMER3, port, addrFrom); },
        [ChipSet.PIT1.PORT+1]: /** @this {ChipSet} */ function inPort49(port, addrFrom) { return this.inTimer(ChipSet.PIT1.INDEX, ChipSet.PIT1.TIMER4, port, addrFrom); },
        [ChipSet.PIT1.PORT+2]: /** @this {ChipSet} */ function inPort4A(port, addrFrom) { return this.inTimer(ChipSet.PIT1.INDEX, ChipSet.PIT1.TIMER5, port, addrFrom); },
        [ChipSet.PIT1.PORT+3]: /** @this {ChipSet} */ function inPort4B(port, addrFrom) { return this.inTimerCtrl(ChipSet.PIT1.INDEX, port, addrFrom); }
    };

    /**
     * Port output notification tables, starting with the one that's common to all models (aPortOutput)
     */
    static aPortOutput = {
        [ChipSet.PIC0.PORT+0]: /** @this {ChipSet} */ function outPort20(port, bOut, addrFrom) { this.outPICLo(ChipSet.PIC0.INDEX, bOut, addrFrom); },
        [ChipSet.PIC0.PORT+1]: /** @this {ChipSet} */ function outPort21(port, bOut, addrFrom) { this.outPICHi(ChipSet.PIC0.INDEX, bOut, addrFrom); },
        [ChipSet.PIT0.PORT+0]: /** @this {ChipSet} */ function outPort40(port, bOut, addrFrom) { this.outTimer(ChipSet.PIT0.INDEX, ChipSet.PIT0.TIMER0, port, bOut, addrFrom); },
        [ChipSet.PIT0.PORT+1]: /** @this {ChipSet} */ function outPort41(port, bOut, addrFrom) { this.outTimer(ChipSet.PIT0.INDEX, ChipSet.PIT0.TIMER1, port, bOut, addrFrom); },
        [ChipSet.PIT0.PORT+2]: /** @this {ChipSet} */ function outPort42(port, bOut, addrFrom) { this.outTimer(ChipSet.PIT0.INDEX, ChipSet.PIT0.TIMER2, port, bOut, addrFrom); },
        [ChipSet.PIT0.PORT+3]: /** @this {ChipSet} */ function outPort43(port, bOut, addrFrom) { this.outTimerCtrl(ChipSet.PIT0.INDEX, port, bOut, addrFrom); },
    };

    static aPortOutput4860 = {
        0x10: ChipSet.prototype.outMFGTest,     // a manufacturing test port that we don't really care about
        [ChipSet.PPI.PORT+0]: ChipSet.prototype.outPPIA,
        [ChipSet.PPI.PORT+1]: ChipSet.prototype.outPPIB,
        [ChipSet.PPI.PORT+2]: ChipSet.prototype.outPPIC,
        [ChipSet.PPI.PORT+3]: ChipSet.prototype.outPPICtrl,
        [ChipSet.NMI.PORT]:   ChipSet.prototype.outNMI
    };

    static aPortOutput5150 = {
        [ChipSet.PPI.PORT+0]: ChipSet.prototype.outPPIA,
        [ChipSet.PPI.PORT+1]: ChipSet.prototype.outPPIB,
        [ChipSet.PPI.PORT+2]: ChipSet.prototype.outPPIC,
        [ChipSet.PPI.PORT+3]: ChipSet.prototype.outPPICtrl,
        [ChipSet.NMI.PORT]:   ChipSet.prototype.outNMI
    };

    static aPortOutput51xx = {
        [ChipSet.DMA0.PORT.CH0_ADDR]:     /** @this {ChipSet} */ function outPort00(port, bOut, addrFrom) { this.outDMAChannelAddr(ChipSet.DMA0.INDEX, 0, port, bOut, addrFrom); },
        [ChipSet.DMA0.PORT.CH0_COUNT]:    /** @this {ChipSet} */ function outPort01(port, bOut, addrFrom) { this.outDMAChannelCount(ChipSet.DMA0.INDEX, 0, port, bOut, addrFrom); },
        [ChipSet.DMA0.PORT.CH1_ADDR]:     /** @this {ChipSet} */ function outPort02(port, bOut, addrFrom) { this.outDMAChannelAddr(ChipSet.DMA0.INDEX, 1, port, bOut, addrFrom); },
        [ChipSet.DMA0.PORT.CH1_COUNT]:    /** @this {ChipSet} */ function outPort03(port, bOut, addrFrom) { this.outDMAChannelCount(ChipSet.DMA0.INDEX, 1, port, bOut, addrFrom); },
        [ChipSet.DMA0.PORT.CH2_ADDR]:     /** @this {ChipSet} */ function outPort04(port, bOut, addrFrom) { this.outDMAChannelAddr(ChipSet.DMA0.INDEX, 2, port, bOut, addrFrom); },
        [ChipSet.DMA0.PORT.CH2_COUNT]:    /** @this {ChipSet} */ function outPort05(port, bOut, addrFrom) { this.outDMAChannelCount(ChipSet.DMA0.INDEX, 2, port, bOut, addrFrom); },
        [ChipSet.DMA0.PORT.CH3_ADDR]:     /** @this {ChipSet} */ function outPort06(port, bOut, addrFrom) { this.outDMAChannelAddr(ChipSet.DMA0.INDEX, 3, port, bOut, addrFrom); },
        [ChipSet.DMA0.PORT.CH3_COUNT]:    /** @this {ChipSet} */ function outPort07(port, bOut, addrFrom) { this.outDMAChannelCount(ChipSet.DMA0.INDEX, 3, port, bOut, addrFrom); },
        [ChipSet.DMA0.PORT.CMD_STATUS]:   /** @this {ChipSet} */ function outPort08(port, bOut, addrFrom) { this.outDMACmd(ChipSet.DMA0.INDEX, port, bOut, addrFrom); },
        [ChipSet.DMA0.PORT.REQUEST]:      /** @this {ChipSet} */ function outPort09(port, bOut, addrFrom) { this.outDMAReq(ChipSet.DMA0.INDEX, port, bOut, addrFrom); },
        [ChipSet.DMA0.PORT.MASK]:         /** @this {ChipSet} */ function outPort0A(port, bOut, addrFrom) { this.outDMAMask(ChipSet.DMA0.INDEX, port, bOut, addrFrom); },
        [ChipSet.DMA0.PORT.MODE]:         /** @this {ChipSet} */ function outPort0B(port, bOut, addrFrom) { this.outDMAMode(ChipSet.DMA0.INDEX, port, bOut, addrFrom); },
        [ChipSet.DMA0.PORT.RESET_FF]:     /** @this {ChipSet} */ function outPort0C(port, bOut, addrFrom) { this.outDMAResetFF(ChipSet.DMA0.INDEX, port, bOut, addrFrom); },
        [ChipSet.DMA0.PORT.MASTER_CLEAR]: /** @this {ChipSet} */ function outPort0D(port, bOut, addrFrom) { this.outDMAMasterClear(ChipSet.DMA0.INDEX, port, bOut, addrFrom); },
        [ChipSet.DMA0.PORT.CH2_PAGE]:     /** @this {ChipSet} */ function outPort81(port, bOut, addrFrom) { this.outDMAPageReg(ChipSet.DMA0.INDEX, 2, port, bOut, addrFrom); },
        [ChipSet.DMA0.PORT.CH3_PAGE]:     /** @this {ChipSet} */ function outPort82(port, bOut, addrFrom) { this.outDMAPageReg(ChipSet.DMA0.INDEX, 3, port, bOut, addrFrom); },
        [ChipSet.DMA0.PORT.CH1_PAGE]:     /** @this {ChipSet} */ function outPort83(port, bOut, addrFrom) { this.outDMAPageReg(ChipSet.DMA0.INDEX, 1, port, bOut, addrFrom); },
        [ChipSet.DMA0.PORT.CH0_PAGE]:     /** @this {ChipSet} */ function outPort87(port, bOut, addrFrom) { this.outDMAPageReg(ChipSet.DMA0.INDEX, 0, port, bOut, addrFrom); }
    };

    static aPortOutput5170 = {
        [ChipSet.C8042.PORT+0]: ChipSet.prototype.out8042InBuffData,
        [ChipSet.C8042.PORT+1]: ChipSet.prototype.out8042RWReg,
        [ChipSet.C8042.PORT+4]: ChipSet.prototype.out8042InBuffCmd,
        0x70: ChipSet.prototype.outCMOSAddr,
        0x71: ChipSet.prototype.outCMOSData,
        0x80: /** @this {ChipSet} */ function outPort80(port, bOut, addrFrom) { this.outDMAPageSpare(7, port, bOut, addrFrom); },
        0x84: /** @this {ChipSet} */ function outPort84(port, bOut, addrFrom) { this.outDMAPageSpare(0, port, bOut, addrFrom); },
        0x85: /** @this {ChipSet} */ function outPort85(port, bOut, addrFrom) { this.outDMAPageSpare(1, port, bOut, addrFrom); },
        0x86: /** @this {ChipSet} */ function outPort86(port, bOut, addrFrom) { this.outDMAPageSpare(2, port, bOut, addrFrom); },
        0x88: /** @this {ChipSet} */ function outPort88(port, bOut, addrFrom) { this.outDMAPageSpare(3, port, bOut, addrFrom); },
        [ChipSet.DMA1.PORT.CH6_PAGE]: /** @this {ChipSet} */ function outPort89(port, bOut, addrFrom) { this.outDMAPageReg(ChipSet.DMA1.INDEX, 2, port, bOut, addrFrom); },
        [ChipSet.DMA1.PORT.CH7_PAGE]: /** @this {ChipSet} */ function outPort8A(port, bOut, addrFrom) { this.outDMAPageReg(ChipSet.DMA1.INDEX, 3, port, bOut, addrFrom); },
        [ChipSet.DMA1.PORT.CH5_PAGE]: /** @this {ChipSet} */ function outPort8B(port, bOut, addrFrom) { this.outDMAPageReg(ChipSet.DMA1.INDEX, 1, port, bOut, addrFrom); },
        0x8C: /** @this {ChipSet} */ function outPort8C(port, bOut, addrFrom) { this.outDMAPageSpare(4, port, bOut, addrFrom); },
        0x8D: /** @this {ChipSet} */ function outPort8D(port, bOut, addrFrom) { this.outDMAPageSpare(5, port, bOut, addrFrom); },
        0x8E: /** @this {ChipSet} */ function outPort8E(port, bOut, addrFrom) { this.outDMAPageSpare(6, port, bOut, addrFrom); },
        0x8F: /** @this {ChipSet} */ function outPort8F(port, bOut, addrFrom) { this.outDMAPageReg(ChipSet.DMA1.INDEX, 0, port, bOut, addrFrom); },
        [ChipSet.PIC1.PORT+0]: /** @this {ChipSet} */ function outPortA0(port, bOut, addrFrom) { this.outPICLo(ChipSet.PIC1.INDEX, bOut, addrFrom); },
        [ChipSet.PIC1.PORT+1]: /** @this {ChipSet} */ function outPortA1(port, bOut, addrFrom) { this.outPICHi(ChipSet.PIC1.INDEX, bOut, addrFrom); },
        [ChipSet.DMA1.PORT.CH4_ADDR]:     /** @this {ChipSet} */ function outPortC0(port, bOut, addrFrom) { this.outDMAChannelAddr(ChipSet.DMA1.INDEX, 0, port, bOut, addrFrom); },
        [ChipSet.DMA1.PORT.CH4_COUNT]:    /** @this {ChipSet} */ function outPortC2(port, bOut, addrFrom) { this.outDMAChannelCount(ChipSet.DMA1.INDEX, 0, port, bOut, addrFrom); },
        [ChipSet.DMA1.PORT.CH5_ADDR]:     /** @this {ChipSet} */ function outPortC4(port, bOut, addrFrom) { this.outDMAChannelAddr(ChipSet.DMA1.INDEX, 1, port, bOut, addrFrom); },
        [ChipSet.DMA1.PORT.CH5_COUNT]:    /** @this {ChipSet} */ function outPortC6(port, bOut, addrFrom) { this.outDMAChannelCount(ChipSet.DMA1.INDEX, 1, port, bOut, addrFrom); },
        [ChipSet.DMA1.PORT.CH6_ADDR]:     /** @this {ChipSet} */ function outPortC8(port, bOut, addrFrom) { this.outDMAChannelAddr(ChipSet.DMA1.INDEX, 2, port, bOut, addrFrom); },
        [ChipSet.DMA1.PORT.CH6_COUNT]:    /** @this {ChipSet} */ function outPortCA(port, bOut, addrFrom) { this.outDMAChannelCount(ChipSet.DMA1.INDEX, 2, port, bOut, addrFrom); },
        [ChipSet.DMA1.PORT.CH7_ADDR]:     /** @this {ChipSet} */ function outPortCC(port, bOut, addrFrom) { this.outDMAChannelAddr(ChipSet.DMA1.INDEX, 3, port, bOut, addrFrom); },
        [ChipSet.DMA1.PORT.CH7_COUNT]:    /** @this {ChipSet} */ function outPortCE(port, bOut, addrFrom) { this.outDMAChannelCount(ChipSet.DMA1.INDEX, 3, port, bOut, addrFrom); },
        [ChipSet.DMA1.PORT.CMD_STATUS]:   /** @this {ChipSet} */ function outPortD0(port, bOut, addrFrom) { this.outDMACmd(ChipSet.DMA1.INDEX, port, bOut, addrFrom); },
        [ChipSet.DMA1.PORT.REQUEST]:      /** @this {ChipSet} */ function outPortD2(port, bOut, addrFrom) { this.outDMAReq(ChipSet.DMA1.INDEX, port, bOut, addrFrom); },
        [ChipSet.DMA1.PORT.MASK]:         /** @this {ChipSet} */ function outPortD4(port, bOut, addrFrom) { this.outDMAMask(ChipSet.DMA1.INDEX, port, bOut, addrFrom); },
        [ChipSet.DMA1.PORT.MODE]:         /** @this {ChipSet} */ function outPortD6(port, bOut, addrFrom) { this.outDMAMode(ChipSet.DMA1.INDEX, port, bOut, addrFrom); },
        [ChipSet.DMA1.PORT.RESET_FF]:     /** @this {ChipSet} */ function outPortD8(port, bOut, addrFrom) { this.outDMAResetFF(ChipSet.DMA1.INDEX, port, bOut, addrFrom); },
        [ChipSet.DMA1.PORT.MASTER_CLEAR]: /** @this {ChipSet} */ function outPortDA(port, bOut, addrFrom) { this.outDMAMasterClear(ChipSet.DMA1.INDEX, port, bOut, addrFrom); },
        0xF0: ChipSet.prototype.outFPUClear,
        0xF1: ChipSet.prototype.outFPUReset
    };

    static aPortOutput6300 = {
        [ChipSet.C8041.PORT+0]: ChipSet.prototype.out8041Kbd,
        [ChipSet.C8041.PORT+1]: ChipSet.prototype.out8041Ctrl,
        [ChipSet.NMI.PORT]:     ChipSet.prototype.outNMI
    };

    static aPortOutputDeskPro386 = {
        [ChipSet.PIT1.PORT+0]: /** @this {ChipSet} */ function outPort48(port, bOut, addrFrom) { this.outTimer(ChipSet.PIT1.INDEX, ChipSet.PIT1.TIMER3, port, bOut, addrFrom); },
        [ChipSet.PIT1.PORT+1]: /** @this {ChipSet} */ function outPort49(port, bOut, addrFrom) { this.outTimer(ChipSet.PIT1.INDEX, ChipSet.PIT1.TIMER4, port, bOut, addrFrom); },
        [ChipSet.PIT1.PORT+2]: /** @this {ChipSet} */ function outPort4A(port, bOut, addrFrom) { this.outTimer(ChipSet.PIT1.INDEX, ChipSet.PIT1.TIMER5, port, bOut, addrFrom); },
        [ChipSet.PIT1.PORT+3]: /** @this {ChipSet} */ function outPort4B(port, bOut, addrFrom) { this.outTimerCtrl(ChipSet.PIT1.INDEX, port, bOut, addrFrom); }
    };
}

/**
 * Initialize every ChipSet module on the page.
 */
WebLib.onInit(ChipSet.init);

/**
 * @copyright https://www.pcjs.org/machines/pcx86/modules/v2/rom.js (C) 2012-2024 Jeff Parsons
 */

/**
 * @class ROMx86
 * @unrestricted (allows the class to define properties, both dot and named, outside of the constructor)
 *
 * NOTE: There's currently no need for this component to have a reset() function, since once the ROM data
 * is loaded, it can't be changed, so there's nothing to reinitialize.
 *
 * OK, well, I take that back, because the Debugger, if installed, has the ability to modify ROM contents,
 * so in that case, having a reset() function that restores the original ROM data might be useful; then again,
 * it might not, depending on what you're trying to debug.
 *
 * If we do add reset(), then we'll want to change copyROM() to hang onto the original ROM data; currently,
 * we release it after copying it into the read-only memory allocated via bus.addMemory().
 */
class ROMx86 extends Component {
    /**
     * ROM BIOS Data Area (RBDA) definitions, in physical address form, using the same CAPITALIZED names
     * found in the original IBM PC ROM BIOS listing.
     */
    static BIOS = {
        RS232_BASE:     0x400,              // ADDRESSES OF RS232 ADAPTERS (4 words)
        PRINTER_BASE:   0x408,              // ADDRESSES OF PRINTERS (4 words)
        EQUIP_FLAG: {                       // INSTALLED HARDWARE (word)
            ADDR:       0x410,
            NUM_PRINT:      0xC000,         // NUMBER OF PRINTERS ATTACHED
            GAME_CTRL:      0x1000,         // GAME I/O ATTACHED
            NUM_RS232:      0x0E00,         // NUMBER OF RS232 CARDS ATTACHED
            NUM_DRIVES:     0x00C0,         // NUMBER OF DISKETTE DRIVES (00=1, 01=2, 10=3, 11=4) ONLY IF IPL_DRIVE SET
            VIDEO_MODE:     0x0030,         // INITIAL VIDEO MODE (00=UNUSED, 01=40X25 COLOR, 10=80X25 COLOR, 11=80X25 MONO)
            RAM_SIZE:       0x000C,         // PLANAR RAM SIZE (00=16K,01=32K,10=48K,11=64K)
            IPL_DRIVE:      0x0001          // IPL (Initial Program Load) FROM DISKETTE (ie, diskette drives exist)
        },
        MFG_TEST:       0x412,              // INITIALIZATION FLAG (byte)
        MEMORY_SIZE:    0x413,              // MEMORY SIZE IN K BYTES (word)
        IO_RAM_SIZE:    0x415,              // PC: MEMORY IN I/O CHANNEL (word)
        MFG_ERR_FLAG:   0x415,              // PC AT: SCRATCHPAD FOR MANUFACTURING ERROR CODES (2 bytes)
        COMPAQ_PREV_SC: 0x415,              // COMPAQ DESKPRO 386: PREVIOUS SCAN CODE (byte)
        COMPAQ_KEYCLICK:0x416,              // COMPAQ DESKPRO 386: KEYCLICK LOUDNESS (byte)
        /**
         * KEYBOARD DATA AREAS
         */
        KB_FLAG: {                          // FIRST BYTE OF KEYBOARD STATUS (byte)
            ADDR:       0x417,              //
            INS_STATE:      0x80,           // INSERT STATE IS ACTIVE
            CAPS_STATE:     0x40,           // CAPS LOCK STATE HAS BEEN TOGGLED
            NUM_STATE:      0x20,           // NUM LOCK STATE HAS BEEN TOGGLED
            SCROLL_STATE:   0x10,           // SCROLL LOCK STATE HAS BEEN TOGGLED
            ALT_SHIFT:      0x08,           // ALTERNATE SHIFT KEY DEPRESSED
            CTL_SHIFT:      0x04,           // CONTROL SHIFT KEY DEPRESSED
            LEFT_SHIFT:     0x02,           // LEFT SHIFT KEY DEPRESSED
            RIGHT_SHIFT:    0x01            // RIGHT SHIFT KEY DEPRESSED
        },
        KB_FLAG_1: {                        // SECOND BYTE OF KEYBOARD STATUS (byte)
            ADDR:       0x418,              //
            INS_SHIFT:      0x80,           // INSERT KEY IS DEPRESSED
            CAPS_SHIFT:     0x40,           // CAPS LOCK KEY IS DEPRESSED
            NUM_SHIFT:      0x20,           // NUM LOCK KEY IS DEPRESSED
            SCROLL_SHIFT:   0x10,           // SCROLL LOCK KEY IS DEPRESSED
            HOLD_STATE:     0x08            // SUSPEND KEY HAS BEEN TOGGLED
        },
        ALT_INPUT:      0x419,              // STORAGE FOR ALTERNATE KEYPAD ENTRY (byte)
        BUFFER_HEAD:    0x41A,              // POINTER TO HEAD OF KEYBOARD BUFFER (word)
        BUFFER_TAIL:    0x41C,              // POINTER TO TAIL OF KEYBOARD BUFFER (word)
        KB_BUFFER:      0x41E,              // ROOM FOR 15 ENTRIES (16 words)
        KB_BUFFER_END:  0x43E,              // HEAD = TAIL INDICATES THAT THE BUFFER IS EMPTY
        /**
         * DISKETTE DATA AREAS
         */
        SEEK_STATUS: {                      // DRIVE RECALIBRATION STATUS (byte)
            ADDR:       0x43E,              //
                                            //      BIT 3-0 = DRIVE 3-0 NEEDS RECAL BEFORE
                                            //      NEXT SEEK IF BIT IS = 0
            INT_FLAG:       0x80,           // INTERRUPT OCCURRENCE FLAG
        },
        MOTOR_STATUS:   0x43F,              // MOTOR STATUS (byte)
                                            //      BIT 3-0 = DRIVE 3-0 IS CURRENTLY RUNNING
                                            //      BIT 7 = CURRENT OPERATION IS A WRITE, REQUIRES DELAY
        MOTOR_COUNT:    0x440,              // TIME OUT COUNTER FOR DRIVE TURN OFF
                                            //      37 == TWO SECONDS OF COUNTS FOR MOTOR TURN OFF
        DISKETTE_STATUS: {                  // SINGLE BYTE OF RETURN CODE INFO FOR STATUS
            ADDR:       0x441,
            TIME_OUT:       0x80,           // ATTACHMENT FAILED TO RESPOND
            BAD_SEEK:       0x40,           // SEEK OPERATION FAILED
            BAD_NEC:        0x20,           // NEC CONTROLLER HAS FAILED
            BAD_CRC:        0x10,           // BAD CRC ON DISKETTE READ
            DMA_BOUNDARY:   0x09,           // ATTEMPT TO DMA ACROSS 64K BOUNDARY
            BAD_DMA:        0x08,           // DMA OVERRUN ON OPERATION
            RECORD_NOT_FND: 0x04,           // REQUESTED SECTOR NOT FOUND
            WRITE_PROTECT:  0x03,           // WRITE ATTEMPTED ON WRITE PROT DISK
            BAD_ADDR_MARK:  0x02,           // ADDRESS MARK NOT FOUND
            BAD_CMD:        0x01            // BAD COMMAND PASSED TO DISKETTE I/O
        },
        NEC_STATUS:     0x442,              // STATUS BYTES FROM NEC (7 bytes)
        /**
         * VIDEO DISPLAY DATA AREA
         */
        CRT_MODE:       0x449,              // CURRENT CRT MODE (byte)
        CRT_COLS:       0x44A,              // NUMBER OF COLUMNS ON SCREEN (word)
        CRT_LEN:        0x44C,              // LENGTH OF REGEN IN BYTES (word)
        CRT_START:      0x44E,              // STARTING ADDRESS IN REGEN BUFFER (word)
        CURSOR_POSN:    0x450,              // CURSOR FOR EACH OF UP TO 8 PAGES (8 words)
        CURSOR_MODE:    0x460,              // CURRENT CURSOR MODE SETTING (word)
        ACTIVE_PAGE:    0x462,              // CURRENT PAGE BEING DISPLAYED (byte)
        ADDR_6845:      0x463,              // BASE ADDRESS FOR ACTIVE DISPLAY CARD (word)
        CRT_MODE_SET:   0x465,              // CURRENT SETTING OF THE 3X8 REGISTER (byte)
        CRT_PALLETTE:   0x466,              // CURRENT PALLETTE SETTING COLOR CARD (byte)
        /**
         * CASSETTE DATA AREA
         */
        EDGE_CNT:       0x467,              // PC: TIME COUNT AT DATA EDGE (word)
        CRC_REG:        0x469,              // PC: CRC REGISTER (word)
        LAST_VAL:       0x46B,              // PC: LAST INPUT VALUE (byte)
        IO_ROM_INIT:    0x467,              // PC AT: POINTER TO ROM INITIALIZATION ROUTINE
        IO_ROM_SEG:     0x469,              // PC AT: POINTER TO I/O ROM SEGMENT
        INTR_FLAG:      0x46B,              // PC AT: FLAG INDICATING AN INTERRUPT HAPPENED
        /**
         * TIMER DATA AREA
         */
        TIMER_LOW:      0x46C,              // LOW WORD OF TIMER COUNT (word)
        TIMER_HIGH:     0x46E,              // HIGH WORD OF TIMER COUNT (word)
        TIMER_OFL:      0x470,              // TIMER HAS ROLLED OVER SINCE LAST READ (byte)
        /**
         * SYSTEM DATA AREA
         */
        BIOS_BREAK:     0x471,              // BIT 7 = 1 IF BREAK KEY HAS BEEN DEPRESSED (byte)
        /**
         * RESET_FLAG is the traditional end of the RBDA, as originally defined by the IBM PC
         */
        RESET_FLAG: {
            ADDR:       0x472,              // SET TO 0x1234 IF KEYBOARD RESET UNDERWAY (word)
            WARMBOOT:       0x1234          // this value indicates a "warm boot", bypassing memory tests
        },
        /**
         * FIXED DISK DATA AREAS
         */
        DISK_STATUS1:   0x474,              // PC AT: FIXED DISK STATUS (byte)
        HF_NUM:         0x475,              // PC AT: COUNT OF FIXED DISK DRIVES (byte)
        CONTROL_BYTE:   0x476,              // PC AT: HEAD CONTROL BYTE (byte)
        PORT_OFF:       0x477,              // PC AT: RESERVED (PORT OFFSET) (byte)
        /**
         * TIME-OUT VARIABLES
         */
        PRINT_TIM_OUT:  0x478,              // PC AT: TIME OUT COUNTERS FOR PRINTER RESPONSE (4 bytes)
        RS232_TIM_OUT:  0x47C,              // PC AT: TIME OUT COUNTERS FOR RS232 RESPONSE (4 bytes)
        /**
         * ADDITIONAL KEYBOARD DATA AREA
         */
        BUFFER_START:   0x480,              // PC AT: OFFSET OF KEYBOARD BUFFER START WITHIN SEGMENT 40H
        BUFFER_END:     0x482,              // PC AT: OFFSET OF END OF BUFFER
        /**
         * EGA/PGA DISPLAY WORK AREA
         */
        ROWS:           0x484,              // PC AT: ROWS ON THE ACTIVE SCREEN (LESS 1) (byte)
        POINTS:         0x485,              // PC AT: BYTES PER CHARACTER (word)
        INFO:           0x487,              // PC AT: MODE OPTIONS (byte)
        /**
         * INFO BITS:
         *
         *      0x80: HIGH BIT OF MODE SET, CLEAR/NOT CLEAR REGEN
         *      0x60: 256K OF VRAM
         *      0x40: 192K OF VRAM
         *      0x20: 128K OF VRAM
         *      0x10: RESERVED
         *      0x08: EGA ACTIVE MONITOR (0), EGA NOT ACTIVE (1)
         *      0x04: WAIT FOR DISPLAY ENABLE (1)
         *      0x02: EGA HAS A MONOCHROME ATTACHED
         *      0x01: SET C_TYPE EMULATE ACTIVE (0)
         */
        INFO_3:         0x488,              // PC AT: FEATURE BIT SWITCHES (1 byte, plus 2 reserved bytes)
        /**
         *     40:88  byte  PCjr: third keyboard status byte
         *                  EGA feature bit switches, emulated on VGA
         *
         *         |7|6|5|4|3|2|1|0| EGA feature bit switches (EGA+)
         *          | | | | | | | `-- EGA SW1 config (1=off)
         *          | | | | | | `--- EGA SW2 config (1=off)
         *          | | | | | `---- EGA SW3 config (1=off)
         *          | | | | `----- EGA SW4 config (1=off)
         *          | | | `------ Input FEAT0 (ISR0 bit 5) after output on FCR0
         *          | | `------- Input FEAT0 (ISR0 bit 6) after output on FCR0
         *          | `-------- Input FEAT1 (ISR0 bit 5) after output on FCR1
         *          `--------- Input FEAT1 (ISR0 bit 6) after output on FCR1
         *
         *     40:89  byte  Video display data area (MCGA and VGA)
         *
         *         |7|6|5|4|3|2|1|0| Video display data area (MCGA and VGA)
         *          | | | | | | | `-- 1=VGA is active
         *          | | | | | | `--- 1=gray scale is enabled
         *          | | | | | `---- 1=using monochrome monitor
         *          | | | | `----- 1=default palette loading is disabled
         *          | | | `------ see table below
         *          | | `------- reserved
         *          | `--------  1=display switching enabled
         *          `--------- alphanumeric scan lines (see table below)
         *
         *           Bit7    Bit4   Scan Lines
         *             0       0    350 line mode
         *             0       1    400 line mode
         *             1       0    200 line mode
         *             1       1    reserved
         */
        /**
         * ADDITIONAL MEDIA DATA
         */
        LASTRATE:       0x48B,              // PC AT: LAST DISKETTE DATA RATE SELECTED (byte)
        HF_STATUS:      0x48C,              // PC AT: STATUS REGISTER (byte)
        HF_ERROR:       0x48D,              // PC AT: ERROR REGISTER (byte)
        HF_INT_FLAG:    0x48E,              // PC AT: FIXED DISK INTERRUPT FLAG (byte)
        HF_CNTRL:       0x48F,              // PC AT: COMBO FIXED DISK/DISKETTE CARD BIT 0=1 (byte)
        DSK_STATE:      0x490,              // PC AT: DRIVE 0/1 MEDIA/OPERATION STATES (4 bytes)
        DSK_TRK:        0x494,              // PC AT: DRIVE 0/1 PRESENT CYLINDER (2 bytes)
        /**
         * ADDITIONAL KEYBOARD FLAGS
         */
        KB_FLAG_3: {
            ADDR:       0x496,              // PC AT: KEYBOARD MODE STATE AND TYPE FLAGS (byte)
            LC_E1:          0b00000001,     // LAST CODE WAS THE E1 HIDDEN CODE
            LC_E0:          0b00000010,     // LAST CODE WAS THE E0 HIDDEN CODE
            R_CTL_SHIFT:    0b00000100,     // RIGHT CTL KEY DOWN
            R_ALT_SHIFT:    0b00001000,     // RIGHT ALT KEY DOWN
            GRAPH_ON:       0b00001000,     // ALT GRAPHICS KEY DOWN (WT ONLY)
            KBX:            0b00010000,     // ENHANCED KEYBOARD INSTALLED
            SET_NUM_LK:     0b00100000,     // FORCE NUM LOCK IF READ ID AND KBX
            LC_AB:          0b01000000,     // LAST CHARACTER WAS FIRST ID CHARACTER
            RD_ID:          0b10000000      // DOING A READ ID (MUST BE BIT0)
        },
        KB_FLAG_2: {
            ADDR:       0x497,              // PC AT: KEYBOARD LED FLAGS (byte)
            KB_LEDS:        0b00000111,     // KEYBOARD LED STATE BITS
            SCROLL_LOCK:    0b00000001,     // SCROLL LOCK INDICATOR
            NUM_LOCK:       0b00000010,     // NUM LOCK INDICATOR
            CAPS_LOCK:      0b00000100,     // CAPS LOCK INDICATOR
            KB_FA:          0b00010000,     // ACKNOWLEDGMENT RECEIVED
            KB_FE:          0b00100000,     // RESEND RECEIVED FLAG
            KB_PR_LED:      0b01000000,     // MODE INDICATOR UPDATE
            KB_ERR:         0b10000000      // KEYBOARD TRANSMIT ERROR FLAG
        },
        /**
         * REAL TIME CLOCK DATA AREA
         */
        USER_FLAG:      0x498,              // PC AT: OFFSET ADDRESS OF USERS WAIT FLAG (word)
        USER_FLAG_SEG:  0x49A,              // PC AT: SEGMENT ADDRESS OF USER WAIT FLAG (word)
        RTC_LOW:        0x49C,              // PC AT: LOW WORD OF USER WAIT FLAG (word)
        RTC_HIGH:       0x49E,              // PC AT: HIGH WORD OF USER WAIT FLAG (word)
        RTC_WAIT_FLAG:  0x4A0,              // PC AT: WAIT ACTIVE FLAG (01=BUSY, 80=POSTED, 00=POST ACKNOWLEDGED) (byte)
        /**
         * AREA FOR NETWORK ADAPTER
         */
        NET:            0x4A1,              // PC AT: RESERVED FOR NETWORK ADAPTERS (7 bytes)
        /**
         * EGA/PGA PALETTE POINTER
         */
        SAVE_PTR:       0x4A8,              // PC AT: POINTER TO EGA PARAMETER CONTROL BLOCK (2 words)
        /**
         * DATA AREA - PRINT SCREEN
         */
        STATUS_BYTE:    0x500               // PRINT SCREEN STATUS BYTE (00=READY/OK, 01=BUSY, FF=ERROR) (byte)
    };

    /**
     * ROMx86(parmsROM)
     *
     * The ROMx86 component expects the following (parmsROM) properties:
     *
     *      addr: physical address of ROM
     *      size: amount of ROM, in bytes
     *      alias: physical alias address (null if none)
     *      file: name of ROM data file
     *      notify: ID of a component to notify once the ROM is in place (optional)
     *
     * NOTE: The ROM data will not be copied into place until the Bus is ready (see initBus()) AND the
     * ROM data file has finished loading (see doneLoad()).
     *
     * Also, while the size parameter may seem redundant, I consider it useful to confirm that the ROM you received
     * is the ROM you expected.
     *
     * @this {ROMx86}
     * @param {Object} parmsROM
     */
    constructor(parmsROM)
    {
        super("ROMx86", parmsROM, MESSAGE.MEM);

        this.abROM = null;
        this.addrROM = +parmsROM['addr'];       // we allow numbers or strings (JSON strings permit hex)
        this.sizeROM = +parmsROM['size'];       // we allow numbers or strings (JSON strings permit hex)

        /**
         * The new 'alias' property can now be EITHER a single physical address (like 'addr') OR an array of
         * physical addresses; eg:
         *
         *      [0xf0000,0xffff0000,0xffff8000]
         *
         * We could have overloaded 'addr' to accomplish the same thing, but I think it's better to have any
         * aliased locations listed under a separate property.
         *
         * Most ROMs are not aliased, in which case the 'alias' property should have the default value of null.
         */
        this.addrAlias = parmsROM['alias'];
        if (typeof this.addrAlias == "string") {
            if (this.addrAlias[0] != '[') {
                this.addrAlias = +this.addrAlias;
            } else {
                this.addrAlias = eval(this.addrAlias);
            }
        }

        /**
         * The 'notify' property can now (as of v1.18.2) contain an array of parameters that the notified
         * component (typically Video) may use as it sees fit.  For example, the Video component is generally
         * interested in knowing the offsets of specific font tables within the ROM, which used to be hard-coded
         * when all we supported were a few specific IBM video cards, but that's no longer feasible as we move
         * beyond the original handful of IBM cards.
         *
         * It's up to the notified component to decide how to interpret the parameters it receives, if any.
         */
        this.idNotify = parmsROM['notify'];
        this.aNotifyParms = null;
        if (this.idNotify) {
            let i = this.idNotify.indexOf('[');
            if (i > 0) {
                try {
                    this.aNotifyParms = eval(this.idNotify.substr(i));
                } catch (e) {}
                this.idNotify = this.idNotify.substr(0, i);
            }
        }

        this.sFileURL = this.sFilePath = parmsROM['file'];

        if (this.sFileURL) {
            let sFileName = StrLib.getBaseName(this.sFileURL);
            if (DEBUG) this.printf(MESSAGE.LOG, "load(\"%s\")\n", this.sFileURL);
            /**
             * If the selected ROM file has a ".json" extension, then we assume it's pre-converted
             * JSON-encoded ROM data, so we load it as-is; ditto for ROM files with a ".hex" extension.
             * Otherwise, we ask our server-side ROM converter to return the file in a JSON-compatible format.
             */
            let sFileExt = StrLib.getExtension(sFileName);
            if (sFileExt != DumpAPI.FORMAT.JSON && sFileExt != DumpAPI.FORMAT.HEX) {
                this.sFileURL = WebLib.getHostOrigin() + DumpAPI.ENDPOINT + '?' + DumpAPI.QUERY.FILE + '=' + this.sFilePath + '&' + DumpAPI.QUERY.FORMAT + '=' + DumpAPI.FORMAT.BYTES + '&' + DumpAPI.QUERY.DECIMAL + '=true';
            }
        }
    }

    /**
     * initBus(cmp, bus, cpu, dbg)
     *
     * @this {ROMx86}
     * @param {Computer} cmp
     * @param {Busx86} bus
     * @param {CPUx86} cpu
     * @param {Debuggerx86} dbg
     */
    initBus(cmp, bus, cpu, dbg)
    {
        this.cmp = cmp;
        this.bus = bus;
        this.cpu = cpu;
        this.dbg = dbg;

        if (this.sFileURL) {
            let rom = this;
            WebLib.getResource(this.sFileURL, null, true, function doneROMLoad(sURL, sResponse, nErrorCode) {
                rom.doneLoad(sURL, sResponse, nErrorCode);
            }, function(nState) {
                rom.printf(MESSAGE.PROGRESS, "Loading %s...\n", rom.sFileURL);
            });
        }
    }

    /**
     * powerUp(data, fRepower)
     *
     * @this {ROMx86}
     * @param {Object|null} data
     * @param {boolean} [fRepower]
     * @returns {boolean} true if successful, false if failure
     */
    powerUp(data, fRepower)
    {
        if (this.aSymbols) {
            if (this.dbg) {
                this.dbg.addSymbols(this.id, 0, this.addrROM >>> 4, 0, this.addrROM, this.sizeROM, this.aSymbols);
            }
            /**
             * Our only role in the handling of symbols is to hand them off to the Debugger at our
             * first opportunity. Now that we've done that, our copy of the symbols, if any, are toast.
             */
            delete this.aSymbols;
        }
        return true;
    }

    /**
     * powerDown(fSave, fShutdown)
     *
     * Since we have nothing to do on powerDown(), and no state to return, we could simply omit
     * this function.  But it doesn't hurt anything, and maybe we'll use our state to save something
     * useful down the road, like user-defined symbols (ie, symbols that the Debugger may have
     * created, above and beyond those symbols we automatically loaded, if any, along with the ROM).
     *
     * @this {ROMx86}
     * @param {boolean} [fSave]
     * @param {boolean} [fShutdown]
     * @returns {Object|boolean} component state if fSave; otherwise, true if successful, false if failure
     */
    powerDown(fSave, fShutdown)
    {
        return true;
    }

    /**
     * doneLoad(sURL, sROMData, nErrorCode)
     *
     * @this {ROMx86}
     * @param {string} sURL
     * @param {string} sROMData
     * @param {number} nErrorCode (response from server if anything other than 200)
     */
    doneLoad(sURL, sROMData, nErrorCode)
    {
        if (nErrorCode) {
            this.printf(nErrorCode < 0? MESSAGE.STATUS : MESSAGE.NOTICE, "Unable to load system ROM (error %d: %s)\n", nErrorCode, sURL);
            return;
        }

        Component.addMachineResource(this.idMachine, sURL, sROMData);

        /**
         * Check for JSON formats first.
         */
        if (sROMData.charAt(0) == "[" || sROMData.charAt(0) == "{") {
            try {
                /**
                 * The most likely source of any exception will be here: parsing the JSON-encoded ROM data.
                 */
                let rom = eval("(" + sROMData + ")");

                /**
                 * PCjs v2 ROM images contain, at a minimum, a 'width' value and a 'values' array, along with
                 * other optional properties, like default load address ('addr'), endianness ('littleEndian'), etc.
                 *
                 * So we'll start with that and fall back to 8-bit 'bytes' or 32-bit 'longs' (or worst-case, 'data',
                 * but the length of 'data' values varied according to the machine architecture, so the introduction
                 * of 'data' was a "bit" ill-advised).
                 */
                let width = rom['width'];
                let values = rom['values'];
                let littleEndian = (rom['littleEndian'] !== false);
                if (!width || !values) {
                    width = 0;
                    if ((values = rom['bytes'])) {
                        width = 8;
                    }
                    else if ((values = rom['longs'] || rom['data'])) {
                        width = 32;
                    }
                }
                /**
                 * Convert all values to bytes, so that subsequent code has a simple and consistent data format: abROM.
                 */
                if (width) {
                    if (width == 8) {
                        this.abROM = values;
                    } else {
                        let bpv = width >>> 3;
                        this.abROM = new Array(values.length * bpv);
                        for (let i = 0, ib = 0; i < values.length; i++) {
                            let v = values[i];
                            if (littleEndian) {
                                for (let b = 0; b < bpv; b++) {
                                    this.abROM[ib + b] = v & 0xff;
                                    v >>>= 8;
                                }
                            } else {
                                for (let b = bpv - 1; b >= 0; b--) {
                                    this.abROM[ib + b] = v & 0xff;
                                    v >>>= 8;
                                }
                            }
                            ib += bpv;
                        }
                    }
                }
                else {
                    this.abROM = rom;
                }

                this.aSymbols = rom['symbols'];

                if (!this.abROM.length) {
                    Component.error("Empty ROM: " + sURL);
                    return;
                }
                else if (this.abROM.length == 1) {
                    Component.error(this.abROM[0]);
                    return;
                }
            } catch (e) {
                this.printf(MESSAGE.NOTICE, "ROM data error: %s\n", e.message);
                return;
            }
        }
        else {
            /**
             * Parse the ROM data manually; we assume it's in "simplified" hex form (a series of hex byte-values
             * separated by whitespace).
             */
            let sHexData = sROMData.replace(/\n/gm, " ").replace(/ +$/, "");
            let asHexData = sHexData.split(" ");
            this.abROM = new Array(asHexData.length);
            for (let i = 0; i < asHexData.length; i++) {
                this.abROM[i] = StrLib.parseInt(asHexData[i], 16);
            }
        }
        this.copyROM();
    }

    /**
     * copyROM()
     *
     * This function is called by both initBus() and doneLoad(), but it cannot copy the the ROM data into place
     * until after initBus() has received the Bus component AND doneLoad() has received the abROM data.  When both
     * those criteria are satisfied, the component becomes "ready".
     *
     * @this {ROMx86}
     */
    copyROM()
    {
        if (!this.isReady()) {
            if (!this.sFilePath) {
                this.setReady();
            }
            else if (this.abROM && this.bus) {
                /**
                 * If no explicit size was specified, then use whatever the actual size is.
                 */
                if (!this.sizeROM) {
                    this.sizeROM = this.abROM.length;
                }
                if (this.abROM.length != this.sizeROM) {
                    /**
                     * Note that setError() sets the component's fError flag, which in turn prevents setReady() from
                     * marking the component ready.  TODO: Revisit this decision.  On the one hand, it sounds like a
                     * good idea to stop the machine in its tracks whenever a setError() occurs, but there may also be
                     * times when we'd like to forge ahead anyway.
                     */
                    this.setError("ROM size (" + StrLib.toHexLong(this.abROM.length) + ") does not match specified size (" + StrLib.toHexLong(this.sizeROM) + ")");
                }
                else if (this.addROM(this.addrROM)) {

                    let aliases = [];
                    if (typeof this.addrAlias == "number") {
                        aliases.push(this.addrAlias);
                    } else if (this.addrAlias != null && this.addrAlias.length) {
                        aliases = this.addrAlias;
                    }
                    for (let i = 0; i < aliases.length; i++) {
                        this.cloneROM(aliases[i]);
                    }
                    /**
                     * If there's a component we should notify, notify it now, and give it the internal byte array, so that
                     * it doesn't have to ask the CPU for the data.  Currently, the only component that uses this notification
                     * option is the Video component, and only when the associated ROM contains font data that it needs.
                     */
                    if (this.idNotify) {
                        let component = Component.getComponentByID(this.idNotify, this.id);
                        if (component) {
                            component.onROMLoad(this.abROM, this.aNotifyParms);
                        } else {
                            this.printf(MESSAGE.NOTICE, "Unable to find component: %s\n", this.idNotify);
                        }
                    }
                    /**
                     * We used to hang onto the original ROM data so that we could restore any bytes the CPU overwrote,
                     * using memory write-notification handlers, but with the introduction of read-only memory blocks, that's
                     * no longer necessary.
                     *
                     * TODO: Consider an option to retain the ROM data, and give the user some way of restoring ROMs.
                     * That may be useful for "resumable" machines that save/restore all dirty block of memory, regardless
                     * whether they're ROM or RAM.  However, the only way to modify a machine's ROM is with the Debugger,
                     * and Debugger users should know better.
                     */
                    delete this.abROM;
                }
                this.setReady();
            }
        }
    }

    /**
     * addROM(addr)
     *
     * @this {ROMx86}
     * @param {number} addr
     * @returns {boolean}
     */
    addROM(addr)
    {
        if (this.bus.addMemory(addr, this.sizeROM, Memoryx86.TYPE.ROM)) {
            if (MAXDEBUG) this.printf(MESSAGE.LOG, "addROM(%#010x): copying %#06x bytes\n", addr, this.abROM.length);
            let bto = null;
            for (let off = 0; off < this.abROM.length; off++) {
                this.bus.setByteDirect(addr + off, this.abROM[off]);
                if (BACKTRACK) {
                    bto = this.bus.addBackTrackObject(this, bto, off);
                    this.bus.writeBackTrackObject(addr + off, bto, off);
                }
            }
            return true;
        }
        /**
         * We don't need to report an error here, because addMemory() already takes care of that.
         */
        return false;
    }

    /**
     * cloneROM(addr)
     *
     * For ROMs with one or more alias addresses, we used to call addROM() for each address.  However,
     * that obviously wasted memory, since each alias was an independent copy, and if you used the
     * Debugger to edit the ROM in one location, the changes would not appear in the other location(s).
     *
     * Now that the Bus component provides low-level getMemoryBlocks() and setMemoryBlocks() methods
     * to manually get and set the blocks of any memory range, it is now possible to create true aliases.
     *
     * @this {ROMx86}
     * @param {number} addr
     */
    cloneROM(addr)
    {
        let aBlocks = this.bus.getMemoryBlocks(this.addrROM, this.sizeROM);
        this.bus.setMemoryBlocks(addr, this.sizeROM, aBlocks);
    }

    /**
     * ROMx86.init()
     *
     * This function operates on every HTML element of class "rom", extracting the
     * JSON-encoded parameters for the ROM constructor from the element's "data-value"
     * attribute, invoking the constructor to create a ROM component, and then binding
     * any associated HTML controls to the new component.
     */
    static init()
    {
        let aeROM = Component.getElementsByClass(APPCLASS, "rom");
        for (let iROM = 0; iROM < aeROM.length; iROM++) {
            let eROM = aeROM[iROM];
            let parmsROM = Component.getComponentParms(eROM);
            let rom = new ROMx86(parmsROM);
            Component.bindComponentControls(rom, eROM, APPCLASS);
        }
    }
}

/**
 * Initialize all the ROM modules on the page.
 */
WebLib.onInit(ROMx86.init);

/**
 * @copyright https://www.pcjs.org/machines/pcx86/modules/v2/ram.js (C) 2012-2024 Jeff Parsons
 */

/**
 * @class RAMx86
 * @unrestricted (allows the class to define properties, both dot and named, outside of the constructor)
 */
class RAMx86 extends Component {
    /**
     * RAMx86(parmsRAM)
     *
     * The RAMx86 component expects the following (parmsRAM) properties:
     *
     *      addr: starting physical address of RAM (default is 0)
     *      size: amount of RAM, in bytes (default is 0, which means defer to motherboard switch settings)
     *      test: true (default) means don't interfere with any BIOS memory tests, false means "fake a warm boot"
     *
     * The 'test' parm can also be overridden by the machine-specific 'testRAM' parm.
     *
     * NOTE: We make a note of the specified size, but no memory is initially allocated for the RAM until the
     * Computer component calls powerUp().
     *
     * @this {RAMx86}
     * @param {Object} parmsRAM
     */
    constructor(parmsRAM)
    {
        super("RAMx86", parmsRAM);

        this.addrRAM = +parmsRAM['addr'];       // we allow numbers or strings (JSON strings permit hex)
        this.sizeRAM = +parmsRAM['size'];       // we allow numbers or strings (JSON strings permit hex)
        this.fTestRAM = parmsRAM['test'] && parmsRAM['test'] != "false";
        this.fInstalled = (!!this.sizeRAM);     // 0 is the default value for 'size' when none is specified
        this.sizeOverride = 0;
        this.fAllocated = false;
    }

    /**
     * setBinding(sHTMLType, sBinding, control, sValue)
     *
     * @this {RAMx86}
     * @param {string} sHTMLType is the type of the HTML control (eg, "button", "list", "text", "submit", "textarea", "canvas")
     * @param {string} sBinding is the value of the 'binding' parameter stored in the HTML control's "data-value" attribute (eg, "size")
     * @param {HTMLElement} control is the HTML control DOM object (eg, HTMLButtonElement)
     * @param {string} [sValue] optional data value
     * @returns {boolean} true if binding was successful, false if unrecognized binding request
     */
    setBinding(sHTMLType, sBinding, control, sValue)
    {
        let id = sBinding;
        if (this.bindings[id] === undefined) {
            switch (sBinding) {
            case "listSizes":
                this.bindings[id] = control;
                return true;
            }
        }
        return false;
    }

    /**
     * displayRAMSetting()
     *
     * @this {RAMx86}
     */
    displayRAMSetting()
    {
        let list = this.bindings["listSizes"];
        if (list) {
            for (let i = 1; i < list.options.length; i++) {
                if (+list.options[i].value == this.sizeRAM) {
                    if (list.selectedIndex != i) {
                        list.selectedIndex = i;
                    }
                    break;
                }
            }
        }
    }

    /**
     * getRAMSetting()
     *
     * @this {RAMx86}
     * @returns {number} (user-selected RAM setting, 0 for default, or -1 if none)
     */
    getRAMSetting()
    {
        let size = this.sizeOverride || -1;
        let list = this.bindings["listSizes"];
        if (list) {
            if (size > 0) {
                list.options[0].value = size.toString();
            }
            size = +list.options[list.selectedIndex].value;
        }
        return size;
    }

    /**
     * initBus(cmp, bus, cpu, dbg)
     *
     * @this {RAMx86}
     * @param {Computer} cmp
     * @param {Busx86} bus
     * @param {CPUx86} cpu
     * @param {Debuggerx86} dbg
     */
    initBus(cmp, bus, cpu, dbg)
    {
        this.bus = bus;
        this.cpu = cpu;
        this.dbg = dbg;
        this.chipset = cmp.getMachineComponent("ChipSet");
        this.fTestRAM = cmp.getMachineBoolean('testRAM', this.fTestRAM);
        this.sizeOverride = +cmp.getMachineParm('sizeRAM') || 0;
        if (this.sizeOverride < 1024) this.sizeOverride *= 1024;
        this.setReady();
    }

    /**
     * powerUp(data, fRepower)
     *
     * @this {RAMx86}
     * @param {Object|null} data
     * @param {boolean} [fRepower]
     * @returns {boolean} true if successful, false if failure
     */
    powerUp(data, fRepower)
    {
        if (!fRepower) {
            /**
             * The Computer powers up the CPU last, at which point CPUx86 state is restored,
             * which includes the Bus state, and since we use the Bus to allocate all our memory,
             * memory contents are already restored for us, so we don't need the usual restore
             * logic.  We just need to call reset(), to allocate memory for the RAM.
             *
             * The only exception is when there's a custom Memory controller (eg, CompaqController).
             */
            this.reset();
            if (data && this.controller) {
                if (!this.restore(data)) return false;
            }
        }
        return true;
    }

    /**
     * powerDown(fSave, fShutdown)
     *
     * @this {RAMx86}
     * @param {boolean} [fSave]
     * @param {boolean} [fShutdown]
     * @returns {Object|boolean} component state if fSave; otherwise, true if successful, false if failure
     */
    powerDown(fSave, fShutdown)
    {
        /**
         * The Computer powers down the CPU first, at which point CPUx86 state is saved,
         * which includes the Bus state, and since we use the Bus component to allocate all
         * our memory, memory contents are already saved for us, so we don't need the usual
         * save logic.
         *
         * The only exception is when there's a custom Memory controller (eg, CompaqController).
         */
        return (fSave && this.controller)? this.save() : true;
    }

    /**
     * reset()
     *
     * NOTE: When we were initialized, we were given an amount of INSTALLED memory (see sizeRAM above).
     * The ChipSet component, on the other hand, tells us how much SPECIFIED memory there is -- which,
     * like a real PC, may not match the amount of installed memory (due to either user error or perhaps
     * an attempt to prevent some portion of the installed memory from being used).
     *
     * However, since we're a virtual machine, we can defer allocation of RAM until we're able to query the
     * ChipSet component, and then allocate an amount of memory that matches the SPECIFIED memory, making
     * it easy to reconfigure the machine on the fly and prevent mismatches.
     *
     * But, we do that ONLY for the RAM instance configured with an addrRAM of 0x0000, and ONLY if that RAM
     * object was not given a specific size (see fInstalled).  If there are other RAM objects in the system,
     * they must necessarily specify a non-conflicting, non-zero start address, in which case their sizeRAM
     * value will never be affected by the ChipSet settings.
     *
     * @this {RAMx86}
     */
    reset()
    {
        if (!this.addrRAM && !this.fInstalled && this.chipset) {
            let baseRAM = this.getRAMSetting();
            if (baseRAM > 0) {
                this.chipset.setDIPMemorySize(baseRAM / 1024);
            } else {
                /**
                 * If the user-defined RAM setting is zero, that maps to "Default", so this passes true to
                 * getDIPMemorySize() to get the initial DIP switch setting; otherwise, we get the current setting.
                 */
                baseRAM = this.chipset.getDIPMemorySize(baseRAM == 0) * 1024;
            }
            if (this.sizeRAM && baseRAM != this.sizeRAM) {
                this.bus.removeMemory(this.addrRAM, this.sizeRAM);
                this.fAllocated = false;
            }
            this.sizeRAM = baseRAM;
        }

        this.displayRAMSetting();

        if (!this.fAllocated && this.sizeRAM) {
            if (this.bus.addMemory(this.addrRAM, this.sizeRAM, Memoryx86.TYPE.RAM)) {
                this.fAllocated = true;

                /**
                 * NOTE: I'm specifying MAXDEBUG for STATUS messages because I'm not yet sure I want these
                 * messages buried in the app, since they're seen only when a Control Panel is active.  Another
                 * and perhaps better alternative is to add "comment" attributes to the XML configuration file
                 * for these components, which the Computer component will display as it "powers up" components.
                 */
                if (MAXDEBUG && !this.addrRAM && this.fInstalled) {
                    this.printf(MESSAGE.STATUS, "specified size overrides SW1\n");
                }

                /**
                 * Memory with an ID of "ramCPQ" is reserved for built-in memory located just below the 16Mb
                 * boundary on COMPAQ DeskPro 386 machines.
                 *
                 * Technically, that memory is part of the first 1Mb of memory that also provides up to 640Kb
                 * of conventional memory (ie, memory below 1Mb).
                 *
                 * However, PCx86 doesn't support individual memory allocations that (a) are discontiguous
                 * or (b) dynamically change location.  Components must simulate those features by performing
                 * a separate allocation for each starting address, and removing/adding memory allocations
                 * whenever their starting address changes.
                 *
                 * Therefore, a DeskPro 386's first 1Mb of physical memory is allocated by PCx86 in two pieces,
                 * and the second piece must have an ID of "ramCPQ", triggering the additional allocation of
                 * COMPAQ-specific memory-mapped registers.
                 *
                 * See CompaqController for more details.
                 */
                if (DESKPRO386) {
                    if (this.idComponent == "ramCPQ") {
                        this.controller = new CompaqController(this);
                        this.bus.addMemory(CompaqController.ADDR, 4, Memoryx86.TYPE.CTRL, this.controller);
                    }
                }
            }
        }
        if (this.fAllocated) {
            if (!this.addrRAM && !this.fTestRAM) {
                /**
                 * HACK: Set the word at 40:72 in the ROM BIOS Data Area (RBDA) to 0x1234 to bypass the ROM BIOS
                 * memory storage tests. See rom.js for more RBDA definitions.
                 */
                if (MAXDEBUG) {
                    this.printf(MESSAGE.STATUS, "ROM BIOS memory test has been disabled\n");
                }
                this.bus.setShortDirect(ROMx86.BIOS.RESET_FLAG.ADDR, ROMx86.BIOS.RESET_FLAG.WARMBOOT);
            }
            /**
             * Don't add the "ramCPQ" memory to the CMOS total, because addCMOSMemory() will add it to the extended
             * memory total, which will just confuse the COMPAQ BIOS.
             */
            if (!DESKPRO386 || this.idComponent != "ramCPQ") {
                if (this.chipset) this.chipset.addCMOSMemory(this.addrRAM, this.sizeRAM);
            }
        } else {
            Component.error("No RAM allocated");
        }
    }

    /**
     * save()
     *
     * This implements save support for the RAM component.
     *
     * @this {RAMx86}
     * @returns {Object}
     */
    save()
    {
        let state = new State(this);
        if (this.controller) state.set(0, this.controller.save());
        return state.data();
    }

    /**
     * restore(data)
     *
     * This implements restore support for the RAM component.
     *
     * @this {RAMx86}
     * @param {Object} data
     * @returns {boolean} true if successful, false if failure
     */
    restore(data)
    {
        if (this.controller) return this.controller.restore(data[0]);
        return true;
    }

    /**
     * RAMx86.init()
     *
     * This function operates on every HTML element of class "ram", extracting the
     * JSON-encoded parameters for the RAM constructor from the element's "data-value"
     * attribute, invoking the constructor to create a RAM component, and then binding
     * any associated HTML controls to the new component.
     */
    static init()
    {
        let aeRAM = Component.getElementsByClass(APPCLASS, "ram");
        for (let iRAM = 0; iRAM < aeRAM.length; iRAM++) {
            let eRAM = aeRAM[iRAM];
            let parmsRAM = Component.getComponentParms(eRAM);
            let ram = new RAMx86(parmsRAM);
            Component.bindComponentControls(ram, eRAM, APPCLASS);
        }
    }
}

/**
 * @class CompaqController
 * @unrestricted (allows the class to define properties, both dot and named, outside of the constructor)
 */
class CompaqController extends Controller {

    static ADDR       = 0x80C00000|0;
    static MAP_SRC    = 0x00FE0000;
    static MAP_DST    = 0x000E0000;
    static MAP_SIZE   = 0x00020000;

    /**
     * Bit definitions for the 16-bit write-only memory-mapping register (wMappings)
     *
     * NOTE: Although COMPAQ says the memory at %FE0000 is "relocated", it actually remains addressable
     * at %FE0000; it simply becomes addressable at %0E0000 as well, displacing any ROMs that used to be
     * addressable at %0E0000 through %0FFFFF.
     */
    static MAPPINGS = {
        UNMAPPED:   0x0001,         // is this bit is CLEAR, the last 128Kb (at 0x00FE0000) is mapped to 0x000E0000
        READWRITE:  0x0002,         // if this bit is CLEAR, the last 128Kb (at 0x00FE0000) is read-only (ie, write-protected)
        RESERVED:   0xFFFC,         // the remaining 6 bits are reserved and should always be SET
        DEFAULT:    0xFFFF          // our default settings (no mapping, no write-protection)
    };

    /**
     * Bit definitions for the 16-bit read-only settings/diagnostics register (wSettings)
     *
     * SW1-7 and SW1-8 are mapped to bits 5 and 4 of wSettings, respectively, as follows:
     *
     *      SW1-7   SW1-8   Bit5    Bit4    Amount (of base memory provided by the COMPAQ 32-bit memory board)
     *      -----   -----   ----    ----    ------
     *        ON      ON      0       0     640Kb
     *        ON      OFF     0       1     Invalid
     *        OFF     ON      1       0     512Kb
     *        OFF     OFF     1       1     256Kb
     *
     * Other SW1 switches include:
     *
     *      SW1-1:  ON enables fail-safe timer
     *      SW1-2:  ON indicates 80387 coprocessor installed
     *      SW1-3:  ON sets memory from 0xC00000 to 0xFFFFFF (between 12 and 16 megabytes) non-cacheable
     *      SW1-4:  ON selects AUTO system speed (OFF selects HIGH system speed)
     *      SW1-5:  RESERVED (however, the system can read its state; see below)
     *      SW1-6:  COMPAQ Dual-Mode Monitor or Color Monitor (OFF selects Monochrome monitor other than COMPAQ)
     *
     * While SW1-7 and SW1-8 are connected to this memory-mapped register, other SW1 DIP switches are accessible
     * through the 8042 Keyboard Controller's KBC.INPORT register, as follows:
     *
     *      SW1-1:  TODO: Determine
     *      SW1-2:  ChipSet.KC8042.INPORT.COMPAQ_NO80387 clear if ON, set (0x04) if OFF
     *      SW1-3:  TODO: Determine
     *      SW1-4:  ChipSet.KC8042.INPORT.COMPAQ_HISPEED clear if ON, set (0x10) if OFF
     *      SW1-5:  ChipSet.KC8042.INPORT.COMPAQ_DIP5OFF clear if ON, set (0x20) if OFF
     *      SW1-6:  ChipSet.KC8042.INPORT.COMPAQ_NONDUAL clear if ON, set (0x40) if OFF
     */
    static SETTINGS = {
        B0_PARITY:  0x0001,         // parity OK in byte 0
        B1_PARITY:  0x0002,         // parity OK in byte 1
        B2_PARITY:  0x0004,         // parity OK in byte 2
        B3_PARITY:  0x0008,         // parity OK in byte 3
        BASE_640KB: 0x0000,         // SW1-7,8: ON  ON   Bits 5,4: 00
        BASE_ERROR: 0x0010,         // SW1-7,8: ON  OFF  Bits 5,4: 01
        BASE_512KB: 0x0020,         // SW1-7,8: OFF ON   Bits 5,4: 10
        BASE_256KB: 0x0030,         // SW1-7,8: OFF OFF  Bits 5,4: 11
        /**
         * TODO: The DeskPro 386/25 TechRef says bit 6 (0x40) is always set,
         * but setting it results in memory configuration errors; review.
         */
        ADDED_1MB:  0x0040,
        /**
         * TODO: The DeskPro 386/25 TechRef says bit 7 (0x80) is always clear; review.
         */
        PIGGYBACK:  0x0080,
        SYS_4MB:    0x0100,         // 4Mb on system board
        SYS_1MB:    0x0200,         // 1Mb on system board
        SYS_NONE:   0x0300,         // no memory on system board
        MODA_4MB:   0x0400,         // 4Mb on module A board
        MODA_1MB:   0x0800,         // 1Mb on module A board
        MODA_NONE:  0x0C00,         // no memory on module A board
        MODB_4MB:   0x1000,         // 4Mb on module B board
        MODB_1MB:   0x2000,         // 1Mb on module B board
        MODB_NONE:  0x3000,         // no memory on module B board
        MODC_4MB:   0x4000,         // 4Mb on module C board
        MODC_1MB:   0x8000,         // 1Mb on module C board
        MODC_NONE:  0xC000,         // no memory on module C board
        /**
         * NOTE: It doesn't seem to matter to the ROM whether I set any of bits 8-15 or not....
         */
        DEFAULT:    0x0A0F          // our default settings (ie, parity OK, 640Kb base memory, 1Mb system memory, 1Mb module A memory)
    };

    static RAMSETUP = {
        SETUP:      0x000F,
        CACHE:      0x0040,
        RESERVED:   0xFFB0,
        DEFAULT:    0x0002          // our default settings (ie, 2Mb, cache disabled)
    };

    /**
     * CompaqController(ram)
     *
     * DeskPro 386 machines came with a minimum of 1Mb of RAM, which could be configured (via jumpers)
     * for 256Kb, 512Kb or 640Kb of conventional memory, starting at address 0x00000000, with the
     * remainder (768Kb, 512Kb, or 384Kb) accessible only at an address just below 0x01000000.  In PCx86,
     * this second chunk of RAM must be separately allocated, with an ID of "ramCPQ".
     *
     * The typical configuration was 640Kb of conventional memory, leaving 384Kb accessible at 0x00FA0000.
     * Presumably, the other configurations (256Kb and 512Kb) would leave 768Kb and 512Kb accessible at
     * 0x00F40000 and 0x00F80000, respectively.
     *
     * The DeskPro 386 also contained two memory-mapped registers at 0x80C00000.  The first is a write-only
     * mapping register that provides the ability to map the 128Kb at 0x00FE0000 to 0x000E0000, replacing
     * any ROMs in the range 0x000E0000-0x000FFFFF, and optionally write-protecting that 128Kb; internally,
     * this register corresponds to wMappings.
     *
     * The second register is a read-only diagnostics register that indicates jumper configuration and
     * parity errors; internally, this register corresponds to wSettings.
     *
     * To emulate the memory-mapped registers at 0x80C00000, the RAM component allocates a block at that
     * address using this custom controller once it sees an allocation for "ramCPQ".
     *
     * Later, when the addressability of "ramCPQ" memory is altered, we record the blocks in all the
     * memory slots spanning 0x000E0000-0x000FFFFF, and then update those slots with the blocks from
     * 0x00FE0000-0x00FFFFFF.  Note that only the top 128Kb of "ramCPQ" addressability is affected; the
     * rest of that memory, ranging anywhere from 256Kb to 640Kb, remains addressable at its original
     * location.  COMPAQ's CEMM and VDISK utilities were generally the only software able to access that
     * remaining memory (what COMPAQ refers to as "Compaq Built-in Memory").
     *
     * @this {CompaqController}
     * @param {RAMx86} ram
     */
    constructor(ram)
    {
        super();

        this.ram = ram;
        this.wMappings = CompaqController.MAPPINGS.DEFAULT;
        /**
         * TODO: wSettings needs to reflect the actual amount of configured memory....
         */
        this.wSettings = CompaqController.SETTINGS.DEFAULT;
        this.wRAMSetup = CompaqController.RAMSETUP.DEFAULT;
        this.aBlocksDst = null;

        this.buffer = [null, 0];
        this.access = [CompaqController.readByte, CompaqController.writeByte];
    }

    /**
     * save()
     *
     * This implements save support for the CompaqController component.
     *
     * @this {CompaqController}
     * @returns {Array}
     */
    save()
    {
        return [this.wMappings, this.wRAMSetup];
    }

    /**
     * restore(data)
     *
     * This implements restore support for the CompaqController component.
     *
     * @this {CompaqController}
     * @param {Object} data
     * @returns {boolean} true if successful, false if failure
     */
    restore(data)
    {
        this.setByte(0, data[0] & 0xff);
        this.setByte(2, data[1] & 0xff);
        return true;
    }

    /**
     * getByte(off)
     *
     * @this {CompaqController}
     * @param {number} off
     * @returns {number}
     */
    getByte(off)
    {
        /**
         * Offsets 0-3 correspond to reads from 0x80C00000-0x80C00003; anything outside that range
         * returns our standard non-responsive value of 0xff.
         */
        let b = 0xff;
        if (off < 0x02) {
            b = (off & 0x1)? (this.wSettings >> 8) : (this.wSettings & 0xff);
        }
        else if (off < 0x4) {
            b = (off & 0x1)? (this.wRAMSetup >> 8) : (this.wRAMSetup & 0xff);
        }
        return b;
    }

    /**
     * setByte(off, b)
     *
     * @this {CompaqController}
     * @param {number} off (relative to 0x80C00000)
     * @param {number} b
     */
    setByte(off, b)
    {
        if (!off) {
            /**
             * This is a write to 0x80C00000
             */
            if (b != (this.wMappings & 0xff)) {
                let bus = this.ram.bus;
                if (!(b & CompaqController.MAPPINGS.UNMAPPED)) {
                    if (!this.aBlocksDst) {
                        this.aBlocksDst = bus.getMemoryBlocks(CompaqController.MAP_DST, CompaqController.MAP_SIZE);
                    }
                    /**
                     * You might think that the next three lines could ALSO be moved to the preceding IF,
                     * but it's possible for the write-protection feature to be enabled/disabled separately
                     * from the mapping feature.  We could avoid executing this code as well by checking the
                     * current read-write state, but this is an infrequent operation, so there's no point.
                     */
                    let aBlocks = bus.getMemoryBlocks(CompaqController.MAP_SRC, CompaqController.MAP_SIZE);
                    let type = (b & CompaqController.MAPPINGS.READWRITE)? Memoryx86.TYPE.RAM : Memoryx86.TYPE.ROM;
                    bus.setMemoryBlocks(CompaqController.MAP_DST, CompaqController.MAP_SIZE, aBlocks, type);
                }
                else {
                    if (this.aBlocksDst) {
                        bus.setMemoryBlocks(CompaqController.MAP_DST, CompaqController.MAP_SIZE, this.aBlocksDst);
                        this.aBlocksDst = null;
                    }
                }
                this.wMappings = (this.wMappings & ~0xff) | b;
            }
        }
        else if (off == 0x2) {
            /**
             * This is a write to 0x80C00002
             */
            this.wRAMSetup = (this.wRAMSetup & ~0xff) | b;
        }
    }

    /**
     * getMemoryAccess()
     *
     * @this {CompaqController}
     * @returns {Array.<function()>}
     */
    getMemoryAccess()
    {
        return this.access;
    }

    /**
     * getMemoryBuffer(addr)
     *
     * @this {CompaqController}
     * @param {number} addr
     * @returns {Array} containing the buffer (and an offset within that buffer)
     */
    getMemoryBuffer(addr)
    {
        return this.buffer;
    }

    /**
     * readByte(off, addr)
     *
     * NOTE: Even though we asked bus.addMemory() for only 4 bytes, corresponding to the 4 memory-mapped register
     * locations we must manage, we're at the mercy of the Bus component's physical block allocation granularity,
     * which, on 80386-based machines, is fixed at 4K (the same as the 80386 page size, to simplify emulation of paging).
     *
     * So we must allow for requests outside that 4-byte range.
     *
     * @this {Memoryx86}
     * @param {number} off (relative to 0x80C00000)
     * @param {number} [addr]
     * @returns {number}
     */
    static readByte(off, addr)
    {
        let b = this.controller.getByte(off);
        if (DEBUG) {
            this.controller.ram.printf(MESSAGE.MEM + MESSAGE.ADDR, "CompaqController.readByte(%#06x) returned %#04x\n", off, b);
        }
        return b;
    }

    /**
     * writeByte(off, b, addr)
     *
     * NOTE: Even though we asked bus.addMemory() for only 4 bytes, corresponding to the 4 memory-mapped register
     * locations we must manage, we're at the mercy of the Bus component's physical memory allocation granularity,
     * which, on 80386-based machines, is fixed at 4K (the same as the 80386 page size, to simplify emulation of paging).
     *
     * So we must allow for requests outside that 4-byte range.
     *
     * @this {Memoryx86}
     * @param {number} off (relative to 0x80C00000)
     * @param {number} b
     * @param {number} [addr]
     */
    static writeByte(off, b, addr)
    {
        this.controller.setByte(off, b);
        /**
         * All bits in 0x80C00001 and 0x80C00003 are reserved, so we can simply ignore those writes.
         */
        if (DEBUG) {
            this.controller.ram.printf(MESSAGE.MEM + MESSAGE.ADDR, "CompaqController.writeByte(%#06x,%#04x)\n", off, b);
        }
    }
}

/**
 * Initialize all the RAM modules on the page.
 */
WebLib.onInit(RAMx86.init);

/**
 * @copyright https://www.pcjs.org/machines/pcx86/modules/v2/keyboard.js (C) 2012-2024 Jeff Parsons
 */

/**
 * @class Keyboardx86
 * @unrestricted (allows the class to define properties, both dot and named, outside of the constructor)
 */
class Keyboardx86 extends Component {

    /**
     * Supported keyboard models (the first entry is the default if the specified model isn't recognized)
     */
    static MODELS = ["US83", "US84", "US101"];

    /**
     * Commands that can be sent to the Keyboard via the 8042; see receiveCmd()
     *
     * Aside from the commands listed below, 0xEF-0xF2 and 0xF7-0xFD are expressly documented as NOPs; ie:
     *
     *      These commands are reserved and are effectively no-operation or NOP. The system does not use these codes.
     *      If sent, the keyboard will acknowledge the command and continue in its prior scanning state. No other
     *      operation will occur.
     *
     * However, IBM's documentation is silent with regard to 0x00-0xEC.  It's likely that most if not all of those
     * commands are NOPs as well.
     *
     * @enum {number}
     */
    static CMD = {
        /**
         * RESET (0xFF)
         *
         * The system issues a RESET command to start a program reset and a keyboard internal self-test. The keyboard
         * acknowledges the command with an 'acknowledge' signal (ACK) and ensures the system accepts the ACK before
         * executing the command. The system signals acceptance of the ACK by raising the clock and data for a minimum
         * of 500 microseconds. The keyboard is disabled from the time it receives the RESET command until the ACK is
         * accepted or until another command overrides the previous one. Following acceptance of the ACK, the keyboard
         * begins the reset operation, which is similar to a power-on reset. The keyboard clears the output buffer and
         * sets up default values for typematic and delay rates.
         */
        RESET:      0xFF,

        /**
         * RESEND (0xFE)
         *
         * The system can send this command when it detects an error in any transmission from the keyboard. It can be
         * sent only after a keyboard transmission and before the system enables the interface to allow the next keyboard
         * output. Upon receipt of RESEND, the keyboard sends the previous output again unless the previous output was
         * RESEND. In this case, the keyboard will resend the last byte before the RESEND command.
         */
        RESEND:     0xFE,

        /**
         * SET DEFAULT (0xF6)
         *
         * The SET DEFAULT command resets all conditions to the power-on default state. The keyboard responds with ACK,
         * clears its output buffer, sets default conditions, and continues scanning (only if the keyboard was previously
         * enabled).
         */
        DEF_ON:     0xF6,

        /**
         * DEFAULT DISABLE (0xF5)
         *
         * This command is similar to SET DEFAULT, except the keyboard stops scanning and awaits further instructions.
         */
        DEF_OFF:    0xF5,

        /**
         * ENABLE (0xF4)
         *
         * Upon receipt of this command, the keyboard responds with ACK, clears its output buffer, and starts scanning.
         */
        ENABLE:     0xF4,

        /**
         * SET TYPEMATIC RATE/DELAY (0xF3)
         *
         * The system issues this command, followed by a parameter, to change the typematic rate and delay. The typematic
         * rate and delay parameters are determined by the value of the byte following the command. Bits 6 and 5 serve as
         * the delay parameter and bits 4,3,2, 1, and 0 (the least-significant bit) are the rate parameter. Bit 7, the
         * most-significant bit, is always 0. The delay is equal to 1 plus the binary value of bits 6 and 5 multiplied by
         * 250 milliseconds Â±20%.
         */
        SET_RATE:   0xF3,

        /**
         * ECHO (0xEE)
         *
         * ECHO is a diagnostic aid. When the keyboard receives this command, it issues a 0xEE response and continues
         * scanning if the keyboard was previously enabled.
         */
        ECHO:       0xEE,

        /**
         * SET/RESET MODE INDICATORS (0xED)
         *
         * Three mode indicators on the keyboard are accessible to the system. The keyboard activates or deactivates
         * these indicators when it receives a valid command from the system. They can be activated or deactivated in
         * any combination.
         *
         * The system remembers the previous state of an indicator so that its setting does not change when a command
         * sequence is issued to change the state of another indicator.
         *
         * A SET/RESET MODE INDICATORS command consists of 2 bytes. The first is the command byte and has the following
         * bit setup:
         *
         *      11101101 - 0xED
         *
         * The second byte is an option byte. It has a list of the indicators to be acted upon. The bit assignments for
         * this option byte are as follows:
         *
         *      Bit         Indicator
         *      ---         ---------
         *       0          Scroll Lock Indicator
         *       1          Num Lock Indicator
         *       2          Caps Lock Indicator
         *      3-7         Reserved (must be 0's)
         *
         * NOTE: Bit 7 is the most-significant bit; bit 0 is the least-significant.
         *
         * The keyboard will respond to the set/reset mode indicators command with an ACK, discontinue scanning, and wait
         * for the option byte. The keyboard will respond to the option byte with an ACK, set the indicators, and continue
         * scanning if the keyboard was previously enabled. If another command is received in place of the option byte,
         * execution of the function of the SET/RESET MODE INDICATORS command is stopped with no change to the indicator
         * states, and the new command is processed. Then scanning is resumed.
         */
        SET_LEDS:   0xED
    };

    /**
     * Command responses returned to the Keyboard via the 8042; see receiveCmd()
     *
     * @enum {number}
     */
    static CMDRES = {
        /**
         * OVERRUN (0x00)
         *
         * An overrun character is placed in position 17 of the keyboard buffer, overlaying the last code if the
         * buffer becomes full. The code is sent to the system as an overrun when it reaches the top of the buffer.
         */
        OVERRUN:    0x00,

        LOAD_TEST:  0x65,   // undocumented "LOAD MANUFACTURING TEST REQUEST" response code

        /**
         * BAT Completion Code (0xAA)
         *
         * Following satisfactory completion of the BAT, the keyboard sends 0xAA. 0xFC (or any other code)
         * means the keyboard microprocessor check failed.
         */
        BAT_OK:     0xAA,

        /**
         * ECHO Response (0xEE)
         *
         * This is sent in response to an ECHO command (also 0xEE) from the system.
         */
        ECHO:       0xEE,

        /**
         * BREAK CODE PREFIX (0xF0)
         *
         * This code is sent as the first byte of a 2-byte sequence to indicate the release of a key.
         */
        BREAK_PREF: 0xF0,

        /**
         * ACK (0xFA)
         *
         * The keyboard issues an ACK response to any valid input other than an ECHO or RESEND command.
         * If the keyboard is interrupted while sending ACK, it will discard ACK and accept and respond
         * to the new command.
         */
        ACK:        0xFA,

        /**
         * BASIC ASSURANCE TEST FAILURE (0xFC)
         */
        BAT_FAIL:   0xFC,   // TODO: Verify this response code (is this just for older 83-key keyboards?)

        /**
         * DIAGNOSTIC FAILURE (0xFD)
         *
         * The keyboard periodically tests the sense amplifier and sends a diagnostic failure code if it detects
         * any problems. If a failure occurs during BAT, the keyboard stops scanning and waits for a system command
         * or power-down to restart. If a failure is reported after scanning is enabled, scanning continues.
         */
        DIAG_FAIL:  0xFD,

        /**
         * RESEND (0xFE)
         *
         * The keyboard issues a RESEND command following receipt of an invalid input, or any input with incorrect parity.
         * If the system sends nothing to the keyboard, no response is required.
         */
        RESEND:     0xFE,

        BUFF_FULL:  0xFF    // TODO: Verify this response code (is this just for older 83-key keyboards?)
    };

    static LIMIT = {
        MAX_SCANCODES: 20   // TODO: Verify this limit for newer keyboards (84-key and up)
    };

    static INJECTION = {
        NONE:       0,
        ON_START:   1,
        ON_INPUT:   2
    };

    static SIMCODE = {
        BS:               Keys.KEYCODE.BS          + Keys.KEYCODE.ONDOWN,
        TAB:              Keys.KEYCODE.TAB         + Keys.KEYCODE.ONDOWN,
        SHIFT:            Keys.KEYCODE.SHIFT       + Keys.KEYCODE.ONDOWN,
        RSHIFT:           Keys.KEYCODE.SHIFT       + Keys.KEYCODE.ONDOWN + Keys.KEYCODE.ONRIGHT,
        CTRL:             Keys.KEYCODE.CTRL        + Keys.KEYCODE.ONDOWN,
        ALT:              Keys.KEYCODE.ALT         + Keys.KEYCODE.ONDOWN,
        RALT:             Keys.KEYCODE.ALT         + Keys.KEYCODE.ONDOWN + Keys.KEYCODE.ONRIGHT,
        CAPS_LOCK:        Keys.KEYCODE.CAPS_LOCK   + Keys.KEYCODE.ONDOWN,
        ESC:              Keys.KEYCODE.ESC         + Keys.KEYCODE.ONDOWN,
        /**
         * It seems that a recent change to Safari on iOS (first noticed in iOS 9.1) treats SPACE
         * differently now, at least with regard to <textarea> controls, and possibly only readonly
         * or hidden controls, like the hidden <textarea> we overlay on the Video <canvas> element.
         *
         * Whatever the exact criteria are, Safari on iOS now performs SPACE's default behavior
         * after the onkeydown event but before the onkeypress event.  So we must now process SPACE
         * as an ONDOWN key, so that we can call preventDefault() and properly simulate the key at
         * the time the key goes down.
         */
        SPACE:            Keys.KEYCODE.SPACE       + Keys.KEYCODE.ONDOWN,
        F1:               Keys.KEYCODE.F1          + Keys.KEYCODE.ONDOWN,
        F2:               Keys.KEYCODE.F2          + Keys.KEYCODE.ONDOWN,
        F3:               Keys.KEYCODE.F3          + Keys.KEYCODE.ONDOWN,
        F4:               Keys.KEYCODE.F4          + Keys.KEYCODE.ONDOWN,
        F5:               Keys.KEYCODE.F5          + Keys.KEYCODE.ONDOWN,
        F6:               Keys.KEYCODE.F6          + Keys.KEYCODE.ONDOWN,
        F7:               Keys.KEYCODE.F7          + Keys.KEYCODE.ONDOWN,
        F8:               Keys.KEYCODE.F8          + Keys.KEYCODE.ONDOWN,
        F9:               Keys.KEYCODE.F9          + Keys.KEYCODE.ONDOWN,
        F10:              Keys.KEYCODE.F10         + Keys.KEYCODE.ONDOWN,
        F11:              Keys.KEYCODE.F11         + Keys.KEYCODE.ONDOWN,
        F12:              Keys.KEYCODE.F12         + Keys.KEYCODE.ONDOWN,
        NUM_LOCK:         Keys.KEYCODE.NUM_LOCK    + Keys.KEYCODE.ONDOWN,
        SCROLL_LOCK:      Keys.KEYCODE.SCROLL_LOCK + Keys.KEYCODE.ONDOWN,
        PRTSC:            Keys.KEYCODE.PRTSC       + Keys.KEYCODE.ONDOWN,
        HOME:             Keys.KEYCODE.HOME        + Keys.KEYCODE.ONDOWN,
        UP:               Keys.KEYCODE.UP          + Keys.KEYCODE.ONDOWN,
        PGUP:             Keys.KEYCODE.PGUP        + Keys.KEYCODE.ONDOWN,
        LEFT:             Keys.KEYCODE.LEFT        + Keys.KEYCODE.ONDOWN,
        NUM_INS:          Keys.KEYCODE.NUM_INS     + Keys.KEYCODE.ONDOWN,
        NUM_END:          Keys.KEYCODE.NUM_END     + Keys.KEYCODE.ONDOWN,
        NUM_DOWN:         Keys.KEYCODE.NUM_DOWN    + Keys.KEYCODE.ONDOWN,
        NUM_PGDN:         Keys.KEYCODE.NUM_PGDN    + Keys.KEYCODE.ONDOWN,
        NUM_LEFT:         Keys.KEYCODE.NUM_LEFT    + Keys.KEYCODE.ONDOWN,
        NUM_CENTER:       Keys.KEYCODE.NUM_CENTER  + Keys.KEYCODE.ONDOWN,
        NUM_RIGHT:        Keys.KEYCODE.NUM_RIGHT   + Keys.KEYCODE.ONDOWN,
        NUM_HOME:         Keys.KEYCODE.NUM_HOME    + Keys.KEYCODE.ONDOWN,
        NUM_UP:           Keys.KEYCODE.NUM_UP      + Keys.KEYCODE.ONDOWN,
        NUM_PGUP:         Keys.KEYCODE.NUM_PGUP    + Keys.KEYCODE.ONDOWN,
        NUM_ADD:          Keys.KEYCODE.NUM_ADD     + Keys.KEYCODE.ONDOWN,
        NUM_SUB:          Keys.KEYCODE.NUM_SUB     + Keys.KEYCODE.ONDOWN,
        NUM_DEL:          Keys.KEYCODE.NUM_DEL     + Keys.KEYCODE.ONDOWN,
        RIGHT:            Keys.KEYCODE.RIGHT       + Keys.KEYCODE.ONDOWN,
        END:              Keys.KEYCODE.END         + Keys.KEYCODE.ONDOWN,
        DOWN:             Keys.KEYCODE.DOWN        + Keys.KEYCODE.ONDOWN,
        PGDN:             Keys.KEYCODE.PGDN        + Keys.KEYCODE.ONDOWN,
        INS:              Keys.KEYCODE.INS         + Keys.KEYCODE.ONDOWN,
        DEL:              Keys.KEYCODE.DEL         + Keys.KEYCODE.ONDOWN,
        CMD:              Keys.KEYCODE.CMD         + Keys.KEYCODE.ONDOWN,
        RCMD:             Keys.KEYCODE.RCMD        + Keys.KEYCODE.ONDOWN,
        FF_CMD:           Keys.KEYCODE.FF_CMD      + Keys.KEYCODE.ONDOWN,
        CTRL_A:           Keys.ASCII.CTRL_A        + Keys.KEYCODE.FAKE,
        CTRL_B:           Keys.ASCII.CTRL_B        + Keys.KEYCODE.FAKE,
        CTRL_C:           Keys.ASCII.CTRL_C        + Keys.KEYCODE.FAKE,
        CTRL_D:           Keys.ASCII.CTRL_D        + Keys.KEYCODE.FAKE,
        CTRL_E:           Keys.ASCII.CTRL_E        + Keys.KEYCODE.FAKE,
        CTRL_F:           Keys.ASCII.CTRL_F        + Keys.KEYCODE.FAKE,
        CTRL_G:           Keys.ASCII.CTRL_G        + Keys.KEYCODE.FAKE,
        CTRL_H:           Keys.ASCII.CTRL_H        + Keys.KEYCODE.FAKE,
        CTRL_I:           Keys.ASCII.CTRL_I        + Keys.KEYCODE.FAKE,
        CTRL_J:           Keys.ASCII.CTRL_J        + Keys.KEYCODE.FAKE,
        CTRL_K:           Keys.ASCII.CTRL_K        + Keys.KEYCODE.FAKE,
        CTRL_L:           Keys.ASCII.CTRL_L        + Keys.KEYCODE.FAKE,
        CTRL_M:           Keys.ASCII.CTRL_M        + Keys.KEYCODE.FAKE,
        CTRL_N:           Keys.ASCII.CTRL_N        + Keys.KEYCODE.FAKE,
        CTRL_O:           Keys.ASCII.CTRL_O        + Keys.KEYCODE.FAKE,
        CTRL_P:           Keys.ASCII.CTRL_P        + Keys.KEYCODE.FAKE,
        CTRL_Q:           Keys.ASCII.CTRL_Q        + Keys.KEYCODE.FAKE,
        CTRL_R:           Keys.ASCII.CTRL_R        + Keys.KEYCODE.FAKE,
        CTRL_S:           Keys.ASCII.CTRL_S        + Keys.KEYCODE.FAKE,
        CTRL_T:           Keys.ASCII.CTRL_T        + Keys.KEYCODE.FAKE,
        CTRL_U:           Keys.ASCII.CTRL_U        + Keys.KEYCODE.FAKE,
        CTRL_V:           Keys.ASCII.CTRL_V        + Keys.KEYCODE.FAKE,
        CTRL_W:           Keys.ASCII.CTRL_W        + Keys.KEYCODE.FAKE,
        CTRL_X:           Keys.ASCII.CTRL_X        + Keys.KEYCODE.FAKE,
        CTRL_Y:           Keys.ASCII.CTRL_Y        + Keys.KEYCODE.FAKE,
        CTRL_Z:           Keys.ASCII.CTRL_Z        + Keys.KEYCODE.FAKE,
        SYS_REQ:          Keys.KEYCODE.ESC         + Keys.KEYCODE.FAKE,
        CTRL_PAUSE:       Keys.KEYCODE.NUM_LOCK    + Keys.KEYCODE.FAKE,
        CTRL_BREAK:       Keys.KEYCODE.SCROLL_LOCK + Keys.KEYCODE.FAKE,
        CTRL_ALT_DEL:     Keys.KEYCODE.DEL         + Keys.KEYCODE.FAKE,
        CTRL_ALT_INS:     Keys.KEYCODE.INS         + Keys.KEYCODE.FAKE,
        CTRL_ALT_ADD:     Keys.KEYCODE.NUM_ADD     + Keys.KEYCODE.FAKE,
        CTRL_ALT_SUB:     Keys.KEYCODE.NUM_SUB     + Keys.KEYCODE.FAKE,
        CTRL_ALT_ENTER:   Keys.KEYCODE.NUM_CR      + Keys.KEYCODE.FAKE,
        CTRL_ALT_SYS_REQ: Keys.KEYCODE.PRTSC       + Keys.KEYCODE.FAKE,
        SHIFT_TAB:        Keys.KEYCODE.TAB         + Keys.KEYCODE.FAKE
    };

    /**
     * Scan code constants
     */
    static SCANCODE = {
        /* 0x01 */ ESC:         1,
        /* 0x02 */ ONE:         2,
        /* 0x03 */ TWO:         3,
        /* 0x04 */ THREE:       4,
        /* 0x05 */ FOUR:        5,
        /* 0x06 */ FIVE:        6,
        /* 0x07 */ SIX:         7,
        /* 0x08 */ SEVEN:       8,
        /* 0x09 */ EIGHT:       9,
        /* 0x0A */ NINE:        10,
        /* 0x0B */ ZERO:        11,
        /* 0x0C */ DASH:        12,
        /* 0x0D */ EQUALS:      13,
        /* 0x0E */ BS:          14,
        /* 0x0F */ TAB:         15,
        /* 0x10 */ Q:           16,
        /* 0x11 */ W:           17,
        /* 0x12 */ E:           18,
        /* 0x13 */ R:           19,
        /* 0x14 */ T:           20,
        /* 0x15 */ Y:           21,
        /* 0x16 */ U:           22,
        /* 0x17 */ I:           23,
        /* 0x18 */ O:           24,
        /* 0x19 */ P:           25,
        /* 0x1A */ LBRACK:      26,
        /* 0x1B */ RBRACK:      27,
        /* 0x1C */ ENTER:       28,
        /* 0x1D */ CTRL:        29,
        /* 0x1E */ A:           30,
        /* 0x1F */ S:           31,
        /* 0x20 */ D:           32,
        /* 0x21 */ F:           33,
        /* 0x22 */ G:           34,
        /* 0x23 */ H:           35,
        /* 0x24 */ J:           36,
        /* 0x25 */ K:           37,
        /* 0x26 */ L:           38,
        /* 0x27 */ SEMI:        39,
        /* 0x28 */ QUOTE:       40,
        /* 0x29 */ BQUOTE:      41,
        /* 0x2A */ SHIFT:       42,
        /* 0x2B */ BSLASH:      43,
        /* 0x2C */ Z:           44,
        /* 0x2D */ X:           45,
        /* 0x2E */ C:           46,
        /* 0x2F */ V:           47,
        /* 0x30 */ B:           48,
        /* 0x31 */ N:           49,
        /* 0x32 */ M:           50,
        /* 0x33 */ COMMA:       51,
        /* 0x34 */ PERIOD:      52,
        /* 0x35 */ SLASH:       53,
        /* 0x36 */ RSHIFT:      54,
        /* 0x37 */ PRTSC:       55,         // unshifted '*'; becomes dedicated 'Print Screen' key on 101-key keyboards
        /* 0x38 */ ALT:         56,
        /* 0x39 */ SPACE:       57,
        /* 0x3A */ CAPS_LOCK:   58,
        /* 0x3B */ F1:          59,
        /* 0x3C */ F2:          60,
        /* 0x3D */ F3:          61,
        /* 0x3E */ F4:          62,
        /* 0x3F */ F5:          63,
        /* 0x40 */ F6:          64,
        /* 0x41 */ F7:          65,
        /* 0x42 */ F8:          66,
        /* 0x43 */ F9:          67,
        /* 0x44 */ F10:         68,
        /* 0x45 */ NUM_LOCK:    69,
        /* 0x46 */ SCROLL_LOCK: 70,
        /* 0x47 */ NUM_HOME:    71,
        /* 0x48 */ NUM_UP:      72,
        /* 0x49 */ NUM_PGUP:    73,
        /* 0x4A */ NUM_SUB:     74,
        /* 0x4B */ NUM_LEFT:    75,
        /* 0x4C */ NUM_CENTER:  76,
        /* 0x4D */ NUM_RIGHT:   77,
        /* 0x4E */ NUM_ADD:     78,
        /* 0x4F */ NUM_END:     79,
        /* 0x50 */ NUM_DOWN:    80,
        /* 0x51 */ NUM_PGDN:    81,
        /* 0x52 */ NUM_INS:     82,
        /* 0x53 */ NUM_DEL:     83,
        /* 0x54 */ SYS_REQ:     84,         // 84-key keyboard only (simulated with 'alt'+'prtsc' on 101-key keyboards)
        /* 0x54 */ PAUSE:       84,         // 101-key keyboard only
        /* 0x57 */ F11:         87,
        /* 0x58 */ F12:         88,
        /* 0x5B */ WIN:         91,         // aka CMD
        /* 0x5C */ RWIN:        92,
        /* 0x5D */ MENU:        93,         // aka CMD + ONRIGHT
        /* 0x7F */ MAKE:        127,
        /* 0x80 */ BREAK:       128,
        /* 0xE0 */ EXTEND1:     224,
        /* 0xE1 */ EXTEND2:     225
    };

    /**
     * These internal "shift key" states are used to indicate BOTH the physical shift-key states (in bitsState)
     * and the simulated shift-key states (in bitsStateSim).  The LOCK keys are problematic in both cases: the
     * browsers give us no way to query the LOCK key states, so we can only infer them, and because they are "soft"
     * locks, the machine's notion of their state is subject to change at any time as well.  Granted, the IBM PC
     * ROM BIOS will store its LOCK states in the ROM BIOS Data Area (@0040:0017), but that's just a BIOS convention.
     *
     * Also, because this is purely for internal use, don't make the mistake of thinking that these bits have any
     * connection to the ROM BIOS bits @0040:0017 (they don't).  We emulate hardware, not ROMs.
     *
     * TODO: Consider taking notice of the ROM BIOS Data Area state anyway, even though I'd rather remain ROM-agnostic;
     * at the very least, it would help us keep our LOCK LEDs in sync with the machine's LOCK states.  However, the LED
     * issue will be largely moot (at least for MODEL_5170 machines) once we add support for PC AT keyboard LED commands.
     *
     * Note that right-hand state bits are equal to the left-hand bits shifted right 1 bit; makes sense, "right"? ;-)
     *
     * @enum {number}
     */
    static STATE = {
        RSHIFT:         0x0001,
        SHIFT:          0x0002,
        SHIFTS:         0x0003,
        RCTRL:          0x0004,             // 101-key keyboard only
        CTRL:           0x0008,
        CTRLS:          0x000C,
        RALT:           0x0010,             // 101-key keyboard only
        ALT:            0x0020,
        ALTS:           0x0030,
        RCMD:           0x0040,             // 101-key keyboard only
        CMD:            0x0080,             // 101-key keyboard only
        CMDS:           0x00C0,
        ALL_RIGHT:      0x0055,             // RSHIFT | RCTRL | RALT | RCMD
        ALL_MODIFIERS:  0x00FF,             // SHIFT | RSHIFT | CTRL | RCTRL | ALT | RALT | CMD | RCMD
        INSERT:         0x0100,             // TODO: Placeholder (we currently have no notion of any "insert" states)
        CAPS_LOCK:      0x0200,
        NUM_LOCK:       0x0400,
        SCROLL_LOCK:    0x0800,
        ALL_LOCKS:      0x0E00              // CAPS_LOCK | NUM_LOCK | SCROLL_LOCK
    };

    /**
     * Maps KEYCODES of modifier keys to their corresponding (default) STATES bit above.
     */
    static MODIFIERS = {
        [Keyboardx86.SIMCODE.RSHIFT]:      Keyboardx86.STATE.RSHIFT,
        [Keyboardx86.SIMCODE.SHIFT]:       Keyboardx86.STATE.SHIFT,
        [Keyboardx86.SIMCODE.CTRL]:        Keyboardx86.STATE.CTRL,
        [Keyboardx86.SIMCODE.ALT]:         Keyboardx86.STATE.ALT,
        [Keyboardx86.SIMCODE.RALT]:        Keyboardx86.STATE.ALT,
        [Keyboardx86.SIMCODE.CMD]:         Keyboardx86.STATE.CMD,
        [Keyboardx86.SIMCODE.RCMD]:        Keyboardx86.STATE.RCMD,
        [Keyboardx86.SIMCODE.FF_CMD]:      Keyboardx86.STATE.CMD
    };

    /**
     * Maps KEYCODES of all modifier and lock keys to their corresponding (default) STATES bit above.
     */
    static KEYSTATES = {
        [Keyboardx86.SIMCODE.RSHIFT]:      Keyboardx86.STATE.RSHIFT,
        [Keyboardx86.SIMCODE.SHIFT]:       Keyboardx86.STATE.SHIFT,
        [Keyboardx86.SIMCODE.CTRL]:        Keyboardx86.STATE.CTRL,
        [Keyboardx86.SIMCODE.ALT]:         Keyboardx86.STATE.ALT,
        [Keyboardx86.SIMCODE.RALT]:        Keyboardx86.STATE.ALT,
        [Keyboardx86.SIMCODE.CMD]:         Keyboardx86.STATE.CMD,
        [Keyboardx86.SIMCODE.RCMD]:        Keyboardx86.STATE.RCMD,
        [Keyboardx86.SIMCODE.FF_CMD]:      Keyboardx86.STATE.CMD,
        [Keyboardx86.SIMCODE.CAPS_LOCK]:   Keyboardx86.STATE.CAPS_LOCK,
        [Keyboardx86.SIMCODE.NUM_LOCK]:    Keyboardx86.STATE.NUM_LOCK,
        [Keyboardx86.SIMCODE.SCROLL_LOCK]: Keyboardx86.STATE.SCROLL_LOCK
    };

    /**
     * Maps CLICKCODE (string) to SIMCODE (number).
     *
     * NOTE: Unlike SOFTCODES, CLICKCODES are upper-case and use underscores instead of dashes, so that this
     * and other components can reference them using "dot" property syntax; using upper-case merely adheres to
     * our convention for constants.  setBinding() will automatically convert any incoming CLICKCODE bindings
     * that use lower-case and dashes to upper-case and underscores before performing property lookup.
     */
    static CLICKCODES = {
        'TAB':              Keyboardx86.SIMCODE.TAB,
        'ESC':              Keyboardx86.SIMCODE.ESC,
        'F1':               Keyboardx86.SIMCODE.F1,
        'F2':               Keyboardx86.SIMCODE.F2,
        'F3':               Keyboardx86.SIMCODE.F3,
        'F4':               Keyboardx86.SIMCODE.F4,
        'F5':               Keyboardx86.SIMCODE.F5,
        'F6':               Keyboardx86.SIMCODE.F6,
        'F7':               Keyboardx86.SIMCODE.F7,
        'F8':               Keyboardx86.SIMCODE.F8,
        'F9':               Keyboardx86.SIMCODE.F9,
        'F10':              Keyboardx86.SIMCODE.F10,
        'LEFT':             Keyboardx86.SIMCODE.LEFT,
        'UP':               Keyboardx86.SIMCODE.UP,
        'RIGHT':            Keyboardx86.SIMCODE.RIGHT,
        'DOWN':             Keyboardx86.SIMCODE.DOWN,
        'NUM_HOME':         Keyboardx86.SIMCODE.HOME,
        'NUM_END':          Keyboardx86.SIMCODE.END,
        'NUM_PGUP':         Keyboardx86.SIMCODE.PGUP,
        'NUM_PGDN':         Keyboardx86.SIMCODE.PGDN,
        'ALT':              Keyboardx86.SIMCODE.ALT,
        'SYS_REQ':          Keyboardx86.SIMCODE.SYS_REQ,
        /**
         * These bindings are for convenience (common key combinations that can be bound to a single control)
         */
        'CTRL_C':           Keyboardx86.SIMCODE.CTRL_C,
        'CTRL_PAUSE':       Keyboardx86.SIMCODE.CTRL_PAUSE,
        'CTRL_BREAK':       Keyboardx86.SIMCODE.CTRL_BREAK,
        'CTRL_ALT_DEL':     Keyboardx86.SIMCODE.CTRL_ALT_DEL,
        'CTRL_ALT_INS':     Keyboardx86.SIMCODE.CTRL_ALT_INS,
        'CTRL_ALT_ADD':     Keyboardx86.SIMCODE.CTRL_ALT_ADD,
        'CTRL_ALT_SUB':     Keyboardx86.SIMCODE.CTRL_ALT_SUB,
        'CTRL_ALT_ENTER':   Keyboardx86.SIMCODE.CTRL_ALT_ENTER,
        'CTRL_ALT_SYS_REQ': Keyboardx86.SIMCODE.CTRL_ALT_SYS_REQ,
        'SHIFT_TAB':        Keyboardx86.SIMCODE.SHIFT_TAB
    };

    /**
     * Maps SOFTCODE (string) to SIMCODE (number) -- which may be the same as KEYCODE for ASCII keys.
     *
     * We define identifiers for all possible keys, based on their primary (unshifted) character or function.
     * This also serves as a definition of all supported keys, making it possible to create full-featured
     * "soft keyboards".
     *
     * One exception to the (unshifted) rule above is 'prtsc': on the original IBM 83-key and 84-key keyboards,
     * its primary (unshifted) character was '*', but on 101-key keyboards, it became a separate key ('prtsc',
     * now labeled "Print Screen"), as did the num-pad '*' ('num-mul'), so 'prtsc' seems worthy of an exception
     * to the rule.
     *
     * On 83-key and 84-key keyboards, 'ctrl'+'num-lock' triggered a "pause" operation and 'ctrl'+'scroll-lock'
     * triggered a "break" operation.
     *
     * On 101-key keyboards, IBM decided to move both those special operations to a new 'pause' ("Pause/Break")
     * key, near the new dedicated 'prtsc' ("Print Screen/SysRq") key -- and to drop the "e" from "Sys Req".
     * Those keys behave as follows:
     *
     *      When 'pause' is pressed alone, it generates 0xe1 0x1d 0x45 0xe1 0x9d 0xc5 on make (nothing on break),
     *      which essentially simulates the make-and-break of the 'ctrl' and 'num-lock' keys (ignoring the 0xe1),
     *      triggering a "pause" operation.
     *
     *      When 'pause' is pressed with 'ctrl', it generates 0xe0 0x46 0xe0 0xc6 on make (nothing on break) and
     *      does not repeat, which essentially simulates the make-and-break of 'scroll-lock', which, in conjunction
     *      with the separate make-and-break of 'ctrl', triggers a "break" operation.
     *
     *      When 'prtsc' is pressed alone, it generates 0xe0 0x2a 0xe0 0x37, simulating the make of both 'shift'
     *      and 'prtsc'; when pressed with 'shift' or 'ctrl', it generates only 0xe0 0x37; and when pressed with
     *      'alt', it generates only 0x54 (to simulate 'sys-req').
     *
     * TODO: Implement the above behaviors, whenever we get around to actually supporting 101-key keyboards.
     *
     * All key identifiers must be quotable using single-quotes, because that's how components.xsl will encode them
     * *inside* the "data-value" attribute of the corresponding HTML control.  Which, in turn, is why the single-quote
     * key is defined as 'quote' rather than "'".  Similarly, if there was unshifted "double-quote" key, it could
     * not be called '"', because components.xsl quotes the *entire* "data-value" attribute using double-quotes.
     *
     * The (commented) numbering of keys below is purely for my own reference.  Two keys are deliberately numbered 84,
     * reflecting the fact that the 'sys-req' key was added to the 84-key keyboard but later dropped from the 101-key
     * keyboard (as a stand-alone key, that is).
     *
     * With the introduction of the PC AT and the 84-key keyboard, IBM developed a new key numbering scheme and
     * key code generation; the 8042 keyboard controller would then convert those key codes into the PC scan codes
     * defined by the older 83-key keyboard.  That's a layer of complexity we currently bypass; instead, we continue
     * to convert browser key codes directly into PC scan codes, which is what our 8042 controller implementation
     * assumes we're doing.
     */
    static SOFTCODES = {
        /*  1 */    'esc':          Keyboardx86.SIMCODE.ESC,
        /*  2 */    '1':            Keys.ASCII['1'],
        /*  3 */    '2':            Keys.ASCII['2'],
        /*  4 */    '3':            Keys.ASCII['3'],
        /*  5 */    '4':            Keys.ASCII['4'],
        /*  6 */    '5':            Keys.ASCII['5'],
        /*  7 */    '6':            Keys.ASCII['6'],
        /*  8 */    '7':            Keys.ASCII['7'],
        /*  9 */    '8':            Keys.ASCII['8'],
        /* 10 */    '9':            Keys.ASCII['9'],
        /* 11 */    '0':            Keys.ASCII['0'],
        /* 12 */    '-':            Keys.ASCII['-'],
        /* 13 */    '=':            Keys.ASCII['='],
        /* 43 */    'bslash':       Keys.ASCII['\\'],               // listed before 'bs' so that injectKeys() doesn't mismatch
        /* 14 */    'bs':           Keyboardx86.SIMCODE.BS,
        /* 15 */    'tab':          Keyboardx86.SIMCODE.TAB,
        /* 16 */    'q':            Keys.ASCII.q,
        /* 17 */    'w':            Keys.ASCII.w,
        /* 18 */    'e':            Keys.ASCII.e,
        /* 19 */    'r':            Keys.ASCII.r,
        /* 20 */    't':            Keys.ASCII.t,
        /* 21 */    'y':            Keys.ASCII.y,
        /* 22 */    'u':            Keys.ASCII.u,
        /* 23 */    'i':            Keys.ASCII.i,
        /* 24 */    'o':            Keys.ASCII.o,
        /* 25 */    'p':            Keys.ASCII.p,
        /* 26 */    '[':            Keys.ASCII['['],
        /* 27 */    ']':            Keys.ASCII[']'],
        /* 28 */    'enter':        Keys.KEYCODE.CR,
        /* 29 */    'ctrl':         Keyboardx86.SIMCODE.CTRL,
        /* 30 */    'a':            Keys.ASCII.a,
        /* 31 */    's':            Keys.ASCII.s,
        /* 32 */    'd':            Keys.ASCII.d,
        /* 33 */    'f':            Keys.ASCII.f,
        /* 34 */    'g':            Keys.ASCII.g,
        /* 35 */    'h':            Keys.ASCII.h,
        /* 36 */    'j':            Keys.ASCII.j,
        /* 37 */    'k':            Keys.ASCII.k,
        /* 38 */    'l':            Keys.ASCII.l,
        /* 39 */    ';':            Keys.ASCII[';'],
        /* 40 */    'quote':        Keys.ASCII["'"],                // formerly "squote"
        /* 41 */    '`':            Keys.ASCII['`'],                // formerly "bquote"
        /* 42 */    'shift':        Keyboardx86.SIMCODE.SHIFT,           // formerly "lshift"
        /* 43 */    '\\':           Keys.ASCII['\\'],               // formerly "bslash"
        /* 44 */    'z':            Keys.ASCII.z,
        /* 45 */    'x':            Keys.ASCII.x,
        /* 46 */    'c':            Keys.ASCII.c,
        /* 47 */    'v':            Keys.ASCII.v,
        /* 48 */    'b':            Keys.ASCII.b,
        /* 49 */    'n':            Keys.ASCII.n,
        /* 50 */    'm':            Keys.ASCII.m,
        /* 51 */    ',':            Keys.ASCII[','],
        /* 52 */    '.':            Keys.ASCII['.'],
        /* 53 */    '/':            Keys.ASCII['/'],
        /* 54 */    'right-shift':  Keyboardx86.SIMCODE.RSHIFT,        // formerly "rshift"
        /* 55 */    'prtsc':        Keyboardx86.SIMCODE.PRTSC,         // unshifted '*'; becomes dedicated 'Print Screen' key on 101-key keyboards
        /* 56 */    'alt':          Keyboardx86.SIMCODE.ALT,
        /* 57 */    'space':        Keyboardx86.SIMCODE.SPACE,
        /* 58 */    'caps-lock':    Keyboardx86.SIMCODE.CAPS_LOCK,
        /* 68 */    'f10':          Keyboardx86.SIMCODE.F10,           // listed before 'f1' so that injectKeys() doesn't mismatch
        /* 59 */    'f1':           Keyboardx86.SIMCODE.F1,
        /* 60 */    'f2':           Keyboardx86.SIMCODE.F2,
        /* 61 */    'f3':           Keyboardx86.SIMCODE.F3,
        /* 62 */    'f4':           Keyboardx86.SIMCODE.F4,
        /* 63 */    'f5':           Keyboardx86.SIMCODE.F5,
        /* 64 */    'f6':           Keyboardx86.SIMCODE.F6,
        /* 65 */    'f7':           Keyboardx86.SIMCODE.F7,
        /* 66 */    'f8':           Keyboardx86.SIMCODE.F8,
        /* 67 */    'f9':           Keyboardx86.SIMCODE.F9,
        /* 69 */    'num-lock':     Keyboardx86.SIMCODE.NUM_LOCK,
        /* 70 */    'scroll-lock':  Keyboardx86.SIMCODE.SCROLL_LOCK,   // TODO: 0xe046 on 101-key keyboards?

        /**
         * Yes, distinguishing keys 71 through 83 with the 'num-' prefix seems like overkill, but it was
         * intended to be future-proofing, for the day when we might eventually add support for 101-key keyboards,
         * because they have their own dedicated non-numeric-keypad versions of these keys (in other words, they
         * account for most of the bloat on the 101-key keyboard, a trend that more modern keyboards have gradually
         * been reversing).
         *
         * To offset 'num-' prefix overkill, injectKeys() allows SOFTCODES to be used with or without the prefix,
         * on the theory that key injection users won't really care precisely which version of the key is used.
         */

        /* 71 */    'num-home':     Keyboardx86.SIMCODE.HOME,          // formerly "home"
        /* 72 */    'num-up':       Keyboardx86.SIMCODE.UP,            // formerly "up-arrow"
        /* 73 */    'num-pgup':     Keyboardx86.SIMCODE.PGUP,          // formerly "page-up"
        /* 74 */    'num-sub':      Keyboardx86.SIMCODE.NUM_SUB,       // formerly "num-minus"
        /* 75 */    'num-left':     Keyboardx86.SIMCODE.LEFT,          // formerly "left-arrow"
        /* 76 */    'num-center':   Keyboardx86.SIMCODE.NUM_CENTER,    // formerly "center"
        /* 77 */    'num-right':    Keyboardx86.SIMCODE.RIGHT,         // formerly "right-arrow"
        /* 78 */    'num-add':      Keyboardx86.SIMCODE.NUM_ADD,       // formerly "num-plus"
        /* 79 */    'num-end':      Keyboardx86.SIMCODE.END,           // formerly "end"
        /* 80 */    'num-down':     Keyboardx86.SIMCODE.DOWN,          // formerly "down-arrow"
        /* 81 */    'num-pgdn':     Keyboardx86.SIMCODE.PGDN,          // formerly "page-down"
        /* 82 */    'num-ins':      Keyboardx86.SIMCODE.INS,           // formerly "ins"
        /* 83 */    'num-del':      Keyboardx86.SIMCODE.DEL,           // formerly "del"
        /* 84 */    'sys-req':      Keyboardx86.SIMCODE.SYS_REQ        // 84-key keyboard only (simulated with 'alt'+'prtsc' on 101-key keyboards)

        /**
         * If I ever add 101-key keyboard support (and it's not clear that I will), then the following entries
         * will have to be converted to SIMCODE indexes, and each SIMCODE index will need an entry in the SIMCODES
         * table that defines the appropriate SCANCODE(S); as this component has evolved, SOFTCODES are no longer
         * mapped directly to SCANCODES.
         */

    //  /* 84 */    'pause':        Keyboardx86.SCANCODE.PAUSE,        // 101-key keyboard only
    //  /* 85 */    'f11':          Keyboardx86.SCANCODE.F11,
    //  /* 86 */    'f12':          Keyboardx86.SCANCODE.F12,
    //  /* 87 */    'num-enter':    Keyboardx86.SCANCODE.EXTEND1 | (Keyboardx86.SCANCODE.ENTER << 8),
    //  /* 88 */    'right-ctrl':   Keyboardx86.SCANCODE.EXTEND1 | (Keyboardx86.SCANCODE.CTRL << 8),
    //  /* 89 */    'num-div':      Keyboardx86.SCANCODE.EXTEND1 | (Keyboardx86.SCANCODE.SLASH << 8),
    //  /* 90 */    'num-mul':      Keyboardx86.SCANCODE.EXTEND1 | (Keyboardx86.SCANCODE.PRTSC << 8),
    //  /* 91 */    'right-alt':    Keyboardx86.SCANCODE.EXTEND1 | (Keyboardx86.SCANCODE.ALT << 8),
    //  /* 92 */    'home':         Keyboardx86.SCANCODE.EXTEND1 | (Keyboardx86.SCANCODE.NUM_HOME << 8),
    //  /* 93 */    'up':           Keyboardx86.SCANCODE.EXTEND1 | (Keyboardx86.SCANCODE.NUM_UP << 8),
    //  /* 94 */    'pgup':         Keyboardx86.SCANCODE.EXTEND1 | (Keyboardx86.SCANCODE.NUM_PGUP << 8),
    //  /* 95 */    'left':         Keyboardx86.SCANCODE.EXTEND1 | (Keyboardx86.SCANCODE.NUM_LEFT << 8),
    //  /* 96 */    'right':        Keyboardx86.SCANCODE.EXTEND1 | (Keyboardx86.SCANCODE.NUM_RIGHT << 8),
    //  /* 97 */    'end':          Keyboardx86.SCANCODE.EXTEND1 | (Keyboardx86.SCANCODE.NUM_END << 8),
    //  /* 98 */    'down':         Keyboardx86.SCANCODE.EXTEND1 | (Keyboardx86.SCANCODE.NUM_DOWN << 8),
    //  /* 99 */    'pgdn':         Keyboardx86.SCANCODE.EXTEND1 | (Keyboardx86.SCANCODE.NUM_PGDN << 8),
    //  /*100 */    'ins':          Keyboardx86.SCANCODE.EXTEND1 | (Keyboardx86.SCANCODE.NUM_INS << 8),
    //  /*101 */    'del':          Keyboardx86.SCANCODE.EXTEND1 | (Keyboardx86.SCANCODE.NUM_DEL << 8),

    //  /*102 */    'win':          Keyboardx86.SCANCODE.EXTEND1 | (Keyboardx86.SCANCODE.WIN << 8),
    //  /*103 */    'right-win':    Keyboardx86.SCANCODE.EXTEND1 | (Keyboardx86.SCANCODE.RWIN << 8),
    //  /*104 */    'menu':         Keyboardx86.SCANCODE.EXTEND1 | (Keyboardx86.SCANCODE.MENU << 8)
    };

    /**
     * Maps "soft-key" definitions (above) of shift/modifier keys to their corresponding (default) STATES bit.
     */
    static LEDSTATES = {
        'caps-lock':    Keyboardx86.STATE.CAPS_LOCK,
        'num-lock':     Keyboardx86.STATE.NUM_LOCK,
        'scroll-lock':  Keyboardx86.STATE.SCROLL_LOCK
    };

    /**
     * Maps SIMCODE (number) to SCANCODE (number(s)).
     *
     * This array is used by simulateKey() to lookup a given SIMCODE and convert it to a SCANCODE
     * (lower byte), plus any required shift key SCANCODES (upper bytes).
     *
     * Using keyCodes from keyPress events proved to be more robust than using keyCodes from keyDown and
     * keyUp events, in part because of differences in the way browsers generate the keyDown and keyUp events.
     * For example, Safari on iOS devices will not generate up/down events for shift keys, and for other keys,
     * the up/down events are usually generated after the actual press is complete, and in rapid succession.
     *
     * The other problem (which is more of a problem with keyboards like the C1P than any IBM keyboards) is
     * that the shift/modifier state for a character on the "source" keyboard may not match the shift/modifier
     * state for the same character on the "target" keyboard.  And since this code is inherited from C1Pjs,
     * we've inherited the same solution: simulateKey() has the ability to "undo" any states in bitsState
     * that conflict with the state(s) required for the character in question.
     */
    static SIMCODES = {
        [Keyboardx86.SIMCODE.ESC]:          Keyboardx86.SCANCODE.ESC,
        [Keys.ASCII['1']]:                  Keyboardx86.SCANCODE.ONE,
        [Keys.ASCII['!']]:                  Keyboardx86.SCANCODE.ONE    | (Keyboardx86.SCANCODE.SHIFT << 8),
        [Keys.ASCII['2']]:                  Keyboardx86.SCANCODE.TWO,
        [Keys.ASCII['@']]:                  Keyboardx86.SCANCODE.TWO    | (Keyboardx86.SCANCODE.SHIFT << 8),
        [Keys.ASCII['3']]:                  Keyboardx86.SCANCODE.THREE,
        [Keys.ASCII['#']]:                  Keyboardx86.SCANCODE.THREE  | (Keyboardx86.SCANCODE.SHIFT << 8),
        [Keys.ASCII['4']]:                  Keyboardx86.SCANCODE.FOUR,
        [Keys.ASCII['$']]:                  Keyboardx86.SCANCODE.FOUR   | (Keyboardx86.SCANCODE.SHIFT << 8),
        [Keys.ASCII['5']]:                  Keyboardx86.SCANCODE.FIVE,
        [Keys.ASCII['%']]:                  Keyboardx86.SCANCODE.FIVE   | (Keyboardx86.SCANCODE.SHIFT << 8),
        [Keys.ASCII['6']]:                  Keyboardx86.SCANCODE.SIX,
        [Keys.ASCII['^']]:                  Keyboardx86.SCANCODE.SIX    | (Keyboardx86.SCANCODE.SHIFT << 8),
        [Keys.ASCII['7']]:                  Keyboardx86.SCANCODE.SEVEN,
        [Keys.ASCII['&']]:                  Keyboardx86.SCANCODE.SEVEN  | (Keyboardx86.SCANCODE.SHIFT << 8),
        [Keys.ASCII['8']]:                  Keyboardx86.SCANCODE.EIGHT,
        [Keys.ASCII['*']]:                  Keyboardx86.SCANCODE.EIGHT  | (Keyboardx86.SCANCODE.SHIFT << 8),
        [Keys.ASCII['9']]:                  Keyboardx86.SCANCODE.NINE,
        [Keys.ASCII['(']]:                  Keyboardx86.SCANCODE.NINE   | (Keyboardx86.SCANCODE.SHIFT << 8),
        [Keys.ASCII['0']]:                  Keyboardx86.SCANCODE.ZERO,
        [Keys.ASCII[')']]:                  Keyboardx86.SCANCODE.ZERO   | (Keyboardx86.SCANCODE.SHIFT << 8),
        [Keys.ASCII['-']]:                  Keyboardx86.SCANCODE.DASH,
        [Keys.ASCII['_']]:                  Keyboardx86.SCANCODE.DASH   | (Keyboardx86.SCANCODE.SHIFT << 8),
        [Keys.ASCII['=']]:                  Keyboardx86.SCANCODE.EQUALS,
        [Keys.ASCII['+']]:                  Keyboardx86.SCANCODE.EQUALS | (Keyboardx86.SCANCODE.SHIFT << 8),
        [Keyboardx86.SIMCODE.BS]:           Keyboardx86.SCANCODE.BS,
        [Keyboardx86.SIMCODE.TAB]:          Keyboardx86.SCANCODE.TAB,
        [Keys.ASCII.q]:                     Keyboardx86.SCANCODE.Q,
        [Keys.ASCII.Q]:                     Keyboardx86.SCANCODE.Q      | (Keyboardx86.SCANCODE.SHIFT << 8),
        [Keys.ASCII.w]:                     Keyboardx86.SCANCODE.W,
        [Keys.ASCII.W]:                     Keyboardx86.SCANCODE.W      | (Keyboardx86.SCANCODE.SHIFT << 8),
        [Keys.ASCII.e]:                     Keyboardx86.SCANCODE.E,
        [Keys.ASCII.E]:                     Keyboardx86.SCANCODE.E      | (Keyboardx86.SCANCODE.SHIFT << 8),
        [Keys.ASCII.r]:                     Keyboardx86.SCANCODE.R,
        [Keys.ASCII.R]:                     Keyboardx86.SCANCODE.R      | (Keyboardx86.SCANCODE.SHIFT << 8),
        [Keys.ASCII.t]:                     Keyboardx86.SCANCODE.T,
        [Keys.ASCII.T]:                     Keyboardx86.SCANCODE.T      | (Keyboardx86.SCANCODE.SHIFT << 8),
        [Keys.ASCII.y]:                     Keyboardx86.SCANCODE.Y,
        [Keys.ASCII.Y]:                     Keyboardx86.SCANCODE.Y      | (Keyboardx86.SCANCODE.SHIFT << 8),
        [Keys.ASCII.u]:                     Keyboardx86.SCANCODE.U,
        [Keys.ASCII.U]:                     Keyboardx86.SCANCODE.U      | (Keyboardx86.SCANCODE.SHIFT << 8),
        [Keys.ASCII.i]:                     Keyboardx86.SCANCODE.I,
        [Keys.ASCII.I]:                     Keyboardx86.SCANCODE.I      | (Keyboardx86.SCANCODE.SHIFT << 8),
        [Keys.ASCII.o]:                     Keyboardx86.SCANCODE.O,
        [Keys.ASCII.O]:                     Keyboardx86.SCANCODE.O      | (Keyboardx86.SCANCODE.SHIFT << 8),
        [Keys.ASCII.p]:                     Keyboardx86.SCANCODE.P,
        [Keys.ASCII.P]:                     Keyboardx86.SCANCODE.P      | (Keyboardx86.SCANCODE.SHIFT << 8),
        [Keys.ASCII['[']]:                  Keyboardx86.SCANCODE.LBRACK,
        [Keys.ASCII['{']]:                  Keyboardx86.SCANCODE.LBRACK | (Keyboardx86.SCANCODE.SHIFT << 8),
        [Keys.ASCII[']']]:                  Keyboardx86.SCANCODE.RBRACK,
        [Keys.ASCII['}']]:                  Keyboardx86.SCANCODE.RBRACK | (Keyboardx86.SCANCODE.SHIFT << 8),
        [Keys.KEYCODE.CR]:                  Keyboardx86.SCANCODE.ENTER,
        [Keyboardx86.SIMCODE.CTRL]:         Keyboardx86.SCANCODE.CTRL,
        [Keys.ASCII.a]:                     Keyboardx86.SCANCODE.A,
        [Keys.ASCII.A]:                     Keyboardx86.SCANCODE.A      | (Keyboardx86.SCANCODE.SHIFT << 8),
        [Keys.ASCII.s]:                     Keyboardx86.SCANCODE.S,
        [Keys.ASCII.S]:                     Keyboardx86.SCANCODE.S      | (Keyboardx86.SCANCODE.SHIFT << 8),
        [Keys.ASCII.d]:                     Keyboardx86.SCANCODE.D,
        [Keys.ASCII.D]:                     Keyboardx86.SCANCODE.D      | (Keyboardx86.SCANCODE.SHIFT << 8),
        [Keys.ASCII.f]:                     Keyboardx86.SCANCODE.F,
        [Keys.ASCII.F]:                     Keyboardx86.SCANCODE.F      | (Keyboardx86.SCANCODE.SHIFT << 8),
        [Keys.ASCII.g]:                     Keyboardx86.SCANCODE.G,
        [Keys.ASCII.G]:                     Keyboardx86.SCANCODE.G      | (Keyboardx86.SCANCODE.SHIFT << 8),
        [Keys.ASCII.h]:                     Keyboardx86.SCANCODE.H,
        [Keys.ASCII.H]:                     Keyboardx86.SCANCODE.H      | (Keyboardx86.SCANCODE.SHIFT << 8),
        [Keys.ASCII.j]:                     Keyboardx86.SCANCODE.J,
        [Keys.ASCII.J]:                     Keyboardx86.SCANCODE.J      | (Keyboardx86.SCANCODE.SHIFT << 8),
        [Keys.ASCII.k]:                     Keyboardx86.SCANCODE.K,
        [Keys.ASCII.K]:                     Keyboardx86.SCANCODE.K      | (Keyboardx86.SCANCODE.SHIFT << 8),
        [Keys.ASCII.l]:                     Keyboardx86.SCANCODE.L,
        [Keys.ASCII.L]:                     Keyboardx86.SCANCODE.L      | (Keyboardx86.SCANCODE.SHIFT << 8),
        [Keys.ASCII[';']]:                  Keyboardx86.SCANCODE.SEMI,
        [Keys.ASCII[':']]:                  Keyboardx86.SCANCODE.SEMI   | (Keyboardx86.SCANCODE.SHIFT << 8),
        [Keys.ASCII["'"]]:                  Keyboardx86.SCANCODE.QUOTE,
        [Keys.ASCII['"']]:                  Keyboardx86.SCANCODE.QUOTE  | (Keyboardx86.SCANCODE.SHIFT << 8),
        [Keys.ASCII['`']]:                  Keyboardx86.SCANCODE.BQUOTE,
        [Keys.ASCII['~']]:                  Keyboardx86.SCANCODE.BQUOTE | (Keyboardx86.SCANCODE.SHIFT << 8),
        [Keyboardx86.SIMCODE.SHIFT]:        Keyboardx86.SCANCODE.SHIFT,
        [Keys.ASCII['\\']]:                 Keyboardx86.SCANCODE.BSLASH,
        [Keys.ASCII['|']]:                  Keyboardx86.SCANCODE.BSLASH | (Keyboardx86.SCANCODE.SHIFT << 8),
        [Keys.ASCII.z]:                     Keyboardx86.SCANCODE.Z,
        [Keys.ASCII.Z]:                     Keyboardx86.SCANCODE.Z      | (Keyboardx86.SCANCODE.SHIFT << 8),
        [Keys.ASCII.x]:                     Keyboardx86.SCANCODE.X,
        [Keys.ASCII.X]:                     Keyboardx86.SCANCODE.X      | (Keyboardx86.SCANCODE.SHIFT << 8),
        [Keys.ASCII.c]:                     Keyboardx86.SCANCODE.C,
        [Keys.ASCII.C]:                     Keyboardx86.SCANCODE.C      | (Keyboardx86.SCANCODE.SHIFT << 8),
        [Keys.ASCII.v]:                     Keyboardx86.SCANCODE.V,
        [Keys.ASCII.V]:                     Keyboardx86.SCANCODE.V      | (Keyboardx86.SCANCODE.SHIFT << 8),
        [Keys.ASCII.b]:                     Keyboardx86.SCANCODE.B,
        [Keys.ASCII.B]:                     Keyboardx86.SCANCODE.B      | (Keyboardx86.SCANCODE.SHIFT << 8),
        [Keys.ASCII.n]:                     Keyboardx86.SCANCODE.N,
        [Keys.ASCII.N]:                     Keyboardx86.SCANCODE.N      | (Keyboardx86.SCANCODE.SHIFT << 8),
        [Keys.ASCII.m]:                     Keyboardx86.SCANCODE.M,
        [Keys.ASCII.M]:                     Keyboardx86.SCANCODE.M      | (Keyboardx86.SCANCODE.SHIFT << 8),
        [Keys.ASCII[',']]:                  Keyboardx86.SCANCODE.COMMA,
        [Keys.ASCII['<']]:                  Keyboardx86.SCANCODE.COMMA  | (Keyboardx86.SCANCODE.SHIFT << 8),
        [Keys.ASCII['.']]:                  Keyboardx86.SCANCODE.PERIOD,
        [Keys.ASCII['>']]:                  Keyboardx86.SCANCODE.PERIOD | (Keyboardx86.SCANCODE.SHIFT << 8),
        [Keys.ASCII['/']]:                  Keyboardx86.SCANCODE.SLASH,
        [Keys.ASCII['?']]:                  Keyboardx86.SCANCODE.SLASH  | (Keyboardx86.SCANCODE.SHIFT << 8),
        [Keyboardx86.SIMCODE.RSHIFT]:       Keyboardx86.SCANCODE.RSHIFT,
        [Keyboardx86.SIMCODE.PRTSC]:        Keyboardx86.SCANCODE.PRTSC,
        [Keyboardx86.SIMCODE.ALT]:          Keyboardx86.SCANCODE.ALT,
        [Keyboardx86.SIMCODE.RALT]:         Keyboardx86.SCANCODE.ALT,
        [Keyboardx86.SIMCODE.SPACE]:        Keyboardx86.SCANCODE.SPACE,
        [Keyboardx86.SIMCODE.CAPS_LOCK]:    Keyboardx86.SCANCODE.CAPS_LOCK,
        [Keyboardx86.SIMCODE.F1]:           Keyboardx86.SCANCODE.F1,
        [Keyboardx86.SIMCODE.F2]:           Keyboardx86.SCANCODE.F2,
        [Keyboardx86.SIMCODE.F3]:           Keyboardx86.SCANCODE.F3,
        [Keyboardx86.SIMCODE.F4]:           Keyboardx86.SCANCODE.F4,
        [Keyboardx86.SIMCODE.F5]:           Keyboardx86.SCANCODE.F5,
        [Keyboardx86.SIMCODE.F6]:           Keyboardx86.SCANCODE.F6,
        [Keyboardx86.SIMCODE.F7]:           Keyboardx86.SCANCODE.F7,
        [Keyboardx86.SIMCODE.F8]:           Keyboardx86.SCANCODE.F8,
        [Keyboardx86.SIMCODE.F9]:           Keyboardx86.SCANCODE.F9,
        [Keyboardx86.SIMCODE.F10]:          Keyboardx86.SCANCODE.F10,
        [Keyboardx86.SIMCODE.NUM_LOCK]:     Keyboardx86.SCANCODE.NUM_LOCK,
        [Keyboardx86.SIMCODE.SCROLL_LOCK]:  Keyboardx86.SCANCODE.SCROLL_LOCK,
        [Keyboardx86.SIMCODE.HOME]:         Keyboardx86.SCANCODE.NUM_HOME,
        [Keyboardx86.SIMCODE.NUM_HOME]:     Keyboardx86.SCANCODE.NUM_HOME,
        [Keyboardx86.SIMCODE.UP]:           Keyboardx86.SCANCODE.NUM_UP,
        [Keyboardx86.SIMCODE.NUM_UP]:       Keyboardx86.SCANCODE.NUM_UP,
        [Keyboardx86.SIMCODE.PGUP]:         Keyboardx86.SCANCODE.NUM_PGUP,
        [Keyboardx86.SIMCODE.NUM_PGUP]:     Keyboardx86.SCANCODE.NUM_PGUP,
        [Keyboardx86.SIMCODE.LEFT]:         Keyboardx86.SCANCODE.NUM_LEFT,
        [Keyboardx86.SIMCODE.NUM_LEFT]:     Keyboardx86.SCANCODE.NUM_LEFT,
        [Keyboardx86.SIMCODE.NUM_CENTER]:   Keyboardx86.SCANCODE.NUM_CENTER,
        [Keyboardx86.SIMCODE.RIGHT]:        Keyboardx86.SCANCODE.NUM_RIGHT,
        [Keyboardx86.SIMCODE.NUM_RIGHT]:    Keyboardx86.SCANCODE.NUM_RIGHT,
        [Keyboardx86.SIMCODE.END]:          Keyboardx86.SCANCODE.NUM_END,
        [Keyboardx86.SIMCODE.NUM_END]:      Keyboardx86.SCANCODE.NUM_END,
        [Keyboardx86.SIMCODE.DOWN]:         Keyboardx86.SCANCODE.NUM_DOWN,
        [Keyboardx86.SIMCODE.NUM_DOWN]:     Keyboardx86.SCANCODE.NUM_DOWN,
        [Keyboardx86.SIMCODE.PGDN]:         Keyboardx86.SCANCODE.NUM_PGDN,
        [Keyboardx86.SIMCODE.NUM_PGDN]:     Keyboardx86.SCANCODE.NUM_PGDN,
        [Keyboardx86.SIMCODE.INS]:          Keyboardx86.SCANCODE.NUM_INS,
        [Keyboardx86.SIMCODE.NUM_INS]:      Keyboardx86.SCANCODE.NUM_INS,
        [Keyboardx86.SIMCODE.NUM_ADD]:      Keyboardx86.SCANCODE.NUM_ADD,
        [Keyboardx86.SIMCODE.NUM_SUB]:      Keyboardx86.SCANCODE.NUM_SUB,
        [Keyboardx86.SIMCODE.DEL]:          Keyboardx86.SCANCODE.NUM_DEL,
        [Keyboardx86.SIMCODE.NUM_DEL]:      Keyboardx86.SCANCODE.NUM_DEL,

        /**
         * The next 6 entries are for keys that existed only on 101-key keyboards (well, except for SYS_REQ,
         * which also existed on the 84-key keyboard), which ALSO means that these keys essentially did not exist
         * for a MODEL_5150 or MODEL_5160 machine, because those machines could use only 83-key keyboards.  Remember
         * that IBM machines and IBM keyboards are our reference point here, so while there were undoubtedly 5150/5160
         * clones that could use newer keyboards, as well as 3rd-party keyboards that could work with older machines,
         * support for non-IBM configurations is left for another day.
         *
         * TODO: The only relevance of newer keyboards to older machines is the fact that you're probably using a newer
         * keyboard with your browser, which raises the question of what to do with newer keys that older machines
         * wouldn't understand.  I don't attempt to filter out any of the entries below based on machine model, but that
         * would seem like a wise thing to do.
         *
         * TODO: Add entries for 'num-mul', 'num-div', 'num-enter', the stand-alone arrow keys, etc, AND at the same time,
         * make sure that keys with multi-byte sequences (eg, 0xe0 0x1c) work properly.
         */
        [Keyboardx86.SIMCODE.SYS_REQ]:      Keyboardx86.SCANCODE.SYS_REQ,
        [Keyboardx86.SIMCODE.F11]:          Keyboardx86.SCANCODE.F11,
        [Keyboardx86.SIMCODE.F12]:          Keyboardx86.SCANCODE.F12,
        [Keyboardx86.SIMCODE.CMD]:          Keyboardx86.SCANCODE.WIN,
        [Keyboardx86.SIMCODE.RCMD]:         Keyboardx86.SCANCODE.MENU,
        [Keyboardx86.SIMCODE.FF_CMD]:       Keyboardx86.SCANCODE.WIN,

        [Keyboardx86.SIMCODE.SHIFT_TAB]:    Keyboardx86.SCANCODE.TAB | (Keyboardx86.SCANCODE.SHIFT << 8),

        [Keyboardx86.SIMCODE.CTRL_A]:       Keyboardx86.SCANCODE.A           | (Keyboardx86.SCANCODE.CTRL << 8),
        [Keyboardx86.SIMCODE.CTRL_B]:       Keyboardx86.SCANCODE.B           | (Keyboardx86.SCANCODE.CTRL << 8),
        [Keyboardx86.SIMCODE.CTRL_C]:       Keyboardx86.SCANCODE.C           | (Keyboardx86.SCANCODE.CTRL << 8),
        [Keyboardx86.SIMCODE.CTRL_D]:       Keyboardx86.SCANCODE.D           | (Keyboardx86.SCANCODE.CTRL << 8),
        [Keyboardx86.SIMCODE.CTRL_E]:       Keyboardx86.SCANCODE.E           | (Keyboardx86.SCANCODE.CTRL << 8),
        [Keyboardx86.SIMCODE.CTRL_F]:       Keyboardx86.SCANCODE.F           | (Keyboardx86.SCANCODE.CTRL << 8),
        [Keyboardx86.SIMCODE.CTRL_G]:       Keyboardx86.SCANCODE.G           | (Keyboardx86.SCANCODE.CTRL << 8),
        [Keyboardx86.SIMCODE.CTRL_H]:       Keyboardx86.SCANCODE.H           | (Keyboardx86.SCANCODE.CTRL << 8),
        [Keyboardx86.SIMCODE.CTRL_I]:       Keyboardx86.SCANCODE.I           | (Keyboardx86.SCANCODE.CTRL << 8),
        [Keyboardx86.SIMCODE.CTRL_J]:       Keyboardx86.SCANCODE.J           | (Keyboardx86.SCANCODE.CTRL << 8),
        [Keyboardx86.SIMCODE.CTRL_K]:       Keyboardx86.SCANCODE.K           | (Keyboardx86.SCANCODE.CTRL << 8),
        [Keyboardx86.SIMCODE.CTRL_L]:       Keyboardx86.SCANCODE.L           | (Keyboardx86.SCANCODE.CTRL << 8),
        [Keyboardx86.SIMCODE.CTRL_M]:       Keyboardx86.SCANCODE.M           | (Keyboardx86.SCANCODE.CTRL << 8),
        [Keyboardx86.SIMCODE.CTRL_N]:       Keyboardx86.SCANCODE.N           | (Keyboardx86.SCANCODE.CTRL << 8),
        [Keyboardx86.SIMCODE.CTRL_O]:       Keyboardx86.SCANCODE.O           | (Keyboardx86.SCANCODE.CTRL << 8),
        [Keyboardx86.SIMCODE.CTRL_P]:       Keyboardx86.SCANCODE.P           | (Keyboardx86.SCANCODE.CTRL << 8),
        [Keyboardx86.SIMCODE.CTRL_Q]:       Keyboardx86.SCANCODE.Q           | (Keyboardx86.SCANCODE.CTRL << 8),
        [Keyboardx86.SIMCODE.CTRL_R]:       Keyboardx86.SCANCODE.R           | (Keyboardx86.SCANCODE.CTRL << 8),
        [Keyboardx86.SIMCODE.CTRL_S]:       Keyboardx86.SCANCODE.S           | (Keyboardx86.SCANCODE.CTRL << 8),
        [Keyboardx86.SIMCODE.CTRL_T]:       Keyboardx86.SCANCODE.T           | (Keyboardx86.SCANCODE.CTRL << 8),
        [Keyboardx86.SIMCODE.CTRL_U]:       Keyboardx86.SCANCODE.U           | (Keyboardx86.SCANCODE.CTRL << 8),
        [Keyboardx86.SIMCODE.CTRL_V]:       Keyboardx86.SCANCODE.V           | (Keyboardx86.SCANCODE.CTRL << 8),
        [Keyboardx86.SIMCODE.CTRL_W]:       Keyboardx86.SCANCODE.W           | (Keyboardx86.SCANCODE.CTRL << 8),
        [Keyboardx86.SIMCODE.CTRL_X]:       Keyboardx86.SCANCODE.X           | (Keyboardx86.SCANCODE.CTRL << 8),
        [Keyboardx86.SIMCODE.CTRL_Y]:       Keyboardx86.SCANCODE.Y           | (Keyboardx86.SCANCODE.CTRL << 8),
        [Keyboardx86.SIMCODE.CTRL_Z]:       Keyboardx86.SCANCODE.Z           | (Keyboardx86.SCANCODE.CTRL << 8),
        [Keyboardx86.SIMCODE.CTRL_BREAK]:   Keyboardx86.SCANCODE.SCROLL_LOCK | (Keyboardx86.SCANCODE.CTRL << 8),

        [Keyboardx86.SIMCODE.CTRL_ALT_DEL]:     Keyboardx86.SCANCODE.NUM_DEL | (Keyboardx86.SCANCODE.CTRL << 8) | (Keyboardx86.SCANCODE.ALT << 16),
        [Keyboardx86.SIMCODE.CTRL_ALT_INS]:     Keyboardx86.SCANCODE.NUM_INS | (Keyboardx86.SCANCODE.CTRL << 8) | (Keyboardx86.SCANCODE.ALT << 16),
        [Keyboardx86.SIMCODE.CTRL_ALT_ADD]:     Keyboardx86.SCANCODE.NUM_ADD | (Keyboardx86.SCANCODE.CTRL << 8) | (Keyboardx86.SCANCODE.ALT << 16),
        [Keyboardx86.SIMCODE.CTRL_ALT_SUB]:     Keyboardx86.SCANCODE.NUM_SUB | (Keyboardx86.SCANCODE.CTRL << 8) | (Keyboardx86.SCANCODE.ALT << 16),
        [Keyboardx86.SIMCODE.CTRL_ALT_ENTER]:   Keyboardx86.SCANCODE.ENTER   | (Keyboardx86.SCANCODE.CTRL << 8) | (Keyboardx86.SCANCODE.ALT << 16),
        [Keyboardx86.SIMCODE.CTRL_ALT_SYS_REQ]: Keyboardx86.SCANCODE.SYS_REQ | (Keyboardx86.SCANCODE.CTRL << 8) | (Keyboardx86.SCANCODE.ALT << 16)
    };

    /**
     * Keyboardx86(parmsKbd)
     *
     * The Keyboard component can be configured with the following (parmsKbd) properties:
     *
     *      model: keyboard model string, which must match one of the values listed in Keyboardx86.MODELS:
     *
     *          "US83" (default)
     *          "US84"
     *          "US101" (not fully supported yet)
     *
     *      autoType: string of keys to automatically inject when the machine is ready (undefined if none)
     *
     *      softKeys: boolean set to true to enable the machine's soft keyboard, if any (default is false)
     *
     * Its main purpose is to receive binding requests for various keyboard events, and to use those events
     * to simulate the PC's keyboard hardware.
     *
     * TODO: Consider finishing 101-key keyboard support, even though that's sort of a "PS/2" thing, and I'm not
     * really interested in taking PCjs into the PS/2 line (that's also why we still support only serial mice, not
     * "PS/2" mice).  In addition, all keyboards *after* the original PC 83-key keyboard supported their own unique
     * scan code sets, which the 8042 controller would then convert to PC-compatible scan codes.  That's probably
     * more important to implement, because that feature was introduced with the 84-key keyboard on the PC AT.
     *
     * @this {Keyboardx86}
     * @param {Object} parmsKbd
     */
    constructor(parmsKbd)
    {
        super("Keyboard", parmsKbd, MESSAGE.KBD);

        this.setModel(parmsKbd['model']);

        this.fMobile = WebLib.isMobile("!iPad");
        this.printf("mobile keyboard support: %b\n", this.fMobile);

        /**
         * This flag (formerly fMSIE, for all versions of Microsoft Internet Explorer, up to and including v11)
         * has been updated to reflect the Microsoft Windows *platform* rather than the *browser*, because it appears
         * that all Windows-based browsers (at least now, as of 2018) have the same behavior with respect to "lock"
         * keys: keys like CAPS-LOCK generate both UP and DOWN events on every press.  On other platforms (eg, macOS),
         * those keys generate only a DOWN event when "locking" and only an UP event when "unlocking".
         */
        this.fMSWindows = WebLib.isUserAgent("Windows");

        /**
         * This is count of the number of "soft keyboard" keys present.  At the moment, its only
         * purpose is to signal findBinding() whether to waste any time looking for SOFTCODE matches.
         */
        this.cSoftCodes = 0;
        this.fSoftKeyboard = parmsKbd['softKeys'];
        this.controlSoftKeyboard = null;
        this.controlTextKeyboard = null;

        /**
         * Updated by onFocusChange()
         */
        this.fHasFocus = true;

        /**
         * This can be used to delay ALT key generation (ie, until some other key in conjunction with the
         * ALT is pressed as well); however, it is currently off by default, because there are apps (eg, the
         * MS-DOS Manager) that don't deal well the rapid back-to-back ALT+key generation that this work-around
         * necessitates.
         */
        this.fDelayALT = false;

        /**
         * This is true whenever the physical Escape key is disabled (eg, by pointer locking code),
         * giving us the opportunity to map a different physical key to machine's virtual Escape key.
         */
        this.fEscapeDisabled = false;

        /**
         * This is set whenever we notice a discrepancy between our internal CAPS_LOCK state and its
         * apparent state; we check whenever aKeysActive has been emptied.
         */
        this.fToggleCapsLock = false;

        /**
         * New unified approach to key event processing: When we process a key on the "down" event,
         * we check the aKeysActive array: if the key is already active, do nothing; otherwise, insert
         * it into the table, generate the "make" scan code(s), and set a timeout for "repeat" if it's
         * a repeatable key (most are).
         *
         * Similarly, when a key goes "up", if it's already not active, do nothing; otherwise, generate
         * the "break" scan code(s), cancel any pending timeout, and remove it from the active key table.
         *
         * If a "press" event is received, then if the key is already active, remove it and (re)insert
         * it at the head of the table, generate the "make" scan code(s), set nRepeat to -1, and set a
         * timeout for "break".
         *
         * This requires an aKeysActive array that keeps track of the status of every active key; only the
         * first entry in the array is allowed to repeat.  Each entry is a key object with the following
         * properties:
         *
         *      simCode:    our simulated keyCode from onKeyActive or onKeyPress
         *      bitsState:  snapshot of the current bitsState when the key is added (currently not used)
         *      fDown:      next state to simulate (true for down, false for up)
         *      nRepeat:    > 0 if timer should generate more "make" scan code(s), -1 for "break" scan code(s)
         *      timer:      timer for next key operation, if any
         *
         * Keys are inserted at the head of aKeysActive, using splice(0, 0, key), but not before zeroing
         * nRepeat of any repeating key that already occupies the head (index 0), so that at most only one
         * key (ie, the most recent) will ever be in a repeating state.
         *
         * IBM PC keyboard repeat behavior: when pressing CTRL, then C, and then releasing CTRL while still
         * holding C, the repeated CTRL_C characters turn into 'c' characters.  We emulate that behavior.
         * However, when pressing C, then CTRL, all repeating stops: not a single CTRL_C is generated, and
         * even if the CTRL is released before the C, no more more 'c' characters are generated either.
         * We do NOT fully emulate that behavior -- we DO stop the repeating, but we also generate one CTRL_C.
         * More investigation is required, because I need to confirm whether the IBM keyboard automatically
         * "breaks" all non-shift keys before it "makes" the CTRL.
         */
        this.aKeysActive = [];

        /**
         * msTransmit was originally 10ms, but I was getting some warning "beeps" in this machine:
         *
         *      /devices/pcx86/machine/5170/ega/2048kb/rev3/debugger/machine.xml
         *
         * while typing very fast, so I bumped it to 15ms. Then the COMPAQ Portable BIOS required another bump to 25ms.
         */
        this.msTransmit      = 25;          // minimum number of milliseconds between data transmissions
        this.msAutoRepeat    = 500;
        this.msNextRepeat    = 100;
        this.msAutoRelease   = 50;
        this.msInjectDefault = 100;         // number of milliseconds between injected keystrokes
        this.msInjectDelay   = 0;           // set by the initial injectKeys() call
        this.msDoubleClick   = 250;         // used by mousedown/mouseup handlers to soft-lock modifier keys
        this.cKeysPressed    = 0;           // count of keys pressed since the last time it was reset
        this.softCodeKeys    = Object.keys(Keyboardx86.SOFTCODES);

        /**
         * Remove all single-character SOFTCODE keys from the softCodeKeys array, because those SOFTCODES
         * are not supported by injectKeys(); they can be specified normally using their single-character identity.
         */
        for (let i = 0; i < this.softCodeKeys.length; i++) {
            if (this.softCodeKeys[i].length < 2) {
                this.softCodeKeys.splice(i, 1);
                i--;
            }
        }

        /**
         * autoType records the machine's specified autoType sequence, if any, and when injectInit() is called
         * with the appropriate INJECTION signal, injectInit() pass autoType to injectKeys().
         */
        this.autoType = parmsKbd['autoType'];
        this.fDOSReady = false;
        this.fnDOSReady = this.fnInjectReady = null;
        this.nInjection = Keyboardx86.INJECTION.ON_INPUT;

        /**
         * HACK: We set fAllDown to false to ignore all down/up events for keys not explicitly marked as ONDOWN;
         * even though that prevents those keys from being repeated properly (ie, at the simulation's repeat rate
         * rather than the browser's repeat rate), it's the safest thing to do when dealing with international keyboards,
         * because our mapping tables are designed for US keyboards, and testing all the permutations of international
         * keyboards and web browsers is more work than I can take on right now.  TODO: Dig into this some day.
         */
        this.fAllDown = false;

        this['exports'] = {
            'type':         this.injectKeys,
            'wait':         this.waitReady
        };

        this.setReady();
    }

    /**
     * setBinding(sHTMLType, sBinding, control, sValue)
     *
     * @this {Keyboardx86}
     * @param {string} sHTMLType is the type of the HTML control (eg, "button", "list", "text", "submit", "textarea", "canvas")
     * @param {string} sBinding is the value of the 'binding' parameter stored in the HTML control's "data-value" attribute (eg, "esc")
     * @param {HTMLElement} control is the HTML control DOM object (eg, HTMLButtonElement)
     * @param {string} [sValue] optional data value
     * @returns {boolean} true if binding was successful, false if unrecognized binding request
     */
    setBinding(sHTMLType, sBinding, control, sValue)
    {
        let kbd = this;
        let className;
        let id = sHTMLType + '-' + sBinding, sCode;
        let controlText = /** @type {HTMLTextAreaElement} */ (control);

        if (this.bindings[id] === undefined) {
            switch (sBinding) {
            case "keys":
            case "keyboard":
                try {
                    let controlSoftKeyboard = document.getElementById(this.idMachine + ".soft-keyboard" + (this.fMobile? "-mobile" : ""));
                    if (!controlSoftKeyboard) {
                        /**
                         * TODO: Fix this rather fragile code, which depends on the current structure of the given xxxx-softkeys.xml
                         */
                        controlSoftKeyboard = control.parentElement.parentElement.nextElementSibling;
                        className = controlSoftKeyboard.className;
                        if (this.fMobile != (className.indexOf('mobile') >= 0)) {
                            controlSoftKeyboard = controlSoftKeyboard.nextElementSibling;
                        }
                    }
                    if (controlSoftKeyboard) {
                        this.controlSoftKeyboard = controlSoftKeyboard;
                        if (this.fSoftKeyboard != null) {
                            this.enableSoftKeyboard(this.fSoftKeyboard);
                        } else {
                            let style = getComputedStyle(controlSoftKeyboard);
                            this.fSoftKeyboard = (style.display != "none");
                        }
                        control.onclick = function onToggleKeyboard(event) {
                            kbd.enableSoftKeyboard(!kbd.fSoftKeyboard);
                        };
                        /**
                         * This is added simply to prevent the page from "zooming" around if you accidentally touch between the keys.
                         */
                        if ('ontouchstart' in window) {
                            controlSoftKeyboard.ontouchstart = function onTouchKeyboard(event) {
                                event.preventDefault();
                            };
                        }
                    }
                } catch(err) {}
                return true;

            case "screen":
                /**
                 * This is a special binding that the Video component uses to effectively bind its screen to the
                 * entire keyboard; eg:
                 *
                 *      this.kbd.setBinding(this.inputTextArea? "textarea" : "canvas", "screen", this.inputScreen);
                 *
                 * Recording the binding ID prevents multiple controls (or components) from attempting to erroneously
                 * bind a control to the same ID, but in the case of a "dual display" configuration, we actually want
                 * to allow BOTH video components to call setBinding() for "screen", so that it doesn't matter which
                 * display the user gives focus to.
                 *
                 *      this.bindings[id] = control;
                 */
                if (sHTMLType == "textarea" && !WebLib.isUserAgent("iPhone")) {
                    this.controlTextKeyboard = controlText;
                    this.controlTextKeyboard.addEventListener(
                        'copy',
                        function onKeyCopy(event) {
                            kbd.onCopy(event);
                        }
                    );
                    this.controlTextKeyboard.addEventListener(
                        'cut',
                        function onKeyCut(event) {
                            kbd.onCut(event);
                        }
                    );
                    this.controlTextKeyboard.addEventListener(
                        'paste',
                        function onKeyPaste(event) {
                            kbd.onPaste(event);
                        }
                    );
                }
                controlText.onkeydown = function onKeyDown(event) {
                    return kbd.onKeyActive(event, true);
                };
                controlText.onkeypress = function onKeyPress(event) {
                    return kbd.onKeyPress(event);
                };
                controlText.onkeyup = function onKeyUp(event) {
                    return kbd.onKeyActive(event, false);
                };
                return true;

            case "caps-lock":
                if (sHTMLType == 'led') {
                    this.bindings[id] = control;
                    control.onclick = function onClickCapsLock(event) {
                        kbd.updateFocus(event);
                        return kbd.toggleCapsLock();
                    };
                    return true;
                }
                /* falls through */

            case "num-lock":
                if (sHTMLType == 'led') {
                    this.bindings[id] = control;
                    control.onclick = function onClickNumLock(event) {
                        kbd.updateFocus(event);
                        return kbd.toggleNumLock();
                    };
                    return true;
                }
                /* falls through */

            case "scroll-lock":
                if (sHTMLType == 'led') {
                    this.bindings[id] = control;
                    control.onclick = function onClickScrollLock(event) {
                        kbd.updateFocus(event);
                        return kbd.toggleScrollLock();
                    };
                    return true;
                }
                /* falls through */

            default:
                /**
                 * Maintain support for older button codes; eg, map button code "ctrl-c" to CLICKCODE "CTRL_C"
                 */
                sCode = sBinding.toUpperCase().replace(/-/g, '_');
                if (Keyboardx86.CLICKCODES[sCode] !== undefined && sHTMLType == "button") {
                    this.bindings[id] = controlText;
                    if (MAXDEBUG) this.printf(MESSAGE.LOG, "binding click-code '%s'\n", sCode);
                    controlText.onclick = function(kbd, sKey, simCode) {
                        return function onKeyboardBindingClick(event) {
                            kbd.printf(MESSAGE.EVENT + MESSAGE.KEY, "%s clicked\n", sKey);
                            kbd.updateFocus(event);
                            kbd.sInjectBuffer = "";                 // key events should stop any injection currently in progress
                            kbd.updateShiftState(simCode, true);    // future-proofing if/when any LOCK keys are added to CLICKCODES
                            kbd.addActiveKey(simCode, true);
                        };
                    }(this, sCode, Keyboardx86.CLICKCODES[sCode]);
                    return true;
                }
                else if (Keyboardx86.SOFTCODES[sBinding] !== undefined) {
                    /**
                     * TODO: Fix this rather fragile code, which depends on the current structure of the given xxxx-softkeys.xml
                     */
                    className = control.parentElement.parentElement.className;
                    if (className && this.fMobile != (className.indexOf('mobile') >= 0)) {
                        break;
                    }
                    this.cSoftCodes++;
                    this.bindings[id] = controlText;
                    if (MAXDEBUG) this.printf(MESSAGE.LOG, "binding soft-code '%s'\n", sBinding);
                    let msLastEvent = 0, nClickState = 0;
                    let fStateKey = (Keyboardx86.KEYSTATES[Keyboardx86.SOFTCODES[sBinding]] <= Keyboardx86.STATE.ALL_MODIFIERS);
                    let fnDown = function(kbd, sKey, simCode) {
                        return function onKeyboardBindingDown(event) {
                            let msDelta = event.timeStamp - msLastEvent;
                            nClickState = (nClickState && msDelta < kbd.msDoubleClick? (nClickState << 1) : 1);
                            msLastEvent = event.timeStamp;
                            event.preventDefault();                 // preventDefault() is necessary to avoid "zooming" when you type rapidly
                            kbd.sInjectBuffer = "";                 // key events should stop any injection currently in progress
                            kbd.addActiveKey(simCode);
                        };
                    }(this, sBinding, Keyboardx86.SOFTCODES[sBinding]);
                    let fnUp = function(kbd, sKey, simCode) {
                        return function onKeyboardBindingUp(event) {
                            if (nClickState) {
                                let msDelta = event.timeStamp - msLastEvent;
                                nClickState = (fStateKey && msDelta < kbd.msDoubleClick? (nClickState << 1) : 0);
                                msLastEvent = event.timeStamp;
                                if (nClickState < 8) {
                                    kbd.removeActiveKey(simCode);
                                } else {
                                    if (MAXDEBUG) this.printf(MESSAGE.LOG, "soft-locking '%s'\n", sBinding);
                                    nClickState = 0;
                                }
                            }
                        };
                    }(this, sBinding, Keyboardx86.SOFTCODES[sBinding]);
                    if ('ontouchstart' in window) {
                        controlText.ontouchstart = fnDown;
                        controlText.ontouchend = fnUp;
                    } else {
                        controlText.onmousedown = fnDown;
                        controlText.onmouseup = controlText.onmouseout = fnUp;
                    }
                    return true;
                }
                else if (sValue) {
                    /**
                     * Instead of just having a dedicated "test" control, we now treat any unrecognized control with
                     * a "value" attribute as a test control.  The only caveat is that such controls must have binding IDs
                     * that do not conflict with predefined controls (which, of course, is the only way you can get here).
                     */
                    this.bindings[id] = control;
                    control.onclick = function onClickTest(event) {
                        kbd.updateFocus(event);
                        return kbd.injectKeys(sValue);
                    };
                    return true;
                }
                break;
            }
        }
        return false;
    }

    /**
     * updateFocus(event)
     *
     * Keyboard control event focus helper.
     *
     * @this {Keyboardx86}
     * @param {Object} event
     */
    updateFocus(event)
    {
        event.preventDefault();     // preventDefault() is necessary for the updateFocus() call to work
        if (!this.fSoftKeyboard && this.cmp) this.cmp.updateFocus();
    }

    /**
     * findBinding(simCode, sType, fDown)
     *
     * TODO: This function is woefully inefficient, because the SOFTCODES table is designed for converting
     * soft key presses into SIMCODES, whereas this function is doing the reverse: looking for the soft key,
     * if any, that corresponds to a SIMCODE, simply so we can provide visual feedback of keys activated
     * by other means (eg, real keyboard events, button clicks that generate key sequences like CTRL-ALT-DEL,
     * etc).
     *
     * To minimize this function's cost, we would want to dynamically create a reverse-lookup table after
     * all the setBinding() calls for the soft keys have been established; note that the reverse-lookup table
     * would contain MORE entries than the SOFTCODES table, because there are multiple simCodes that correspond
     * to a given soft key (eg, '1' and '!' both map to the same soft key).
     *
     * @this {Keyboardx86}
     * @param {number} simCode
     * @param {string} sType is the type of control (eg, "button" or "key")
     * @param {boolean} [fDown] is true if the key is going down, false if up, or undefined if unchanged
     * @returns {Object} is the HTML control DOM object (eg, HTMLButtonElement), or undefined if no such control exists
     */
    findBinding(simCode, sType, fDown)
    {
        let control;
        if (this.cSoftCodes && this.fSoftKeyboard) {
            for (let code in Keys.SHIFTED_KEYCODES) {
                if (simCode == Keys.SHIFTED_KEYCODES[code]) {
                    simCode = +code;
                    code = Keys.NONASCII_KEYCODES[code];
                    if (code) simCode = +code;
                    break;
                }
            }
            /**
             * TODO: Create a table that maps these SIMCODEs to the corresponding entries in the SOFTCODES table;
             * these SIMCODEs can be generated by CLICKCODEs or by the special key remapping HACKs in onKeyActive().
             */
            if (simCode == Keyboardx86.SIMCODE.CTRL_PAUSE) {
                simCode = Keyboardx86.SIMCODE.NUM_LOCK;
            }
            else if (simCode == Keyboardx86.SIMCODE.CTRL_BREAK) {
                simCode = Keyboardx86.SIMCODE.SCROLL_LOCK;
            }
            else if (simCode == Keyboardx86.SIMCODE.CTRL_ALT_DEL) {
                simCode = Keyboardx86.SIMCODE.DEL;
            }
            else if (simCode == Keyboardx86.SIMCODE.CTRL_ALT_INS) {
                simCode = Keyboardx86.SIMCODE.INS;
            }
            else if (simCode == Keyboardx86.SIMCODE.CTRL_ALT_ADD) {
                simCode = Keyboardx86.SIMCODE.NUM_ADD;
            }
            else if (simCode == Keyboardx86.SIMCODE.CTRL_ALT_SUB) {
                simCode = Keyboardx86.SIMCODE.NUM_SUB;
            }
            else if (simCode == Keyboardx86.SIMCODE.CTRL_ALT_SYS_REQ) {
                simCode = Keyboardx86.SIMCODE.SYS_REQ;
            }
            for (let sBinding in Keyboardx86.SOFTCODES) {
                if (Keyboardx86.SOFTCODES[sBinding] == simCode || Keyboardx86.SOFTCODES[sBinding] == this.toUpperKey(simCode)) {
                    let id = sType + '-' + sBinding;
                    control = this.bindings[id];
                    if (control && fDown !== undefined) {
                        this.setSoftKeyState(control, fDown);
                    }
                    break;
                }
            }
        }
        return control;
    }

    /**
     * initBus(cmp, bus, cpu, dbg)
     *
     * @this {Keyboardx86}
     * @param {Computer} cmp
     * @param {Busx86} bus
     * @param {CPUx86} cpu
     * @param {Debuggerx86} dbg
     */
    initBus(cmp, bus, cpu, dbg)
    {
        this.cmp = cmp;
        this.bus = bus;
        this.cpu = cpu;
        this.dbg = dbg;

        let kbd = this;
        this.timerInject = this.cpu.addTimer(this.id + ".inject", function injectKeysTimer() {
            kbd.injectKeys();
        });

        this.timerTransmit = this.cpu.addTimer(this.id + ".transmit", function transmitDataTimer() {
            kbd.transmitData();
        });

        this.chipset = cmp.getMachineComponent("ChipSet");
        this.autoType = cmp.getMachineParm('autoType') || this.autoType;

        let softKeys = cmp.getMachineParm('softKeys');
        if (softKeys) this.enableSoftKeyboard(softKeys != "false");

        this.video = cmp.getMachineComponent("Video");
        cpu.addIntNotify(Interrupts.DOS, this.intDOS.bind(this));
    }

    /**
     * start()
     *
     * Notification from the Computer that it's starting.
     *
     * We take advantage of the fact that this notification occurs AFTER the Computer component has disabled the
     * textarea overlay for diagnostic purposes; we must partially "re-enable" it in order for the browser to send
     * us "paste" events.  In particular, while setting lineHeight to zero was a good way to ensure the textarea
     * was completely invisible (as well as disabling any blinking cursor/caret whenever the textarea had focus),
     * it turns out that lineHeight must NOT be zero to allow paste events.  Obvious, eh?  We can only hope that the
     * textarea still remains invisible in all browsers, largely by virtue of its opacity having been set to zero
     * when diagnostic display was disabled.  In addition, we must select all the diagnostic text still residing
     * in the textarea so that we'll receive "copy" events.
     *
     * I tried setting lineHeight on-demand (eg, inside an "oncontextmenu" event handler), but that was too late,
     * at least for the first time you right-clicked.  And that wouldn't have helped with paste events triggered by
     * keyboard shortcut (eg, Cmd+V), or with machines where mouse events were being captured as well.
     *
     * @this {Keyboardx86}
     */
    start()
    {
        if (this.controlTextKeyboard) {
            this.controlTextKeyboard.style.lineHeight = "normal";
            this.controlTextKeyboard.focus();
            this.controlTextKeyboard.select();
        }
        this.injectInit(Keyboardx86.INJECTION.ON_START);
    }

    /**
     * intDOS()
     *
     * Monitors selected DOS interrupts for signals to initialize 'autoType' injection.
     *
     * @this {Keyboardx86}
     * @param {number} addr
     * @returns {boolean} true to proceed with the INT 0x21 software interrupt, false to skip
     */
    intDOS(addr)
    {
        let AH = (this.cpu.regEAX >> 8) & 0xff;
        this.fDOSReady = false;
        if (AH == 0x0A) {
            this.fDOSReady = true;
            if (this.fnDOSReady) {
                this.fnDOSReady();
                this.fnDOSReady = null;
            } else {
                this.injectInit(Keyboardx86.INJECTION.ON_INPUT);
            }
        }
        return true;
    }

    /**
     * notifyEscape(fDisabled, fAllDown)
     *
     * When ESC is used by the browser to disable pointer lock, this gives us the option of mapping a different key to ESC.
     *
     * @this {Keyboardx86}
     * @param {boolean} fDisabled
     * @param {boolean} [fAllDown] (an experimental option to re-enable processing of all onkeydown/onkeyup events)
     */
    notifyEscape(fDisabled, fAllDown)
    {
        this.fEscapeDisabled = fDisabled;
        if (fAllDown !== undefined) this.fAllDown = fAllDown;
    }

    /**
     * resetDevice()
     *
     * @this {Keyboardx86}
     */
    resetDevice()
    {
        /**
         * TODO: There's more to reset, like LED indicators, default type rate, and emptying the scan code buffer.
         */
        this.printf(MESSAGE.KBD + MESSAGE.PORT, "keyboard reset\n");
        this.abBuffer = [];
        this.setResponse(Keyboardx86.CMDRES.BAT_OK);
    }

    /**
     * setModel(sModel)
     *
     * This breaks a model string (eg, "US83") into two parts: modelCountry (eg, "US") and modelKeys (eg, 83).
     * If the model string isn't recognized, we use Keyboardx86.MODELS[0] (ie, the first entry in the model array).
     *
     * @this {Keyboardx86}
     * @param {string|undefined} sModel
     */
    setModel(sModel)
    {
        let iModel = 0;
        this.model = null;
        if (typeof sModel == "string") {
            this.model = sModel.toUpperCase();
            iModel = Keyboardx86.MODELS.indexOf(this.model);
            if (iModel < 0) iModel = 0;
        }
        sModel = Keyboardx86.MODELS[iModel];
        if (sModel) {
            this.modelCountry = sModel.substr(0, 2);
            this.modelKeys = parseInt(sModel.substr(2), 10);
        }
    }

    /**
     * checkBuffer(b)
     *
     * This is the ChipSet's interface to let us know it's ready.
     *
     * @this {Keyboardx86}
     * @param {number} [b] (set to the data, if any, that the ChipSet just delivered)
     */
    checkBuffer(b)
    {
        let fReady = false;
        if (b) {
            /**
             * The following hack is for the 5170 ROM BIOS keyboard diagnostic, which expects the keyboard
             * to report BAT_OK immediately after the ACK from a RESET command.  The BAT_OK response should already
             * be in the keyboard's buffer; we just need to give it a little nudge.
             */
            if (b == Keyboardx86.CMDRES.ACK) {
                fReady = true;
            }
            if (this.cpu) {
                this.cpu.setTimer(this.timerTransmit, this.msTransmit, true);
            }
        }
        this.transmitData(fReady);
    }

    /**
     * flushBuffer()
     *
     * This is the ChipSet's interface to flush any buffered keyboard data.
     *
     * @this {Keyboardx86}
     */
    flushBuffer()
    {
        this.abBuffer = [];
        if (!COMPILED) this.printf("keyboard data flushed\n");
    }

    /**
     * receiveCmd(bCmd)
     *
     * This is the ChipSet's interface for controlling "Model M" keyboards (ie, those used with MODEL_5170
     * machines).  Commands are delivered through the ChipSet's 8042 Keyboard Controller.
     *
     * @this {Keyboardx86}
     * @param {number} bCmd should be one of the Keyboardx86.CMD.* command codes (Model M keyboards only)
     * @returns {number} response should be one of the Keyboardx86.CMDRES.* response codes, or -1 if unrecognized
     */
    receiveCmd(bCmd)
    {
        let b = -1;

        if (!COMPILED) this.printf("receiveCmd(%#04X)\n", this.bCmdPending || bCmd);

        switch(this.bCmdPending || bCmd) {

        case Keyboardx86.CMD.RESET:              // 0xFF
            b = Keyboardx86.CMDRES.ACK;
            this.resetDevice();
            break;

        case Keyboardx86.CMD.SET_RATE:           // 0xF3
            if (this.bCmdPending) {
                this.setRate(bCmd);
                bCmd = 0;
            }
            this.setResponse(Keyboardx86.CMDRES.ACK);
            this.bCmdPending = bCmd;
            break;

        case Keyboardx86.CMD.SET_LEDS:           // 0xED
            if (this.bCmdPending) {
                this.setLEDs(bCmd);
                bCmd = 0;
            }
            this.setResponse(Keyboardx86.CMDRES.ACK);
            this.bCmdPending = bCmd;
            break;

        default:
            if (!COMPILED) this.printf("receiveCmd(): unrecognized command\n");
            break;
        }

        return b;
    }

    /**
     * setEnabled(fData, fClock)
     *
     * This is the ChipSet's interface for toggling keyboard "data" and "clock" lines.
     *
     * For MODEL_5150 and MODEL_5160 machines, this function is called from the ChipSet's PPI_B
     * output handler.  For MODEL_5170 machines, this function is called when selected CMD
     * "data bytes" have been written.
     *
     * @this {Keyboardx86}
     * @param {boolean} fData is true if the keyboard simulated data line should be enabled
     * @param {boolean} fClock is true if the keyboard's simulated clock line should be enabled
     * @returns {boolean} true if keyboard was re-enabled, false if not (or no change)
     */
    setEnabled(fData, fClock)
    {
        let fReset = false;
        if (this.fClock !== fClock) {
            if (!COMPILED) this.printf(MESSAGE.KBD + MESSAGE.PORT, "keyboard clock line changing to %b\n", fClock);
            /**
             * Toggling the clock line low and then high signals a "reset", which we acknowledge once the
             * data line is high as well.
             */
            this.fClock = this.fResetOnEnable = fClock;
        }
        if (this.fData !== fData) {
            if (!COMPILED) this.printf(MESSAGE.KBD + MESSAGE.PORT, "keyboard data line changing to %b\n", fData);
            this.fData = fData;
            if (fData && !this.fResetOnEnable) {
                this.transmitData(true);
            }
        }
        if (this.fData && this.fResetOnEnable) {
            this.resetDevice();
            this.fResetOnEnable = false;
            fReset = true;
        }
        return fReset;
    }

    /**
     * setLEDs(b)
     *
     * This processes the option byte received after a SET_LEDS command byte.
     *
     * @this {Keyboardx86}
     * @param {number} b
     */
    setLEDs(b)
    {
        this.bLEDs = b;             // TODO: Implement
    }

    /**
     * setRate(b)
     *
     * This processes the rate parameter byte received after a SET_RATE command byte.
     *
     * @this {Keyboardx86}
     * @param {number} b
     */
    setRate(b)
    {
        this.bRate = b;             // TODO: Implement
    }

    /**
     * setResponse(b)
     *
     * @this {Keyboardx86}
     * @param {number} b
     */
    setResponse(b)
    {
        if (this.chipset) {
            this.abBuffer.unshift(b);
            if (!COMPILED) this.printf("keyboard response %#04X buffered\n", b);
            this.transmitData();
        }
    }

    /**
     * transmitData(fReady)
     *
     * This manages communication with the ChipSet's receiveKbdData() interface.
     *
     * @this {Keyboardx86}
     * @param {boolean} [fReady]
     */
    transmitData(fReady)
    {
        if (this.chipset) {
            if (fReady || !this.cpu.isTimerSet(this.timerTransmit)) {
                /**
                 * The original IBM PC BIOS performs a "stuck key" test by resetting the keyboard
                 * (by toggling the CLOCK line), then checking for a BAT_OK response (0xAA), and then
                 * clocking in the next byte (by toggling the DATA line); if that next byte isn't 0x00,
                 * then the BIOS reports a "301" error, along with "AA" if we failed to properly flush
                 * the BAT_OK response.
                 */
                let b = this.abBuffer.length? this.abBuffer[0] : 0;
                if (this.chipset.receiveKbdData(b)) {
                    if (!COMPILED) this.printf("keyboard data %#04X delivered\n", b);
                    this.abBuffer.shift();
                }
                if (b) this.cpu.setTimer(this.timerTransmit, this.msTransmit);
            }
        }
    }

    /**
     * powerUp(data, fRepower)
     *
     * @this {Keyboardx86}
     * @param {Object|null} data
     * @param {boolean} [fRepower]
     * @returns {boolean} true if successful, false if failure
     */
    powerUp(data, fRepower)
    {
        if (!fRepower) {
            /**
             * TODO: Save/restore support for Keyboard is the barest minimum.  In fact, originally, I wasn't
             * saving/restoring anything, and that was OK, but if we don't at least re-initialize fClock/fData,
             * we can get a spurious reset following a restore.  In an ideal world, we might choose to save/restore
             * abBuffer as well, but realistically, I think it's going to be safer to always start with an
             * empty buffer--and who's going to notice anyway?
             *
             * So, like Debugger, we deviate from the typical save/restore pattern: instead of reset OR restore,
             * we always reset and then perform a (very limited) restore.
             */
            this.reset();
            if (data && this.restore) {
                if (!this.restore(data)) return false;
            }
        }
        return true;
    }

    /**
     * powerDown(fSave, fShutdown)
     *
     * @this {Keyboardx86}
     * @param {boolean} [fSave]
     * @param {boolean} [fShutdown]
     * @returns {Object|boolean} component state if fSave; otherwise, true if successful, false if failure
     */
    powerDown(fSave, fShutdown)
    {
        return fSave? this.save() : true;
    }

    /**
     * reset()
     *
     * @this {Keyboardx86}
     */
    reset()
    {
        /**
         * If no keyboard model was specified, our initial setModel() call will select the "US83" keyboard as the
         * default, but now that the ChipSet is initialized, we can pick a better default, based on the ChipSet model.
         */
        if (!this.model && this.chipset) {
            switch(this.chipset.model) {
            case ChipSet.MODEL_5150:
            case ChipSet.MODEL_5160:
                this.setModel(Keyboardx86.MODELS[0]);
                break;
            case ChipSet.MODEL_5170:
            default:
                this.setModel(Keyboardx86.MODELS[1]);
                break;
            }
        }
        this.initState();
    }

    /**
     * save()
     *
     * This implements save support for the Keyboard component.
     *
     * @this {Keyboardx86}
     * @returns {Object}
     */
    save()
    {
        let state = new State(this);
        state.set(0, this.saveState());
        return state.data();
    }

    /**
     * restore(data)
     *
     * This implements restore support for the Keyboard component.
     *
     * @this {Keyboardx86}
     * @param {Object} data
     * @returns {boolean} true if successful, false if failure
     */
    restore(data)
    {
        return this.initState(data[0]);
    }

    /**
     * initState(data)
     *
     * @this {Keyboardx86}
     * @param {Array} [data]
     * @returns {boolean} true if successful, false if failure
     */
    initState(data)
    {
        if (!data) {
            data = [false, false, Keyboardx86.INJECTION.ON_INPUT];
        } else {
            /**
             * If there is a predefined state for this machine, then the assumption is that any injection
             * sequence can be injected as soon as the machine starts.  Any other kind of state must disable
             * injection, because injection depends on the machine being in a known state.
             */
            data[2] = this.cmp.sStatePath? Keyboardx86.INJECTION.ON_START : (data[2] || Keyboardx86.INJECTION.NONE);
        }

        let i = 0;
        this.fClock = data[i++];
        this.fData = data[i++];
        this.nInjection = data[i++];
        this.sInjectBuffer = data[i++] || "";
        this.msInjectDelay = data[i] || this.msInjectDefault;

        this.bCmdPending = 0;       // when non-zero, a command is pending (eg, SET_LED or SET_RATE)

        /**
         * The current (assumed) physical (and simulated) modifier/lock key states, along with a set
         * of (fake) modifier key states maintained by simulateKey() to keep track of faked modifiers.
         *
         * TODO: Determine how (or whether) we can query the browser's initial shift/lock key states.
         */
        this.bitsState = this.bitsStateSim = this.bitsStateFake = 0;

        /**
         * New scan codes are "pushed" onto abBuffer and then "shifted" off.
         */
        this.abBuffer = [];

        return true;
    }

    /**
     * saveState()
     *
     * @this {Keyboardx86}
     * @returns {Array}
     */
    saveState()
    {
        let data = [], i = 0;
        data[i++] = this.fClock;
        data[i++] = this.fData;
        data[i++] = this.nInjection;
        data[i++] = this.sInjectBuffer;
        data[i] = this.msInjectDelay;
        return data;
    }

    /**
     * enableSoftKeyboard(fEnable)
     *
     * In addition to enabling or disabling our own soft keyboard (if any), this also attempts to disable or enable
     * (as appropriate) the textarea control (if any) that machines use to trigger a touch device's built-in keyboard.
     *
     * @this {Keyboardx86}
     * @param {boolean} fEnable
     */
    enableSoftKeyboard(fEnable)
    {
        if (this.controlSoftKeyboard) {
            if (!fEnable) {
                this.controlSoftKeyboard.style.display = "none";
                if (this.controlTextKeyboard) {
                    this.controlTextKeyboard.readOnly = false;
                }
            } else {
                this.controlSoftKeyboard.style.display = "block";
                if (this.controlTextKeyboard) {
                    this.controlTextKeyboard.readOnly = true;
                }
            }
        }
        this.fSoftKeyboard = fEnable;
    }

    /**
     * setSoftKeyState(control, f)
     *
     * @this {Keyboardx86}
     * @param {HTMLElement} control is an HTML control DOM object
     * @param {boolean} f is true if the key represented by e should be "on", false if "off"
     */
    setSoftKeyState(control, f)
    {
        control.style.color = (f? "#ffffff" : "#000000");
        control.style.backgroundColor = (f? "#000000" : "#ffffff");
    }

    /**
     * addScanCode(bScan)
     *
     * @this {Keyboardx86}
     * @param {number} bScan
     */
    addScanCode(bScan)
    {
        /**
         * Prepare for the possibility that our reset() function may not have been called yet.
         *
         * TODO: Determine whether we need to reset() the Keyboard sooner (ie, in the constructor),
         * or if we need to protect other methods from prematurely accessing certain Keyboard structures,
         * as a result of calls from any of the key event handlers established by setBinding().
         */
        if (this.abBuffer) {
            if (this.abBuffer.length < Keyboardx86.LIMIT.MAX_SCANCODES) {
                if (DESKPRO386) {
                    if (this.chipset && this.chipset.model == ChipSet.MODEL_COMPAQ_DESKPRO386) {
                        /**
                         * COMPAQ keyclick support is being disabled because we are currently unable to properly
                         * simulate the keyclick sound, due to the way the COMPAQ DeskPro 386 ROM rapidly toggles
                         * the speaker bit.  And there isn't really a better time to disable it, because the
                         * COMPAQ_KEYCLICK byte is set by IBMBIO.COM initialization code in COMPAQ MS-DOS, if the
                         * machine model byte is FC (indicating PC AT):
                         *
                         *      &0070:2EF7 2E               CS:
                         *      &0070:2EF8 803E442DFC       CMP      [2D44],FC
                         *      &0070:2EFD 750C             JNZ      2F0B (IBMBIO.COM+0x3174)
                         *      &0070:2EFF 26               ES:
                         *      &0070:2F00 C606160401       MOV      [0416],01
                         */
                        if (!this.cpu.isProtMode()) {
                            this.bus.setByteDirect(ROMx86.BIOS.COMPAQ_KEYCLICK, 0);
                        }
                    }
                }
                this.abBuffer.push(bScan);
                if (!COMPILED) this.printf("keyboard data %#04X buffered\n", bScan);
                this.transmitData();
                return;
            }
            if (this.abBuffer.length == Keyboardx86.LIMIT.MAX_SCANCODES) {
                this.abBuffer.push(Keyboardx86.CMDRES.BUFF_FULL);
            }
            this.printf("keyboard buffer overflow\n");
        }
    }

    /**
     * injectInit(nCondition)
     *
     * @this {Keyboardx86}
     * @param {number} nCondition
     */
    injectInit(nCondition)
    {
        if (this.nInjection == nCondition) {
            this.nInjection = Keyboardx86.INJECTION.NONE;
            if (this.autoType) this.injectKeys(this.autoType);
        }
    }

    /**
     * injectKeys(sKeys, msDelay)
     *
     * @this {Keyboardx86}
     * @param {string} [sKeys] (keys listed in SOFTCODES must be prefixed with '$')
     * @param {number} [msDelay] is an optional injection delay (default is msInjectDefault)
     * @returns {boolean}
     */
    injectKeys(sKeys, msDelay = this.msInjectDefault)
    {
        if (sKeys) {
            let sInjectBuffer = this.parseKeys(sKeys);
            if (sInjectBuffer) {
                this.nInjection = Keyboardx86.INJECTION.NONE;
                this.sInjectBuffer = sInjectBuffer;
                if (DEBUG) this.printf("injectKeys(\"%s\")\n", this.sInjectBuffer.split("\n").join("\\n"));
                this.msInjectDelay = msDelay || 0;
                this.injectKeys();
                return true;
            }
            return false;
        }
        /**
         * Any delay of one second or more ($10 and up) is automatically reverted to the default.
         */
        if (this.msInjectDelay >= 1000) {
            this.msInjectDelay = this.msInjectDefault;
        }
        let simCode = 0;
        while (this.sInjectBuffer.length > 0 && !simCode) {
            let ch = this.sInjectBuffer.charAt(0);
            if (ch == '$') {
                /**
                 * $<number> pauses injection by the specified number of tenths of a second; eg,
                 * $5 pauses for 1/2 second.  $0 reverts the default injection delay (eg, 100ms).
                 * Also, you may end the number with a period if you need to avoid an injected digit
                 * being misinterpreted as part of the delay (eg, $5.1) pauses for 1/2 second and
                 * then injects "1").
                 */
                let digits = this.sInjectBuffer.match(/^\$([0-9]+)\.?/);
                if (digits) {
                    this.msInjectDelay = (+digits[1] * 100) || this.msInjectDefault;
                    this.sInjectBuffer = this.sInjectBuffer.substr(digits[0].length);
                    break;
                }
                /**
                 * Yes, this code is slow and gross, but it's simple, and key injection doesn't have
                 * to be that fast anyway.  The added check for SOFTCODES that have omitted the 'num-'
                 * prefix adds to the slowness, but it's a nice convenience, allowing you to specify
                 * non-ASCII keys like 'num-right' or 'num-up' more succinctly as  "$right" or "$up".
                 */
                for (let i = 0; i < this.softCodeKeys.length; i++) {
                    let name = this.softCodeKeys[i];
                    if (this.sInjectBuffer.indexOf(name) == 1) {
                        simCode = Keyboardx86.SOFTCODES[name];
                        this.sInjectBuffer = this.sInjectBuffer.substr(name.length + 1);
                        break;
                    }
                    let shortName = (name.indexOf('num-') == 0? name.substr(4) : "");
                    if (shortName && this.sInjectBuffer.indexOf(shortName) == 1) {
                        simCode = Keyboardx86.SOFTCODES[name];
                        this.sInjectBuffer = this.sInjectBuffer.substr(shortName.length + 1);
                        break;
                    }
                }
            }
            if (simCode) break;
            this.sInjectBuffer = this.sInjectBuffer.substr(1);
            let charCode = ch.charCodeAt(0);
            /**
             * charCodes 0x01-0x1A correspond to key combinations CTRL-A through CTRL-Z, unless they
             * are \t, \n, or \r, which are reserved for TAB, LINE-FEED, and RETURN, respectively, so if
             * you need to simulate CTRL-I, CTRL-J, or CTRL-M, those must be specified using \x1C, \x1D,
             * or \x1E, respectively.  Also, since PCs have no dedicated LINE-FEED key, and since \n is
             * often used instead of \r, we map LINE-FEED (LF) to RETURN (CR) below.
             */
            if (charCode <= Keys.ASCII.CTRL_Z) {
                simCode = charCode;
                /**
                 * I could require all callers to supply CRs instead of LFs, but this is friendlier; besides,
                 * PCs don't have a dedicated LINE-FEED key, so the LF charCode is somewhat meaningless.
                 */
                if (charCode == 0x0A) simCode = 0x0D;
                if (charCode != Keys.ASCII.CTRL_I && charCode != Keys.ASCII.CTRL_J && charCode != Keys.ASCII.CTRL_M) {
                    simCode += Keys.KEYCODE.FAKE;
                }
            }
            else if (charCode == 0x1C) {
                simCode = Keys.ASCII.CTRL_I + Keys.KEYCODE.FAKE;
            }
            else if (charCode == 0x1D) {
                simCode = Keys.ASCII.CTRL_J + Keys.KEYCODE.FAKE;
            }
            else if (charCode == 0x1E) {
                simCode = Keys.ASCII.CTRL_M + Keys.KEYCODE.FAKE;
            }
            else if (charCode == 0x1F) {
                simCode = Keys.ASCII['$'];
            }
            else if (charCode <= 0x7F) {
                simCode = charCode;
            }
        }

        if (simCode) {
            let fPress = (Keyboardx86.MODIFIERS[simCode] === undefined);
            this.addActiveKey(simCode, fPress);
            if (fPress) this.clearActiveKeys(true);
        }

        if (!this.sInjectBuffer.length) {
            if (this.fnInjectReady) {
                this.fnInjectReady();
                this.fnInjectReady = null;
            }
        } else {
            this.cpu.setTimer(this.timerInject, this.msInjectDelay);
        }
        return true;
    }

    /**
     * parseKeys(sKeys)
     *
     * The following special "macro" sequences are recognized:
     *
     *      $date:  converted to MM-DD-YYYY
     *      $time:  converted to HH:MM
     *
     * In addition, property keys in the SOFTCODES tables can be prefixed with "$" if you want to specify
     * a key by its SOFTCODE; eg:
     *
     *      $f1:    the F1 function key
     *      $alt:   the ALT key
     *
     * Not all SOFTCODES are allowed; for example, SOFTCODES that begin with a digit or other non-alpha symbol,
     * or that contain only one letter, because those SOFTCODES can already be specified as-is, WITHOUT a leading
     * "$".  Also, all we replace here are the "macro" sequences, leaving any prefixed SOFTCODES in place so that
     * injectKeys() can convert them on the fly.
     *
     * If you want any of those sequences to be typed as-is, then you must specify two "$" (eg, "$$date").
     * Pairs of dollar signs will be automatically converted to single dollar signs, and single dollar signs
     * will be used as-is, provided they don't precede any of the above "macro" or SOFTCODE sequences.
     *
     * WARNING: the JavaScript replace() function ALWAYS interprets "$" specially in replacement strings,
     * even when the search string is NOT a RegExp; specifically:
     *
     *      $$  Inserts a "$"
     *      $&  Inserts the matched substring
     *      $`  Inserts the portion of the string that precedes the matched substring
     *      $'  Inserts the portion of the string that follows the matched substring
     *      $n  Where n is a positive integer less than 100, inserts the nth parenthesized sub-match string,
     *          provided the first argument was a RegExp object
     *
     * Since we build machine definitions on a page from a potentially indeterminate number of string replace()
     * operations, multiple dollar signs could eventually get reduced to a single dollar sign BEFORE we get here.
     *
     * To compensate, I've changed a few replace() methods, like MarkOut's convertMDMachineLinks() and HTMLOut's
     * addFilesToHTML(), from the conventional string replace() to my own StrLib.replace(), and for situations like the
     * embed.js parseXML() function, which needs to use a RegExp-style replace(), I've added a preliminary
     * replace(/\$/g, "$$$$") to the replacement string.
     *
     * Unfortunately, this is something that will be extremely difficult to prevent from breaking down the road.
     * So, heads up to future me....
     *
     * @this {Keyboardx86}
     * @param {string|undefined} sKeys
     * @returns {string|undefined}
     */
    parseKeys(sKeys)
    {
        if (sKeys) {
            let date = new Date();
            let match, reSpecial = /(?:^|[^$])\$([a-z0-9][a-z0-9-]+)/g;
            while ((match = reSpecial.exec(sKeys))) {
                let sReplace = "";
                if (reSpecial.lastIndex) reSpecial.lastIndex--;
                switch (match[1]) {
                case 'date':
                    sReplace = StrLib.sprintf("%M-%02D-%04Y", date);
                    break;
                case 'time':
                    sReplace = StrLib.sprintf("%H:%02N:%02S", date);
                    break;
                default:
                    continue;
                }
                sKeys = sKeys.replace('$' + match[1], sReplace);
            }
            /**
             * Any lingering "$$" sequences are now converted to a special code (\x1F) that injectKeys() knows about.
             */
            sKeys = sKeys.replace(/\$\$/g, '\x1F');
        }
        return sKeys;
    }

    /**
     * waitReady(fnCallReady, sOption)
     *
     * @this {Keyboardx86}
     * @param {function()|null} fnCallReady
     * @param {string} [sOption]
     * @returns {boolean} false if wait required, true otherwise
     */
    waitReady(fnCallReady, sOption)
    {
        let fReady = false;

        switch(sOption) {
        case "DOS":
            if (this.fDOSReady) {
                fReady = true;
            } else {
                this.fnDOSReady = fnCallReady;
            }
            break;

        default:
            if (!this.sInjectBuffer.length) {
                fReady = true;
            } else {
                this.fnInjectReady = fnCallReady;
            }
            break;
        }
        return fReady;
    }

    /**
     * setLED(control, f)
     *
     * @this {Keyboardx86}
     * @param {HTMLElement} control is an HTML control DOM object
     * @param {boolean} f is true if the LED represented by control should be "on", false if "off"
     */
    setLED(control, f)
    {
        /**
         * TODO: Add support for user-definable LED colors
         */
        control.style.backgroundColor = (f? "#00ff00" : "#000000");
    }

    /**
     * updateLEDs(bitState)
     *
     * Updates any and all shift-related LEDs with the corresponding state in bitsStateSim.
     *
     * @this {Keyboardx86}
     * @param {number} [bitState] is the bit in bitsStateSim that may have changed, if known; undefined if not
     */
    updateLEDs(bitState)
    {
        let control;
        for (let sBinding in Keyboardx86.LEDSTATES) {
            let id = "led-" + sBinding;
            let bitLED = Keyboardx86.LEDSTATES[sBinding];
            if ((!bitState || bitState == bitLED) && (control = this.bindings[id])) {
                this.setLED(control, !!(this.bitsStateSim & bitLED));
            }
        }
    }

    /**
     * toggleCapsLock()
     *
     * @this {Keyboardx86}
     */
    toggleCapsLock()
    {
        this.addActiveKey(Keyboardx86.SIMCODE.CAPS_LOCK, true);
    }

    /**
     * toggleNumLock()
     *
     * @this {Keyboardx86}
     */
    toggleNumLock()
    {
        this.addActiveKey(Keyboardx86.SIMCODE.NUM_LOCK, true);
    }

    /**
     * toggleScrollLock()
     *
     * @this {Keyboardx86}
     */
    toggleScrollLock()
    {
        this.addActiveKey(Keyboardx86.SIMCODE.SCROLL_LOCK, true);
    }

    /**
     * updateShiftState(simCode, fSim, fDown)
     *
     * For non-locking shift keys, this function is straightforward: when fDown is true, the corresponding bitState
     * is set, and when fDown is false, it's cleared.  However, for LOCK keys, fDown true means toggle, and fDown false
     * means no change.
     *
     * @this {Keyboardx86}
     * @param {number} simCode (includes any ONDOWN and/or ONRIGHT modifiers)
     * @param {boolean} [fSim] is true to update simulated state only
     * @param {boolean|null} [fDown] is true for down, false for up, undefined for toggle
     * @returns {number} 0 if not a shift key, 1 if shift key down, -1 if shift key up
     */
    updateShiftState(simCode, fSim, fDown)
    {
        let result = 0;
        if (Keyboardx86.SIMCODES[simCode]) {
            let fRight = (Math.floor(simCode / 1000) & 2);
            let bitState = Keyboardx86.KEYSTATES[simCode] || 0;
            if (bitState) {
                if (fRight && !(bitState & Keyboardx86.STATE.ALL_RIGHT)) {
                    bitState >>= 1;
                }
                if (bitState & Keyboardx86.STATE.ALL_LOCKS) {
                    if (fDown === false) return -1;
                    fDown = null;
                }
                if (fDown == null) {        // ie, null or undefined
                    fDown = !((fSim? this.bitsStateSim : this.bitsState) & bitState);
                }
                else if (!fDown && !fSim) {
                    /**
                     * In current webkit browsers, pressing and then releasing both left and right shift keys together
                     * (or both ALT keys, or both CMD/Windows keys, or presumably both CTRL keys) results in 4 events,
                     * as you would expect, but 3 of the 4 are "down" events; only the last of the 4 is an "up" event.
                     *
                     * Perhaps this is a browser accessibility feature (ie, deliberately suppressing the "up" event
                     * of one of the shift keys to implement a "sticky shift mode"?), but in any case, to maintain our
                     * internal consistency, if this is an "up" event and the shift state bit is any of ALL_MODIFIERS,
                     * then we set it to ALL_MODIFIERS, so that we'll automatically clear ALL shift states.
                     *
                     * TODO: The only downside to this work-around is that the simulation will still think a shift key is
                     * down.  So in effect, we have enabled a "sticky shift mode" inside the simulation, whether or not that
                     * was the browser's intent.  To fix that, we would have to identify the shift key that never went up
                     * and simulate the "up".  That's more work than I think the problem merits.  The user just needs to tap
                     * a single shift key to get out that mode.
                     */
                    if (bitState & Keyboardx86.STATE.ALL_MODIFIERS) bitState = Keyboardx86.STATE.ALL_MODIFIERS;
                }
                if (!fSim) {
                    this.bitsState &= ~bitState;
                    if (fDown) this.bitsState |= bitState;
                } else {
                    /**
                     * This next line reflects the fact that we don't want to modify any simulated LOCK states if a simulated
                     * shift state (ie, CTRL, ALT, SHIFT, etc) is also active.  For example, CTRL-NUM-LOCK is a special sequence
                     * (Pause) that isn't supposed to alter the NUM-LOCK state; similarly, CTRL-SCROLL-LOCK (aka Ctrl-Break)
                     * isn't supposed to alter the SCROLL-LOCK state.
                     */
                    if (!(this.bitsStateSim & Keyboardx86.STATE.ALL_MODIFIERS) || !(bitState & Keyboardx86.STATE.ALL_LOCKS)) {
                        this.bitsStateSim &= ~bitState;
                        if (fDown) this.bitsStateSim |= bitState;
                        this.updateLEDs(bitState);
                    }
                }
                result = fDown? 1 : -1;
            }
        }
        return result;
    }

    /**
     * addActiveKey(simCode, fPress)
     *
     * @this {Keyboardx86}
     * @param {number} simCode
     * @param {boolean} [fPress]
     * @returns {boolean} true if added, false if not (eg, not recognized, already added, etc)
     */
    addActiveKey(simCode, fPress)
    {
        let wCode = Keyboardx86.SIMCODES[simCode] || Keyboardx86.SIMCODES[simCode += Keys.KEYCODE.ONDOWN];

        if (!wCode) {
            if (!COMPILED) this.printf(MESSAGE.KBD + MESSAGE.KEY, "addActiveKey(%d,%s): unrecognized\n", simCode, (fPress? "press" : "down"));
            return false;
        }

        /**
         * Ignore all active keys if the CPU is not running.
         */
        if (!this.cpu || !this.cpu.isRunning()) return false;

        /**
         * If this simCode is in the KEYSTATE table, then stop all repeating.
         */
        if (Keyboardx86.KEYSTATES[simCode] && this.aKeysActive.length) {
            if (this.aKeysActive[0].nRepeat > 0) this.aKeysActive[0].nRepeat = 0;
        }

        let i, key;
        for (i = 0; i < this.aKeysActive.length; i++) {
            key = this.aKeysActive[i];
            if (key.simCode == simCode) {
                /**
                 * This key is already active, so if this a "down" request (or a "press" for a key we already
                 * processed as a "down"), ignore it.
                 */
                if (!fPress || key.nRepeat >= 0) {
                    i = -1;
                    break;
                }
                if (i > 0) {
                    if (this.aKeysActive[0].nRepeat > 0) this.aKeysActive[0].nRepeat = 0;
                    this.aKeysActive.splice(i, 1);
                }
                break;
            }
        }

        if (!COMPILED) this.printf(MESSAGE.KBD + MESSAGE.KEY, "addActiveKey(%d,%s): %s\n", simCode, (fPress? "press" : "down"), (i < 0? "already active" : (i == this.aKeysActive.length? "adding" : "updating")));

        if (i < 0) return false;

        if (i == this.aKeysActive.length) {
            key = {simCode};                            // create a new Key object
            // key.bitsState = this.bitsState;          // not needed unless we revive checkActiveKeyShift()
            this.findBinding(simCode, "key", true);
            i++;
        }

        if (i > 0) {
            this.aKeysActive.splice(0, 0, key);         // aka aKeysActive.unshift(key)
        }

        key.fDown = true;
        key.nRepeat = (fPress? -1: (Keyboardx86.KEYSTATES[simCode]? 0 : 1));

        this.updateActiveKey(key);
        return true;
    }

    /**
     * checkActiveKey()
     *
     * @this {Keyboardx86}
     * @returns {number} simCode of active key, 0 if none
     */
    checkActiveKey()
    {
        return this.aKeysActive.length? this.aKeysActive[0].simCode : 0;
    }

    /**
     * isAlphaKey(code)
     *
     * @this {Keyboardx86}
     * @param {number} code
     * @returns {boolean} true if alpha key, false if not
     */
    isAlphaKey(code)
    {
        return (code >= Keys.ASCII.A && code <= Keys.ASCII.Z || code >= Keys.ASCII.a && code <= Keys.ASCII.z);
    }

    /**
     * toUpperKey(code)
     *
     * @this {Keyboardx86}
     * @param {number} code
     * @returns {number}
     */
    toUpperKey(code)
    {
        if (code >= Keys.ASCII.a && code <= Keys.ASCII.z) {
            code -= (Keys.ASCII.a - Keys.ASCII.A);
        }
        return code;
    }

    /**
     * clearActiveKeys(fModifiers)
     *
     * Force all active keys to "deactivate" (or, optionally, just any modifiers)
     *
     * @this {Keyboardx86}
     * @param {boolean} [fModifiers] (true to clear modifier keys only; default is ALL keys)
     */
    clearActiveKeys(fModifiers)
    {
        for (let i = 0; i < this.aKeysActive.length; i++) {
            let key = this.aKeysActive[i];
            if (fModifiers && !Keyboardx86.MODIFIERS[key.simCode]) continue;
            if (this.removeActiveKey(key.simCode)) i--;
        }
    }

    /**
     * removeActiveKey(simCode, fFlush)
     *
     * @param {number} simCode
     * @param {boolean} [fFlush] is true whenever the key must be removed, independent of other factors
     * @returns {boolean} true if successfully removed, false if not
     */
    removeActiveKey(simCode, fFlush)
    {
        if (!Keyboardx86.SIMCODES[simCode]) {
            if (!COMPILED) this.printf(MESSAGE.KBD + MESSAGE.KEY, "removeActiveKey(%d): unrecognized\n", simCode);
            return false;
        }

        /**
         * Ignore all active keys if the CPU is not running.
         */
        if (!fFlush && (!this.cpu || !this.cpu.isRunning())) return false;

        let fRemoved = false;
        for (let i = 0; i < this.aKeysActive.length; i++) {
            let key = this.aKeysActive[i];
            if (key.simCode == simCode || key.simCode == Keys.SHIFTED_KEYCODES[simCode]) {
                this.aKeysActive.splice(i, 1);
                if (key.timer) clearTimeout(key.timer);
                if (key.fDown && !fFlush) this.simulateKey(key.simCode, false);
                this.findBinding(simCode, "key", false);
                fRemoved = true;
                break;
            }
        }

        if (!COMPILED && !fFlush) {
            this.printf(MESSAGE.KBD + MESSAGE.KEY, "removeActiveKey(%d): %s\n", simCode, (fRemoved? "removed" : "not active"));
        }

        if (!this.aKeysActive.length && this.fToggleCapsLock) {
            if (!COMPILED) this.printf(MESSAGE.KBD + MESSAGE.KEY, "removeActiveKey(): inverting caps-lock now\n");
            this.updateShiftState(Keyboardx86.SIMCODE.CAPS_LOCK);
            this.fToggleCapsLock = false;
        }
        return fRemoved;
    }

    /**
     * updateActiveKey(key, msTimer)
     *
     * When called by addActiveKey(), msTimer is undefined; that's used only when we're called by our own timeout handler.
     *
     * @param {Object} key
     * @param {number} [msTimer]
     */
    updateActiveKey(key, msTimer)
    {
        /**
         * All active keys are automatically removed once the CPU stops running.
         */
        if (!this.cpu || !this.cpu.isRunning()) {
            this.removeActiveKey(key.simCode, true);
            return;
        }

        if (!COMPILED) {
            this.printf(MESSAGE.KBD + MESSAGE.KEY, "updateActiveKey(%d,%dms): %b\n", key.simCode, msTimer, key.fDown);
        }

        if (msTimer && key.nRepeat < 0) {
            key.fDown = false;
        }

        if (!this.simulateKey(key.simCode, key.fDown) || !key.nRepeat) {
            /**
             * Why isn't there a simple return here? In order to set breakpoints on two different return conditions, of course!
             */
            if (!msTimer) {
                return;
            }
            return;
        }

        let ms;
        if (key.nRepeat < 0) {
            if (!key.fDown) {
                this.removeActiveKey(key.simCode);
                return;
            }
            ms = this.msAutoRelease;
        }
        else {
            ms = (key.nRepeat++ == 1? this.msAutoRepeat : this.msNextRepeat);
        }

        if (key.timer) {
            clearTimeout(key.timer);
        }

        key.timer = setTimeout(function(kbd) {
            return function onUpdateActiveKey() {
                kbd.updateActiveKey(key, ms);
            };
        }(this), ms);
    }

    /**
     * getSimCode(keyCode)
     *
     * @this {Keyboardx86}
     * @param {number} keyCode
     * @param {boolean} fShifted
     * @returns {number} simCode
     */
    getSimCode(keyCode, fShifted)
    {
        let code;
        let simCode = keyCode;

        if (keyCode >= Keys.ASCII.A && keyCode <= Keys.ASCII.Z) {
            if (!(this.bitsState & (Keyboardx86.STATE.SHIFT | Keyboardx86.STATE.RSHIFT | Keyboardx86.STATE.CAPS_LOCK)) == fShifted) {
                simCode = keyCode + (Keys.ASCII.a - Keys.ASCII.A);
            }
        }
        else if (keyCode >= Keys.ASCII.a && keyCode <= Keys.ASCII.z) {
            if (!!(this.bitsState & (Keyboardx86.STATE.SHIFT | Keyboardx86.STATE.RSHIFT | Keyboardx86.STATE.CAPS_LOCK)) == fShifted) {
                simCode = keyCode - (Keys.ASCII.a - Keys.ASCII.A);
            }
        }
        else if (!!(this.bitsState & (Keyboardx86.STATE.SHIFT | Keyboardx86.STATE.RSHIFT)) == fShifted) {
            if ((code = Keys.SHIFTED_KEYCODES[keyCode])) {
                simCode = code;
            }
        }
        else {
            if ((code = Keys.NONASCII_KEYCODES[keyCode])) {
                simCode = code;
            }
        }
        return simCode;
    }

    /**
     * onFocusChange(fFocus)
     *
     * @this {Keyboardx86}
     * @param {boolean} fFocus is true if gaining focus, false if losing it
     */
    onFocusChange(fFocus)
    {
        if (!COMPILED && this.fHasFocus != fFocus) {
            this.printf(MESSAGE.EVENT, "onFocusChange(%b)\n", fFocus);
        }
        this.fHasFocus = fFocus;
        /**
         * Since we can't be sure of any shift states after losing focus, we clear them all.
         */
        if (!fFocus) {
            this.bitsState &= ~Keyboardx86.STATE.ALL_MODIFIERS;
            this.clearActiveKeys();
        }
    }

    /**
     * onKeyActive(event, fDown)
     *
     * @this {Keyboardx86}
     * @param {Object} event
     * @param {boolean} fDown is true for a keyDown event, false for a keyUp event
     * @returns {boolean} true to pass the event along, false to consume it
     */
    onKeyActive(event, fDown)
    {
        let fPass = true;
        let fPress = false;
        let fIgnore = false;
        let keyCode = event.keyCode;

        /**
         * HACK for the Apple Magic Keyboard connected to an iPad: iPadOS inexplicably generates CTRL-ENTER (or CTRL-J)
         * whenever CTRL-C is pressed, so we attempt to undo that behavior -- at the loss of a genuine CTRL-ENTER, sadly.
         *
         * NOTE: isUserAgent struggles to detect iPadOS because Apple insists on pretending that it be indistinguishable
         * from desktop systems, so be aware that this hack may stop working at some undefined point.
         */
        if (WebLib.isUserAgent("iOS") && (this.bitsState & Keyboardx86.STATE.CTRL)) {
            if (keyCode == Keys.KEYCODE.CR) {
                keyCode = Keys.ASCII.C;
            }
        }

        /**
         * We used to be able to capture keystrokes like "Alt-E" by simply checking keyCode for "ALT" (18) and "E" (69),
         * but browsers keep pulling the rug out from under such simple assumptions.  A number of "Alt-Key" combinations
         * have now apparently been repurposed for other things (like IMEs), so what was once simple is now more complicated.
         * One would think that new features could be added using new properties that are used only by new code, but browsers
         * (eg, Chrome) can't resist shoving their new features down the throats of EXISTING code, too.
         *
         * And even with this remapping logic, creating a seamless experience for the underlying machine is still a
         * challenge, because for a key like "Alt-E", the browser insists on processing the NEXT key differently; it still
         * gets delivered, but whereas before a normal key would have been delivered with a keypress event, it's now delivered
         * with a keydown event.  Sigh.
         *
         * And lest one think this might be a platform-specific issue, Firefox handles "Alt-E" just like any other "Alt-Key"
         * combination; Chrome and Safari do not.
         */
        if (keyCode == 229 && event.code) {
            let code = event.code;
            if (code.indexOf("Key") == 0) {
                keyCode = code.charCodeAt(3);
            } else if (code.indexOf("Digit") == 0) {
                keyCode = code.charCodeAt(5);
            } else {
                keyCode = Keys.CODEKEY[code] || 0;
            }
            this.printf(MESSAGE.EVENT + MESSAGE.KEY, "onKeyActive(%d): remapped using event code '%s'\n", keyCode, code);
        }

        if (!this.cmp.notifyKbdEvent(event, fDown)) {
            return false;
        }

        if (fDown) {
            this.cKeysPressed++;
            this.sInjectBuffer = "";                    // actual key DOWN (not UP) events should also stop any injection in progress
            /**
             * Unless the key happens to be ESC, ANY user input at all now cancels injection.
             */
            if (keyCode != 27) this.nInjection = Keyboardx86.INJECTION.NONE;
        }

        Component.processScript(this.idMachine);        // and any script, too

        /**
         * Although it would be nice to pay attention ONLY to these "up" and "down" events, and ignore "press"
         * events, iOS devices force us to process "press" events, because they don't give us shift-key events,
         * so we have to infer the shift state from the character code in the "press" event.
         *
         * So, to seamlessly blend "up" and "down" events with "press" events, we must convert any keyCodes we
         * receive here to a compatibly shifted simCode.
         */
        let simCode = this.getSimCode(keyCode, true);

        if (this.fEscapeDisabled && simCode == Keys.ASCII['`']) {
            keyCode = simCode = Keys.KEYCODE.ESC;
        }

        if (Keyboardx86.SIMCODES[keyCode + Keys.KEYCODE.ONDOWN]) {

            simCode += Keys.KEYCODE.ONDOWN;
            if (event.location == Keys.LOCATION.RIGHT) {
                simCode += Keys.KEYCODE.ONRIGHT;
            }

            let nShiftState = this.updateShiftState(simCode, false, fDown);
            if (nShiftState) {

                if (keyCode == Keys.KEYCODE.CAPS_LOCK || keyCode == Keys.KEYCODE.NUM_LOCK || keyCode == Keys.KEYCODE.SCROLL_LOCK) {
                    /**
                     * FYI, "lock" keys generate a DOWN event ONLY when getting locked and an UP event ONLY
                     * when getting unlocked--which is a little odd, since the key did go UP and DOWN each time.
                     *
                     * We must treat each event like a "down", and also as a "press", so that addActiveKey() will
                     * automatically generate both the "make" and "break".
                     *
                     * Of course, there have to be exceptions, most notably both Microsoft Internet Explorer and Edge
                     * (and, apparently, pretty much any other browser running on the Windows platform), which send both
                     * UP and DOWN events on every press, so there's no need for this trickery.
                     */
                    if (!this.fMSWindows) {
                        fDown = fPress = true;
                    }
                }

                /**
                 * HACK for Windows (as the host operating system): the ALT key is often used with key combinations
                 * not meant for our machine (eg, Alt-Tab to switch to a different window, or simply tapping the ALT
                 * key by itself to switch focus to the browser's menubar).  And sadly, browsers are quite happy to
                 * give us the DOWN event for the ALT key, but not an UP event, leaving our machine with the impression
                 * that the ALT key is still down, which the user user has no easy way to detect OR correct.
                 *
                 * So we still record the ALT state in bitsState as best we can, and clear it whenever we lose focus
                 * in onFocusChange(), but we no longer pass through DOWN events to our machine.  Instead, we now
                 * check bitsState prior to simulating any other key, and if the ALT bit is set, we simulate an
                 * active ALT key first; you'll find that check at the end of both onKeyActive() and onKeyPress().
                 *
                 * NOTE: Even though this is a hack intended largely for browsers running on Windows, I'm implementing
                 * it for all platforms, for consistency.
                 */
                if (this.fDelayALT && keyCode == Keys.KEYCODE.ALT) {
                    if (fDown) {
                        /**
                         * One exception to this hack is the "Sidekick" exception: if the CTRL key is also down,
                         * we'll still simulate ALT immediately, for those users who press CTRL and then ALT to pop up
                         * Sidekick (as opposed to pressing ALT and then CTRL, which should also work, regardless).
                         */
                        if (!(this.bitsState & Keyboardx86.STATE.CTRL)) fIgnore = true;
                        /**
                         * Reset cKeysPressed so that we can detect the mere "tapping" of the ALT key, which some PCjs
                         * demos depend on (eg, Multi-tasking MS-DOS 4.0).
                         */
                        this.cKeysPressed = 0;
                    }
                    else {
                        if (!this.cKeysPressed) {
                            /**
                             * Since cKeysPressed is zero, the assumption here is that the ALT key (and the Alt key ALONE)
                             * was just tapped, so as long the ALT key was not already "soft-locked" (based on bitsStateSim),
                             * we will transform this "up" event into a "fake press" event.
                             */
                            if (!(this.bitsStateSim & (Keyboardx86.STATE.ALT | Keyboardx86.STATE.RALT))) {
                                fDown = fPress = true;
                            }
                        }
                    }
                }

                /**
                 * As a safeguard, whenever the CMD key goes up, clear all active keys, because there appear to be
                 * cases where we don't always get notification of a CMD key's companion key going up (this probably
                 * overlaps with most if not all situations where we also lose focus).
                 */
                if (!fDown && (keyCode == Keys.KEYCODE.CMD || keyCode == Keys.KEYCODE.RCMD)) {
                    this.clearActiveKeys();
                }
            }
            else {
                /**
                 * Here we have all the non-shift keys in the ONDOWN category; eg, BS, TAB, ESC, UP, DOWN, LEFT, RIGHT,
                 * and many more.
                 *
                 * For various reasons (some of which are discussed below), we don't want to pass these on (ie, we want
                 * to suppress their "press" event), which means we must perform all key simulation on the "up" and "down"
                 * events.
                 *
                 * Regarding BS: I never want the browser to act on BS, since it does double-duty as the BACK button,
                 * leaving the current page.
                 *
                 * Regarding TAB: If I don't consume TAB on the "down" event, then that's all I'll see, because the browser
                 * acts on it by giving focus to the next control.
                 *
                 * Regarding ESC: This key generates "down" and "up" events (LOTS of "down" events for that matter), but no
                 * "press" event.
                 */

                /**
                 * HACKs for mapping CTRL-BACKSPACE and CTRL-ALT-BACKSPACE to CTRL-BREAK and CTRL-ALT-DEL, respectively.
                 */
                if (keyCode == Keys.KEYCODE.BS && (this.bitsState & (Keyboardx86.STATE.CTRL|Keyboardx86.STATE.ALT)) == Keyboardx86.STATE.CTRL) {
                    simCode = Keyboardx86.SIMCODE.CTRL_BREAK;
                }
                if (keyCode == Keys.KEYCODE.BS && (this.bitsState & (Keyboardx86.STATE.CTRL|Keyboardx86.STATE.ALT)) == (Keyboardx86.STATE.CTRL|Keyboardx86.STATE.ALT)) {
                    simCode = Keyboardx86.SIMCODE.CTRL_ALT_DEL;
                }

                /**
                 * There are a number of other common key sequences that interfere with our machines; for example,
                 * the up/down arrows have a "default" behavior of scrolling the web page up and down, which is
                 * definitely NOT a behavior we want.  Since we mark those keys as ONDOWN, we'll catch them all here.
                 */
                fPass = false;
            }
        }
        else {
            /**
             * HACKs for mapping assorted CTRL-ALT sequences involving "normal" keys (eg, PERIOD, EQUALS, and DASH).
             */
            if ((this.bitsState & (Keyboardx86.STATE.CTRL|Keyboardx86.STATE.ALT)) == (Keyboardx86.STATE.CTRL|Keyboardx86.STATE.ALT)) {
                if (keyCode == Keys.KEYCODE.PERIOD) {
                    simCode = Keyboardx86.SIMCODE.CTRL_ALT_DEL;    // in case your operating system won't let you type CTRL-ALT-BACKSPACE either
                }
                if (keyCode == Keys.KEYCODE.EQUALS) {
                    simCode = Keyboardx86.SIMCODE.CTRL_ALT_ADD;    // in case your keyboard doesn't have a numeric keypad '+'
                }
                else if (keyCode == Keys.KEYCODE.DASH) {
                    simCode = Keyboardx86.SIMCODE.CTRL_ALT_SUB;    // in case your keyboard doesn't have a numeric keypad '-'
                }
            }

            /**
             * When I have defined system-wide CTRL-key sequences to perform common editing operations (eg, CTRL_W
             * and CTRL_Z to scroll pages of text), the browser likes to act on those operations, so let's set fPass
             * to false to prevent that.
             *
             * Also, we don't want to set fIgnore in such cases, because the browser may not give us a press event for
             * these CTRL-key sequences, so we can't risk ignoring them.
             */
            if (Keyboardx86.SIMCODES[simCode] && (this.bitsState & (Keyboardx86.STATE.CTRLS | Keyboardx86.STATE.ALTS))) {
                fPass = false;
            }

            /**
             * Don't simulate any key not explicitly marked ONDOWN, as well as any key sequence with the CMD key held.
             */
            if (!this.fAllDown && fPass && fDown || (this.bitsState & Keyboardx86.STATE.CMDS)) {
                fIgnore = true;
            }
        }

        if (!fPass) {
            event.preventDefault();
        }

        this.printf(MESSAGE.EVENT + MESSAGE.KEY, "onKeyActive(%d): %b%s\n", keyCode, fDown, (fIgnore? ",ignore" : (fPass? "" : ",consume")));

        /**
         * Mobile (eg, iOS) keyboards don't fully support onkeydown/onkeyup events; for example, they usually
         * don't generate ANY events when a shift key is pressed, and even for normal keys, they seem to generate
         * rapid (ie, fake) "up" and "down" events around "press" events, probably more to satisfy compatibility
         * issues rather than making a serious effort to indicate when a key ACTUALLY went down or up.
         */
        if (!fIgnore && (!this.fMobile || !fPass)) {
            if (fDown) {
                /**
                 * This is the companion code to the onKeyActive() hack for Windows that suppresses DOWN events
                 * for ALT keys: if we're about to activate another key and we believe that an ALT key is still down,
                 * we fake an ALT activation first.
                 */
                if (this.fDelayALT && (this.bitsState & Keyboardx86.STATE.ALTS)) {
                    let simCodeAlt = Keyboardx86.SIMCODE.ALT;
                    this.printf(MESSAGE.EVENT, "onKeyActive(%d): simulating ALT down\n", simCodeAlt);
                    this.addActiveKey(simCodeAlt);
                }
                this.addActiveKey(simCode, fPress);
            } else {
                if (!this.removeActiveKey(simCode)) {
                    let code = this.getSimCode(keyCode, false);
                    if (code != simCode) this.removeActiveKey(code);
                }
            }
        }

        return fPass;
    }

    /**
     * onKeyPress(event)
     *
     * @this {Keyboardx86}
     * @param {Object} event
     * @returns {boolean} true to pass the event along, false to consume it
     */
    onKeyPress(event)
    {
        event = event || window.event;
        let keyCode = event.which || event.keyCode;

        if (!this.cmp.notifyKbdEvent(event)) {
            return false;
        }

        this.cKeysPressed++;
        this.sInjectBuffer = "";        // actual key PRESS events should stop any injection currently in progress

        if (this.fAllDown) {
            let simCode = this.checkActiveKey();
            if (simCode && this.isAlphaKey(simCode) && this.isAlphaKey(keyCode) && simCode != keyCode) {
                if (!COMPILED) this.printf(MESSAGE.EVENT + MESSAGE.KEY, "onKeyPress(%d) out of sync with %d, invert caps-lock\n", keyCode, simCode);
                this.fToggleCapsLock = true;
                keyCode = simCode;
            }
        }

        let fPass = !Keyboardx86.SIMCODES[keyCode] || !!(this.bitsState & Keyboardx86.STATE.CMD);

        this.printf(MESSAGE.EVENT + MESSAGE.KEY, "onKeyPress(%d): %b\n", keyCode, fPass);

        if (!fPass) {
            /**
             * This is the companion code to the onKeyActive() hack for Windows that suppresses DOWN events
             * for ALT keys: if we're about to activate another key and we believe that an ALT key is still down,
             * we fake an ALT activation first.
             */
            if (this.fDelayALT && (this.bitsState & Keyboardx86.STATE.ALTS)) {
                let simCodeAlt = Keyboardx86.SIMCODE.ALT;
                this.printf(MESSAGE.EVENT, "onKeyPress(%d): simulating ALT down\n", simCodeAlt);
                this.addActiveKey(simCodeAlt);
            }
            this.addActiveKey(keyCode, true);
        }

        return fPass;
    }

    /**
     * onCopy(event)
     *
     * You may have noticed in the Keyboard start() handler that I force all the diagnostic text still residing
     * in the hidden textarea to be selected; if we don't, the browser will think there's nothing to copy, so it won't
     * deliver any "copy" events.  However, that's NOT the text we actually want to copy; we want to copy is whatever
     * is currently displayed on screen.  Hence this handler's job is to override the default "copy" behavior, and
     * instead call the Video component's getTextData() function for the text to be deposited on the clipboard.
     *
     * @this {Keyboardx86}
     * @param {Object} event
     */
    onCopy(event)
    {
        if (event.stopPropagation) event.stopPropagation();
        if (event.preventDefault) event.preventDefault();
        var clipboardData = event.clipboardData || window.clipboardData;
        if (clipboardData && this.video) {
            clipboardData.setData("text/plain", this.video.getTextData());
        }
    }

    /**
     * onCut(event)
     *
     * I don't actually care about Cut operations, just Copy and Paste; HOWEVER, you may have noticed in the
     * Keyboard start() handler that I force all the diagnostic text still residing in the hidden textarea to be
     * selected, so that we will receive "copy" events -- and, by extension, "cut" events, even though as I said
     * we don't care about them.  Unfortunately, we MUST care about them, because if we allow all that selected
     * text to actually be cut, it will be removed, nothing will remain selected or selectable, and so "copy"
     * events will no longer be delivered.
     *
     * So the main purpose of this function is to simply prevent any text from being cut.  And since we might as
     * well deliver something as part of the Cut operation, we deliver all the diagnostic text, which is available
     * in "this.controlTextKeyboard.value".  I could deliver the same exact text that onCopy() delivers, but where's
     * the fun in that?
     *
     * @this {Keyboardx86}
     * @param {Object} event
     */
    onCut(event)
    {
        if (event.stopPropagation) event.stopPropagation();
        if (event.preventDefault) event.preventDefault();
        var clipboardData = event.clipboardData || window.clipboardData;
        if (clipboardData) {
            clipboardData.setData("text/plain", this.controlTextKeyboard.value);
        }
    }

    /**
     * onPaste(event)
     *
     * @this {Keyboardx86}
     * @param {Object} event
     */
    onPaste(event)
    {
        if (event.stopPropagation) event.stopPropagation();
        if (event.preventDefault) event.preventDefault();
        var clipboardData = event.clipboardData || window.clipboardData;
        if (clipboardData) {
            let s = clipboardData.getData("text/plain");
            /**
             * We replace every '$' with '$$' to ensure there's no misinterpretation of a character sequence as one
             * of our special macro/key/delay sequences; see parseKeys() for a list.  The assumption here is that,
             * normally, the user will want pasted text injected exactly as-is.  But, there are always exceptions,
             * so if the pasted data ends with a '$', we will strip that trailing '$' and leave the rest of the string
             * as-is, allowing any special macros/keys/delays defined with '$' to pass through.
             *
             * And last but not least, an exception to the exception: if you need the pasted data to be treated as-is
             * AND to end with a '$', use TWO '$' at the end.
             */
            let end = s.slice(-1);
            if (end == '$') {
                s = s.slice(0, -1);
                if (s.slice(-1) == '$') end = '';
            }
            if (end != '$') {
                s = s.replace(/\$/g, '$$$$');   // remember, replace() treats '$' special; '$$' is really just one '$'
            }
            /**
             * Since the text on the clipboard may contain CR+LF line endings, and since injectKeys() maps both CR
             * and LF to the Enter key, and since we don't want TWO carriage returns at the end of every injected line,
             * we must transform every CR+LF into a single CR (it could be an LF as well; injectKeys() doesn't care
             * which you use).
             */
            this.injectKeys(s.replace(/\r\n/g, '\r'));
        }
    }

    /**
     * simulateKey(simCode, fDown)
     *
     * @this {Keyboardx86}
     * @param {number} simCode
     * @param {boolean} fDown
     * @returns {boolean} true if successfully simulated, false if unrecognized/unsupported key
     */
    simulateKey(simCode, fDown)
    {
        let fSimulated = false;

        this.updateShiftState(simCode, true, fDown);

        let wCode = Keyboardx86.SIMCODES[simCode] || Keyboardx86.SIMCODES[simCode + Keys.KEYCODE.ONDOWN];

        if (wCode !== undefined) {

            let abScanCodes = [];
            let bCode = wCode & 0xff;

            /**
             * TODO: Update the following restrictions to address 84-key and 101-key keyboard limitations.
             */
            if (bCode > 83 && this.modelKeys == 83) {
                return false;
            }

            abScanCodes.push(bCode | (fDown? 0 : Keyboardx86.SCANCODE.BREAK));

            let fAlpha = (simCode >= Keys.ASCII.A && simCode <= Keys.ASCII.Z || simCode >= Keys.ASCII.a && simCode <= Keys.ASCII.z);

            while ((wCode >>>= 8)) {
                let bScan = wCode & 0xff;
                /**
                 * TODO: The handling of SIMCODE entries with "extended" codes still needs to be tested, and
                 * moreover, if any of them need to perform any shift-state modifications, those modifications
                 * may need to be encoded differently.
                 */
                if (bCode == Keyboardx86.SCANCODE.EXTEND1 || bCode == Keyboardx86.SCANCODE.EXTEND2) {
                    abScanCodes.push(bCode | (fDown? 0 : Keyboardx86.SCANCODE.BREAK));
                    continue;
                }
                let bitsFake = 0;
                if (bScan == Keyboardx86.SCANCODE.SHIFT) {
                    if (!(this.bitsStateSim & (Keyboardx86.STATE.SHIFT | Keyboardx86.STATE.RSHIFT))) {
                        if (!(this.bitsStateSim & Keyboardx86.STATE.CAPS_LOCK) || !fAlpha) {
                            bitsFake |= Keyboardx86.STATE.SHIFT;
                        }
                    }
                }
                else if (bScan == Keyboardx86.SCANCODE.CTRL) {
                    if (!(this.bitsStateSim & (Keyboardx86.STATE.CTRL | Keyboardx86.STATE.RCTRL))) {
                        bitsFake |= Keyboardx86.STATE.CTRL;
                    }
                }
                else if (bScan == Keyboardx86.SCANCODE.ALT) {
                    if (!(this.bitsStateSim & (Keyboardx86.STATE.ALT | Keyboardx86.STATE.RALT))) {
                        bitsFake |= Keyboardx86.STATE.ALT;
                    }
                }
                else {
                    abScanCodes.push(bCode | (fDown? 0 : Keyboardx86.SCANCODE.BREAK));
                }
                /**
                 * If we have to fake a modifier key (eg, because some caller wants to simulate a modified key
                 * for which the modifier is not currently down), then if the modified key is going DOWN, make a
                 * note that the modifier is being faked, and if the modified key is going UP, make sure that
                 * the modifier was actually faked before "unfaking" it.
                 *
                 * Otherwise, the BIOS may complain (ie, beep) if it sees an UP event for a modifier key that it
                 * thinks is already up.  For example, if you press SHIFT, then press '?', then release SHIFT, then
                 * release '?', since we didn't have to fake a SHIFT when pressing '?', we should also avoid faking
                 * it when releasing '?'.
                 */
                if (bitsFake) {
                    if (fDown) {
                        this.bitsStateFake |= bitsFake;
                    } else if (this.bitsStateFake & bitsFake) {
                        this.bitsStateFake &= ~bitsFake;
                    } else {
                        bitsFake = 0;
                    }
                }
                if (bitsFake) {
                    if (fDown) {
                        abScanCodes.unshift(bScan);
                    } else {
                        abScanCodes.push(bScan | Keyboardx86.SCANCODE.BREAK);
                    }
                }
            }

            for (let i = 0; i < abScanCodes.length; i++) {
                this.addScanCode(abScanCodes[i]);
            }

            fSimulated = true;
        }

        if (!COMPILED) this.printf(MESSAGE.KBD + MESSAGE.KEY, "simulateKey(%d,%b): %b\n", simCode, fDown, fSimulated);

        return fSimulated;
    }

    /**
     * checkActiveKeyShift()
     *
     * @this {Keyboardx86}
     * @returns {number|null} bitsState for active key, null if none
     *
     checkActiveKeyShift()
     {
         return this.aKeysActive.length? this.aKeysActive[0].bitsState : null;
     }
     */

    /**
     * Keyboardx86.init()
     *
     * This function operates on every HTML element of class "keyboard", extracting the
     * JSON-encoded parameters for the Keyboard constructor from the element's "data-value"
     * attribute, invoking the constructor to create a Keyboard component, and then binding
     * any associated HTML controls to the new component.
     */
    static init()
    {
        let aeKbd = Component.getElementsByClass(APPCLASS, "keyboard");
        for (let iKbd = 0; iKbd < aeKbd.length; iKbd++) {
            let eKbd = aeKbd[iKbd];
            let parmsKbd = Component.getComponentParms(eKbd);
            let kbd = new Keyboardx86(parmsKbd);
            Component.bindComponentControls(kbd, eKbd, APPCLASS);
        }
    }
}

/**
 * Initialize every Keyboard module on the page.
 */
WebLib.onInit(Keyboardx86.init);

/**
 * @copyright https://www.pcjs.org/machines/pcx86/modules/v2/video.js (C) 2012-2024 Jeff Parsons
 */

/**
 * MDA/CGA Support
 * ---------------
 *
 * Since there's a lot of similarity between the MDA and CGA (eg, their text-mode video buffer
 * format, and their use of the 6845 CRT controller), since the MDA ROM contains the fonts used
 * by both devices, and since the same ROM BIOS supports both (in fact, the BIOS indiscriminately
 * initializes both, regardless which is actually installed), this same component emulates both
 * devices.
 *
 * When no model is specified, this component supports the ability to dynamically switch between
 * MDA and CGA emulation, by simply toggling the SW1 motherboard "monitor type" switch settings
 * and resetting the machine.  In that model-less configuration, we install I/O port handlers for
 * both MDA and CGA cards, regardless which monitor type is initially selected.
 *
 * To simulate an IBM PC containing both an MDA and CGA (ie, a "dual display" system), the machine
 * configuration simply defines two video components, one with model "mda" and the other with model
 * "cga", resulting in two displays; setting a specific model forces each instance of this component
 * to register only those I/O ports belonging to that model.
 *
 * In a single-display system, dynamically switching cards (ie, between MDA and CGA) creates some
 * visual challenges.  For one, the MDA prefers a native screen size of 720x350, as it supports only
 * one video mode, 80x25, with a 9x14 cell size.  The CGA, on the other hand, has an 8x8 cell size,
 * so when using an MDA-size screen, an 80x25 CGA screen will end up with 40-pixel borders on the
 * left and right, and 75-pixel borders on the top and bottom.  The result is a rather tiny CGA font
 * surrounded by lots of wasted space, so it's best to turn on font scaling (see the "scale" property)
 * and go with a larger screen size of, say, 960x400 (50% larger in width, 100% larger in height).
 *
 * I've also added support for font-doubling in createFont().  We use the 8x8 font for 80-column
 * modes and the "doubled" 16x16 font for 40-column modes OR whenever the screen is large enough
 * to use the 16x16 font, since font rendering without scaling provides the sharpest results.
 * In fact, there's special logic in setDimensions() to ignore fScaleFont in certain cases (eg,
 * 40-column modes, to improve sharpness and avoid stretching the font beyond readability).
 *
 * Graphics modes, on the other hand, are always scaled to the screen size.  Pixels are captured
 * in an off-screen buffer, which is then drawn to match the size of the virtual screen.
 *
 * TODO: Whenever there are borders, they should be filled with the CGA's overscan colors.  However,
 * in the case of graphics modes (and text modes whenever font scaling is enabled), we don't reserve
 * any space for borders, so if borders are important, explicit border support will be required.
 *
 * EGA Support
 * -----------
 *
 * EGA support piggy-backs on the existing MDA/CGA support.  All the existing MDA/CGA port handlers
 * now refer to either cardMono or cardColor (instead of directly to cardMDA or cardCGA), enabling
 * the handlers to be redirected to cardMDA, cardCGA or cardEGA as appropriate.
 *
 * Note that an MDA card supported only a Monochrome Display and a CGA card supported only a Color
 * Display (well, OK, *or* a TV monitor, which we don't currently support), but the EGA is much
 * more flexible: the Enhanced Color Display was the preferred display, but the EGA also supported
 * older displays; a Color Display on EGA wasn't ideal (same low resolutions but with more colors),
 * but the EGA also brought high-resolution graphics to Monochrome displays, which was nice.  Anyway,
 * while all those EGA/monitor combinations will be nice to support, our virtual display support
 * will focus initially on the Enhanced Color Display.
 *
 * TODO: Add support for jumpers P1 and P3 (see EGA TechRef p.85).  P1 selects either 5-color-output
 * for a CGA monitor or 6-color-output for an EGA monitor; we would presumably use this only to
 * control certain assumptions about the virtual display's capabilities (ie, Color Display vs. Enhanced
 * Color Display).  P3 can switch all the I/O ports from 0x3nn to 0x2nn; the default is 0x3nn, and
 * that's the only port range the EGA ROM supports as well.
 *
 * For quick reference, IBM EGA register values for the standard EGA modes, from pages 63-68 of the
 * "IBM Enhanced Graphics Adapter" (http://minuszerodegrees.net/oa/OA - IBM Enhanced Graphics Adapter.pdf).
 *
 * WARNING: Some of these value are not programmed exactly as-is; for example, the CURSCANB values are
 * adjusted +1 by the ROM BIOS in most cases, due to an EGA idiosyncrasy that IBM may not have intended.
 *
 *      INT 0x10 Mode Requested:    00  01  02  03  04  05  06  07  0D  0E  0F  10  0F^ 10^ 00* 01* 02* 03*
 *
 *      BIOSMODE:                   01  01  03  03  04  04  06  07  0D  0E  0F  10  0F  10  01  01  03  03
 *      CRTC[0x00]: HTOTAL          37  37  70  70  37  37  70  60  37  70  60  5B  60  5B  2D  2D  5B  5B
 *      CRTC[0x01]: HDEND           27  27  4F  4F  27  27  4F  4F  27  4F  4F  4F  4F  4F  27  27  4F  4F
 *      CRTC[0x02]: HBSTART         2D  2D  5C  %C  2D  2D  59  56  2D  56  56  53  56  53  2B  2B  53  53
 *      CRTC[0x03]: HBEND           37  37  2F  2F  37  37  2D  3A  37  2D  1A  17  3A  37  2D  2D  37  37
 *      CRTC[0x04]: HRSTART         31  31  5F  5F  30  30  5E  51  30  5E  50  50  50  52  28  28  51  51
 *      CRTC[0x05]: HREND           15  15  07  07  14  14  06  60  14  06  E0  BA  60  00  6D  6D  5B  5B
 *      CRTC[0x06]: VTOTAL          04  04  04  04  04  04  04  70  04  04  70  6C  70  6C  6C  6C  6C  6C
 *      CRTC[0x07]: OVERFLOW        11  11  11  11  11  11  11  1F  11  11  1F  1F  1F  1F  1F  1F  1F  1F
 *      CRTC[0x08]: PRESCAN         00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00
 *      CRTC[0x09]: MAXSCAN         07  07  07  07  01  01  01  0D  00  00  00  00  00  00  0D  0D  0D  0D
 *      CRTC[0x0A]: CURSCAN         06  06  06  06  00  00  00  0B  00  00  00  00  00  00  0B  0B  0B  0B
 *      CRTC[0x0B]: CURSCANB        07  07  07  07  00  00  00  0C  00  00  00  00  00  00  0C  0C  0C  0C
 *      CRTC[0x0C]: STARTHI         --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --
 *      CRTC[0x0D]: STARTLO         --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --
 *      CRTC[0x0E]: CURSORHI        --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --
 *      CRTC[0x0F]: CURSORLO        --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --  --
 *      CRTC[0x10]: VRSTART         E1  E1  E1  E1  E1  E1  E0  5E  E1  E0  5E  5E  5E  5E  5E  5E  5E  5E
 *      CRTC[0x11]: VREND           24  24  24  24  24  24  23  2E  24  23  2E  2B  2E  2B  2B  2B  2B  2B
 *      CRTC[0x12]: VDEND           C7  C7  C7  C7  C7  C7  C7  5D  C7  C7  5D  5D  5D  5D  5D  5D  5D  5D
 *      CRTC[0x13]: OFFSET          14  14  28  28  14  14  28  28  14  28  14  14  28  28  14  14  28  28
 *      CRTC[0x14]: UNDERLINE       08  08  08  08  00  00  00  0D  00  00  0D  0F  0D  0F  0F  0F  0F  0F
 *      CRTC[0x15]: VBSTART         E0  E0  E0  E0  E0  E0  DF  5E  E0  DF  5E  5F  5E  5F  5E  5E  5E  5E
 *      CRTC[0x16]: VBEND           F0  F0  F0  F0  F0  F0  EF  6E  F0  EF  6E  0A  6E  0A  0A  0A  0A  0A
 *      CRTC[0x17]: MODECTRL        A3  A3  A3  A3  A2  A2  C2  A3  E3  E3  8B  8B  E3  E3  A3  A3  A3  A3
 *      CRTC[0x18]: LINECOMP        FF  FF  FF  FF  FF  FF  FF  FF  FF  FF  FF  FF  FF  FF  FF  FF  FF  FF
 *       GRC[0x00]: SRESET          00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00
 *       GRC[0x01]: ESRESET         00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00
 *       GRC[0x02]: COLORCOMP       00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00
 *       GRC[0x03]: DATAROT         00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00
 *       GRC[0x04]: READMAP         00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00
 *       GRC[0x05]: MODE            10  10  10  10  30  30  00  10  00  00  10  10  00  00  10  10  10  10
 *       GRC[0x06]: MISC            0E  0E  0E  0E  0F  0F  0D  0A  05  05  07  07  05  05  0E  0E  0E  0E
 *       GRC[0x07]: COLORDC         00  00  00  00  00  00  00  00  0F  0F  0F  0F  0F  0F  00  00  00  00
 *       GRC[0x08]: BITMASK         FF  FF  FF  FF  FF  FF  FF  FF  FF  FF  FF  FF  FF  FF  FF  FF  FF  FF
 *       SEQ[0x00]: RESET           03  03  03  03  03  03  03  03  03  03  03  03  03  03  03  03  03  03
 *       SEQ[0x01]: CLKMODE         0B  0B  01  01  0B  0B  01  00  0B  01  05  05  01  01  0B  0B  01  01
 *       SEQ[0x02]: MAPMASK         03  03  03  03  03  03  01  03  0F  0F  0F  0F  0F  0F  03  03  03  03
 *       SEQ[0x03]: CHARMAP         00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00
 *       SEQ[0x04]: MEMMODE         03  03  03  03  02  02  06  03  06  06  00  00  06  06  03  03  03  03
 *       ATC[0x00]: PAL00           00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00
 *       ATC[0x01]: PAL01           01  01  01  01  13  13  17  08  01  01  08  01  08  01  01  01  01  01
 *       ATC[0x02]: PAL02           02  02  02  02  15  15  17  08  02  02  00  00  00  02  02  02  02  02
 *       ATC[0x03]: PAL03           03  03  03  03  17  17  17  08  03  03  00  00  00  03  03  03  03  03
 *       ATC[0x04]: PAL04           04  04  04  04  02  02  17  08  04  04  18  04  18  04  04  04  04  04
 *       ATC[0x05]: PAL05           05  05  05  05  04  04  17  08  05  05  18  07  18  05  05  05  05  05
 *       ATC[0x06]: PAL06           06  06  06  06  06  06  17  08  06  06  00  00  00  06  14  14  14  14
 *       ATC[0x07]: PAL07           07  07  07  07  07  07  17  08  07  07  00  00  00  07  07  07  07  07
 *       ATC[0x08]: PAL08           10  10  10  10  10  10  17  10  10  10  00  00  00  38  38  38  38  38
 *       ATC[0x09]: PAL09           11  11  11  11  11  11  17  18  11  11  08  01  08  39  39  39  39  39
 *       ATC[0x0A]: PAL0A           12  12  12  12  12  12  17  18  12  12  00  00  00  3A  3A  3A  3A  3A
 *       ATC[0x0B]: PAL0B           13  13  13  13  13  13  17  18  13  13  00  00  00  3B  3B  3B  3B  3B
 *       ATC[0x0C]: PAL0C           14  14  14  14  14  14  17  18  14  14  00  04  00  3C  3C  3C  3C  3C
 *       ATC[0x0D]: PAL0D           15  15  15  15  15  15  17  18  15  15  18  07  18  3D  3D  3D  3D  3D
 *       ATC[0x0E]: PAL0E           16  16  16  16  16  16  17  18  16  16  00  00  00  3E  3E  3E  3E  3E
 *       ATC[0x0F]: PAL0F           17  17  17  17  17  17  18  17  17  00  00  00  3F  3F  3F  3F  3F  3F
 *       ATC[0x10]: MODE            08  08  08  08  01  01  01  0E  01  01  0B  0B  0B  01  08  08  08  08
 *       ATC[0x11]: OVERSCAN        00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00
 *       ATC[0x12]: PLANES          0F  0F  0F  0F  03  03  01  0F  0F  0F  05  05  05  0F  0F  0F  0F  0F
 *       ATC[0x13]: HPAN            00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00  00
 *
 * VGA Support
 * -----------
 *
 * VGA support further piggy-backs on the existing EGA support, by adding the extra registers, I/O port
 * handlers, etc, that the VGA requires; any differences in registers common to both EGA and VGA are handled on
 * a case-by-case basis, usually according to the Videox86.CARD value stored in nCard.
 *
 * More will be said here about PCjs VGA support later.  But first, a word from IBM: "Video Graphics Array [VGA]
 * Programming Considerations":
 *
 *      Certain internal timings must be guaranteed by the user, in order to have the CRTC perform properly.
 *      This is due to the physical design of the chip. These timings can be guaranteed by ensuring that the
 *      rules listed below are followed when programming the CRTC.
 *
 *           1. The Horizontal Total [HTOTAL] register (R0) must be greater than or equal to a value of
 *              25 decimal.
 *
 *           2. The minimum positive pulse width of the HSYNC output must be four character clock units.
 *
 *           3. Register R5, Horizontal Sync End [HREND], must be programmed such that the HSYNC
 *              output goes to a logic 0 a minimum of one character clock time before the 'horizontal display enable'
 *              signal goes to a logical 1.
 *
 *           4. Register R16, Vsync Start [VRSTART], must be a minimum of one horizontal scan line greater
 *              than register R18 [VDEND].  Register R18 defines where the 'vertical display enable' signal ends.
 *
 *     When bit 5 of the Attribute Mode Control register equals 1, a successful line compare (see Line Compare
 *     [LINECOMP] register) in the CRT Controller forces the output of the PEL Panning register to 0's until Vsync
 *     occurs.  When Vsync occurs, the output returns to the programmed value.  This allows the portion of the screen
 *     indicated by the Line Compare register to be operated on by the PEL Panning register.
 *
 *     A write to the Character Map Select register becomes valid on the next whole character line.  No deformed
 *     characters are displayed by changing character generators in the middle of a character scan line.
 *
 *     For 256-color 320 x 200 graphics mode hex 13, the attribute controller is configured so that the 8-bit attribute
 *     stored in video memory for each PEL becomes the 8-bit address (P0 - P7) into the integrated DAC.  The user should
 *     not modify the contents of the internal Palette registers when using this mode.
 *
 *     The following sequence should be followed when accessing any of the Attribute Data registers pointed to by the
 *     Attribute Index register:
 *
 *           1. Disable interrupts
 *           2. Reset read/write flip/flop
 *           3. Write to Index register
 *           4. Read from or write to a data register
 *           5. Enable interrupts
 *
 *      The Color Select register in the Attribute Controller section may be used to rapidly switch between sets of colors
 *      in the video DAC.  When bit 7 of the Attribute Mode Control register equals 0, the 8-bit color value presented to the
 *      video DAC is composed of 6 bits from the internal Palette registers and bits 2 and 3 from the Color Select register.
 *      When bit 7 of the Attribute Mode Control register equals 1, the 8-bit color value presented to the video DAC is
 *      composed of the lower four bits from the internal Palette registers and the four bits in the Color Select register.
 *      By changing the value in the Color Select register, software rapidly switches between sets of colors in the video DAC.
 *      Note that BIOS does not support multiple sets of colors in the video DAC.  The user must load these colors if this
 *      function is to be used.  Also see the Attribute Controller block diagram on page 4-26.  Note that the above discussion
 *      applies to all modes except 256 Color Graphics mode.  In this mode the Color Select register is not used to switch
 *      between sets of colors.
 *
 *      An application that saves the "Video State" must store the 4 bytes of information contained in the system microprocessor
 *      latches in the graphics controller subsection. These latches are loaded with 32 bits from video memory (8 bits per map)
 *      each time the system microprocessor does a read from video memory.  The application needs to:
 *
 *           1. Use write mode 1 to write the values in the latches to a location in video memory that is not part of
 *              the display buffer.  The last location in the address range is a good choice.
 *
 *           2. Save the values of the latches by reading them back from video memory.
 *
 *           Note: If in a chain 4 or odd/even mode, it will be necessary to reconfigure the memory organization as four
 *           sequential maps prior to performing the sequence above.  BIOS provides support for completely saving and
 *           restoring video state.  See the IBM Personal System/2 and Personal Computer BIOS Interface Technical Reference
 *           for more information.
 *
 *      The description of the Horizontal PEL Panning register includes a figure showing the number of PELs shifted left
 *      for each valid value of the PEL Panning register and each valid video mode.  Further panning beyond that shown in
 *      the figure may be accomplished by changing the start address in the CRT Controller registers, Start Address High
 *      and Start Address Low.  The sequence involved in further panning would be as follows:
 *
 *           1. Use the PEL Panning register to shift the maximum number of bits to the left. See Figure 4-103 on page
 *              4-106 for the appropriate values.
 *
 *           2. Increment the start address.
 *
 *           3. If you are not using Modes 0 + , 1 + , 2 + , 3 + ,7, or7 + , set the PEL Panning register to 0.  If you
 *              are using these modes, set the PEL Panning register to 8.  The screen will now be shifted one PEL left
 *              of the position it was in at the end of step 1.  Step 1 through Step 3 may be repeated as desired.
 *
 *      The Line Compare register (CRTC register hex 18) should be programmed with even values in 200 line modes when
 *      used in split screen applications that scroll a second screen on top of a first screen.  This is a requirement
 *      imposed by the scan doubling logic in the CRTC.
 *
 *      If the Cursor Start register (CRTC register hex 0A) is programmed with a value greater than that in the Cursor End
 *      register (CRTC register hex 0B), then no cursor is displayed.  A split cursor is not possible on the VGA.
 *
 *      In 8-dot character modes, the underline attribute produces a solid line across adjacent characters, as in the IBM
 *      Color/Graphics Monitor Adapter, Monochrome Display Adapter and the Enhanced Graphics Adapter.  In 9-dot modes, the
 *      underline across adjacent characters is dashed, as in the IBM 327X display terminals.  In 9-dot modes, the line
 *      graphics characters (C0 - DF character codes) have solid underlines.
 *
 *      For compatibility with the IBM Enhanced Graphics Adapter (EGA), the internal VGA palette is programmed the same
 *      as the EGA.  The video DAC is programmed by BIOS so that the compatible values in the internal VGA palette produce
 *      a color compatible with what was produced by EGA.  Mode hex 13 (256 colors) is programmed so that the first 16
 *      locations in the DAC produce compatible colors.
 *
 *      Summing: When BIOS is used to load the video DAC palette for a color mode and a monochrome display is connected
 *      to the system unit, the color palette is changed.  The colors are summed to produce shades of gray that allow
 *      color applications to produce a readable screen.
 *
 *      There are 4 bits that should not be modified unless the sequencer is reset by setting bit 1 of the Reset register
 *      to 0.  These bits are:
 *
 *           â¢ Bit 3, or bit 0 of the Clocking Mode register
 *           â¢ Bit 3, or bit 2 of the Miscellaneous Output register
 *
 * Also, for quick reference, IBM VGA register values for the standard VGA modes (from http://www.pcjs.org/blog/2015/06/01/):
 *
 *      INT 0x10 Mode Requested:    00  01  02  03  04  05  06  0D  0E  10  12  13
 *
 *      BIOSMODE:                   01  01  03  03  04  04  06  0D  0E  10  12  13
 *      CRTC[0x00]: HTOTAL          2D  2D  5F  5F  2D  2D  5F  2D  5F  5F  5F  5F
 *      CRTC[0x01]: HDEND           27  27  4F  4F  27  27  4F  27  4F  4F  4F  4F
 *      CRTC[0x02]: HBSTART         28  28  50  50  28  28  50  28  50  50  50  50
 *      CRTC[0x03]: HBEND           90  90  82  82  90  90  82  90  82  82  82  82
 *      CRTC[0x04]: HRSTART         2B  2B  55  55  2B  2B  54  2B  54  54  54  54
 *      CRTC[0x05]: HREND           A0  A0  81  81  80  80  80  80  80  80  80  80
 *      CRTC[0x06]: VTOTAL          BF  BF  BF  BF  BF  BF  BF  BF  BF  BF  0B  BF
 *      CRTC[0x07]: OVERFLOW        1F  1F  1F  1F  1F  1F  1F  1F  1F  1F  3E  1F
 *      CRTC[0x08]: PRESCAN         00  00  00  00  00  00  00  00  00  00  00  00
 *      CRTC[0x09]: MAXSCAN         4F  4F  4F  4F  C1  C1  C1  C0  C0  40  40  41
 *      CRTC[0x0A]: CURSCAN         0D  0D  0D  0D  00  00  00  00  00  00  00  00
 *      CRTC[0x0B]: CURSCANB        0E  0E  0E  0E  00  00  00  00  00  00  00  00
 *      CRTC[0x0C]: STARTHI         00  00  00  00  00  00  00  00  00  00  00  00
 *      CRTC[0x0D]: STARTLO         00  00  00  00  00  00  00  00  00  00  00  00
 *      CRTC[0x0E]: CURSORHI        01  01  01  01  01  01  01  01  01  01  01  00
 *      CRTC[0x0F]: CURSORLO        19  19  41  41  19  19  41  19  41  41  E1  A2
 *      CRTC[0x10]: VRSTART         9C  9C  9C  9C  9C  9C  9C  9C  9C  83  EA  9C
 *      CRTC[0x11]: VREND           8E  8E  8E  8E  8E  8E  8E  8E  8E  85  8C  8E
 *      CRTC[0x12]: VDEND           8F  8F  8F  8F  8F  8F  8F  8F  8F  5D  DF  8F
 *      CRTC[0x13]: OFFSET          14  14  28  28  14  14  28  14  28  28  28  28
 *      CRTC[0x14]: UNDERLINE       1F  1F  1F  1F  00  00  00  00  00  0F  00  40
 *      CRTC[0x15]: VBSTART         96  96  96  96  96  96  96  96  96  63  E7  96
 *      CRTC[0x16]: VBEND           B9  B9  B9  B9  B9  B9  B9  B9  B9  BA  04  B9
 *      CRTC[0x17]: MODECTRL        A3  A3  A3  A3  A2  A2  C2  E3  E3  E3  E3  A3
 *      CRTC[0x18]: LINECOMP        FF  FF  FF  FF  FF  FF  FF  FF  FF  FF  FF  FF
 *       GRC[0x00]: SRESET          00  00  00  00  00  00  00  00  00  00  00  00
 *       GRC[0x01]: ESRESET         00  00  00  00  00  00  00  00  00  00  00  00
 *       GRC[0x02]: COLORCOMP       00  00  00  00  00  00  00  00  00  00  00  00
 *       GRC[0x03]: DATAROT         00  00  00  00  00  00  00  00  00  00  00  00
 *       GRC[0x04]: READMAP         00  00  00  00  00  00  00  00  00  00  00  00
 *       GRC[0x05]: MODE            10  10  10  10  30  30  00  00  00  00  00  40
 *       GRC[0x06]: MISC            0E  0E  0E  0E  0F  0F  0D  05  05  05  05  05
 *       GRC[0x07]: COLORDC         00  00  00  00  00  00  00  0F  0F  0F  0F  0F
 *       GRC[0x08]: BITMASK         FF  FF  FF  FF  FF  FF  FF  FF  FF  FF  FF  FF
 *       SEQ[0x00]: RESET           03  03  03  03  03  03  03  03  03  03  03  03
 *       SEQ[0x01]: CLKMODE         08  08  00  00  09  09  01  09  01  01  01  01
 *       SEQ[0x02]: MAPMASK         03  03  03  03  03  03  01  0F  0F  0F  0F  0F
 *       SEQ[0x03]: CHARMAP         00  00  00  00  00  00  00  00  00  00  00  00
 *       SEQ[0x04]: MEMMODE         03  03  03  03  02  02  06  06  06  06  06  0E
 *       ATC[0x00]: PAL00           00  00  00  00  00  00  00  00  00  00  00  00
 *       ATC[0x01]: PAL01           01  01  01  01  13  13  17  01  01  01  01  01
 *       ATC[0x02]: PAL02           02  02  02  02  15  15  17  02  02  02  02  02
 *       ATC[0x03]: PAL03           03  03  03  03  17  17  17  03  03  03  03  03
 *       ATC[0x04]: PAL04           04  04  04  04  02  02  17  04  04  04  04  04
 *       ATC[0x05]: PAL05           05  05  05  05  04  04  17  05  05  05  05  05
 *       ATC[0x06]: PAL06           14  14  14  14  06  06  17  06  06  14  14  06
 *       ATC[0x07]: PAL07           07  07  07  07  07  07  17  07  07  07  07  07
 *       ATC[0x08]: PAL08           38  38  38  38  10  10  17  10  10  38  38  08
 *       ATC[0x09]: PAL09           39  39  39  39  11  11  17  11  11  39  39  09
 *       ATC[0x0A]: PAL0A           3A  3A  3A  3A  12  12  17  12  12  3A  3A  0A
 *       ATC[0x0B]: PAL0B           3B  3B  3B  3B  13  13  17  13  13  3B  3B  0B
 *       ATC[0x0C]: PAL0C           3C  3C  3C  3C  14  14  17  14  14  3C  3C  0C
 *       ATC[0x0D]: PAL0D           3D  3D  3D  3D  15  15  17  15  15  3D  3D  0D
 *       ATC[0x0E]: PAL0E           3E  3E  3E  3E  16  16  17  16  16  3E  3E  0E
 *       ATC[0x0F]: PAL0F           3F  3F  3F  3F  17  17  17  17  17  3F  3F  0F
 *       ATC[0x10]: MODE            0C  0C  0C  0C  01  01  01  01  01  01  01  41
 *       ATC[0x11]: OVERSCAN        00  00  00  00  00  00  00  00  00  00  00  00
 *       ATC[0x12]: PLANES          0F  0F  0F  0F  03  03  01  0F  0F  0F  0F  0F
 *       ATC[0x13]: HPAN            08  08  08  08  00  00  00  00  00  00  00  00
 */

/**
 * Supported Monitors
 *
 * The MDA monitor displays 350 lines of vertical resolution, 720 lines of horizontal resolution, and refreshes
 * at ~50Hz.  The CGA monitor displays 200 lines vertically, 640 horizontally, and refreshes at ~60Hz.
 *
 * Based on actual MDA timings (see http://diylab.atwebpages.com/pressureDev.htm), the total horizontal
 * period (drawing a line and retracing) is ~54.25uSec (1000000uSec / 18432) and the horizontal retrace interval
 * is about 15% of that, or ~8.14uSec.  Vertical sync occurs once every 370 horizontal periods.  Of those 370,
 * only 354 represent actively drawn lines (and of those, only 350 are visible); the remaining 16 horizontal
 * periods, or 4% of the 370 total, represent the vertical retrace interval.
 *
 * I don't have similar numbers for the CGA or EGA, so for now, I assume similar percentages; ie, 15% of
 * the horizontal period will represent horizontal retrace, and 4% of the vertical pixel maximum (262) will
 * represent vertical retrace.  However, 24% of the CGA's 262 vertical maximum represents non-visible lines,
 * whereas only 5% of the MDA's 370 maximum represents non-visible lines; is there really that much "overscan"
 * on the CGA?
 *
 * For each monitor type, there's a MonitorSpecs object that describes the horizontal and vertical
 * timings, along with my assumptions about the percentage of time that drawing is "active" within those periods,
 * and then based on the selected monitor type, I compute the number of CPU cycles that each period lasts,
 * as well as the number of CPU cycles that drawing lasts within each period, so that the horizontal and vertical
 * retrace status flags can be quickly calculated.
 *
 * For reference, here are some important numbers to know (from https://github.com/reenigne/reenigne/blob/master/8088/cga/register_values.txt):
 *
 *              CGA          MDA
 *  Pixel clock 14.318 MHz   16.257 MHz (aka "maximum video bandwidth", as IBM Tech Refs sometimes call it)
 *  Horizontal  15.700 KHz   18.432 KHz (aka "horizontal drive", as IBM Tech Refs sometimes call it)
 *  Vertical    59.923 Hz    49.816 Hz
 *  Usage       53.69%       77.22%
 *  H pix       912 = 114*8  882 = 98*9
 *  V pix       262          370
 *  Dots        238944       326340
 */

/** @typedef {{ nHorzPeriodsPerSec: number, nHorzPeriodsPerFrame: number, percentHorzActive: number, percentVertActive: number }} */
let MonitorSpecs;

/**
 * @class Card
 * @property {Debuggerx86} dbg
 * @unrestricted (allows the class to define properties, both dot and named, outside of the constructor)
 */
class Card extends Controller {
    /**
     * MDA Registers (ports 0x3B4, 0x3B5, 0x3B8, and 0x3BA)
     *
     * NOTE: All monochrome cards (at least all IBM cards) included a parallel interface at ports 0x3BC/0x3BD/0x3BE;
     * for the same functionality in PCx86, you must include a properly configured ParallelPort component.
     */
    static MDA = {
        CRTC: {
            INDX: {
                PORT:           0x3B4,      // NOTE: the low byte of this port address (0xB4) is mirrored at 40:0063 (0x0463)
                MASK:           0x1F
            },
            DATA: {
                PORT:           0x3B5
            }
        },
        MODE: {
            PORT:               0x3B8,      // Mode Select Register, aka CRT Control Port 1 (write-only); the BIOS mirrors this register at 40:0065 (0x0465)
            HIRES:              0x01,
            VIDEO_ENABLE:       0x08,
            BLINK_ENABLE:       0x20
        },
        STATUS: {
            PORT:               0x3BA,
            HDRIVE:             0x01,
            BWVIDEO:            0x08
        }
    };

    /**
     * CGA Registers (ports 0x3D4, 0x3D5, 0x3D8, 0x3D9, and 0x3DA)
     */
    static CGA = {
        CRTC: {
            INDX: {
                PORT:           0x3D4,      // NOTE: the low byte of this port address (0xB4) is mirrored at 40:0063 (0x0463)
                MASK:           0x1F
            },
            DATA: {
                PORT:           0x3D5
            }
        },
        MODE: {
            PORT:               0x3D8,      // Mode Select Register (write-only); the BIOS mirrors this register at 40:0065 (0x0465)
            _80X25:             0x01,
            GRAPHIC_SEL:        0x02,
            BW_SEL:             0x04,
            VIDEO_ENABLE:       0x08,       // same as MDA.MODE.VIDEO_ENABLE
            HIRES_BW:           0x10,
            BLINK_ENABLE:       0x20        // same as MDA.MODE.BLINK_ENABLE
        },
        COLOR: {
            PORT:               0x3D9,      // Color Select Register, aka Overscan Register (write-only)
            BORDER:             0x07,
            BRIGHT:             0x08,
            BGND_ALT:           0x10,       // alternate, intensified background colors in text mode
            COLORSET1:          0x20        // selects aCGAColorSet1 colors for 320x200 graphics mode; aCGAColorSet0 otherwise
        },
        STATUS: {
            PORT:               0x3DA,      // read-only; same for EGA (although the EGA calls this STATUS1, to distinguish it from STATUS0)
            RETRACE:            0x01,
            PEN_TRIGGER:        0x02,
            PEN_ON:             0x04,
            VRETRACE:           0x08        // when set, this indicates the CGA is performing a vertical retrace
        },
        /**
         * TODO: Add support for light pen port(s) someday....
         */
        CLEAR_PEN: {
            PORT:               0x3DB
        },
        PRESET_PEN: {
            PORT:               0x3DC
        }
    };

    /**
     * Common CRT hardware registers (ports 0x3B4/0x3B5 or 0x3D4/0x3D5)
     *
     * NOTE: In this implementation, because we have to make at least two of the registers readable (CURSORHI and CURSORLO),
     * we end up making ALL the registers readable, otherwise we would have to explicitly block any register marked write-only.
     * I don't think making the CRT registers fully readable presents any serious compatibility issues, and it actually offers
     * some benefits (eg, improved debugging).
     *
     * However, some things are broken: the (readable) light pen registers on the EGA are overloaded as (writable) vertical retrace
     * registers, so the vertical retrace registers cannot actually be read that way.  I'm sure the VGA solved that problem, but I haven't
     * looked into it yet.
     */
    static CRTC = {
        HTOTAL:             0x00,           // Horizontal Total
        HDISP:              0x01,           // Horizontal Displayed
        HSPOS:              0x02,           // Horizontal Sync Position
        HSWIDTH:            0x03,           // Horizontal Sync Width
        VTOTAL:             0x04,           // Vertical Total
        VTOTADJ:            0x05,           // Vertical Total Adjust
        VDISP:              0x06,           // Vertical Displayed
        VSPOS:              0x07,           // Vertical Sync Position
        ILMODE:             0x08,           // Interlace Mode
        MAXSCAN:            0x09,           // Max Scan Line Address
        CURSCAN:            0x0A,           // Cursor Scan Line Top
        CURSCAN_SLMASK:         0x1F,       // Scan Line Mask
        /**
         * I don't entirely understand the cursor blink control bits.  Here's what the MC6845 datasheet says:
         *
         *      Bit 5 is the blink timing control.  When bit 5 is low, the blink frequency is 1/16 of the vertical field rate,
         *      and when bit 5 is high, the blink frequency is 1/32 of the vertical field rate.  Bit 6 is used to enable a blink.
         */
        CURSCAN_BLINKON:        0x00,       // (supposedly, 0x40 has the same effect as 0x00?)
        CURSCAN_BLINKOFF:       0x20,       // if blinking is disabled, the cursor is effectively hidden (TODO: CGA and VGA only?)
        CURSCAN_BLINKFAST:      0x60,       // default is 1/16 of the frame rate; this switches to 1/32 of the frame rate (TODO: CGA only?)
        CURSCANB:           0x0B,           // Cursor Scan Line Bottom
        STARTHI:            0x0C,           // Start Address High
        STARTLO:            0x0D,           // Start Address Low
        CURSORHI:           0x0E,           // Cursor Address High
        CURSORLO:           0x0F,           // Cursor Address Low
        PENHI:              0x10,           // Light Pen High
        PENLO:              0x11,           // Light Pen Low
        TOTAL_REGS:         0x12,           // total CRT registers on MDA/CGA
        EGA: {
            HDEND:          0x01,
            HBSTART:        0x02,
            HBEND:          0x03,
            HRSTART:        0x04,
            HREND:          0x05,
            VTOTAL:         0x06,
            OVERFLOW: {
                INDX:       0x07,
                VTOTAL_BIT8:    0x01,       // bit 8 of register 0x06
                VDEND_BIT8:     0x02,       // bit 8 of register 0x12
                VRSTART_BIT8:   0x04,       // bit 8 of register 0x10
                VBSTART_BIT8:   0x08,       // bit 8 of register 0x15
                LINECOMP_BIT8:  0x10,       // bit 8 of register 0x18
                CURSCAN_BIT8:   0x20,       // bit 8 of register 0x0A (EGA only; TODO: What is this for? The CURSCAN register doesn't even use bit 7, so why would it need a bit 8?)
                VTOTAL_BIT9:    0x20,       // bit 9 of register 0x06 (VGA only)
                VDEND_BIT9:     0x40,       // bit 9 of register 0x12 (VGA only, unused on EGA)
                VRSTART_BIT9:   0x80        // bit 9 of register 0x10 (VGA only, unused on EGA)
            },
            PRESCAN:        0x08,
            /**
             * NOTE: EGA/VGA CRTC registers 0x09-0x0F are the same as the MDA/CGA CRTC registers defined above
             */
            MAXSCAN: {
                INDX:       0x09,           // (same as MDA/CGA)
                SLMASK:         0x1F,       // Scan Line Mask
                VBSTART_BIT9:   0x20,       // (VGA only)
                LINECOMP_BIT9:  0x40,       // (VGA only)
                CONVERT400:     0x80        // 200-to-400 scan-line conversion is in effect (VGA only)
            },
            CURSCAN:        0x0A,           // (same as MDA/CGA)
            CURSCANB:       0x0B,           // (same as MDA/CGA)
            STARTHI:        0x0C,           // (same as MDA/CGA)
            STARTLO:        0x0D,           // (same as MDA/CGA)
            CURSORHI:       0x0E,           // (same as MDA/CGA)
            CURSORLO:       0x0F,           // (same as MDA/CGA)
            VRSTART:        0x10,           // (formerly PENHI on MDA/CGA)
            VREND:          {               // (formerly PENLO on MDA/CGA; last register on the original 6845 controller)
                INDX:       0x11,
                HSCAN:          0x0F,       // the horizontal scan count value when the vertical retrace output signal becomes inactive
                UNCLEAR_VRINT:  0x10,       // clear vertical retrace interrupt if NOT set
                DISABLE_VRINT:  0x20        // enable vertical retrace interrupt if NOT set
            },
            VDEND:          0x12,
            /**
             * The OFFSET register (bits 0-7) specifies the logical line width of the screen.  The starting memory address
             * for the next character row is larger than the current character row by two or four times this amount.
             * The OFFSET register is programmed with a word address.  Depending on the method of clocking the CRT Controller,
             * this word address is [effectively] either a word or double-word address. #IBMVGATechRef
             */
            OFFSET:         0x13,
            UNDERLINE: {
                INDX:       0x14,
                SLMASK:         0x1F,
                COUNT_BY_4:     0x20,       // (VGA only)
                DWORD:          0x40        // (VGA only)
            },
            VBSTART:        0x15,
            VBEND:          0x16,
            MODECTRL: {
                INDX:       0x17,
                COMPAT_MODE:    0x01,       // Compatibility Mode Support (CGA A13 control)
                SEL_ROW_SCAN:   0x02,       // Select Row Scan Counter
                SEL_HRETRACE:   0x04,       // Horizontal Retrace Select
                COUNT_BY_2:     0x08,       // Count By Two
                OUTPUT_CTRL:    0x10,       // Output Control
                ADDR_WRAP:      0x20,       // Address Wrap (in Word mode, 1 maps A15 to A0 and 0 maps A13; use the latter when only 64Kb is installed)
                BYTE_MODE:      0x40,       // Byte Mode (1 selects Byte Mode; 0 selects Word Mode)
                HARD_RESET:     0x80        // Hardware Reset
            },
            LINECOMP:       0x18,
            TOTAL_REGS:     0x19            // total CRT registers on EGA/VGA
        }
    };

    /**
     * TODO: These mask tables need to be card-specific.  For example, the STARTHI and CURSORHI registers used to be
     * limited to 0x3F, because the MC6845 controller used with the original MDA and CGA cards was limited to 16Kb of RAM,
     * whereas later cards like the EGA and VGA had anywhere from 64Kb to 256Kb, so all the bits of those registers were
     * significant.  Currently, I'm doing very little masking, which means most CRTC registers are treated as full 8-bit
     * registers (and fully readable as well), which might cause some compatibility problems for any MDA/CGA apps that
     * were sloppy about how they programmed registers.
     *
     * I do make an exception, however, in the case of STARTHI and CURSORHI, due to the way the MC6845 controller wraps
     * addresses around to the beginning of the buffer, because that seems like a high-risk case.  See the card-specific
     * variable addrMaskHigh.
     */
    static CRTCMASKS = {
        [Card.CRTC.HTOTAL]:     0xFF,       // R0
        [Card.CRTC.HDISP]:      0xFF,       // R1
        [Card.CRTC.HSPOS]:      0xFF,       // R2
        [Card.CRTC.HSWIDTH]:    0x0F,       // R3
        [Card.CRTC.VTOTAL]:     0x7F,       // R4
        [Card.CRTC.VTOTADJ]:    0x1F,       // R5
        [Card.CRTC.VDISP]:      0x7F,       // R6
        [Card.CRTC.VSPOS]:      0x7F,       // R7
        [Card.CRTC.ILMODE]:     0x03,       // R8
        [Card.CRTC.MAXSCAN]:    0x1F,       // R9
        [Card.CRTC.CURSCAN]:    0x7F,       // R10
        [Card.CRTC.CURSCANB]:   0x1F,       // R11
        [Card.CRTC.STARTHI]:    0x3F,       // R12
        [Card.CRTC.STARTLO]:    0xFF,       // R13
        [Card.CRTC.CURSORHI]:   0x3F,       // R14
        [Card.CRTC.CURSORLO]:   0xFF,       // R15
        [Card.CRTC.PENHI]:      0x3F,       // R16
        [Card.CRTC.PENLO]:      0xFF        // R17
    };

    /**
     * EGA/VGA Input Status 1 Register (port 0x3DA)
     *
     * STATUS1 bit 0 has confusing documentation: the EGA Tech Ref says "Logical 0 indicates the CRT raster is in a
     * horizontal or vertical retrace interval", whereas the VGA Tech Ref says "Logical 1 indicates a horizontal or
     * vertical retrace interval," but then clarifies: "This bit is the real-time status of the INVERTED display enable
     * signal".  So, instead of calling bit 0 DISP_ENABLE (or more precisely, DISP_ENABLE_INVERTED), it's simply RETRACE.
     *
     * STATUS1 diagnostic bits 5 and 4 are set according to the Card.ATC.PLANES.MUX bits:
     *
     *      MUX     Bit 5   Bit 4
     *      ---     ----    ----
     *      00:     Red     Blue
     *      01:     SecBlue Green
     *      10:     SecRed  SecGreen
     *      11:     unused  unused
     */
    static STATUS1 = {
        PORT:                   0x3DA,
        RETRACE:                0x01,       // bit 0: logical OR of horizontal and vertical retrace
        VRETRACE:               0x08,       // bit 3: set during vertical retrace interval
        DIAGNOSTIC:             0x30,       // bits 5,4 are controlled by the Card.ATC.PLANES.MUX bits
        RESERVED:               0xC6
    };

    /**
     * EGA/VGA Attribute Controller Registers (port 0x3C0: regATCIndx and regATCData)
     *
     * The current ATC INDX value is stored in cardEGA.regATCIndx (including the Card.ATC.INDX_ENABLE bit), and the
     * ATC DATA values are stored in cardEGA.regATCData.  The state of the ATC INDX/DATA flip-flop is stored in fATCData.
     *
     * Note that the ATC palette registers (0x0-0xf) all use the following 6 bit assignments, with bits 6 and 7 unused:
     *
     *      0: Blue
     *      1: Green
     *      2: Red
     *      3: SecBlue (or mono video)
     *      4: SecGreen (or intensity)
     *      5: SecRed
     */
    static ATC = {
        PORT:                   0x3C0,      // ATC Index/Data Port
        INDX_MASK:              0x1F,
        INDX_PAL_ENABLE:        0x20,       // must be clear when loading palette registers
        PALETTE: {
            INDX:               0x00,       // 16 registers: 0x00 - 0x0F
            MASK:               0x3f,
            BLUE:               0x01,
            GREEN:              0x02,
            RED:                0x04,
            SECBLUE:            0x08,
            BRIGHT:             0x10,       // NOTE: The IBM EGA manual (p.56) also calls this the "intensity" bit
            SECGREEN:           0x10,
            SECRED:             0x20
        },
        PALETTE_REGS:           0x10,       // 16 total palette registers
        MODE: {
            INDX:               0x10,       // ATC Mode Control Register
            GRAPHICS:           0x01,       // bit 0: set for graphics mode, clear for alphanumeric mode
            MONOEM:             0x02,       // bit 1: set for monochrome emulation mode, clear for color emulation
            TEXT_9DOT:          0x04,       // bit 2: set for 9-dot replication in character codes 0xC0-0xDF
            BLINK_ENABLE:       0x08,       // bit 3: set for text/graphics blink, clear for background intensity
            RESERVED:           0x10,       // bit 4: reserved
            PANCOMPAT:          0x20,       // bit 5: set for pixel-panning compatibility
            PELWIDTH:           0x40,       // bit 6: set for 256-color modes, clear for all other modes
            COLORSEL_ALL:       0x80        // bit 7: set to enable all COLORSEL bits (ie, COLORSEL.DAC_BIT5 and COLORSEL.DAC_BIT4)
        },
        OVERSCAN: {
            INDX:               0x11        // ATC Overscan Color Register
        },
        PLANES: {
            INDX:               0x12,       // ATC Color Plane Enable Register
            MASK:               0x0F,
            MUX:                0x30,
            RESERVED:           0xC0
        },
        HPAN: {
            INDX:               0x13,       // ATC Horizontal PEL Panning Register
            SHIFT_LEFT:         0x0F        // bits 0-3 indicate # of pixels to shift left
        },
        COLORSEL: {
            INDX:               0x14,       // ATC Color Select Register (VGA only)
            DAC_BIT7:           0x08,       // specifies bit 7 of DAC values (ignored in 256-color modes)
            DAC_BIT6:           0x04,       // specifies bit 6 of DAC values (ignored in 256-color modes)
            DAC_BIT5:           0x02,       // specifies bit 5 of DAC values (if ATC.MODE.COLORSEL_ALL is set; ignored in 256-color modes)
            DAC_BIT4:           0x01        // specifies bit 4 of DAC values (if ATC.MODE.COLORSEL_ALL is set; ignored in 256-color modes)
        },
        TOTAL_REGS:             0x14
    };

    /**
     * EGA/VGA Feature Control Register (port 0x3BA or 0x3DA: regFeat)
     *
     * The EGA BIOS writes 0x1 to Card.FEAT_CTRL.BITS and reads Card.STATUS0.FEAT, then writes 0x2 to
     * Card.FEAT_CTRL.BITS and reads Card.STATUS0.FEAT.  The bits from the first and second reads are shifted
     * into the high nibble of the byte at 40:88h.
     */
    static FEAT_CTRL = {
        PORT_MONO:              0x3BA,      // write port address (other than the two bits below, the rest are reserved and/or unused)
        PORT_COLOR:             0x3DA,      // write port address (other than the two bits below, the rest are reserved and/or unused)
        PORT_READ:              0x3CA,      // read port address (VGA only)
        BITS:                   0x03        // feature control bits
    };

    /**
     * EGA/VGA Miscellaneous Output Register (port 0x3C2: regMisc)
     */
    static MISC = {
        PORT_WRITE:             0x3C2,      // write port address (EGA and VGA)
        PORT_READ:              0x3CC,      // read port address (VGA only)
        IO_SELECT:              0x01,       // 0 sets CRT ports to 0x3Bn, 1 sets CRT ports to 0x3Dn
        ENABLE_RAM:             0x02,       // 0 disables video RAM, 1 enables
        CLOCK_SELECT:           0x0C,       // 0x0: 14Mhz I/O clock, 0x4: 16Mhz on-board clock, 0x8: external clock, 0xC: unused
        DISABLE_DRV:            0x10,       // 0 activates internal video drivers, 1 activates feature connector direct drive outputs
        PAGE_ODD_EVEN:          0x20,       // 0 selects the low 64Kb page of video RAM for text modes, 1 selects the high page
        HPOLARITY:              0x40,       // 0 selects positive horizontal retrace
        VPOLARITY:              0x80        // 0 selects positive vertical retrace
    };

    /**
     * EGA/VGA Input Status 0 Register (port 0x3C2: regStatus0)
     */
    static STATUS0 = {
        PORT:                   0x3C2,      // read-only (aka STATUS0, to distinguish it from PORT_CGA_STATUS)
        RESERVED:               0x0F,
        SWSENSE:                0x10,
        SWSENSE_SHIFT:          4,
        FEAT:                   0x60,       // VGA: reserved
        INTERRUPT:              0x80        // 1: video is being displayed; 0: vertical retrace is occurring
    };

    /**
     * VGA Subsystem Enable Register (port 0x3C3: regVGAEnable)
     */
    static VGA_ENABLE = {
        PORT:                   0x3C3,
        ENABLED:                0x01,       // when set, all VGA I/O and memory decoding is enabled; otherwise disabled (TODO: Implement)
        RESERVED:               0xFE
    };

    /**
     * EGA/VGA Sequencer Registers (ports 0x3C4/0x3C5: regSEQIndx and regSEQData)
     */
    static SEQ = {
        INDX: {
            PORT:               0x3C4,      // Sequencer Index Port
            MASK:               0x07
        },
        DATA: {
            PORT:               0x3C5       // Sequencer Data Port
        },
        RESET: {
            INDX:               0x00,       // Sequencer Reset Register
            ASYNC:              0x01,
            SYNC:               0x02
        },
        CLKMODE: {
            INDX:               0x01,       // Sequencer Clocking Mode Register
            DOTS8:              0x01,       // 1: 8 dots; 0: 9 dots
            BANDWIDTH:          0x02,       // 0: CRTC has access 4 out of every 5 cycles (for high-res modes); 1: CRTC has access 2 out of 5 (VGA: reserved)
            SHIFTLOAD:          0x04,
            DOTCLOCK:           0x08,       // 0: normal dot clock; 1: master clock divided by two (used for 320x200 modes: 0, 1, 4, 5, and D)
            SHIFT4:             0x10,       // VGA only
            SCREEN_OFF:         0x20,       // VGA only
            RESERVED:           0xC0
        },
        MAPMASK: {
            INDX:               0x02,       // Sequencer Map Mask Register
            PL0:                0x01,
            PL1:                0x02,
            PL2:                0x04,
            PL3:                0x08,
            MAPS:               0x0F,
            RESERVED:           0xF0
        },
        CHARMAP: {
            INDX:               0x03,       // Sequencer Character Map Select Register
            SELB:               0x03,       // 0x0: 1st 8Kb of plane 2; 0x1: 2nd 8Kb; 0x2: 3rd 8Kb; 0x3: 4th 8Kb (used when attribute bit 3 is 0)
            SELA:               0x0C,       // 0x0: 1st 8Kb of plane 2; 0x4: 2nd 8Kb; 0x8: 3rd 8Kb; 0xC: 4th 8Kb (used when attribute bit 3 is 1)
            SELB_HI:            0x10,       // VGA only
            SELA_HI:            0x20        // VGA only
        },
        MEMMODE: {
            INDX:               0x04,       // Sequencer Memory Mode Register
            ALPHA:              0x01,       // set for alphanumeric (A/N) mode, clear for graphics (APA or "All Points Addressable") mode (EGA only)
            EXT:                0x02,       // set if memory expansion installed, clear if not installed
            SEQUENTIAL:         0x04,       // set for sequential memory access, clear for mapping even addresses to planes 0/2, odd addresses to planes 1/3
            CHAIN4:             0x08        // VGA only: set to select memory map (plane) based on low 2 bits of address
        },
        TOTAL_REGS:             0x05
    };

    /**
     * VGA Digital-to-Analog Converter (DAC) Registers (regDACMask, regDACState, regDACAddr, and regDACData)
     *
     * To write DAC data, write an address to DAC.ADDR.PORT_WRITE, then write 3 bytes to DAC.DATA.PORT; the low 6 bits
     * of each byte will be concatenated to form an 18-bit DAC value (red is least significant, followed by green, then blue).
     * When the final byte is received, the 18-bit DAC value is updated and regDACAddr is auto-incremented.
     *
     * To read DAC data, the process is similar, but the initial address is written to DAC.ADDR.PORT_READ instead.
     *
     * DAC.STATE.PORT and DAC.ADDR.PORT_WRITE can be read at any time and will not interfere with a read or write operation
     * in progress.  To prevent "snow", reading or writing DAC values should be limited to retrace intervals (see regStatus1),
     * or by using the SCREEN_OFF bit in the SEQ.CLKMODE register.
     */
    static DAC = {
        MASK: {
            PORT:               0x3C6,      // initialized to 0xFF and should not be changed
            DEFAULT:            0xFF
        },
        STATE: {
            PORT:               0x3C7,
            MODE_WRITE:         0x00,       // the DAC is in write mode if bits 0 and 1 are clear
            MODE_READ:          0x03        // the DAC is in read mode if bits 0 and 1 are set
        },
        ADDR: {
            PORT_READ:          0x3C7,      // write to initiate a read
            PORT_WRITE:         0x3C8       // write to initiate a write; read to determine the current ADDR
        },
        DATA: {
            PORT:               0x3C9
        },
        TOTAL_REGS:             0x100
    };

    /**
     * EGA/VGA Graphics Controller Registers (ports 0x3CE/0x3CF: regGRCIndx and regGRCData)
     *
     * The VGA added Write Mode 3, which is described as follows:
     *
     *      "Each map is written with 8 bits of the value contained in the Set/Reset register for that map
     *      (the Enable Set/Reset register has no effect). Rotated system microprocessor data is ANDed with the
     *      Bit Mask register data to form an 8-bit value that performs the same function as the Bit Mask register
     *      does in write modes 0 and 2."
     */
    static GRC = {
        POS1_PORT:              0x3CC,      // EGA only, write-only
        POS2_PORT:              0x3CA,      // EGA only, write-only
        INDX: {
            PORT:               0x3CE,      // GRC Index Port
            MASK:               0x0F
        },
        DATA: {
            PORT:               0x3CF       // GRC Data Port
        },
        SRESET: {
            INDX:               0x00        // GRC Set/Reset Register (write-only; each bit used only if WRITE.MODE0 and corresponding ESR bit set)
        },
        ESRESET: {
            INDX:               0x01        // GRC Enable Set/Reset Register
        },
        COLORCOMP: {
            INDX:               0x02        // GRC Color Compare Register
        },
        DATAROT: {
            INDX:               0x03,       // GRC Data Rotate Register
            COUNT:              0x07,
            AND:                0x08,
            OR:                 0x10,
            XOR:                0x18,
            FUNC:               0x18,
            MASK:               0x1F
        },
        READMAP: {
            INDX:               0x04,       // GRC Read Map Select Register
            NUM:                0x03
        },
        MODE: {
            INDX:               0x05,       // GRC Mode Register
            WRITE: {
                MODE0:          0x00,       // write mode 0: each plane written with CPU data, rotated as needed, unless SR enabled
                MODE1:          0x01,       // write mode 1: each plane written with contents of the processor latches (loaded by a read)
                MODE2:          0x02,       // write mode 2: memory plane N is written with 8 bits matching data bit N
                MODE3:          0x03,       // write mode 3: VGA only
                MASK:           0x03
            },
            TEST:               0x04,
            READ: {
                MODE0:          0x00,       // read mode 0: read map mode
                MODE1:          0x08,       // read mode 1: color compare mode
                MASK:           0x08
            },
            EVENODD:            0x10,
            SHIFT:              0x20,
            COLOR256:           0x40        // VGA only
        },
        MISC: {
            INDX:               0x06,       // GRC Miscellaneous Register
            GRAPHICS:           0x01,       // set for graphics mode addressing, clear for text mode addressing
            CHAIN:              0x02,       // set for odd/even planes selected with odd/even values of the processor AO bit
            MAPMEM:             0x0C,       //
            MAPA0128:           0x00,       //
            MAPA064:            0x04,       //
            MAPB032:            0x08,       //
            MAPB832:            0x0C        //
        },
        COLORDC: {
            INDX:               0x07        // GRC Color "Don't Care" Register
        },
        BITMASK: {
            INDX:               0x08        // GRC Bit Mask Register
        },
        TOTAL_REGS:             0x09
    };

    /**
     * EGA Memory Access Functions
     *
     * Here's where we define all the getMemoryAccess() functions that know how to deal with "planar" EGA memory,
     * which consists of 32-bit values for every byte of address space, allowing us to internally store plane 0
     * bytes in bits 0-7, plane 1 bytes in bits 8-15, plane 2 bytes in bits 16-23, and plane 3 bytes in bits 24-31.
     *
     * All our functions have slightly more overhead than the standard Bus memory access functions, because the
     * offset (off) parameter is block-relative, which we must transform into a buffer-relative offset.  Fortunately,
     * all our Memory objects know this and have already recorded their buffer-relative offset in "this.offset".
     *
     * Also, the EGA includes a set of latches, one for each plane, which must be updated on most reads/writes;
     * we rely on the Memory object's "this.controller" property to give us access to the Card's state.
     *
     * And we take a little extra time to conditionally set DIRTY on writes, meaning if a write did not actually
     * change the value of the memory, we will not set DIRTY.  The default write functions in memory.js don't take
     * that performance hit, but here, it may be worthwhile, because if it results in fewer dirty blocks, display
     * updates may be faster.
     *
     * Note that we don't have to worry about dealing with word accesses that straddle block boundaries, because
     * the Bus component automatically breaks those accesses into separate byte requests.  Similarly, byte and word
     * values for the write functions have already been pre-masked by the Bus component to 8 and 16 bits, respectively.
     *
     * My motto: Be paranoid, but also be careful not to do any more work than you absolutely have to.
     *
     *
     * CGA Emulation on the EGA
     *
     * Modes 4/5 (320x200 low-res graphics) emulate the same buffer format that the CGA uses.  To recap: 1 byte contains
     * 4 pixels (pixel 0 in bits 7-6, pixel 1 in bits 5-4, etc), and thus one row of pixels is 80 (0x50) bytes long.
     * Moreover, all even rows are stored in the first 8K of the video buffer (at 0xB8000), and all odd rows are stored
     * in the second 8K (at 0xBA000).  Of each 8K, only 8000 (0x1F40) bytes are used (80 bytes X 100 rows); the remaining
     * 192 bytes of each 8K are unused.
     *
     * For these modes, the EGA's GRC.MODE is programmed with 0x30: Card.GRC.MODE.EVENODD and Card.GRC.MODE.SHIFT.
     * The latter claims to work by forming each 2-bit pixel with even bits from plane 0 and odd bits from plane 1;
     * however, I'm unclear how that works if even bytes are only written to plane 0 and odd bytes are only written to
     * plane 1, as Card.GRC.MODE.EVENODD implies, because plane 0 would never have any bits for the odd bytes, and
     * plane 1 would never have any bits for the even bytes.  TODO: Figure this out.
     *
     *
     * Even/Odd Memory Access Functions
     *
     * The "EVENODD" functions deal with the EGA's default text-mode addressing, where EVEN addresses are mapped to
     * plane 0 (and 2) and ODD addresses are mapped to plane 1 (and 3).  This occurs when SEQ.MEMMODE.SEQUENTIAL is
     * clear (and GRC.MODE.EVENODD is set), turning address bit 0 (A0) into a "plane select" bit.  Whether A0 is also
     * used as a memory address bit depends on CRTC.MODECTRL.BYTE_MODE: if it's set, then we're in "Byte Mode" and A0 is
     * used as-is; if it's clear, then we're in "Word Mode", and either A15 (when CRTC.MODECTRL.ADDR_WRAP is set) or A13
     * (when CRTC.MODECTRL.ADDR_WRAP is clear, typically when only 64Kb of EGA memory is installed) is substituted for A0.
     *
     * Note that A13 remains clear until addresses reach 8K, at which point we've spanned 32Kb of EGA memory, so it makes
     * sense to propagate A13 to A0 at that point, so that the next 8K of addresses start using ODD instead of EVEN bytes,
     * and no memory is wasted on a 64Kb EGA card.
     *
     * These functions, however, don't yet deal with all those subtleties: A0 is currently used only as a "plane select"
     * bit and set to zero for addressing purposes, meaning that only the EVEN bytes in EGA memory will ever be used.
     * TODO: Implement the subtleties.
     */

    /**
     * Card(video, nCard, data, cbMemory)
     *
     * Creates an object representing an initial video card state;
     * can also restore a video card from state data created by saveCard().
     *
     * WARNING: Since Card objects are low-level objects that have no UI requirements,
     * they do not inherit from the Component class, so you should only use class methods
     * of Component, such as Component.assert(), or methods of the parent (video) object.
     *
     * @this {Card}
     * @param {Videox86} [video]
     * @param {number} [nCard] (see Videox86.CARD.*)
     * @param {Array|null} [data]
     * @param {number} [cbMemory] is specified if the card must allocate its own memory buffer
     */
    constructor(video, nCard, data, cbMemory)
    {
        super();

        /**
         * If a card was originally not present (eg, EGA), then the state will be empty,
         * so we need to detect that case and continue indicating that the card is not present.
         */
        if (nCard !== undefined && (!data || data.length)) {

            this.video = video;

            let specs = Videox86.cardSpecs[nCard];
            let nMonitorType = video.nMonitorType || specs[5];

            if (!data || data.length < 6) {
                data = [false, 0, null, null, 0, new Array(nCard < Videox86.CARD.EGA? Card.CRTC.TOTAL_REGS : Card.CRTC.EGA.TOTAL_REGS)];
            }

            /**
             * If a Debugger is present, we want to stash a bit more info in each Card.
             */
            if (DEBUGGER) {
                this.dbg = video.dbg;
                this.type = specs[0];
                this.port = specs[1];
            }

            this.nCard = nCard;
            this.addrBuffer = specs[2];     // default (physical) video buffer address
            this.sizeBuffer = specs[3];     // default video buffer length (this is the total size, not the current visible size;
                                            // this.cbScreen is calculated on the fly to reflect the latter)

            /**
             * If no memory size is specified, then setMode() will use addMemory() to automatically add enough
             * memory blocks to cover the video buffer specified above; otherwise, it instructs addMemory() to call
             * getMemoryBuffer(), which will return a portion of the buffer (adwMemory) allocated below.  This allows
             * a card like the EGA to move/resize its video buffer as needed, as well as giving it total control over
             * the underlying memory.
             */
            this.cbMemory = cbMemory || specs[4];

            /**
             * All of our cardSpec video buffer sizes are based on the default text mode (eg, 4Kb for an MDA, 16Kb for
             * a CGA), but for a card with 64Kb or more of memory (ie, any EGA card), the default text mode video buffer
             * size should be dynamically recalculated as the smaller of: cbMemory divided by 4, or 32Kb.
             */
            if (this.cbMemory >= 0x10000 && this.addrBuffer >= 0xB0000) {
                this.sizeBuffer = Math.min(this.cbMemory >> 2, 0x8000);
            }

            this.fActive    = data[0];
            this.regMode    = data[1];      // see MDA.MODE* or CGA.MODE_*
                                            // use MDA.MODE.HIRES | MDA.MODE.VIDEO_ENABLE | MDA.MODE.BLINK_ENABLE
                                            // if you want to test blinking immediately after the initial power-on reset)
            this.regColor   = data[2];      // see CGA.COLOR.* (undefined on MDA)
            this.regStatus  = data[3];      // see MDA.STATUS.* or CGA.STATUS.*
            this.regCRTIndx = data[4] & 0xff;
            this.regCRTPrev = (data[4] >> 8) & 0xff;
            this.regCRTData = data[5];
            this.nCRTCRegs  = Card.CRTC.TOTAL_REGS;
            this.asCRTCRegs = DEBUGGER? Card.CRTC.REGS : [];
            this.offStart   = this.regCRTData[Card.CRTC.STARTLO] | (this.regCRTData[Card.CRTC.STARTHI] << 8);
            this.rowStart   = 0;            // initialize to zero and let the first latchStartAddress() call update it
            this.addrMaskHigh = 0x3F;       // card-specific mask for the high (bits 8 and up) of CRTC address registers

            if (nCard < Videox86.CARD.EGA) {
                this.initMemory(data[6], data[8]);
                this.setMemoryAccess(Card.READ.PAIRS | Card.WRITE.PAIRS);
            } else {
                this.addrMaskHigh = 0xFF;
                this.nCRTCRegs = Card.CRTC.EGA.TOTAL_REGS;
                this.asCRTCRegs = DEBUGGER? Card.CRTC.EGA_REGS : [];
                this.initEGA(data[6], nMonitorType);
            }

            let monitorSpecs = Videox86.monitorSpecs[nMonitorType] || Videox86.monitorSpecs[ChipSet.MONITOR.MONO];

            /**
             * nCyclesVertPeriod determines how frequently startVerticalRetrace() is called.  That function
             * snaps the current cycle count in nCyclesVertRetrace.  Then whenever getRetraceBits() is called,
             * it subtracts nCyclesVertRetrace from the current cycle count, and whenever the delta exceeds
             * nCyclesVertPeriod - nCyclesVertActive, vertical retrace has ended.  Similarly, horizontal retrace
             * ends whenever that delta MOD nCyclesHorzPeriod exceeds nCyclesHorzActive.
             */
            let nCyclesDefault = video.cpu.getBaseCyclesPerSecond();
            this.nCyclesHorzPeriod = (nCyclesDefault / monitorSpecs.nHorzPeriodsPerSec)|0;
            this.nCyclesHorzActive = (this.nCyclesHorzPeriod * monitorSpecs.percentHorzActive / 100)|0;
            this.nCyclesVertActive = (this.nCyclesHorzPeriod * monitorSpecs.nHorzPeriodsPerFrame)|0;
            this.nCyclesVertPeriod = (this.nCyclesVertActive / (monitorSpecs.percentVertActive / 100))|0;
            this.nCyclesVertRetrace = (data[7] || 0);
            this.nCountVertRetrace = 0;
        }
    }

    /**
     * initEGA(data)
     *
     * Another one of my frustrations with JSON is that it encodes empty arrays with non-zero lengths as
     * arrays of nulls, which means that any uninitialized register arrays whose elements were all originally
     * undefined come back via the JSON round-trip as *initialized* arrays whose elements are now all null.
     *
     * I'm a bit surprised, because JavaScript purists tell us to always use the '===' operator (eg, use
     * 'aReg[i] === undefined' to determine if an element is initialized), but because of this JSON stupidity,
     * that would require all such tests to become 'aReg[i] === undefined || aReg[i] === null'.  I'm puzzled
     * why the coercion of '==' is considered evil but JSON's coercion of undefined to null is perfectly fine.
     *
     * The simple solution is to change such comparisons to 'aReg[i] == null', because undefined is coerced
     * to null, whereas numeric values are not.
     *
     * [What do I mean by "another" frustration?  Let me talk to you some day about disallowing hex constants,
     * or insisting that property names be quoted, or refusing to allow comments.  I think it's fine for
     * JSON.stringify() to produce output that adheres to rules like that -- although some parameters to control
     * the output would be nice -- but it's completely unnecessary for JSON.parse() to refuse to parse objects
     * that are perfectly valid.]
     *
     * @this {Card}
     * @param {Array|undefined} data
     * @param {number} nMonitorType
     */
    initEGA(data, nMonitorType)
    {
        if (data === undefined) {
            data = [
                /* 0*/  false,
                /* 1*/  0,
                /* 2*/  new Array(Card.ATC.TOTAL_REGS),
                /* 3*/  0,
                /* 4*/  (nMonitorType == ChipSet.MONITOR.MONO? 0: Card.MISC.IO_SELECT),
                /* 5*/  0,
                /* 6*/  0,
                /* 7*/  new Array(Card.SEQ.TOTAL_REGS),
                /* 8*/  0,
                /* 9*/  0,
                /*10*/  0,
                /*11*/  new Array(Card.GRC.TOTAL_REGS),
                /*12*/  0,
                /*13*/  [this.addrBuffer, this.sizeBuffer, this.cbMemory],
                /*14*/  null,
                /**
                 * Card.WRITE.MODE0 by itself is a pretty good default, but if we choose to "randomize" the screen with
                 * text characters prior to starting the machine, defaulting to Card.WRITE.EVENODD is more faithful to how
                 * characters and attributes are typically stored (ie, in planes 0 and 1, respectively).
                 *
                 *      Card.READ.MODE0 | Card.READ.EVENODD | Card.WRITE.MODE0 | Card.WRITE.EVENODD | Card.V2
                 *
                 * Unfortunately, a typical ROM BIOS will almost immediately write to one of the original MDA or CGA mode registers,
                 * changing the default mode, so we may as well initialize the card to byte-pair access.
                 */
                /*15*/  Card.READ.PAIRS | Card.WRITE.PAIRS  | Card.V2,
                /*16*/  0,
                /*17*/  0xffffffff|0,
                /*18*/  0,
                /*19*/  0xffffffff|0,
                /*20*/  0,
                /*21*/  0xffffffff|0,
                /*22*/  0,
                /*23*/  0,
                /*24*/  0,
                /*25*/  0,
                /*26*/  Card.VGA_ENABLE.ENABLED,
                /*27*/  Card.DAC.MASK.DEFAULT,
                /*28*/  0,
                /*29*/  0,
                /*30*/  Card.DAC.STATE.MODE_WRITE,
                /*31*/  new Array(Card.DAC.TOTAL_REGS)
            ];
        }

        this.fATCData   = data[0];
        this.regATCIndx = data[1];
        this.regATCData = data[2];
        this.asATCRegs  = DEBUGGER? Card.ATC.REGS : [];
        this.regStatus0 = data[3];      // aka STATUS0 (not to be confused with this.regStatus, which the EGA refers to as STATUS1)
        this.regMisc    = data[4];
        this.regFeat    = data[5];      // for feature control bits, see Card.FEAT_CTRL.BITS; for feature status bits, see Card.STATUS0.FEAT
        this.regSEQIndx = data[6];
        this.regSEQData = data[7];
        this.asSEQRegs  = DEBUGGER? Card.SEQ.REGS : [];
        this.regGRCPos1 = data[8];
        this.regGRCPos2 = data[9];
        this.regGRCIndx = data[10];
        this.regGRCData = data[11];
        this.asGRCRegs  = DEBUGGER? Card.GRC.REGS : [];
        this.latches    = data[12];

        /**
         * Since we originally neglected to save/restore the card's active video buffer address and length,
         * we're now stashing all that information in data[13].  So if we're presented with an old data entry
         * that contains only the card's memory size, fix it up.
         *
         * TODO: This code just creates the required array; the correct video buffer address and length would
         * still need to be calculated from the current GRC registers; checkMode() knows how to do that, but I'm
         * not prepared to shoehorn in a call to checkMode() here, and potentially create more issues, for an
         * old problem that will eventually disappear anyway.
         */
        let a = data[13];
        if (typeof a == "number") {
            a = [this.addrBuffer, this.sizeBuffer, a];
        }
        this.addrBuffer = a[0];
        this.sizeBuffer = a[1];


        this.initMemory(data[14], this.cbMemory >> 2);

        let nAccess = data[15];
        if (nAccess) {
            if (nAccess & Card.V2) {
                nAccess &= ~Card.V2;
            } else {

                nAccess = Card.V1[nAccess & 0xff00] | Card.V1[nAccess & 0xff];
            }
        }
        this.setMemoryAccess(nAccess);

        /**
         * nReadMapShift must perfectly track how the GRC.READMAP register is programmed, so that Card.READ.MODE0
         * memory read functions read the appropriate plane.  This default is not terribly critical, unless Card.WRITE.MODE0
         * is chosen as our default AND you want the screen randomizer to work.
         */
        this.nReadMapShift  = data[16];

        /**
         * Similarly, nSeqMapMask must perfectly track how the SEQ.MAPMASK register is programmed, so that memory write
         * functions write the appropriate plane(s).  Again, this default is not terribly critical, unless Card.WRITE.MODE0
         * is chosen as our default AND you want the screen randomizer to work.
         */
        this.nSeqMapMask    = data[17];
        this.nDataRotate    = data[18];
        this.nBitMapMask    = data[19];
        this.nSetMapData    = data[20];
        this.nSetMapMask    = data[21];
        this.nSetMapBits    = data[22];
        this.nColorCompare  = data[23];
        this.nColorDontCare = data[24];
        this.offStart       = data[25];     // this is the last CRTC start address latched from CRTC.STARTHI,CRTC.STARTLO

        if (this.nCard == Videox86.CARD.VGA) {
            this.regVGAEnable   = data[26];
            this.regDACMask     = data[27];
            this.regDACAddr     = data[28];
            this.regDACShift    = data[29];
            this.regDACState    = data[30];
            this.regDACData     = data[31];
        }

        /**
         * While every Video memory block maintains its own DIRTY flag, used by the Bus cleanMemory() function to
         * quickly determine if anything changed within a given block, we supplement that information at the Card level
         * in certain memory controller functions that we know are used to modify font data in plane 2.
         *
         * Whenever plane 2 is modified, one of bits 0-7 in bitsDirtyBanks is modified as well, indicating which of
         * the corresponding font "banks" was modified.  The EGA supports only four font banks (0, 2, 4, and 6), while
         * the VGA supports four additional "interleaved" banks (1, 3, 5, and 7).
         *
         * NOTE: Our bank numbers (0-7) should not be confused with EGA INT 10h (AH=11h) "Character Generator Routine"
         * block numbers 0 to 3, which must be multiplied by 2 to obtain the corresponding bank number; VGA block numbers
         * 4 to 7 must also be multiplied by 2 and then reduced by 7 to produce the correct interleaved bank number.
         */
        this.bitsDirtyBanks = 0;
    }

    /**
     * initMemory(data, length)
     *
     * If we're restoring an older MDA or CGA buffer, where 4 bytes were stored in every dword instead of 2, then the
     * final size of adwMemory will be cbMemory >> 2.  Newer MDA and CGA buffers store only 2 bytes in every dword, to
     * make them compatible with their EGA and VGA counterparts, so their final size should be cbMemory >> 1.
     *
     * When we detect the older format, we must convert it to the newer.
     *
     * @this {Card}
     * @param {Array|null} data
     * @param {number} [length]
     */
    initMemory(data, length)
    {
        let cdw = this.cbMemory >> 2;
        this.adwMemory = data;
        if (!this.adwMemory || !this.adwMemory.length) {
            if (!length) length = cdw * 2;
            this.adwMemory = new Array(length);
        }
        else {
            cdw = length || cdw;
            if (this.adwMemory.length < cdw) {
                this.adwMemory = State.decompressEvenOdd(this.adwMemory, cdw);
            }
        }
        if (!length) {
            let adwOld = this.adwMemory;
            let adwNew = new Array(this.adwMemory.length * 2);

            for (let i = 0, j = 0; i < this.adwMemory.length; i++, j += 2) {
                adwNew[j] = adwOld[i] & 0xffff;
                adwNew[j+1] = (adwOld[i] >> 16) & 0xffff;
            }
            this.adwMemory = adwNew;
        } else {

        }
    }

    /**
     * saveCard()
     *
     * @this {Card}
     * @returns {Array}
     */
    saveCard()
    {
        let data = [];
        if (this.nCard !== undefined) {
            data[0] = this.fActive;
            data[1] = this.regMode;
            data[2] = this.regColor;
            data[3] = this.regStatus;
            data[4] = this.regCRTIndx | (this.regCRTPrev << 8);
            data[5] = this.regCRTData;
            data[6] = (this.nCard < Videox86.CARD.EGA? State.compressEvenOdd(this.adwMemory) : this.saveEGA());
            data[7] = this.nCyclesVertRetrace;
            data[8] = this.adwMemory.length;
        }
        return data;
    }

    /**
     * saveEGA()
     *
     * @this {Card}
     * @returns {Array}
     */
    saveEGA()
    {
        let data = [];
        data[0]  = this.fATCData;
        data[1]  = this.regATCIndx;
        data[2]  = this.regATCData;
        data[3]  = this.regStatus0;
        data[4]  = this.regMisc;
        data[5]  = this.regFeat;
        data[6]  = this.regSEQIndx;
        data[7]  = this.regSEQData;
        data[8]  = this.regGRCPos1;
        data[9]  = this.regGRCPos2;
        data[10] = this.regGRCIndx;
        data[11] = this.regGRCData;
        data[12] = this.latches;
        data[13] = [this.addrBuffer, this.sizeBuffer, this.cbMemory];
        data[14] = State.compressEvenOdd(this.adwMemory);
        data[15] = this.nAccess | Card.V2;
        data[16] = this.nReadMapShift;
        data[17] = this.nSeqMapMask;
        data[18] = this.nDataRotate;
        data[19] = this.nBitMapMask;
        data[20] = this.nSetMapData;
        data[21] = this.nSetMapMask;
        data[22] = this.nSetMapBits;
        data[23] = this.nColorCompare;
        data[24] = this.nColorDontCare;
        data[25] = this.offStart;

        if (this.nCard == Videox86.CARD.VGA) {
            data[26] = this.regVGAEnable;
            data[27] = this.regDACMask;
            data[28] = this.regDACAddr;
            data[29] = this.regDACShift;
            data[30] = this.regDACState;
            data[31] = this.regDACData;
        }
        return data;
    }

    /**
     * dumpRegs()
     *
     * Since we don't pre-allocate the register arrays (eg, ATC, CRTC, GRC, etc) on a Card, we can't
     * rely on their array length, so we instead rely on the number of register names supplied in asRegs.
     *
     * @this {Card}
     * @param {string} sName
     * @param {number} iReg
     * @param {Array} [aRegs]
     * @param {Array} [asRegs]
     */
    dumpRegs(sName, iReg, aRegs, asRegs)
    {
        if (DEBUGGER) {
            if (!aRegs) {
                this.dbg.printf("%s: %02X\n", sName, iReg);
                return;
            }
            let i, s = "";
            let nRegs = (asRegs? asRegs.length : aRegs.length);
            for (i = 0; i < nRegs; i++) {
                /**
                 * In the case of the CRTC, we call the helper function getCRTCReg() to automatically concatenate
                 * the extended bits of certain registers, so that we don't have to "mentally" concatenate them.
                 */
                let reg = (aRegs === this.regCRTData)? this.getCRTCReg(i) : aRegs[i];
                let sRegName = (asRegs? asRegs[i] : sName.substr(1) + StrLib.toDec(i, 3));
                s += StrLib.sprintf("%s[%02X]: %-12s %*X%s (%*d)\n", sName, i, sRegName, (asRegs? 4 : 6), reg, (i === iReg? '*' : ' '), (asRegs? 4 : 6), reg);
            }
            this.dbg.printf("%s", s);
        }
    }

    /**
     * dumpVideoCard()
     *
     * @this {Card}
     */
    dumpVideoCard()
    {
        if (DEBUGGER) {
            /**
             * Start with registers that are common to all cards....
             */
            this.dumpRegs("CRTC", this.regCRTIndx, this.regCRTData, this.asCRTCRegs);

            if (this.nCard >= Videox86.CARD.EGA) {
                this.dumpRegs(" GRC", this.regGRCIndx, this.regGRCData, this.asGRCRegs);
                this.dumpRegs(" SEQ", this.regSEQIndx, this.regSEQData, this.asSEQRegs);
                this.dumpRegs(" ATC", this.regATCIndx, this.regATCData, this.asATCRegs);
                this.dumpRegs(" ATCINDX", this.regATCIndx);
                this.dbg.printf(" ATCDATA: %b\n", this.fATCData);
                this.dumpRegs("    FEAT", this.regFeat);
                this.dumpRegs("    MISC", this.regMisc);
                this.dumpRegs(" STATUS0", this.regStatus0);
                /**
                 * There are few more EGA regs we could dump, like GRCPos1, GRCPos2, but does anyone care?
                 */
                if (this.nCard == Videox86.CARD.VGA) {
                    this.dumpRegs(" DAC", this.regDACAddr, this.regDACData);
                }
            }

            /**
             * TODO: This simply dumps the last value read from the STATUS1 register, not necessarily
             * its current state; consider dumping getRetraceBits() instead of (or in addition to) this.
             */
            this.dumpRegs(" STATUS1", this.regStatus);

            if (this.nCard == Videox86.CARD.MDA || this.nCard == Videox86.CARD.CGA) {
                this.dumpRegs(" MODEREG", this.regMode);
            }

            if (this.nCard == Videox86.CARD.CGA) {
                this.dumpRegs("   COLOR", this.regColor);
            }

            if (this.nCard >= Videox86.CARD.EGA) {
                this.dbg.printf(" LATCHES: %0X\n", this.latches);
                this.dbg.printf("  ACCESS: %04X\n",  this.nAccess);
                this.dbg.printf("  PLANE2: %02X\n", this.bitsDirtyBanks);
                this.dbg.printf("Use 'd video [addr]' to dump video memory\n");
                /**
                 * There are few more EGA regs we could dump, like GRCPos1, GRCPos2, but does anyone care?
                 */
            }
        }
    }

    /**
     * dumpVideoBuffer(asArgs)
     *
     * Rather than requiring the first parameter to ALWAYS be a frame buffer address OR a frame buffer
     * offset, we'll just make a guess as to what the user intended and support BOTH; basically, if the
     * value is less than the frame buffer address, we'll assume it's an offset.
     *
     * Also, we allow some special options to be encoded in asArgs: 'l' followed by a number means
     * print that many rows of data.  'n' followed by a number (1-8) means print only that number of
     * memory locations per row, and then adjust the starting address of the next row by the number
     * of bytes per row (or whatever is specified by the 'w' option) so that the dump reflects a
     * rectangular chunk of video data.  Finally, if asArgs contains 'p' followed by a number (0-3),
     * we display only the bits from that plane for each memory location, in binary instead of hex.
     *
     * For example, assuming a standard VGA frame buffer with 640x480 pixels across 38400 (0x9600) memory
     * locations, the following command will dump a vertical swath of bits from plane 0 that is 32 (0x20)
     * rows tall and 8 columns wide, from roughly the center of the screen (0x4B00 + 0x28 - 2 = 0x4B26).
     *
     *      d video 4b26 l20 n8 p0
     *
     * Subsequent commands that omit a starting address or offset will continue where the last dump
     * left off; eg:
     *
     *      d video n8 p0
     *
     * To dump a chunk of off-screen memory starting at 0x9600, where the Windows VGA driver typically
     * stores a copy of the video memory containing the current mouse pointer:
     *
     *      d video 9600 l20 n5 w5 p0
     *
     * Alternatively, you could use decimal values:
     *
     *      d video 9600 l32. n5. w5. p0.
     *
     * NOTE: If these commands look suspiciously like weird Hayes modem command strings, trust me,
     * that is ENTIRELY coincidental (but mildly amusing).
     *
     * TODO: Make these options more general-purpose (it currently assumes a conventional VGA planar layout).
     *
     * @this {Card}
     * @param {Array.<string>} asArgs (all numeric arguments default to base 16 unless otherwise specified)
     */
    dumpVideoBuffer(asArgs)
    {
        if (DEBUGGER) {
            if (!this.adwMemory) {
                this.dbg.printf("no buffer\n");
                return;
            }

            let i, j, idw, fColAdjust = false;
            let l = 8, n = 8, p = -1, w = this.video.nCols >> 3;

            for (i = 0; i < asArgs.length; i++) {

                let s = asArgs[i];
                if (!i) {
                    idw = StrLib.parseInt(s, 16);
                    continue;
                }

                let ch = s.charAt(0);
                j = StrLib.parseInt(s.substr(1), 16);

                switch(ch) {
                case 'l':
                    l = j;
                    break;
                case 'n':
                    if (j >= 1 && j <= 8) {
                        n = j;
                        fColAdjust = true;
                    }
                    break;
                case 'p':
                    if (j >= 0 && j <= 3) p = j;
                    break;
                case 'w':
                    if (j < w) w = j;
                    break;
                default:
                    this.dbg.printf("unrecognized argument: %s\n", s);
                    break;
                }
            }

            if (idw === undefined) {
                idw = this.prevDump || 0;
            } else if (idw >= this.addrBuffer) {
                idw -= this.addrBuffer;
            }

            let sDump = "";
            for (i = 0; i < l; i++) {
                let sData = StrLib.toHex(this.addrBuffer + idw) + ":";
                for (j = 0; j < n && idw < this.adwMemory.length; j++) {
                    let dw = this.adwMemory[idw++];
                    sData += ' ' + ((p < 0)? StrLib.toHex(dw, 8) : StrLib.toBin((dw >> (p << 3)), 8));
                }
                if (fColAdjust) idw += w - n;
                sDump += sData + "\n";
            }

            if (sDump) this.dbg.print(sDump);
            this.prevDump = idw;
        }
    }

    /**
     * getMemoryBuffer(addr)
     *
     * If we passed a controller object (ie, this card) to addMemory(), then each allocated Memory block
     * will call this function to obtain a buffer.
     *
     * @this {Card}
     * @param {number} addr
     * @returns {Array} containing the buffer (and the offset within that buffer that corresponds to the requested block)
     */
    getMemoryBuffer(addr)
    {
        return [this.adwMemory, addr - this.addrBuffer];
    }

    /**
     * getMemoryAccess()
     *
     * WARNING: This is a public method, whereas most Card methods are private to the Video component;
     * because a Card also acts as a Memory controller, it must provide getMemoryAccess() to the Memory component.
     *
     * Return the last set of memory access functions recorded by setMemoryAccess().
     *
     * @this {Card}
     * @returns {Array.<function()>}
     */
    getMemoryAccess()
    {
        return this.afnAccess;
    }

    /**
     * setMemoryAccess(nAccess)
     *
     * This transforms the memory access value that getCardAccess() returns into the best available set of
     * memory access functions, which are then returned via getMemoryAccess() to any memory blocks we allocate
     * or modify.
     *
     * @this {Card}
     * @param {number|undefined} nAccess
     */
    setMemoryAccess(nAccess)
    {
        if (nAccess != null && nAccess != this.nAccess) {

            let nReadAccess = nAccess & Card.READ.MASK;
            let fnReadByte = Card.FUNCS[nReadAccess];
            if (!fnReadByte) {
                if (DEBUG && this.dbg) {
                    this.dbg.printf(MESSAGE.VIDEO, "Card.setMemoryAccess(%#06x): missing readByte handler", nAccess);
                    /**
                     * I've taken a look, and the cases I've seen so far stem from the order in which the IBM VGA BIOS
                     * reprograms registers during a mode change: it reprograms the Sequencer registers BEFORE the Graphics
                     * Controller registers, so if GRC.MODE was set to READ.MODE1 prior to the mode change and the new mode
                     * clears SEQ.MEMMODE.SEQUENTIAL, we will briefly be in an "odd" (unsupported) state.
                     *
                     * This didn't used to occur when we relied on the GRC.MODE register instead of the SEQ.MEMMODE for
                     * determining the EVENODD state.  But, as explained in getCardAccess(), we've run into inconsistencies in
                     * how GRC.MODE.EVENODD is programmed, so we must live with this warning.
                     *
                     * The ultimate solution is to provide a EVENODD handler for READ.MODE1, since there is the remote
                     * possibility of third-party software that relies on that "odd" combination.
                     *
                     *      this.dbg.stopCPU();     // let's take a look
                     */
                }
                if (nReadAccess & Card.READ.EVENODD) {
                    fnReadByte = Card.FUNCS[Card.READ.EVENODD];
                }
            }
            let nWriteAccess = nAccess & Card.WRITE.MASK;
            let fnWriteByte = Card.FUNCS[nWriteAccess];
            if (!fnWriteByte) {
                if (DEBUG && this.dbg) {
                    this.dbg.printf(MESSAGE.VIDEO, "Card.setMemoryAccess(%#06x): missing writeByte handler", nAccess);
                    /**
                     * I've taken a look, and the cases I've seen so far stem from the order in which the IBM VGA BIOS
                     * reprograms registers during a mode change: it reprograms the Sequencer registers BEFORE the Graphics
                     * Controller registers, so if GRC.MODE was set to WRITE.MODE2 prior to the mode change and the new mode
                     * clears SEQ.MEMMODE.SEQUENTIAL, we will briefly be in an "odd" (unsupported) state.
                     *
                     * This didn't used to occur when we relied on the GRC.MODE register instead of the SEQ.MEMMODE for
                     * determining the EVENODD state.  But, as explained in getCardAccess(), we've run into inconsistencies in
                     * how GRC.MODE.EVENODD is programmed, so we must live with this warning.
                     *
                     * The ultimate solution is to provide EVENODD handlers for all modes other than WRITE.MODE0, since there
                     * is the remote possibility of third-party software that relies on one of those "odd" combinations.
                     *
                     *      this.dbg.stopCPU();     // let's take a look
                     */
                }
                if (nWriteAccess & Card.WRITE.EVENODD) {
                    fnWriteByte = Card.FUNCS[Card.WRITE.EVENODD];
                }
            }
            if (!this.afnAccess) this.afnAccess = new Array(6);
            this.afnAccess[0] = fnReadByte;
            this.afnAccess[1] = fnWriteByte;
            this.nAccess = nAccess;
        }
    }

    /**
     * getCRTCReg()
     *
     * @this {Card}
     * @param {number} iReg
     * @returns {number}
     */
    getCRTCReg(iReg)
    {
        let reg = this.regCRTData[iReg];
        if (reg != null && this.nCard >= Videox86.CARD.EGA) {
            let bOverflowBit8 = 0, bOverflowBit9 = 0, bMaxScanBit9 = 0;
            switch(iReg) {
            case Card.CRTC.EGA.VTOTAL:              // 0x06
                bOverflowBit8 = Card.CRTC.EGA.OVERFLOW.VTOTAL_BIT8;         // 0x01
                if (this.nCard == Videox86.CARD.VGA) bOverflowBit9 = Card.CRTC.EGA.OVERFLOW.VTOTAL_BIT9;
                break;
            case Card.CRTC.EGA.CURSCAN:             // 0x0A
                if (this.nCard == Videox86.CARD.EGA) bOverflowBit8 = Card.CRTC.EGA.OVERFLOW.CURSCAN_BIT8;
                break;
            case Card.CRTC.EGA.VRSTART:             // 0x10
                bOverflowBit8 = Card.CRTC.EGA.OVERFLOW.VRSTART_BIT8;        // 0x04
                if (this.nCard == Videox86.CARD.VGA) bOverflowBit9 = Card.CRTC.EGA.OVERFLOW.VRSTART_BIT9;
                break;
            case Card.CRTC.EGA.VDEND:               // 0x12
                bOverflowBit8 = Card.CRTC.EGA.OVERFLOW.VDEND_BIT8;          // 0x02
                if (this.nCard == Videox86.CARD.VGA) bOverflowBit9 = Card.CRTC.EGA.OVERFLOW.VDEND_BIT9;
                break;
            case Card.CRTC.EGA.VBSTART:             // 0x15
                bOverflowBit8 = Card.CRTC.EGA.OVERFLOW.VBSTART_BIT8;        // 0x08
                if (this.nCard == Videox86.CARD.VGA) bMaxScanBit9 = Card.CRTC.EGA.MAXSCAN.VBSTART_BIT9;
                break;
            case Card.CRTC.EGA.LINECOMP:            // 0x18
                bOverflowBit8 = Card.CRTC.EGA.OVERFLOW.LINECOMP_BIT8;       // 0x10
                if (this.nCard == Videox86.CARD.VGA) bMaxScanBit9 = Card.CRTC.EGA.MAXSCAN.LINECOMP_BIT9;
                break;
            }
            if (bOverflowBit8) {
                reg |= ((this.regCRTData[Card.CRTC.EGA.OVERFLOW.INDX] & bOverflowBit8)? 0x100 : 0);
                reg |= ((this.regCRTData[Card.CRTC.EGA.OVERFLOW.INDX] & bOverflowBit9)? 0x200 : 0);
                reg |= ((this.regCRTData[Card.CRTC.EGA.MAXSCAN.INDX] & bMaxScanBit9)? 0x200 : 0);
            }
        }
        return reg;
    }

    /**
     * readBytePairs(off, addr)
     *
     * Used for MDA/CGA byte-pair access (ie, pairs of bytes stored in a single dword).
     *
     * Externally, this makes the buffer look like a linear series of byte pairs, perfect for emulating MDA and CGA
     * character/attribute text modes, while internally, it looks similar to an EvenOdd arrangement, except that odd
     * dwords not skipped (ie, wasted).  This similarity makes life simpler for updateScreenText().
     *
     * @this {Memoryx86}
     * @param {number} off
     * @param {number} [addr]
     * @returns {number}
     */
    static readBytePairs(off, addr)
    {
        off += this.offset;
        return ((this.adw[off >> 1] >>> ((off & 0x1) << 3)) & 0xff);
    }

    /**
     * readByteMode0(off, addr)
     *
     * @this {Memoryx86}
     * @param {number} off
     * @param {number} [addr]
     * @returns {number}
     */
    static readByteMode0(off, addr)
    {
        off += this.offset;
        let dw = this.controller.latches = this.adw[off];
        return (dw >> this.controller.nReadMapShift) & 0xff;
    }

    /**
     * readByteMode0Chain4(off, addr)
     *
     * See writeByteMode0Chain4 for a description of how writes are distributed across planes.
     *
     * @this {Memoryx86}
     * @param {number} off
     * @param {number} [addr]
     * @returns {number}
     */
    static readByteMode0Chain4(off, addr)
    {
        let idw = (off & ~0x3) + this.offset;
        let shift = (off & 0x3) << 3;
        return ((this.controller.latches = this.adw[idw]) >> shift) & 0xff;
    }

    /**
     * readByteMode0EvenOdd(off, addr)
     *
     * @this {Memoryx86}
     * @param {number} off
     * @param {number} [addr]
     * @returns {number}
     */
    static readByteMode0EvenOdd(off, addr)
    {
        /**
         * TODO: As discussed in getCardAccess(), we need to run some tests on real EGA/VGA hardware to determine
         * exactly what gets latched (ie, from which address) when EVENODD is in effect.  Whatever we learn may also
         * dictate a special EVENODD function for READ.MODE1 as well.
         */
        let idw = (off += this.offset) & ~0x1;
        let dw = this.controller.latches = this.adw[idw];
        return (!(off & 1)? dw : (dw >> 8)) & 0xff;
    }

    /**
     * readByteMode1(off, addr)
     *
     * This mode requires us to step through each of the 8 sets of 4 bits in the specified DWORD of video memory,
     * returning a 1 wherever all 4 match the Color Compare (COLORCOMP) Register and a 0 otherwise.  An added wrinkle
     * is that the Color Don't Care (COLORDC) Register can specify that any/all/none of the 4 bits must be ignored.
     *
     * We perform the comparison from most to least significant bit, because that matches how the nColorCompare and
     * nColorDontCare masks are initialized; we could have gone either way, but this is more consistent with the rest
     * of the component (eg, pixels are drawn across the screen from left to right, starting with the most significant
     * bit of each byte).
     *
     * Also note that, while not well-documented, this mode also affects the internal latches, so we make sure those
     * are updated as well.
     *
     * @this {Memoryx86}
     * @param {number} off
     * @param {number} [addr]
     * @returns {number}
     */
    static readByteMode1(off, addr)
    {
        let card = this.controller;
        let dw = card.latches = this.adw[off + this.offset];
        /**
         * Minor optimization: we could pre-mask nColorCompare with nColorDontCare, whenever either register
         * is updated, but that's a drop in the bucket compared to all the other work this function must do.
         */
        let mask = card.nColorDontCare;
        let color = card.nColorCompare & mask;
        let b = 0, bit = 0x80;
        while (bit) {
            if ((dw & mask) == color) b |= bit;
            color >>>= 1;  mask >>>= 1;  bit >>= 1;
        }
        return b;
    }

    /**
     * writeBytePairs(off, b, addr)
     *
     * Used for MDA/CGA byte-pair access (ie, pairs of bytes stored in a single dword).
     *
     * Externally, this makes the buffer look like a linear series of byte pairs, perfect for emulating MDA and CGA
     * character/attribute text modes, while internally, it looks similar to an EvenOdd arrangement, except that odd
     * dwords not skipped (ie, wasted).  This similarity makes life simpler for updateScreenText().
     *
     * @this {Memoryx86}
     * @param {number} off
     * @param {number} b (which should already be pre-masked to 8 bits; see cpu.setByte())
     * @param {number} [addr]
     */
    static writeBytePairs(off, b, addr)
    {
        off += this.offset;
        let idw = off >> 1;
        let nShift = (off & 0x1) << 3;
        let dw = (this.adw[idw] & ~(0xff << nShift)) | (b << nShift);
        if (this.adw[idw] != dw) {
            this.adw[idw] = dw;
            this.flags |= Memoryx86.FLAGS.DIRTY;
        }
    }

    /**
     * writeByteMode0(off, b, addr)
     *
     * Supporting Set/Reset means that for every plane for which Set/Reset is enabled, we must
     * replace the corresponding byte in dw with a byte of zeros or ones.  This is accomplished with
     * nSetMapMask, nSetMapData, and nSetMapBits.  nSetMapMask is the inverse of the ESRESET bits,
     * because we use it to mask the processor data, nSetMapData records the desired SRESET bits,
     * and nSetMapBits contains the bits to replace those that we masked in the processor data.
     *
     * We could have done this:
     *
     *      dw = (dw & card.nSetMapMask) | (card.nSetMapData & ~card.nSetMapMask)
     *
     * but by maintaining nSetMapBits equal to (nSetMapData & ~nSetMapMask), we are able to make the
     * writes slightly more efficient.
     *
     * @this {Memoryx86}
     * @param {number} off
     * @param {number} b (which should already be pre-masked to 8 bits; see cpu.setByte())
     * @param {number} [addr]
     */
    static writeByteMode0(off, b, addr)
    {
        let card = this.controller;
        let idw = off + this.offset;
        let dw = b | (b << 8) | (b << 16) | (b << 24);
        dw = (dw & card.nSetMapMask) | card.nSetMapBits;
        dw = (dw & card.nBitMapMask) | (card.latches & ~card.nBitMapMask);
        dw = (dw & card.nSeqMapMask) | (this.adw[idw] & ~card.nSeqMapMask);
        let delta = (this.adw[idw] ^ dw);
        if (delta) {
            this.adw[idw] = dw;
            this.flags |= Memoryx86.FLAGS.DIRTY;
            // card.bitsDirtyPlanes |= delta;       // we no longer track dirty planes, just dirty font banks
            if (delta & 0x00ff0000) {               // if any plane 2 bits were modified, mark the appropriate font bank dirty
                let bitDirtyBank = (1 << ((idw >> 13) & 7));
                if (!(card.bitsDirtyBanks & bitDirtyBank)) {
                    card.bitsDirtyBanks |= bitDirtyBank;
                    if (DEBUG) card.video.printf(MESSAGE.VIDEO, "writeByteMode0(%#010X): modified font bank %#04X\n", addr, bitDirtyBank);
                }
            }
        }
        if (DEBUG) card.video.printf(MESSAGE.VIDEO + MESSAGE.MEM, "writeByteMode0(%#10X): %#04X -> %#10X\n", addr, b, dw);
    }

    /**
     * writeByteMode0Chain4(off, b, addr)
     *
     * This is how we distribute writes of 0xff across the address space to the planes (assuming that all
     * planes are enabled by the Sequencer's MAPMASK register):
     *
     *      off     idw     adw[idw]
     *      ------  ------  ----------
     *      0x0000: 0x0000  0x000000ff
     *      0x0001: 0x0000  0x0000ff00
     *      0x0002: 0x0000  0x00ff0000
     *      0x0003: 0x0000  0xff000000
     *      0x0004: 0x0004  0x000000ff
     *      0x0005: 0x0004  0x0000ff00
     *      0x0006: 0x0004  0x00ff0000
     *      0x0007: 0x0004  0xff000000
     *      ...
     *
     * Some VGA emulations calculate the video buffer index (idw) by shifting the offset (off) right 2 bits,
     * instead of simply masking off the low 2 bits, as we do here.  That would be a more "pleasing" arrangement,
     * because we would be using sequential video buffer locations, instead of multiples of 4, and would match how
     * pixels are stored in "Mode X".  However, I don't think that's how CHAIN4 modes operate (although that still
     * needs to be confirmed, because multiple sources conflict on this point).  TODO: Confirm CHAIN4 operation on
     * actual VGA hardware, including the extent to which ALU and other writeByteMode0() functionality needs to
     * be folded into this.
     *
     * Address decoding may not matter that much, as long as both the read and write CHAIN4 functions decode their
     * addresses in exactly the same manner; we'd only get into trouble with software that "unchained" or otherwise
     * reconfigured the planes and then made assumptions about existing data in the video buffer.
     *
     * @this {Memoryx86}
     * @param {number} off
     * @param {number} b (which should already be pre-masked to 8 bits; see cpu.setByte())
     * @param {number} [addr]
     */
    static writeByteMode0Chain4(off, b, addr)
    {
        let card = this.controller;
        let idw = (off & ~0x3) + this.offset;
        let shift = (off & 0x3) << 3;
        /**
         * TODO: Consider adding a separate "unmasked" version of this CHAIN4 write function when nSeqMapMask is -1
         * (or removing nSeqMapMask from the equation altogether, if CHAIN4 is never used with any planes disabled).
         */
        let dw = ((b << shift) & card.nSeqMapMask) | (this.adw[idw] & ~((0xff << shift) & card.nSeqMapMask));
        if (this.adw[idw] != dw) {
            this.adw[idw] = dw;
            this.flags |= Memoryx86.FLAGS.DIRTY;
        }
        if (DEBUG) card.video.printf(MESSAGE.MEM + MESSAGE.VIDEO, "writeByteMode0Chain4(%#010X): %#04X -> %#010X\n", addr, b, dw);
    }

    /**
     * writeByteMode0EvenOdd(off, b, addr)
     *
     * @this {Memoryx86}
     * @param {number} off
     * @param {number} b (which should already be pre-masked to 8 bits; see cpu.setByte())
     * @param {number} [addr]
     */
    static writeByteMode0EvenOdd(off, b, addr)
    {
        let card = this.controller;
        let idw = (off += this.offset) & ~0x1;
        let dw = b | (b << 8) | (b << 16) | (b << 24);
        /**
         * When even/odd addressing is enabled, nSeqMapMask must be cleared for planes 1
         * and 3 if the address is even, and cleared for planes 0 and 2 if the address is odd.
         */
        dw = (dw & card.nBitMapMask) | (card.latches & ~card.nBitMapMask);
        let maskMaps = card.nSeqMapMask & (idw == off? 0x00ff00ff : (0xff00ff00|0));
        dw = (dw & maskMaps) | (this.adw[idw] & ~maskMaps);
        if (this.adw[idw] != dw) {
            this.adw[idw] = dw;
            this.flags |= Memoryx86.FLAGS.DIRTY;
        }
        if (DEBUG) card.video.printf(MESSAGE.MEM + MESSAGE.VIDEO, "writeByteMode0EvenOdd(%#010X): %#04X -> %#010X\n", addr, b, dw);
    }

    /**
     * writeByteMode0Rot(off, b, addr)
     *
     * @this {Memoryx86}
     * @param {number} off
     * @param {number} b (which should already be pre-masked to 8 bits; see cpu.setByte())
     * @param {number} [addr]
     */
    static writeByteMode0Rot(off, b, addr)
    {
        let card = this.controller;
        let idw = off + this.offset;
        b = ((b >> card.nDataRotate) | (b << (8 - card.nDataRotate)) & 0xff);
        let dw = b | (b << 8) | (b << 16) | (b << 24);
        dw = (dw & card.nSetMapMask) | card.nSetMapBits;
        dw = (dw & card.nBitMapMask) | (card.latches & ~card.nBitMapMask);
        dw = (dw & card.nSeqMapMask) | (this.adw[idw] & ~card.nSeqMapMask);
        if (this.adw[idw] != dw) {
            this.adw[idw] = dw;
            this.flags |= Memoryx86.FLAGS.DIRTY;
        }
        if (DEBUG) card.video.printf(MESSAGE.MEM + MESSAGE.VIDEO, "writeByteMode0Rot(%#010X): %#04X -> %#010X\n", addr, b, dw);
    }

    /**
     * writeByteMode0And(off, b, addr)
     *
     * @this {Memoryx86}
     * @param {number} off
     * @param {number} b (which should already be pre-masked to 8 bits; see cpu.setByte())
     * @param {number} [addr]
     */
    static writeByteMode0And(off, b, addr)
    {
        let card = this.controller;
        let idw = off + this.offset;
        b = ((b >> card.nDataRotate) | (b << (8 - card.nDataRotate)) & 0xff);
        let dw = b | (b << 8) | (b << 16) | (b << 24);
        dw = (dw & card.nSetMapMask) | card.nSetMapBits;
        dw &= card.latches;
        dw = (dw & card.nBitMapMask) | (card.latches & ~card.nBitMapMask);
        dw = (dw & card.nSeqMapMask) | (this.adw[idw] & ~card.nSeqMapMask);
        if (this.adw[idw] != dw) {
            this.adw[idw] = dw;
            this.flags |= Memoryx86.FLAGS.DIRTY;
        }
        if (DEBUG) card.video.printf(MESSAGE.MEM + MESSAGE.VIDEO, "writeByteMode0And(%#010X): %#04X -> %#010X\n", addr, b, dw);
    }

    /**
     * writeByteMode0Or(off, b, addr)
     *
     * @this {Memoryx86}
     * @param {number} off
     * @param {number} b (which should already be pre-masked to 8 bits; see cpu.setByte())
     * @param {number} [addr]
     */
    static writeByteMode0Or(off, b, addr)
    {
        let card = this.controller;
        let idw = off + this.offset;
        b = ((b >> card.nDataRotate) | (b << (8 - card.nDataRotate)) & 0xff);
        let dw = b | (b << 8) | (b << 16) | (b << 24);
        dw = (dw & card.nSetMapMask) | card.nSetMapBits;
        dw |= card.latches;
        dw = (dw & card.nBitMapMask) | (card.latches & ~card.nBitMapMask);
        dw = (dw & card.nSeqMapMask) | (this.adw[idw] & ~card.nSeqMapMask);
        if (this.adw[idw] != dw) {
            this.adw[idw] = dw;
            this.flags |= Memoryx86.FLAGS.DIRTY;
        }
        if (DEBUG) card.video.printf(MESSAGE.MEM + MESSAGE.VIDEO, "writeByteMode0Or(%#010X): %#04X -> %#010X\n", addr, b, dw);
    }

    /**
     * writeByteMode0Xor(off, b, addr)
     *
     * @this {Memoryx86}
     * @param {number} off
     * @param {number} b (which should already be pre-masked to 8 bits; see cpu.setByte())
     * @param {number} [addr]
     */
    static writeByteMode0Xor(off, b, addr)
    {
        let card = this.controller;
        let idw = off + this.offset;
        b = ((b >> card.nDataRotate) | (b << (8 - card.nDataRotate)) & 0xff);
        let dw = b | (b << 8) | (b << 16) | (b << 24);
        dw = (dw & card.nSetMapMask) | card.nSetMapBits;
        dw ^= card.latches;
        dw = (dw & card.nBitMapMask) | (card.latches & ~card.nBitMapMask);
        dw = (dw & card.nSeqMapMask) | (this.adw[idw] & ~card.nSeqMapMask);
        if (this.adw[idw] != dw) {
            this.adw[idw] = dw;
            this.flags |= Memoryx86.FLAGS.DIRTY;
        }
        if (DEBUG) card.video.printf(MESSAGE.MEM + MESSAGE.VIDEO, "writeByteMode0Xor(%#010X): %#04X -> %#010X\n", addr, b, dw);
    }

    /**
     * writeByteMode1(off, b, addr)
     *
     * @this {Memoryx86}
     * @param {number} off
     * @param {number} b (ignored; the EGA latches provide the source data)
     * @param {number} [addr]
     */
    static writeByteMode1(off, b, addr)
    {
        let card = this.controller;
        let idw = off + this.offset;
        let dw = (this.adw[idw] & ~card.nSeqMapMask) | (card.latches & card.nSeqMapMask);
        if (this.adw[idw] != dw) {
            this.adw[idw] = dw;
            this.flags |= Memoryx86.FLAGS.DIRTY;
        }
        if (DEBUG) card.video.printf(MESSAGE.MEM + MESSAGE.VIDEO, "writeByteMode1(%#010X): %#010X\n", addr, dw);
    }

    /**
     * writeByteMode1EvenOdd(off, b, addr)
     *
     * @this {Memoryx86}
     * @param {number} off
     * @param {number} b (ignored; the EGA latches provide the source data)
     * @param {number} [addr]
     */
    static writeByteMode1EvenOdd(off, b, addr)
    {
        /**
         * When even/odd addressing is enabled, nSeqMapMask must be cleared for planes 1 and 3 if the
         * address is even, and cleared for planes 0 and 2 if the address is odd.
         *
         * TODO: As discussed in getCardAccess(), we need to run some tests on real EGA/VGA hardware to
         * determine exactly where latches are written (ie, to which address) when EVENODD is in effect.
         */
        let card = this.controller;
        let idw = (off += this.offset) & ~0x1;
        let maskMaps = card.nSeqMapMask & (idw == off? 0x00ff00ff : (0xff00ff00|0));
        let dw = (this.adw[idw] & ~maskMaps) | (card.latches & maskMaps);
        if (this.adw[idw] != dw) {
            this.adw[idw] = dw;
            this.flags |= Memoryx86.FLAGS.DIRTY;
        }
        if (DEBUG) card.video.printf(MESSAGE.MEM + MESSAGE.VIDEO, "writeByteMode1EvenOdd(%#010X): %#010X\n", addr, dw);
    }

    /**
     * writeByteMode2(off, b, addr)
     *
     * @this {Memoryx86}
     * @param {number} off
     * @param {number} b (which should already be pre-masked to 8 bits; see cpu.setByte())
     * @param {number} [addr]
     */
    static writeByteMode2(off, b, addr)
    {
        let card = this.controller;
        let idw = off + this.offset;
        let dw = Videox86.aEGAByteToDW[b & 0xf];
        dw = (dw & card.nBitMapMask) | (card.latches & ~card.nBitMapMask);
        dw = (dw & card.nSeqMapMask) | (this.adw[idw] & ~card.nSeqMapMask);
        if (this.adw[idw] != dw) {
            this.adw[idw] = dw;
            this.flags |= Memoryx86.FLAGS.DIRTY;
        }
        if (DEBUG) card.video.printf(MESSAGE.MEM + MESSAGE.VIDEO, "writeByteMode2(%#010X): %#04X -> %#010X\n", addr, b, dw);
    }

    /**
     * writeByteMode2And(off, b, addr)
     *
     * @this {Memoryx86}
     * @param {number} off
     * @param {number} b (which should already be pre-masked to 8 bits; see cpu.setByte())
     * @param {number} [addr]
     */
    static writeByteMode2And(off, b, addr)
    {
        let card = this.controller;
        let idw = off + this.offset;
        let dw = Videox86.aEGAByteToDW[b & 0xf];
        dw &= card.latches;
        dw = (dw & card.nBitMapMask) | (card.latches & ~card.nBitMapMask);
        dw = (dw & card.nSeqMapMask) | (this.adw[idw] & ~card.nSeqMapMask);
        if (this.adw[idw] != dw) {
            this.adw[idw] = dw;
            this.flags |= Memoryx86.FLAGS.DIRTY;
        }
        if (DEBUG) card.video.printf(MESSAGE.MEM + MESSAGE.VIDEO, "writeByteMode2And(%#010X): %#04X -> %#010X\n", addr, b, dw);
    }

    /**
     * writeByteMode2Or(off, b, addr)
     *
     * @this {Memoryx86}
     * @param {number} off
     * @param {number} b (which should already be pre-masked to 8 bits; see cpu.setByte())
     * @param {number} [addr]
     */
    static writeByteMode2Or(off, b, addr)
    {
        let card = this.controller;
        let idw = off + this.offset;
        let dw = Videox86.aEGAByteToDW[b & 0xf];
        dw |= card.latches;
        dw = (dw & card.nBitMapMask) | (card.latches & ~card.nBitMapMask);
        dw = (dw & card.nSeqMapMask) | (this.adw[idw] & ~card.nSeqMapMask);
        if (this.adw[idw] != dw) {
            this.adw[idw] = dw;
            this.flags |= Memoryx86.FLAGS.DIRTY;
        }
        if (DEBUG) card.video.printf(MESSAGE.MEM + MESSAGE.VIDEO, "writeByteMode2Or(%#010X): %#04X -> %#010X\n", addr, b, dw);
    }

    /**
     * writeByteMode2Xor(off, b, addr)
     *
     * @this {Memoryx86}
     * @param {number} off
     * @param {number} b (which should already be pre-masked to 8 bits; see cpu.setByte())
     * @param {number} [addr]
     */
    static writeByteMode2Xor(off, b, addr)
    {
        let card = this.controller;
        let idw = off + this.offset;
        let dw = Videox86.aEGAByteToDW[b & 0xf];
        dw ^= card.latches;
        dw = (dw & card.nBitMapMask) | (card.latches & ~card.nBitMapMask);
        dw = (dw & card.nSeqMapMask) | (this.adw[idw] & ~card.nSeqMapMask);
        if (this.adw[idw] != dw) {
            this.adw[idw] = dw;
            this.flags |= Memoryx86.FLAGS.DIRTY;
        }
        if (DEBUG) card.video.printf(MESSAGE.MEM + MESSAGE.VIDEO, "writeByteMode2Xor(%#010X): %#04X -> %#010X\n", addr, b, dw);
    }

    /**
     * writeByteMode3(off, b, addr)
     *
     * In MODE3, Set/Reset is always enabled, so the ESRESET bits (and therefore nSetMapMask and nSetMapBits)
     * are ignored; we look only at the SRESET bits, which are stored in nSetMapData.
     *
     * Unlike MODE0, we currently have no non-rotate function for MODE3.  If performance dictates, we can add one;
     * ditto for other features like the Sequencer's MAPMASK register (nSeqMapMask).
     *
     * @this {Memoryx86}
     * @param {number} off
     * @param {number} b (which should already be pre-masked to 8 bits; see cpu.setByte())
     * @param {number} [addr]
     */
    static writeByteMode3(off, b, addr)
    {
        let card = this.controller;
        let idw = off + this.offset;
        b = ((b >> card.nDataRotate) | (b << (8 - card.nDataRotate)) & 0xff);
        let dw = b | (b << 8) | (b << 16) | (b << 24);
        let dwMask = (dw & card.nBitMapMask);
        dw = (card.nSetMapData & dwMask) | (card.latches & ~dwMask);
        dw = (dw & card.nSeqMapMask) | (this.adw[idw] & ~card.nSeqMapMask);
        if (this.adw[idw] != dw) {
            this.adw[idw] = dw;
            this.flags |= Memoryx86.FLAGS.DIRTY;
        }
        if (DEBUG) card.video.printf(MESSAGE.MEM + MESSAGE.VIDEO, "writeByteMode3(%#010X): %#04X -> %#010X\n", addr, b, dw);
    }

    /**
     * Values returned by getCardAccess(); the high byte describes the read mode, and the low byte describes the write mode.
     *
     * V2 should never appear in any values used by getCardAccess() or setCardAccess(); the sole purpose of V2 is to
     * distinguish newer (V2) access values from older (V1) access values in saved contexts.  It's set when the context
     * is saved, and cleared when the context is restored.  Thus, if V2 is not set on restore, we assume we're dealing with
     * a V1 value, so we run it through the V1 table (below) to produce a V2 value.  Hopefully at some point V1 contexts
     * can be deprecated, and the V2 bit can be eliminated/repurposed.
     */
    static READ = {                     // READ values are designed to be OR'ed with WRITE values
        MODE0:      0x0400,
        MODE1:      0x0500,
        PAIRS:      0x0800,
        EVENODD:    0x1000,
        CHAIN4:     0x4000,
        MASK:       0xFF00
    };

    static WRITE = {                    // and WRITE values are designed to be OR'ed with READ values
        MODE0:      0x0000,
        MODE1:      0x0001,
        MODE2:      0x0002,
        MODE3:      0x0003,             // VGA only
        CHAIN4:     0x0004,
        PAIRS:      0x0008,
        EVENODD:    0x0010,
        ROT:        0x0020,
        AND:        0x0060,
        OR:         0x00A0,
        XOR:        0x00E0,
        MASK:       0x00FF
    };

    /**
     * Table of older (V1) access values and their corresponding new values; the new values are similar but more orthogonal
     */
    static V1 = {
        0x0002: Card.READ.MODE0,
        0x0003: Card.READ.MODE0  | Card.READ.EVENODD,
        0x0010: Card.READ.MODE1,
        0x0200: Card.WRITE.MODE0,
        0x0400: Card.WRITE.MODE0 | Card.WRITE.ROT,
        0x0600: Card.WRITE.MODE0 | Card.WRITE.AND,
        0x0A00: Card.WRITE.MODE0 | Card.WRITE.OR,
        0x0E00: Card.WRITE.MODE0 | Card.WRITE.XOR,
        0x0300: Card.WRITE.MODE0 | Card.WRITE.EVENODD,
        0x1000: Card.WRITE.MODE1,
        0x2000: Card.WRITE.MODE2,
        0x6000: Card.WRITE.MODE2 | Card.WRITE.AND,
        0xA000: Card.WRITE.MODE2 | Card.WRITE.OR,
        0xE000: Card.WRITE.MODE2 | Card.WRITE.XOR
    };

    static V2 = (0x80000000|0);         // this is a signature bit used ONLY to differentiate V2 access values from V1

    /**
     * Mappings from getCardAccess() values to access functions above
     */
    static FUNCS = {
        [Card.READ.MODE0]:                          Card.readByteMode0,
        [Card.READ.MODE0  | Card.READ.CHAIN4]:      Card.readByteMode0Chain4,
        [Card.READ.MODE0  | Card.READ.EVENODD]:     Card.readByteMode0EvenOdd,
        [Card.READ.MODE1]:                          Card.readByteMode1,
        [Card.READ.PAIRS]:                          Card.readBytePairs,
        [Card.WRITE.MODE0]:                         Card.writeByteMode0,
        [Card.WRITE.MODE0 | Card.WRITE.ROT]:        Card.writeByteMode0Rot,
        [Card.WRITE.MODE0 | Card.WRITE.AND]:        Card.writeByteMode0And,
        [Card.WRITE.MODE0 | Card.WRITE.OR]:         Card.writeByteMode0Or,
        [Card.WRITE.MODE0 | Card.WRITE.XOR]:        Card.writeByteMode0Xor,
        [Card.WRITE.MODE0 | Card.WRITE.CHAIN4]:     Card.writeByteMode0Chain4,
        [Card.WRITE.MODE0 | Card.WRITE.EVENODD]:    Card.writeByteMode0EvenOdd,
        [Card.WRITE.MODE1]:                         Card.writeByteMode1,
        [Card.WRITE.MODE1 | Card.WRITE.EVENODD]:    Card.writeByteMode1EvenOdd,
        [Card.WRITE.MODE2]:                         Card.writeByteMode2,
        [Card.WRITE.MODE2 | Card.WRITE.AND]:        Card.writeByteMode2And,
        [Card.WRITE.MODE2 | Card.WRITE.OR]:         Card.writeByteMode2Or,
        [Card.WRITE.MODE2 | Card.WRITE.XOR]:        Card.writeByteMode2Xor,
        [Card.WRITE.MODE3]:                         Card.writeByteMode3,
        [Card.WRITE.PAIRS]:                         Card.writeBytePairs
    };
}

if (DEBUGGER) {
    Card.CRTC.REGS = [
        "HTOTAL","HDISP","HSPOS","HSWIDTH","VTOTAL","VTOTADJ",
        "VDISP","VSPOS","ILMODE","MAXSCAN","CURSCAN","CURSCANB",
        "STARTHI","STARTLO","CURSORHI","CURSORLO","PENHI","PENLO"
    ];
    Card.CRTC.EGA_REGS = [
        "HTOTAL","HDEND","HBSTART","HBEND","HRSTART","HREND",
        "VTOTAL","OVERFLOW","PRESCAN","MAXSCAN","CURSCAN","CURSCANB",
        "STARTHI","STARTLO","CURSORHI","CURSORLO","VRSTART","VREND",
        "VDEND","OFFSET","UNDERLINE","VBSTART","VBEND","MODECTRL","LINECOMP"
    ];
    Card.ATC.REGS = [
        "ATC00","ATC01","ATC02","ATC03","ATC04","ATC05","ATC06","ATC07",
        "ATC08","ATC09","ATC0A","ATC0B","ATC0C","ATC0D","ATC0E","ATC0F",
        "ATCMODE","OVERSCAN","PLANES","HPAN","COLORSEL"
    ];
    Card.SEQ.REGS = [
        "RESET","CLKMODE","MAPMASK","CHARMAP","MEMMODE"
    ];
    Card.GRC.REGS = [
        "SRESET","ESRESET","COLORCOMP","DATAROT","READMAP","GRCMODE","GRCMISC","COLORDC","BITMASK"
    ];
}

/** @typedef {{ cxChar: number, cyChar: number, cxCell: number, cyCell: number, aCSSColors: Array, aRGBColors: Array, aColorMap: Array, aCanvas: Array }} */
let Font;

/**
 * @class Videox86
 * @property {CPUx86} cpu
 * @property {Debuggerx86} dbg
 * @property {number} cUpdates
 * @property {number} msUpdatePrev
 * @unrestricted (allows the class to define properties, both dot and named, outside of the constructor)
 */
class Videox86 extends Component {

    static TRAPALL = true;      // monitor all I/O by default (not just deltas)

    /**
     * Supported Cards (and associated fonts)
     *
     * These IDs are also used to identify which "slots" in the aFonts[] array contain fonts, which is why
     * there are gaps between the numbers.  The MDA and CGA use a single supplied font, so they will always
     * use font slot 1 or 2, respectively, but the EGA supports up to 4 font "banks", so depending on which
     * bank is being used, font slots 4-7 may be used.  Similarly, the VGA supports up to 8 font "banks",
     * using font slots 8-15.
     *
     * Once we've finished loading the standard 8K font file, aFonts[] should contain at least one of the
     * entries listed below.  For the standard MDA/CGA font ROM, the first (MDA) font resides in the first 4Kb,
     * and the second and third (CGA) fonts reside in the two 2K halves of the second 4Kb.
     *
     * Additional notes from the IBM EGA Manual (p.5):
     *
     *      In alphanumeric modes, characters are formed from one of two ROM (Read Only Memory) character
     *      generators on the adapter. One character generator defines 7x9 characters in a 9x14 character box.
     *      For Enhanced Color Display support, the 9x14 character set is modified to provide an 8x14 character set.
     *      The second character generator defines 7x7 characters in an 8x8 character box. These generators contain
     *      dot patterns for 256 different characters. The character sets are identical to those provided by the
     *      IBM Monochrome Display Adapter and the IBM Color/Graphics Monitor Adapter.
     */
    static CARD = {
        MDA:    1,              // uses 9x14 monochrome font
        CGA:    2,              // uses 8x8 color font
        EGA:    4,              // uses 8x14 color font (by default)
        VGA:    8               // uses 9x16 color font (by default)
    };

    /**
     * Supported Modes
     *
     * Although this component is designed to be a video hardware emulation, not a BIOS simulation, we DO
     * look for changes to the hardware state that correspond to standard BIOS mode settings, so our internal
     * mode setting will normally match the current BIOS mode setting; however, this a debugging convenience,
     * not an attempt to monitor or emulate the BIOS.
     *
     * We do have some BIOS awareness (eg, when loading ROM-based fonts, and some special code to ensure all
     * the BIOS diagnostics pass), but for the most part, we treat the BIOS like any other application code.
     *
     * As we expand support to include more programmable cards like the EGA, it becomes quite easy for the card
     * to enter a "mode" that has no BIOS counterpart (eg, non-standard combinations of video buffer address,
     * memory access modes, fonts, display regions, etc).  Our hardware emulation routines will cope with those
     * situations as best they can (and when they don't, it should be considered a bug if some application is
     * broken as a result), but realistically, our hardware emulation is never likely to be 100% accurate.
     */
    static MODE = {
        CGA_40X25_BW:       0,
        CGA_40X25:          1,
        CGA_80X25_BW:       2,
        CGA_80X25:          3,
        CGA_320X200:        4,
        CGA_320X200_BW:     5,
        CGA_640X200:        6,
        MDA_80X25:          7,
        EGA_320X200:        0x0D,   // mapped at A000:0000, color, 4bpp, planar
        EGA_640X200:        0x0E,   // mapped at A000:0000, color, 4bpp, planar
        EGA_640X350_MONO:   0x0F,   // mapped at A000:0000, mono,  2bpp, planar
        EGA_640X350:        0x10,   // mapped at A000:0000, color, 4bpp, planar
        VGA_640X480_MONO:   0x11,   // mapped at A000:0000, mono,  2bpp, planar
        VGA_640X480:        0x12,   // mapped at A000:0000, color, 4bpp, planar
        VGA_320X200:        0x13,   // mapped at A000:0000, color, 8bpp, linear
        /**
         * The remaining mode identifiers are for internal use only; there is no correlation with any
         * publicly defined BIOS modes, and overlap with any third-party mode numbers is purely coincidental.
         */
        VGA_320X200P:       0x14,   // mapped at A000:0000, color, 8bpp, planar
        VGA_320X240P:       0x15,   // mapped at A000:0000, color, 8bpp, planar ("Mode X")
        VGA_320X400P:       0x16,   // mapped at A000:0000, color, 8bpp, planar
        /**
         * Here's where we might assign additional identifiers to certain unique combinations, like the
         * fTextGraphicsHybrid 320x400 mode that Windows 95 uses (ie, when the buffer is mapped to B800:0000
         * instead of A000:0000 and is configured for text mode access, but graphics are still being displayed
         * from the second half of video memory).
         */
        UNKNOWN:            0xFF
    };

    static UPDATES_PER_SECOND = 60;

    /**
     * Supported Models
     *
     * Each model refers to an array where [0] is the card ID, and [1] is the default mode.
     */
    static MODEL = {
        "mda": [Videox86.CARD.MDA, Videox86.MODE.MDA_80X25],
        "cga": [Videox86.CARD.CGA, Videox86.MODE.CGA_80X25],
        "ega": [Videox86.CARD.EGA, Videox86.MODE.CGA_80X25],
        "vga": [Videox86.CARD.VGA, Videox86.MODE.CGA_80X25]
    };

    /**
     * @type {Object.<MonitorSpecs>}
     */
    static monitorSpecs = {
        /**
         * NOTE: The number of horizontal periods per frame (200) is dictated by the EGA ROM BIOS at C000:03D0.
         */
        [ChipSet.MONITOR.COLOR]: {
            nHorzPeriodsPerSec: 15700,
            nHorzPeriodsPerFrame: 200,
            percentHorzActive: 75,
            percentVertActive: 96
        },
        /**
         * NOTE: The number of horizontal periods per frame (350) is dictated by the EGA ROM BIOS at C000:03D0.
         */
        [ChipSet.MONITOR.MONO]: {
            nHorzPeriodsPerSec: 18432,
            nHorzPeriodsPerFrame: 350,
            percentHorzActive: 75,
            percentVertActive: 96
        },
        /**
         * NOTE: The number of horizontal periods per frame (350) is dictated by the EGA ROM BIOS at C000:03D0.
         */
        [ChipSet.MONITOR.EGACOLOR]: {
            nHorzPeriodsPerSec: 21850,
            nHorzPeriodsPerFrame: 350,
            percentHorzActive: 75,
            percentVertActive: 96
        },
        /**
         * NOTE: The number of horizontal periods per frame (400) is dictated by the IBM VGA ROM code at C000:024A.
         */
        [ChipSet.MONITOR.VGACOLOR]: {
            nHorzPeriodsPerSec: 31500,
            nHorzPeriodsPerFrame: 400,
            percentHorzActive: 85,
            percentVertActive: 83
        }
    };

    /**
     * EGA Miscellaneous ports and SW1-Sw4
     *
     * The Card.MISC.CLOCK_SELECT bits determine which of the EGA board's 4 configuration switches are
     * returned via Card.STATUS0.SWSENSE (when SWSENSE is zero, the switch is closed):
     *
     *      0xC: return SW1
     *      0x8: return SW2
     *      0x4: return SW3
     *      0x0: return SW4
     *
     * These 4 bits are also copied to the byte at 40:88h by the EGA BIOS, where bit 0 is SW1, bit 1 is SW2,
     * bit 2 is SW3 and bit 3 is SW4.  Our switch settings come from bEGASwitches, which in turn comes from
     * sSwitches, which in turn comes from the "switches" property passed to the Video component, if any.
     *
     * As usual, the switch settings are reversed in both direction and sense from the switch settings; the
     * good news, however, is that we can use the parseSwitches() method in the ChipSet component to parse them.
     *
     * The set of valid EGA switch values, after conversion, is stored in the table below.  For each value,
     * there is an array that defines the corresponding monitor type(s) for the EGA adapter and any secondary
     * adapter.  The third value is a boolean indicating whether the EGA is the primary adapter.
     */
    static aEGAMonitorSwitches = {
        0x06: [ChipSet.MONITOR.TV,           ChipSet.MONITOR.MONO,  true],  // "1001"
        0x07: [ChipSet.MONITOR.COLOR,        ChipSet.MONITOR.MONO,  true],  // "0001" [used by 5153 monitor configs]
        0x08: [ChipSet.MONITOR.EGAEMULATION, ChipSet.MONITOR.MONO,  true],  // "1110"
        0x09: [ChipSet.MONITOR.EGACOLOR,     ChipSet.MONITOR.MONO,  true],  // "0110" [used by 5154 monitor configs (default; see bEGASwitches below)]
        0x0a: [ChipSet.MONITOR.MONO,         ChipSet.MONITOR.TV,    true],  // "1010"
        0x0b: [ChipSet.MONITOR.MONO,         ChipSet.MONITOR.COLOR, true],  // "0010" [used by 5151 monitor configs]
        0x00: [ChipSet.MONITOR.TV,           ChipSet.MONITOR.MONO,  false], // "1111"
        0x01: [ChipSet.MONITOR.COLOR,        ChipSet.MONITOR.MONO,  false], // "0111"
        0x02: [ChipSet.MONITOR.EGAEMULATION, ChipSet.MONITOR.MONO,  false], // "1011"
        0x03: [ChipSet.MONITOR.EGACOLOR,     ChipSet.MONITOR.MONO,  false], // "0011"
        0x04: [ChipSet.MONITOR.MONO,         ChipSet.MONITOR.TV,    false], // "1101"
        0x05: [ChipSet.MONITOR.MONO,         ChipSet.MONITOR.COLOR, false]  // "0101"
    };

    /**
     * For each video mode, we need to know the following pieces of information:
     *
     *      0: # of columns (nCols)
     *      1: # of rows (nRows)
     *      2: # points per cell (nPointsPerCell: # of points per cell cache entry)
     *      3: # points per byte (nPointsPerByte: # of points per frame buffer byte)
     *      4: # bytes of visible screen padding, if any (used for CGA graphics modes only)
     *      5: font ID (nFont: undefined if graphics mode)
     *
     * The 3rd entry used to be nCellsPerWord, but it is now nPointsPerCell.  nCols * nRows yields total
     * (viewable) points, and dividing that by nPointsPerCell yields the size of the cell cache (nCellCache).
     *
     * For MDA and CGA modes, a "word" of memory is 16 bits of CPU-addressable data, so by calculating
     * ([0] * [1]) / [2], we obtain the number of words that mode actively displays; for example, the
     * amount of visible memory used by mode 0x04 is (320 * 200) / 4, or 16000.
     *
     * However, for EGA and VGA graphics modes, a "word" of memory is a single element in the video buffer
     * containing 32 bits of pixel data.
     */
    static aModeParms = {                                                                   // Mode
        [Videox86.MODE.CGA_40X25_BW]:        [ 40,  25,  1, 0.5,   0, Videox86.CARD.CGA],   // 0x00
        [Videox86.MODE.CGA_40X25]:           [ 40,  25,  1, 0.5,   0, Videox86.CARD.CGA],   // 0x01
        [Videox86.MODE.CGA_80X25_BW]:        [ 80,  25,  1, 0.5,   0, Videox86.CARD.CGA],   // 0x02
        [Videox86.MODE.CGA_80X25]:           [ 80,  25,  1, 0.5,   0, Videox86.CARD.CGA],   // 0x03
        [Videox86.MODE.CGA_320X200]:         [320, 200,  8,   4, 192],                      // 0x04
        [Videox86.MODE.CGA_320X200_BW]:      [320, 200,  8,   4, 192],                      // 0x05
        [Videox86.MODE.CGA_640X200]:         [640, 200, 16,   8, 192],                      // 0x06
        [Videox86.MODE.MDA_80X25]:           [ 80,  25,  1, 0.5,   0, Videox86.CARD.MDA],   // 0x07
        [Videox86.MODE.EGA_320X200]:         [320, 200,  8,   8],                           // 0x0D
        [Videox86.MODE.EGA_640X200]:         [640, 200,  8,   8],                           // 0x0E
        [Videox86.MODE.EGA_640X350_MONO]:    [640, 350,  8,   8],                           // 0x0F
        [Videox86.MODE.EGA_640X350]:         [640, 350,  8,   8],                           // 0x10
        [Videox86.MODE.VGA_640X480_MONO]:    [640, 480,  8,   8],                           // 0x11
        [Videox86.MODE.VGA_640X480]:         [640, 480,  8,   8],                           // 0x12
        [Videox86.MODE.VGA_320X200]:         [320, 200,  4,   1],                           // 0x13
        [Videox86.MODE.VGA_320X200P]:        [320, 200,  4,   4],                           // 0x14
        [Videox86.MODE.VGA_320X240P]:        [320, 240,  4,   4],                           // 0x15
        [Videox86.MODE.VGA_320X400P]:        [320, 400,  4,   4]                            // 0x16
    };

    /**
     * MDA attribute byte definitions
     *
     * For MDA, only the first eight ATTR definitions are supported; any FGND/BGND value combinations outside that
     * group will be treated as "normal" (ATTR_FGND_WHITE | ATTR_BGND_BLACK).
     *
     * NOTE: Assuming MDA.MODE.BLINK_ENABLE is set (which the ROM BIOS sets by default), ATTR_BGND_BLINK will
     * cause the *foreground* element of the cell to blink, even though it is part of the *background* attribute bits.
     *
     * Regarding blink rate, characters are supposed to blink every 16 vertical frames, which amounts to .26667 blinks
     * per second, assuming a 60Hz vertical refresh rate.  So roughly every 267ms, we need to take care of any blinking
     * characters.  updateScreen() maintains a global count (cBlinkVisible) of blinking characters, to simplify the
     * decision of when to redraw the screen.
     *
     * Here's a "cheat sheet" for attribute byte combinations that the IBM MDA could have supported.  The original (Aug 1981)
     * IBM Tech Ref is very terse and implies that only those marked with * are actually supported.
     *
     *     *0x00: non-display                       ATTR_FGND_BLACK |                    ATTR_BGND_BLACK
     *     *0x01: underline                         ATTR_FGND_ULINE |                    ATTR_BGND_BLACK
     *     *0x07: normal (white on black)           ATTR_FGND_WHITE |                    ATTR_BGND_BLACK
     *    **0x09: bright underline                  ATTR_FGND_ULINE | ATTR_FGND_BRIGHT | ATTR_BGND_BLACK
     *    **0x0F: bold (bright white on black)      ATTR_FGND_WHITE | ATTR_FGND_BRIGHT | ATTR_BGND_BLACK
     *     *0x70: reverse (black on white)          ATTR_FGND_BLACK |                  | ATTR_BGND_WHITE
     *      0x81: blinking underline                ATTR_FGND_ULINE |                  | ATTR_BGND_BLINK (or dim background if blink disabled)
     *    **0x87: blinking normal                   ATTR_FGND_WHITE |                  | ATTR_BGND_BLINK (or dim background if blink disabled)
     *      0x89: blinking bright underline         ATTR_FGND_ULINE | ATTR_FGND_BRIGHT | ATTR_BGND_BLINK (or dim background if blink disabled)
     *    **0x8F: blinking bold                     ATTR_FGND_WHITE | ATTR_FGND_BRIGHT | ATTR_BGND_BLINK (or dim background if blink disabled)
     *    **0xF0: blinking reverse                  ATTR_FGND_WHITE | ATTR_FGND_BRIGHT | ATTR_BGND_BLINK (or bright background if blink disabled)
     *
     * Unsupported attributes reportedly display as "normal" (ATTR_FGND_WHITE | ATTR_BGND_BLACK).  However, precisely which
     * attributes are unsupported on the MDA varies depending on the source.  Some sources (eg, the IBM Tech Ref) imply that
     * only those marked by * are supported, while others (eg, some--but not all--Peter Norton guides) include those marked
     * by **, and still others include ALL the combinations listed above.
     *
     * Furthermore, according to http://www.seasip.info/VintagePC/mda.html:
     *
     *      Attributes 0x00, 0x08, 0x80 and 0x88 display as black space;
     *      Attribute 0x78 displays as dark green on green; depending on the monitor, there may be a green "halo" where the dark and bright bits meet;
     *      Attribute 0xF0 displays as a blinking version of 0x70 if blink enabled, and black on bright green otherwise;
     *      Attribute 0xF8 displays as a blinking version of 0x78 if blink enabled, and as dark green on bright green otherwise.
     *
     * However, I'm rather skeptical about supporting 0x78 and 0xF8, until I see some evidence that "bright black" actually
     * produced dark green on IBM equipment; it also doesn't sound like a combination many people would have used.  I'll probably
     * treat all of 0x08, 0x80 and 0x88 the same as 0x00, only because it seems logical (they're all "black on black" combinations
     * with only BRIGHT and/or BLINK bits set). Beyond that, I'll likely treat any other combination not listed in the above cheat
     * sheet as "normal".
     *
     * All the discrepancies/disagreements I've found are probably due in part to the proliferation of IBM and non-IBM MDA
     * cards, combined with IBM and non-IBM monochrome monitors, and people assuming that their non-IBM card and/or monitor
     * behaved exactly like the original IBM equipment, which probably wasn't true in all cases.
     *
     * I would like to limit my MDA display support to EXACTLY everything that the IBM MDA supported and nothing more, but
     * since there will be combinations that will logically "fall out" unless I specifically exclude them, it's very likely
     * this implementation will end up being a superset.
     *
     * CGA attribute byte definitions simply extend the set of MDA attributes, with the exception of ATTR_FNGD_ULINE,
     * which the CGA can treat only as ATTR_FGND_BLUE.
     */
    static ATTRS = {
        FGND_BLACK:     0x00,
        FGND_ULINE:     0x01,
        FGND_WHITE:     0x07,
        FGND_BRIGHT:    0x08,
        BGND_BLACK:     0x00,
        BGND_WHITE:     0x70,
        BGND_BLINK:     0x80,
        BGND_BRIGHT:    0x80,

        FGND_BLUE:      0x01,
        FGND_GREEN:     0x02,
        FGND_CYAN:      0x03,
        FGND_RED:       0x04,
        FGND_MAGENTA:   0x05,
        FGND_BROWN:     0x06,
        BGND_BLUE:      0x10,
        BGND_GREEN:     0x20,
        BGND_CYAN:      0x30,
        BGND_RED:       0x40,
        BGND_MAGENTA:   0x50,
        BGND_BROWN:     0x60,

        DRAW_FGND:     0x100,   // this is an internal attribute bit, indicating the foreground should be drawn
        DRAW_CURSOR:   0x200    // this is an internal attribute bit, indicating when the cursor should be drawn
    };

    /**
     * For the MDA, there are currently three distinct "colors": off, normal, and intense.  There are
     * also two variations of normal and intense: with and without underlining.  Technically, underlining
     * makes no difference in the actual color, but because different fonts must be built for each, and
     * because the presence of underlining is determined by character's attribute (aka "color") bits, we
     * use separate color indices for each variation; so ODD color indices are used for underlining and
     * EVEN indices are not.
     *
     * I'm still not sure about dark green (see comments above); if it exists on a standard IBM monitor
     * (model 5151), then I may need to support another "color": dark.  For now, the attributes that may
     * require dark (ie, 0x78 and 0xF8) have their foreground attribute (0x8) mapped to 0x0 (off) instead.
     */
    static aMDAColors = [
        [0x00, 0x00, 0x00, 0xff],       // 0: off
        [0x09, 0xcc, 0x50, 0xff],       // 1: normal (with underlining)
        [0x09, 0xcc, 0x50, 0xff],       // 2: normal
        [0x3c, 0xff, 0x83, 0xff],       // 3: intense (with underlining)
        [0x3c, 0xff, 0x83, 0xff]        // 4: intense
    ];

    /**
     * Each of the following FGND attribute values are mapped to one of the above "colors":
     *
     *      0x0: black font (per above, attribute value 0x8 is also mapped to attribute 0x0)
     *      0x1: green font with underlining
     *      0x7: green font without underlining (attribute values 0x2-0x6 are mapped to attribute 0x7)
     *      0x9: bright green font with underlining
     *      0xf: bright green font without underlining (attribute values 0xa-0xe are mapped to attribute 0xf)
     *
     * MDA attributes form an index into aMDAColorMap, which in turn provides an index into aMDAColors.
     */
    static aMDAColorMap = [0x0, 0x1, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x0, 0x3, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4];

    static aCGAColors = [
        [0x00, 0x00, 0x00, 0xff],   // 0x00: ATTR_FGND_BLACK
        [0x00, 0x00, 0xaa, 0xff],   // 0x01: ATTR_FGND_BLUE
        [0x00, 0xaa, 0x00, 0xff],   // 0x02: ATTR_FGND_GREEN
        [0x00, 0xaa, 0xaa, 0xff],   // 0x03: ATTR_FGND_CYAN
        [0xaa, 0x00, 0x00, 0xff],   // 0x04: ATTR_FGND_RED
        [0xaa, 0x00, 0xaa, 0xff],   // 0x05: ATTR_FGND_MAGENTA
        [0xaa, 0x55, 0x00, 0xff],   // 0x06: ATTR_FGND_BROWN
        [0xaa, 0xaa, 0xaa, 0xff],   // 0x07: ATTR_FGND_WHITE                      (aka light gray)
        [0x55, 0x55, 0x55, 0xff],   // 0x08: ATTR_FGND_BLACK   | ATTR_FGND_BRIGHT (aka gray)
        [0x55, 0x55, 0xff, 0xff],   // 0x09: ATTR_FGND_BLUE    | ATTR_FGND_BRIGHT
        [0x55, 0xff, 0x55, 0xff],   // 0x0A: ATTR_FGND_GREEN   | ATTR_FGND_BRIGHT
        [0x55, 0xff, 0xff, 0xff],   // 0x0B: ATTR_FGND_CYAN    | ATTR_FGND_BRIGHT
        [0xff, 0x55, 0x55, 0xff],   // 0x0C: ATTR_FGND_RED     | ATTR_FGND_BRIGHT
        [0xff, 0x55, 0xff, 0xff],   // 0x0D: ATTR_FGND_MAGENTA | ATTR_FGND_BRIGHT
        [0xff, 0xff, 0x55, 0xff],   // 0x0E: ATTR_FGND_BROWN   | ATTR_FGND_BRIGHT (aka yellow)
        [0xff, 0xff, 0xff, 0xff]    // 0x0F: ATTR_FGND_WHITE   | ATTR_FGND_BRIGHT (aka white)
    ];

    static aCGAColorSet0 = [Videox86.ATTRS.FGND_GREEN, Videox86.ATTRS.FGND_RED,     Videox86.ATTRS.FGND_BROWN];
    static aCGAColorSet1 = [Videox86.ATTRS.FGND_CYAN,  Videox86.ATTRS.FGND_MAGENTA, Videox86.ATTRS.FGND_WHITE];

    /**
     * Here is the EGA BIOS default ATC palette register set for color text modes, from which getCardColors()
     * builds a default RGB array, similar to aCGAColors above.
     */
    static aEGAPalDef = [0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x14, 0x07, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F];

    static aEGAByteToDW = [
        0x00000000,   0x000000ff,   0x0000ff00,   0x0000ffff,
        0x00ff0000,   0x00ff00ff,   0x00ffff00,   0x00ffffff,
        0xff000000|0, 0xff0000ff|0, 0xff00ff00|0, 0xff00ffff|0,
        0xffff0000|0, 0xffff00ff|0, 0xffffff00|0, 0xffffffff|0
    ];

    static aEGADWToByte = {
        [0x00000000]:    0x0,
        [0x00000080]:    0x1,
        [0x00008000]:    0x2,
        [0x00008080]:    0x3,
        [0x00800000]:    0x4,
        [0x00800080]:    0x5,
        [0x00808000]:    0x6,
        [0x00808080]:    0x7,
        [0x80000000|0]:  0x8,
        [0x80000080|0]:  0x9,
        [0x80008000|0]:  0xa,
        [0x80008080|0]:  0xb,
        [0x80800000|0]:  0xc,
        [0x80800080|0]:  0xd,
        [0x80808000|0]:  0xe,
        [0x80808080|0]:  0xf
    };

    /**
     * Card Specifications
     *
     * We support dynamically switching between MDA and CGA cards by simply flipping switches on
     * the virtual SW1 switch block and resetting the machine.  However, I'm not sure I'll support
     * dynamically switching the EGA card the same way; there's certainly no UI for it at this point.
     *
     * For each supported card, there is a cardSpec array that the Card class uses to initialize the
     * card's defaults:
     *
     *      [0]: card descriptor
     *      [1]: default CRTC port address
     *      [2]: default video buffer address
     *      [3]: default video buffer size
     *      [4]: total on-board memory (if no "memory" parm was specified)
     *      [5]: default monitor type
     *
     * If total on-board memory is zero, then addMemory() will simply add the specified video buffer
     * to the address space; otherwise, we will allocate an internal buffer (adwMemory) and tell addMemory()
     * to map it to the video buffer address.  The latter approach gives us total control over the buffer;
     * refer to getMemoryAccess().
     */
    static cardSpecs = {
        [Videox86.CARD.MDA]: ["MDA", Card.MDA.CRTC.INDX.PORT, 0xB0000, 0x01000, 0x01000, ChipSet.MONITOR.MONO],
        [Videox86.CARD.CGA]: ["CGA", Card.CGA.CRTC.INDX.PORT, 0xB8000, 0x04000, 0x04000, ChipSet.MONITOR.COLOR],
        [Videox86.CARD.EGA]: ["EGA", Card.CGA.CRTC.INDX.PORT, 0xB8000, 0x04000, 0x10000, ChipSet.MONITOR.EGACOLOR],
        [Videox86.CARD.VGA]: ["VGA", Card.CGA.CRTC.INDX.PORT, 0xB8000, 0x04000, 0x40000, ChipSet.MONITOR.VGACOLOR]
    };

    /**
     * Values for nTouchConfig; a value will be selected based on the sTouchScreen configuration parameter.
     */
    static TOUCH = {
        NONE:       0,
        DEFAULT:    1,
        KEYGRID:    2,
        MOUSE:      3
    };

    /**
     * Why simulate a SPACE if the tap is in the middle third (center) of the screen?  Well, apparently
     * I didn't explain earlier that the WHOLE reason I originally added KEYGRID support (before it was
     * even called KEYGRID support) was to make the 1985 game "Rogue" (pcjs.org/apps/pcx86/1985/rogue)
     * more fun to play on an iPad (the space-bar is a commonly required key).
     */
    static KEYGRID = [
        [Keyboardx86.SIMCODE.HOME, Keyboardx86.SIMCODE.UP,    Keyboardx86.SIMCODE.PGUP],
        [Keyboardx86.SIMCODE.LEFT, Keyboardx86.SIMCODE.SPACE, Keyboardx86.SIMCODE.RIGHT],
        [Keyboardx86.SIMCODE.END,  Keyboardx86.SIMCODE.DOWN,  Keyboardx86.SIMCODE.PGDN],
    ];

    /**
     * Videox86(parmsVideo, canvas, context, textarea, container, aDiagElements)
     *
     * The Videox86 component can be configured with the following (parmsVideo) properties:
     *
     *      model: model (eg, "mda" for Monochrome Display Adapter)
     *      mode: initial video mode (default is null, which selects a mode based on model)
     *      screenWidth: width of the screen canvas, in pixels
     *      screenHeight: height of the screen canvas, in pixels
     *      screenColor: background color of the screen canvas (default is black)
     *      flicker: 1 enables screen flicker, 0 disables (default is 0.5)
     *      scale: true for font scaling, false (default) to center the display on the screen
     *      charCols: number of character columns
     *      charRows: number of character rows
     *      fontROM: path to .rom file (or a JSON representation) containing the character set
     *      touchScreen: string specifying desired touch-screen support (default is none)
     *      autoLock: true to (attempt to) auto-lock the mouse to the canvas (default is false)
     *      randomize: 1 enables screen randomization, 0 disables (default is 1)
     *      irq: 0-15 for IRQ, -1 to disable (default is null, implying Chipset.IRQ.VID or 2)
     *
     * An EGA/VGA may specify the following additional properties:
     *
     *      switches: string representing EGA switches (see "SW1-SW4" documentation below)
     *      memory: the size of the EGA's on-board memory (overrides EGA's Videox86.cardSpecs)
     *
     * This calls the Bus to allocate a video buffer at the appropriate memory location whenever
     * a reset() or setMode() occurs; setMode() is called whenever a mode change is detected at
     * the port level, and whenever reset() is called.  setMode() also invokes updateScreen(true),
     * which forces reallocation of our internal buffer (aCellCache) that mirrors the video buffer.
     *
     * Our initBus() handler defines a timer that periodically calls updateScreen() for each Video
     * instance.  These updates should occur at a rate of 60 times/second, to update any blinking
     * elements (the cursor and any cells with the blink attribute), to compare/update the contents
     * of our internal buffer with the video buffer, and to render any differences between the two
     * buffers into the associated screen canvas, via either updateChar() or setPixel().
     *
     * Thanks to the Bus' new block-based memory manager that allows us to sparse-allocate memory
     * (in 4Kb increments), updateScreen() can also ask the CPU for the "dirty" state of all the
     * blocks underlying the video buffer, bypassing the update completely if the buffer is still clean.
     *
     * Sadly, that optimization is defeated if the count of active blink elements is non-zero,
     * because we must rescan the entire buffer to locate and redraw them all; I'm assuming for now
     * that, more often than not, very few (if any) blink attributes will be present, and therefore
     * they're not worth a separate caching mechanism.  If the only blinking element is the cursor,
     * that's no problem, as we redraw only the one cell containing the cursor (assuming the buffer
     * is otherwise clean).
     *
     * @this {Videox86}
     * @param {Object} parmsVideo
     * @param {HTMLCanvasElement} [canvas]
     * @param {CanvasRenderingContext2D} [context]
     * @param {HTMLTextAreaElement} [textarea]
     * @param {HTMLElement} [container]
     * @param {Array.<HTMLElement>} [aDiagElements]
     */
    constructor(parmsVideo, canvas, context, textarea, container, aDiagElements)
    {
        super("Video", parmsVideo, MESSAGE.VIDEO);

        let video = this, sProp, sEvent;
        this.bindingsExternal = [];
        this.parmsVideo = parmsVideo;

        /**
         * This records the model specified (eg, "mda", "cga", "ega", "vga", "vdu", or "" if no model
         * is specified); when a model is specified, it overrides whatever model we infer from the ChipSet's
         * switches (since those motherboard switches tell us only the type of monitor, not the type of card).
         */
        this.model = parmsVideo['model'];
        let aModelDefaults = Videox86.MODEL[this.model] || Videox86.MODEL['mda'];

        this.nCard = aModelDefaults[0];
        let irq = parmsVideo['irq'];
        if (irq == undefined) irq = ChipSet.IRQ.VID;
        this.nIRQ = (this.nCard >= Videox86.CARD.EGA && irq >= 0 && irq <= 15)? irq : undefined;

        this.nCardFont = 0;
        this.nActiveFont = this.nAlternateFont = 0;
        this.nFontSelect = 0;                       // current set of selectable logical fonts
        this.cbMemory = +parmsVideo['memory'] || 0; // zero means fallback to the cardSpec's default size
        this.sSwitches = parmsVideo['switches'];
        this.nRandomize = parmsVideo['randomize'];
        if (this.nRandomize == null) this.nRandomize = 1;

        /**
         * powerUp() uses the default mode ONLY if ChipSet doesn't give us a default.
         */
        this.nModeDefault = parmsVideo['mode'];
        if (this.nModeDefault == null || Videox86.aModeParms[this.nModeDefault] == null) {
            this.nModeDefault = aModelDefaults[1];
        }

        /**
         * setDimensions() uses these values ONLY if it doesn't recognize the video mode.
         */
        this.nColsDefault = parmsVideo['charCols'];
        this.nRowsDefault = parmsVideo['charRows'];
        if (this.nColsDefault === undefined || this.nRowsDefault === undefined) {
            this.nColsDefault = Videox86.aModeParms[this.nModeDefault][0];
            this.nRowsDefault = Videox86.aModeParms[this.nModeDefault][1];
        }

        /**
         * setDimensions() uses these values unconditionally, as the machine has no idea what the
         * physical screen size should be.
         */
        this.cxScreen = parmsVideo['screenWidth'];
        this.cyScreen = parmsVideo['screenHeight'];

        /**
         * The font 'scale' parameter is deprecated (we ALWAYS scale now), and the internal fDoubleFont
         * setting is now always true, but it is retained in case we want to revisit the benefits (or lack
         * thereof) of font-doubling.
         *
         *      this.fScaleFont = parmsVideo['scale'];
         *
         * When fScaleFont was false, one key difference was these additional lines in setDimensions():
         *
         *      if (!this.fScaleFont) {
         *          this.cxScreenCell = font.cxCell;
         *          this.cyScreenCell = font.cyCell;
         *      }
         *
         * which meant that if the font was only 8 pixels wide (instead of 16), then 40-column mode would
         * simply display normal size characters with large black borders on either of the screen.
         */
        this.fDoubleFont = true;

        this.canvasScreen = canvas;
        this.contextScreen = context;
        this.inputTextArea = textarea;
        this.inputScreen = textarea || canvas || null;

        /**
         * We now ensure that a colorScreen property is always set (to "black" if nothing else), and
         * set BOTH the canvas element's AND the container element's backgroundColor to match that color.
         *
         * This gives us option of doing "cute" things like flipping the canvas element's opacity from
         * 1 to 0 briefly, alternately revealing and hiding the underlying container element, to simulate
         * screen "flicker".
         */
        this.colorScreen = parmsVideo['screenColor'] || "black";
        this.fOpacityReduced = false;
        this.fStyleCanvasFullScreen = false;
        if (canvas) {
            canvas.style.backgroundColor = this.colorScreen;
            this.fStyleCanvasFullScreen = document.fullscreenEnabled || WebLib.isUserAgent("Edge/");   // formerly fGecko = WebLib.isUserAgent("Gecko/");
        }
        if (container) container.style.backgroundColor = this.colorScreen;

        /**
         * Support for disabling (or, less commonly, enabling) image smoothing, which all browsers
         * seem to support now (well, OK, I still have to test the latest MS Edge browser), despite
         * it still being labelled "experimental technology".  Let's hope the browsers standardize
         * on this.  I see other options emerging, like the CSS property "image-rendering: pixelated"
         * that's apparently been added to Chrome.  Sigh.
         *
         * UPDATE: Now that fDoubleFont is always true, and now that we're loading fonts (eg, VGA 9x16)
         * that may have a significantly different aspect ratio from that of the preferred screen size
         * (eg, 640x480), I've decided to turn smoothing ON just for text modes.  So now we just record
         * the default property name and value, and leave it to setDimensions() to do the actual setting.
         */
        let fSmoothing = parmsVideo['smoothing'];
        let sSmoothing = WebLib.getURLParm('smoothing');
        if (sSmoothing) fSmoothing = (sSmoothing == "true");
        this.fSmoothing = fSmoothing;
        this.sSmoothing = WebLib.findProperty(this.contextScreen, 'imageSmoothingEnabled');

        /**
         * initBus() will determine touch-screen support; for now, just record values and set defaults.
         */
        this.sTouchScreen = parmsVideo['touchScreen'];
        this.nTouchConfig = Videox86.TOUCH.NONE;

        /**
         * If a Mouse exists, we'll be notified when it requests our canvas, and we make a note of it
         * so that if lockPointer() is ever invoked, we can notify the Mouse.
         */
        this.mouse = null;
        this.fAutoLock = parmsVideo['autoLock'];

        /**
         * Originally, setMode() would map/unmap the video buffer ONLY when the active card changed,
         * because as long as an MDA or CGA remained active, its video buffer never changed.  However,
         * since the EGA can change its video buffer on the fly, setMode() must also compare the card's
         * hard-coded and/or programmed buffer address/size to the "active" address/size; the latter
         * is recorded here.
         */
        this.addrBuffer = this.sizeBuffer = 0;

        /**
         * aFonts is an array of font objects indexed by FONT ID.  Font characters are arranged
         * in 16x16 grids, with one grid per canvas object in the aCanvas array of each font object.
         *
         * Each element is a Font object that describes the font size and provides bitmaps for all the font
         * color permutations.  aFonts.length will be non-zero if ANY fonts are loaded, but do NOT assume
         * that EVERY font has been loaded; check for the existence of a font by checking for its unique ID
         * within this sparse array.
         */
        this.aFonts = [];

        /**
         * aFontDiff entries are created by createFontDiff(), and each entry is a 256-element array of either
         * 0 (no difference) or -1 for every character code that differs between the fonts that correspond to
         * the aFontDiff index.
         */
        this.aFontDiff = [];

        /**
         * Instead of (re)allocating a new color array every time getCardColors() is called, we preallocate
         * an array and simply update the entries as needed.  Note that for an EGA (or a VGA operating in an
         * EGA-compatible mode), only the first 16 entries get used (derived from the ATC); only when a VGA
         * is operating in an 8bpp mode are 256 entries used (derived from the DAC rather than the ATC).
         */
        this.aRGB = new Array(this.nCard == Videox86.CARD.VGA? 256 : 16);
        this.fRGBValid = false;     // whenever this is false, it signals getCardColors() to rebuild aRGB

        this.aCellCache = [];
        this.nCellCache = 0;
        this.iCellCacheValid = 0;   // 0: invalid, 1: partially valid, 2: completely valid
        this.fShifted = false;      // set to true whenever the image has been shifted by one or more pixels
        this.nShiftLeft = this.nShiftUp = 0;

        /**
         * Since I've not found clear documentation on a reliable way to check whether a particular DOM element
         * (other than the BODY element) has focus at any given time, I've added onfocus() and onblur() handlers
         * to the screen to maintain my own focus state.
         */
        this.fHasFocus = false;

        /**
         * Here's the gross code to handle full-screen support across all supported browsers.  The lack of standards
         * is exasperating; browsers can't agree on 'Fullscreen' (most common) or 'FullScreen' (least common), and while
         * some browsers honor other browser prefixes, most don't.  Event handlers tend to be more consistent (ie, all
         * lower-case).
         */
        this.container = container;
        if (this.container) {
            sProp = WebLib.findProperty(container, 'requestFullscreen') || WebLib.findProperty(container, 'requestFullScreen');
            if (sProp) {
                this.container.doFullScreen = container[sProp];
                sEvent = WebLib.findProperty(document, 'on', 'fullscreenchange');
                if (sEvent) {
                    let sFullScreen = WebLib.findProperty(document, 'fullscreenElement') || WebLib.findProperty(document, 'fullScreenElement');
                    document.addEventListener(sEvent, function onFullScreenChange() {
                        video.notifyFullScreen(document[sFullScreen] != null);
                    }, false);
                }
                sEvent = WebLib.findProperty(document, 'on', 'fullscreenerror');
                if (sEvent) {
                    document.addEventListener(sEvent, function onFullScreenError() {
                        video.notifyFullScreen();
                    }, false);
                }
            }
        }

        /**
         * More gross code to handle pointer-locking support across all supported browsers.
         */
        if (this.inputScreen) {
            this.inputScreen.onfocus = function onFocusScreen() {
                return video.onFocusChange(true);
            };
            this.inputScreen.onblur = function onBlurScreen() {
                return video.onFocusChange(false);
            };
            this.inputScreen.lockPointer = (sProp = WebLib.findProperty(this.inputScreen, 'requestPointerLock')) && this.inputScreen[sProp];
            this.inputScreen.unlockPointer = (sProp = WebLib.findProperty(this.inputScreen, 'exitPointerLock')) && this.inputScreen[sProp];
            if (this.inputScreen.lockPointer) {
                sEvent = WebLib.findProperty(document, 'on', 'pointerlockchange');
                if (sEvent) {
                    let sPointerLock = WebLib.findProperty(document, 'pointerLockElement');
                    document.addEventListener(sEvent, function onPointerLockChange() {
                        let fLocked = !!(sPointerLock && document[sPointerLock] === video.inputScreen);
                        video.notifyPointerLocked(fLocked);
                    }, false);
                }
            }
        }

        this.sFileURL = parmsVideo['fontROM'];

        if (this.sFileURL) {
            let sFileExt = StrLib.getExtension(this.sFileURL);
            if (sFileExt != "json") {
                this.sFileURL = WebLib.getHostOrigin() + DumpAPI.ENDPOINT + '?' + DumpAPI.QUERY.FILE + '=' + this.sFileURL + '&' + DumpAPI.QUERY.FORMAT + '=' + DumpAPI.FORMAT.BYTES;
            }
        }

        /**
         * TODO: A complete list of what we want to support in terms of "diagnostic elements" needs to be fleshed out
         * at some point.  For now, all I do is save the contexts of all supplied canvas elements and use them in createFont()
         * to display the font data (for as many font banks as there are canvas elements) whenever the font(s) get rebuilt.
         */
        this.aDiagContexts = [];
        if (aDiagElements) {
            for (let i = 0; i < aDiagElements.length; i++) {
                let element = aDiagElements[i];
                if (element.tagName == "CANVAS") {
                    let context = element.getContext("2d");
                    this.aDiagContexts.push(context);
                }
            }
        }

        /**
         * Allocate image and canvas caches.
         */
        this.imageCache = {};
        this.canvasCache = {};
    }

    /**
     * initBus(cmp, bus, cpu, dbg)
     *
     * This is a notification issued by the Computer component, after all the other components (notably the CPU)
     * have had a chance to initialize.
     *
     * @this {Videox86}
     * @param {Computer} cmp
     * @param {Busx86} bus
     * @param {CPUx86} cpu
     * @param {Debuggerx86} dbg
     */
    initBus(cmp, bus, cpu, dbg)
    {
        let video = this;

        this.bus = bus;
        this.cpu = cpu;
        this.dbg = dbg;

        let nRandomize = +cmp.getMachineParm('randomize');
        if (nRandomize >= 0 && nRandomize <= 1) this.nRandomize = nRandomize;

        this.colorFont = cmp.getMachineParm('fontColor', this.parmsVideo);
        if (this.colorFont) {
            this.rgbFont = [0xff, 0xff, 0xff, 0xff];
            let i = 0, j = 0, s;
            if (this.colorFont[i] == '#') i++;
            while ((s = this.colorFont.substr(i, 2))) {
                this.rgbFont[j++] = Number.parseInt(s, 16);
                i += 2;
            }
        }

        /**
         * Moved this from the constructor (and changed WebLib.getURLParm() to cmp.getMachineParm()),
         * so that the flicker setting can be easily overridden from the page, not just from the URL.
         */
        this.opacityFlicker = (1 - (cmp.getMachineParm('flicker', this.parmsVideo) || 0)).toString();

        /**
         * nCard will be undefined if no model was explicitly set (whereas this.nCard is ALWAYS defined).
         */
        let aModel = Videox86.MODEL[this.model];
        let nCard = aModel && aModel[0];

        /**
         * The only time we do NOT want to trap MDA ports is when the model has been explicitly set to CGA.
         */
        if (nCard !== Videox86.CARD.CGA) {
            bus.addPortInputTable(this, Videox86.aMDAPortInput);
            bus.addPortOutputTable(this, Videox86.aMDAPortOutput);
        }

        /**
         * Similarly, the only time we do NOT want to trap CGA ports is when the model is explicitly set to MDA.
         */
        if (nCard !== Videox86.CARD.MDA) {
            bus.addPortInputTable(this, Videox86.aCGAPortInput);
            bus.addPortOutputTable(this, Videox86.aCGAPortOutput);
        }

        /**
         * Note that in the case of EGA and VGA models, the above code ensures that we will trap both MDA and CGA
         * port ranges -- which is good, because both the EGA and VGA can be reprogrammed to respond to those ports,
         * but also potentially bad if you want to simulate a "dual display" system, where one of the displays is
         * driven by either an MDA or CGA.
         *
         * However, you should still be able to make that work by loading the MDA or CGA video component first, because
         * components should be initialized in the order they appear in the machine configuration file.  Any attempt
         * by another component to trap the same ports should be ignored.
         */
        if (this.nCard >= Videox86.CARD.EGA) {
            bus.addPortInputTable(this, Videox86.aEGAPortInput);
            bus.addPortOutputTable(this, Videox86.aEGAPortOutput);
        }

        if (this.nCard == Videox86.CARD.VGA) {
            bus.addPortInputTable(this, Videox86.aVGAPortInput);
            bus.addPortOutputTable(this, Videox86.aVGAPortOutput);
        }

        if (DEBUGGER && dbg) {
            dbg.messageDump(MESSAGE.VIDEO, function onDumpVideo(asArgs) {
                video.dumpVideo(asArgs);
            });
        }

        /**
         * If we have an associated keyboard, then ensure that the keyboard will be notified whenever the canvas
         * gets focus and receives input.
         */
        this.kbd = cmp.getMachineComponent("Keyboard");
        if (this.kbd && this.inputScreen) {
            this.kbd.setBinding(this.inputTextArea? "textarea" : "canvas", "screen", this.inputScreen);
        }

        this.panel = cmp.getMachineComponent("Panel", false);
        for (let i = 0; i < this.bindingsExternal.length; i++) {
            let binding = this.bindingsExternal[i];
            if (this.kbd && this.kbd.setBinding(...binding)) continue;
            if (this.panel && this.panel.setBinding(...binding)) continue;
        }

        this.bEGASwitches = 0x09;   // our default "switches" setting (see aEGAMonitorSwitches)
        this.chipset = cmp.getMachineComponent("ChipSet");
        if (this.chipset && this.sSwitches) {
            if (this.nCard == Videox86.CARD.EGA) {
                this.bEGASwitches = this.chipset.parseDIPSwitches(this.sSwitches, this.bEGASwitches);
            }
        }

        /**
         * The default value for the 'touchScreen' parameter is an empty string; machine configs must explicitly
         * select one of the following values, via the 'touchscreen' attribute in the <video> element, to enable any
         * touch-screen support.
         */
        if (this.sTouchScreen == "mouse") {
            this.mouse = cmp.getMachineComponent("Mouse", false);
            if (this.mouse) this.captureTouch(Videox86.TOUCH.MOUSE);
        }
        else if (this.sTouchScreen == "keygrid") {
            if (this.kbd) this.captureTouch(Videox86.TOUCH.KEYGRID);
        }

        /**
         * If no touch support was required or requested, we still want to do some minimal touch event processing;
         * eg, notifying the ChipSet component whenever a touchstart occurs, so that it can enable audio in response
         * to a user action on iOS devices.
         */
        if (!this.nTouchConfig) {
            this.captureTouch(Videox86.TOUCH.DEFAULT);
        }

        if (this.sFileURL) {
            let sProgress = "Loading " + this.sFileURL + "...";
            WebLib.getResource(this.sFileURL, null, true, function(sURL, sResponse, nErrorCode) {
                video.doneLoad(sURL, sResponse, nErrorCode);
            }, function(nState) {
                video.printf(MESSAGE.PROGRESS, "%s\n", sProgress);
            });
            return;
        }

        /**
         * TODO: Improve how Video readiness is signalled.  Currently, all the video cards we support either have
         * a font ROM (which we load ourselves; see above) OR a system ROM (which the ROM component takes care of),
         * but not both.
         *
         * If the former, doneLoad() will call setReady(), and if the latter, onROMLoad() will call setReady().
         *
         * However, theoretically, a video card could have NEITHER or BOTH; as things stand, a card with NEITHER
         * will never be marked ready, and a card with BOTH will be prematurely marked as ready.  The Video component
         * parameters (parmsVideo) should be updated to reflect how many resources we should be waiting for.
         */
        // this.setReady();
    }

    /**
     * setBinding(sHTMLType, sBinding, control, sValue)
     *
     * @this {Videox86}
     * @param {string} sHTMLType is the type of the HTML control (eg, "button", "list", "text", "submit", "textarea", "canvas")
     * @param {string} sBinding is the value of the 'binding' parameter stored in the HTML control's "data-value" attribute (eg, "refresh")
     * @param {HTMLElement} control is the HTML control DOM object (eg, HTMLButtonElement)
     * @param {string} [sValue] optional data value
     * @returns {boolean} true if binding was successful, false if unrecognized binding request
     */
    setBinding(sHTMLType, sBinding, control, sValue)
    {
        let video = this;

        if (!this.bindings[sBinding]) {

            /**
             * We now save every binding that comes in, so that if there are bindings for "caps-lock' and the like,
             * we can forward them to the Keyboard.  TODO: Perhaps we should limit this to sHTMLType == "led", and collect
             * them in a separate object (eg, ledBindings), so that initBus() can safely enumerate JUST the LEDs.  This
             * is what we do in PCx80.  Be aware that's there's also sHTMLType == "rled" now, too.
             */
            this.bindings[sBinding] = control;

            switch (sBinding) {

            case "fullScreen":
                if (this.container && this.container.doFullScreen) {
                    control.onclick = function onClickFullScreen() {
                        if (DEBUG) video.printf("fullScreen()\n");
                        video.goFullScreen();
                    };
                } else {
                    if (DEBUG) this.printf(MESSAGE.LOG, "FullScreen API not available\n");
                    control.parentNode.removeChild(/** @type {Node} */ (control));
                }
                return true;

            case "lockPointer":
                this.sLockMessage = control.textContent;
                if (this.inputScreen && this.inputScreen.lockPointer) {
                    control.onclick = function onClickLockPointer() {
                        if (DEBUG) video.printf("lockPointer()\n");
                        video.lockPointer(true);
                    };
                } else {
                    if (DEBUG) this.printf(MESSAGE.LOG, "Pointer Lock API not available\n");
                    control.parentNode.removeChild(/** @type {Node} */ (control));
                }
                return true;

            case "refresh":
                control.onclick = function onClickRefresh() {
                    if (DEBUG) video.printf("refreshScreen()\n");
                    video.updateScreen(true);
                };
                return true;

            default:
                this.bindingsExternal.push([sHTMLType, sBinding, control, sValue]);
                delete this.bindings[sBinding];
                break;
            }
        }
        return false;
    }

    /**
     * setFocus(fScroll)
     *
     * @this {Videox86}
     * @param {boolean} [fScroll]
     */
    setFocus(fScroll)
    {
        if (this.inputScreen) {
            this.inputScreen.focus();
            if (fScroll) {
                let element = document.getElementById(this.idMachine) || this.inputScreen;
                element.scrollIntoView();
            }
        }
    }

    /**
     * getScreen()
     *
     * This is an interface used by the Mouse component, so that it can capture mouse events from the screen.
     *
     * @this {Videox86}
     * @param {Mouse} [mouse]
     * @returns {Object|undefined}
     */
    getScreen(mouse)
    {
        this.mouse = mouse;
        return this.inputScreen;
    }

    /**
     * getTextArea()
     *
     * This is an interface used by the Computer component, so that it can display resource status messages.
     *
     * @this {Videox86}
     * @returns {HTMLTextAreaElement|undefined}
     */
    getTextArea()
    {
        return this.inputTextArea;
    }

    /**
     * getTextData()
     *
     * This is an interface used by the Keyboard component, to obtain a plain-text copy of any currently visible text,
     * usually for the purpose of copying it to the clipboard.
     *
     * To keep the function simple and relieve ourselves of some tedious calculations, such as the current visible start
     * address within the frame buffer, we rely on the cell cache, which conveniently mirrors all visible cells as of the
     * last screen refresh.  The only caveat is that the cell cache may be over-buffering by one entire column and row,
     * but that's easily accounted for (eg, every row must step through nColsBuffer -- not merely nCols -- of cell data).
     *
     * @this {Videox86}
     * @returns {string}
     */
    getTextData()
    {
        let s = "", i = 0;
        if (this.nCardFont) {
            for (let row = 0; row < this.nRows; row++) {
                let line = "";
                for (let col = 0; col < this.nColsBuffer; col++) {
                    if (col < this.nCols) {
                        let code = this.aCellCache[i] & 0xff;
                        line += CharSet.CP437[code];    // String.fromCharCode(code);
                    }
                    i++;
                }
                s += line.replace(/\s*$/, "\n");
            }
        }
        return s;
    }

    /**
     * goFullScreen()
     *
     * @this {Videox86}
     * @returns {boolean} true if request successful, false if not (eg, failed OR not supported)
     */
    goFullScreen()
    {
        let fSuccess = false;
        if (this.container) {
            if (this.container.doFullScreen) {
                /**
                 * Styling the container with a width of "100%" and a height of "auto" works great when the aspect ratio
                 * of our virtual screen is at least roughly equivalent to the physical screen's aspect ratio, but now that
                 * we support virtual VGA screens with an aspect ratio of 1.33, that's very much out of step with modern
                 * wide-screen monitors, which usually have an aspect ratio of 1.6 or greater.
                 *
                 * And unfortunately, none of the browsers I've tested appear to make any attempt to scale our container to
                 * the physical screen's dimensions, so the bottom of our screen gets clipped.  To prevent that, I reduce
                 * the width from 100% to whatever percentage will accommodate the entire height of the virtual screen.
                 *
                 * NOTE: Mozilla recommends both a width and a height of "100%", but all my tests suggest that using "auto"
                 * for height works equally well, so I'm sticking with it, because "auto" is also consistent with how I've
                 * implemented a responsive canvas when the browser window is being resized.
                 */
                let sWidth = "100%";
                let sHeight = "auto";
                if (screen && screen.width && screen.height) {
                    let aspectPhys = screen.width / screen.height;
                    let aspectVirt = this.cxScreen / this.cyScreen;
                    if (aspectPhys > aspectVirt) {
                        sWidth = Math.round(aspectVirt / aspectPhys * 100) + '%';
                    }
                    // TODO: We may need to someday consider the case of a physical screen with an aspect ratio < 1.0....
                }
                if (!this.fStyleCanvasFullScreen) {
                    this.container.style.width = sWidth;
                    this.container.style.height = sHeight;
                } else {
                    /**
                     * Sadly, the above code doesn't work for Firefox (nor for Chrome, as of Chrome 75 or so), because as:
                     *
                     *      http://developer.mozilla.org/en-US/docs/Web/Guide/API/DOM/Using_full_screen_mode
                     *
                     * explains:
                     *
                     *      'It's worth noting a key difference here between the Gecko and WebKit implementations at this time:
                     *      Gecko automatically adds CSS rules to the element to stretch it to fill the screen: "width: 100%; height: 100%".
                     *
                     * Which would be OK if Gecko did that BEFORE we're called, but apparently it does that AFTER, effectively
                     * overwriting our careful calculations.  So we style the inner element (canvasScreen) instead, which
                     * requires even more work to ensure that the canvas is properly centered.  FYI, this solution is consistent
                     * with Mozilla's recommendation for working around their automatic CSS rules:
                     *
                     *      '[I]f you're trying to emulate WebKit's behavior on Gecko, you need to place the element you want
                     *      to present inside another element, which you'll make fullscreen instead, and use CSS rules to adjust
                     *      the inner element to match the appearance you want.'
                     */
                    this.canvasScreen.style.width = sWidth;
                    this.canvasScreen.style.height = sHeight;
                    this.canvasScreen.style.display = "block";
                    this.canvasScreen.style.margin = "auto";
                }
                this.container.style.backgroundColor = this.colorScreen;
                this.container.doFullScreen();
                fSuccess = true;
            }
            this.setFocus();
        }
        return fSuccess;
    }

    /**
     * notifyFullScreen(fFullScreen)
     *
     * @this {Videox86}
     * @param {boolean} [fFullScreen] (undefined if there was a full-screen error)
     */
    notifyFullScreen(fFullScreen)
    {
        if (!fFullScreen && this.container) {
            if (!this.fStyleCanvasFullScreen) {
                this.container.style.width = this.container.style.height = "";
            } else {
                this.canvasScreen.style.width = this.canvasScreen.style.height = "";
            }
        }
        if (DEBUG) this.printf("notifyFullScreen(%b)\n", fFullScreen);
        if (this.kbd) this.kbd.notifyEscape(fFullScreen == true);
    }

    /**
     * lockPointer()
     *
     * @this {Videox86}
     * @param {boolean} fLock
     * @returns {boolean} true if request successful, false if not (eg, failed OR not supported)
     */
    lockPointer(fLock)
    {
        let fSuccess = false;
        if (this.inputScreen && this.mouse) {
            if (fLock) {
                if (this.inputScreen.lockPointer) {
                    this.inputScreen.lockPointer();
                    this.mouse.notifyPointerLocked(true);
                    fSuccess = true;
                }
            } else {
                if (this.inputScreen.unlockPointer) {
                    this.inputScreen.unlockPointer();
                    this.mouse.notifyPointerLocked(false);
                    fSuccess = true;
                }
            }
            this.setFocus();
        }
        return fSuccess;
    }

    /**
     * notifyPointerActive(fActive)
     *
     * @this {Videox86}
     * @param {boolean} fActive
     * @returns {boolean} true if autolock enabled AND pointer lock supported, false if not
     */
    notifyPointerActive(fActive)
    {
        if (this.fAutoLock) {
            return this.lockPointer(fActive);
        }
        return false;
    }

    /**
     * notifyPointerLocked(fLocked)
     *
     * @this {Videox86}
     * @param {boolean} fLocked
     */
    notifyPointerLocked(fLocked)
    {
        if (this.mouse) {
            this.mouse.notifyPointerLocked(fLocked);
            if (this.kbd) this.kbd.notifyEscape(fLocked);
        }
        let control = this.bindings["lockPointer"];
        if (control) control.textContent = (fLocked? "Press Esc to Unlock Pointer" : this.sLockMessage);
    }

    /**
     * captureTouch(nTouchConfig)
     *
     * @this {Videox86}
     * @param {number} nTouchConfig (must be one of the supported Videox86.TOUCH values)
     */
    captureTouch(nTouchConfig)
    {
        let control = this.inputScreen;
        if (control) {
            let video = this;
            if (!this.nTouchConfig) {

                this.nTouchConfig = nTouchConfig;

                let addPassive = false;
                if (nTouchConfig != Videox86.TOUCH.MOUSE) {
                    /**
                     * If we're not capturing touch events for mouse event simulation, then we won't be calling
                     * preventDefault(), which means we should tell Chrome and any other browser that supports
                     * passive event listeners that we're installing a "passive" event listener, so that the browser
                     * won't suspend us during `touchstart` and `touchmove` events.  But in order to know whether
                     * the browser supports that feature, we have to probe for it first.
                     */
                    try {
                        let opts = Object.defineProperty({}, 'passive', {
                            /* eslint getter-return: ["off"] */
                            get: function() {
                                addPassive = true;
                            }
                        });
                        window.addEventListener("testPassive", null, opts);
                        window.removeEventListener("testPassive", null, opts);
                    } catch (e) {
                    }
                }

                control.addEventListener(
                    'touchstart',
                    function onTouchStart(event) {
                        video.onTouchStart(event);
                    },
                    addPassive? {passive: true} : false
                );

                if (nTouchConfig == Videox86.TOUCH.DEFAULT) {
                    return;
                }

                control.addEventListener(
                    'touchmove',
                    function onTouchMove(event) {
                        video.onTouchMove(event);
                    },
                    addPassive? {passive: true} : true
                );

                control.addEventListener(
                    'touchend',
                    function onTouchEnd(event) {
                        video.onTouchEnd(event);
                    },
                    false                   // we'll specify false for the 'useCapture' parameter for now...
                );

                /**
                 * Using desktop mouse events to simulate touch events should only be enabled as needed.
                 */
                if (MAXDEBUG) {
                    control.addEventListener(
                        'mousedown',
                        function onMouseDown(event) {
                            video.onTouchStart(event);
                        },
                        false               // we'll specify false for the 'useCapture' parameter for now...
                    );
                    control.addEventListener(
                        'mousemove',
                        function onMouseMove(event) {
                            video.onTouchMove(event);
                        },
                        true
                    );
                    control.addEventListener(
                        'mouseup',
                        function onMouseUp(event) {
                            video.onTouchEnd(event);
                        },
                        false               // we'll specify false for the 'useCapture' parameter for now...
                    );
                }

                // this.printf(MESSAGE.LOG, "touch events captured\n");

                this.xTouch = this.yTouch = this.timeTouch = -1;

                /**
                 * As long as fTouchDefault is false, we call preventDefault() on every touch event, to prevent
                 * the page from moving/scrolling while the canvas is processing touch events.  However, there must
                 * also be exceptions to permit the soft keyboard to activate; see processTouchEvent() for details.
                 */
                this.fTouchDefault = false;

                /**
                 * I also need to come up with some rules for when the simulated mouse's primary button stays down.
                 * Let's try setting a timeout handler whenever a touchstart is received, which we'll immediately cancel
                 * as soon as a touchmove or touchend event is received, and if the timeout handler fires, we'll set
                 * fLongTouch to true.
                 */
                this.hLongTouch = null;
                this.fLongTouch = false;
                this.onLongTouch = function onLongTouch() {
                    video.startLongTouch();
                };
            }
        }
    }

    /**
     * onFocusChange(fFocus)
     *
     * @this {Videox86}
     * @param {boolean} fFocus is true if gaining focus, false if losing it
     */
    onFocusChange(fFocus)
    {
        /**
         * As per http://stackoverflow.com/questions/6740253/disable-scrolling-when-changing-focus-form-elements-ipad-web-app,
         * I decided to try this work-around to prevent the webpage from scrolling around whenever the canvas is given
         * focus.  That sort of scrolling-into-view sounds great in principle, but in practice, if you were reading some other
         * portion of the page, it can be irritating to be scrolled away from that portion when refreshing/returning to the page.
         *
         * However, this work-around doesn't seem to work with the latest version of Safari (or else I misunderstood something).
         *
         *  if (fFocus) {
         *      window.scrollTo(0, 0);
         *      document.body.scrollTop = 0;
         *  }
         */
        this.fHasFocus = fFocus;
        if (this.kbd) this.kbd.onFocusChange(fFocus);
    }

    /**
     * onTouchStart(event)
     *
     * @this {Videox86}
     * @param {Event} event object from a 'touch' event
     */
    onTouchStart(event)
    {
        if (DEBUG) this.printf("onTouchStart()\n");
        this.chipset.startAudio(event);
        if (this.nTouchConfig == Videox86.TOUCH.DEFAULT) return;
        this.processTouchEvent(event, true);
    }

    /**
     * onTouchMove(event)
     *
     * @this {Videox86}
     * @param {Event} event object from a 'touch' event
     */
    onTouchMove(event)
    {
        if (DEBUG) this.printf("onTouchMove()\n");
        this.processTouchEvent(event);
    }

    /**
     * onTouchEnd(event)
     *
     * @this {Videox86}
     * @param {Event} event object from a 'touch' event
     */
    onTouchEnd(event)
    {
        if (DEBUG) this.printf("onTouchEnd()\n");
        this.processTouchEvent(event, false);
    }

    /**
     * processTouchEvent(event, fStart)
     *
     * If nTouchConfig is non-zero, touch event handlers are installed, which pass their events to this function.
     *
     * What we do with those events here depends on the value of nTouchConfig.  Originally, the only supported
     * configuration was the experimental conversion of touch events into arrow keys, based on an invisible grid
     * that divided the screen into thirds; that configuration is now identified as Videox86.TOUCH.KEYGRID.
     *
     * The new preferred configuration is Videox86.TOUCH.MOUSE, which does little more than allow you to "push" the
     * simulated mouse around.  If Videox86.TOUCH.MOUSE is enabled, it's already been confirmed the machine has a mouse.
     *
     * @this {Videox86}
     * @param {Event|MouseEvent|TouchEvent} event object from a 'touch' event
     * @param {boolean} [fStart] (true if 'touchstart', false if 'touchend', undefined if 'touchmove')
     */
    processTouchEvent(event, fStart)
    {
        let xTouch, yTouch;

        // if (!event) event = window.event;

        /**
         * Touch coordinates (that is, the pageX and pageY properties) are relative to the page, so to make
         * them relative to the canvas, we must subtract the canvas's left and top positions.  This Apple web page:
         *
         *      https://developer.apple.com/library/safari/documentation/AudioVideo/Conceptual/HTML-canvas-guide/AddingMouseandTouchControlstoCanvas/AddingMouseandTouchControlstoCanvas.html
         *
         * makes it sound simple, but it turns out we have to walk the canvas' entire "parentage" of DOM elements
         * to get the exact offsets.
         *
         * TODO: Determine whether the getBoundingClientRect() code used in panel.js for mouse events can also
         * be used here to simplify this annoyingly complicated code for touch events.
         */
        let xTouchOffset = 0;
        let yTouchOffset = 0;
        let eCurrent = this.canvasScreen;

        do {
            if (!isNaN(eCurrent.offsetLeft)) {
                xTouchOffset += eCurrent.offsetLeft;
                yTouchOffset += eCurrent.offsetTop;
            }
        } while ((eCurrent = eCurrent.offsetParent));

        /**
         * Due to the responsive nature of our pages, the displayed size of the canvas may be smaller than the
         * allocated size, and the coordinates we receive from touch events are based on the currently displayed size.
         */
        let xScale = this.cxScreen / this.canvasScreen.offsetWidth;
        let yScale = this.cyScreen / this.canvasScreen.offsetHeight;

        /**
         * @name Event
         * @property {Array} targetTouches
         */
        if (!event.targetTouches || !event.targetTouches.length) {
            xTouch = event.pageX;
            yTouch = event.pageY;
        } else {
            xTouch = event.targetTouches[0].pageX;
            yTouch = event.targetTouches[0].pageY;
        }

        xTouch = ((xTouch - xTouchOffset) * xScale);
        yTouch = ((yTouch - yTouchOffset) * yScale);

        if (this.nTouchConfig == Videox86.TOUCH.KEYGRID) {

            /**
             * We don't want to simulate a key on EVERY touch event; preferably, only touchstart or touchend.  And
             * I probably would have preferred triggering key presses on touchend, so that if you decided to move
             * your finger off-screen before releasing, you could avoid a key press, but sadly (as I've documented in
             * the Mandelbot project; see https://github.com/jeffpar/mandelbot/blob/master/src/mandelbot.js),
             * touchend doesn't reliably provide coordinates on all platforms, so we're going to go with touchstart.
             */
            if (fStart) {

                let xThird = (xTouch / (this.cxScreen / 3)) | 0;
                let yThird = (yTouch / (this.cyScreen / 3)) | 0;

                /**
                 * At this point, xThird and yThird should both be one of 0, 1 or 2, indicating which horizontal and
                 * vertical third of the virtual screen the touch event occurred.
                 */
                this.kbd.addActiveKey(Videox86.KEYGRID[yThird][xThird], true);
            }
        } else {

            if (this.mouse) {
                /**
                 * As long as fTouchDefault is false, we call preventDefault() on every touch event, to keep
                 * the page stable.  However, we must allow some touch event(s) to perform their default action,
                 * otherwise the soft keyboard can never be activated.  So if a touchstart occurs at least 1/2
                 * second (500ms) after the last touchstart, with no intervening touchmove events, fTouchDefault
                 * is allowed to become true.
                 */
                let fTouchDefault = this.fTouchDefault;
                let timeDelta = event.timeStamp - this.timeTouch;

                if (fStart === true) {
                    this.fTouchDefault = (timeDelta > 500);
                    this.timeTouch = event.timeStamp;
                    this.hLongTouch = setTimeout(this.onLongTouch, 500);
                } else {
                    if (this.hLongTouch != null) {
                        clearTimeout(this.hLongTouch);
                        this.hLongTouch = null;
                    }
                }

                if (fStart === undefined) {
                    this.fTouchDefault = false;
                }

                if (DEBUG) this.printf("processTouchEvent(%s,%dms,%b)\n", (fStart? "touchStart" : (fStart === false? "touchEnd" : "touchMove")), timeDelta, fTouchDefault);

                if (!fTouchDefault) {
                    event.preventDefault();
                }

                if (fStart === false) {
                    /**
                     * NOTE: 200ms is merely my initial stab at a reasonable number of milliseconds to interpret a
                     * start/end touch sequence as a "tap"; I also make no note of any intervening move events (ie,
                     * events where fStart is undefined), and perhaps I should....
                     */
                    if (this.endLongTouch()) {
                        return;
                    }
                    if (timeDelta < 200) {
                        this.mouse.clickMouse(Mouse.BUTTON.LEFT, true);
                        this.mouse.clickMouse(Mouse.BUTTON.LEFT, false);
                        return;
                    }
                }
                /**
                 * This 'touchmove" code mimics the 'mousemove' event processing in processMouseEvent() in mouse.js, with
                 * one important difference: every time touching "restarts", we need to reset the variables used to calculate
                 * the deltas, so that the mere act of lifting and replacing your finger doesn't generate a delta by itself.
                 */
                if (fStart || this.xTouch < 0 || this.yTouch < 0) {
                    this.xTouch = xTouch;
                    this.yTouch = yTouch;
                }
                let xDelta = Math.round(xTouch - this.xTouch);
                let yDelta = Math.round(yTouch - this.yTouch);
                this.xTouch = xTouch;
                this.yTouch = yTouch;
                // this.printf("moveMouse(%d,%d)\n", xDelta, yDelta);
                this.mouse.moveMouse(xDelta, yDelta, this.xTouch, this.yTouch);
            }
        }
    }

    /**
     * startLongTouch()
     *
     * @this {Videox86}
     */
    startLongTouch()
    {
        this.fLongTouch = true;
        this.mouse.clickMouse(Mouse.BUTTON.LEFT, true);
    }

    /**
     * endLongTouch()
     *
     * @this {Videox86}
     * @returns {boolean} true if long touch was active, false if not
     */
    endLongTouch()
    {
        if (this.fLongTouch) {
            this.mouse.clickMouse(Mouse.BUTTON.LEFT, false);
            this.fLongTouch = false;
            return true;
        }
        return false;
    }

    /**
     * powerUp(data, fRepower)
     *
     * @this {Videox86}
     * @param {Object|null} data
     * @param {boolean} [fRepower]
     * @returns {boolean} true if successful, false if failure
     */
    powerUp(data, fRepower)
    {
        if (!fRepower) {
            if (!data || !this.restore) {
                this.reset();
            } else {
                if (!this.restore(data)) return false;
            }
            if (this.timerRetrace == undefined) {
                /**
                 * Note that startVerticalRetrace() will fire every nCyclesVertPeriod, ensuring predictability
                 * and repeatability regardless of the machine's current speed multiplier or the whether the machine
                 * is achieving the desired target number of cycles per second.
                 *
                 * The only downside is that when the machine is recalibrating (or the multiplier is being increased),
                 * we may be called more than 60Hz (msUpdateNormal or 16.667ms).  So we don't allow the next update
                 * until at least msUpdateInterval has passed.  msUpdateInterval is initialized to msUpdateNormal, but
                 * can be increased if the updates are taking too long (eg, too many on-screen changes).
                 */
                this.msUpdateNormal = (1000 / Videox86.UPDATES_PER_SECOND)|0;
                this.msUpdateInterval = this.msUpdateNormal;
                this.msUpdatePrev = this.cmsUpdate = 0;

                let video = this;
                this.timerRetrace = this.cpu.addTimer(this.id, function startVerticalRetrace() {
                    let card = video.cardActive;
                    /**
                     * The following code is a work-around for IBM's VGA diagnostic code starting at C000:01E5,
                     * which expects an entire screen refresh (ie, 400 horizontal retraces followed by 1 vertical
                     * retrace) to take roughly 1/30 of a second instead of 1/60.  The longer vertical retrace
                     * period may be due to some idiosyncrasy of how they programmed the card beforehand, I'm not
                     * sure.  But I do know that they've turned on the SEQ.CLKMODE.SCREEN_OFF bit, so I use that
                     * bit to trigger this work-around, which involves skipping every other (odd) vertical retrace
                     * timeout here, and cutting the corresponding number of elapsed cycles in getRetraceBits()
                     * by half.
                     *
                     * If we don't do this, then the card generates an annoying series of beeps every time the
                     * machine resets.  TODO: Figure out why the VGA diagnostic takes more time on real hardware.
                     */
                    card.nCountVertRetrace++;
                    if (card.nCard === Videox86.CARD.VGA) {
                        if (card.regSEQData[Card.SEQ.CLKMODE.INDX] & Card.SEQ.CLKMODE.SCREEN_OFF) {
                            if (card.nCountVertRetrace & 1) {
                                return;
                            }
                        }
                    }
                    card.nCyclesVertRetrace = video.cpu.getCycles();
                    if (DEBUG) video.printf(MESSAGE.VIDEO + MESSAGE.TIMER, "vertical retrace timer fired (%d cycles)\n", card.nCyclesVertRetrace);
                    if (video.nIRQ) {
                        if (!(card.regCRTData[Card.CRTC.EGA.VREND.INDX] & Card.CRTC.EGA.VREND.DISABLE_VRINT)) {
                            if (video.chipset) video.chipset.setIRR(video.nIRQ);
                        }
                    }
                    /**
                     * For simplicity, let's imagine that the normal screen update interval is 15ms.  If retraces are
                     * happening a bit too fast (eg, every 10ms), we'll skip the update on the first retrace, do it on
                     * the second retrace, skip on the third, and so on.  That's clearly too many skips, so when we
                     * do the second retrace, we should "bank" the extra 5ms by rewinding msUpdatePrev that amount.
                     * Just make sure we never "bank" too much (for example, on the first update, when msUpdatePrev is
                     * zero).
                     */
                    let msUpdate = Date.now();
                    let msDelta = (msUpdate - video.msUpdatePrev) - video.msUpdateInterval;
                    if (msDelta >= 0) {
                        let fUpdated = video.updateScreen();
                        if (fUpdated) {
                            let cmsUpdate = Date.now() - msUpdate;
                            /**
                             * Make sure that the modulo number here is always a multiple of the blink modulo in
                             * updateScreen(), so that we don't create blink irregularity every time we reset our
                             * average update time (cmsUpdate).
                             */
                            if (video.cUpdates % 120 == 1) {
                                video.cUpdates = 1;
                                video.cmsUpdate = cmsUpdate;
                            } else {
                                video.cmsUpdate += cmsUpdate;
                                cmsUpdate = video.cmsUpdate / video.cUpdates;
                            }
                            /**
                             * If cmsUpdate is taking more than 25% of the update interval (eg, 4ms of a 16ms interval),
                             * then we want to increase the interval, so that updates are a smaller percentage of the overall
                             * workload.
                             */
                            if (cmsUpdate >= video.msUpdateInterval / 4) {
                                video.msUpdateInterval = video.msUpdateNormal * 2;
                            }
                            else if (cmsUpdate < video.msUpdateNormal / 4) {
                                video.msUpdateInterval = video.msUpdateNormal;
                            }
                        }
                        video.msUpdatePrev = msUpdate - (msDelta >= video.msUpdateInterval? 0 : msDelta);
                    }
                    else if (DEBUG) {
                        video.printf(MESSAGE.VIDEO + MESSAGE.TIMER, "skipping update (%dms too soon)\n", -msDelta);
                    }
                    video.latchStartAddress();
                }, -this.cardActive.nCyclesVertPeriod);
            }
        }
        return true;
    }

    /**
     * powerDown(fSave, fShutdown)
     *
     * This is where we might add some method of blanking the display, without the disturbing the video
     * buffer contents, and blocking all further updates to the display.
     *
     * @this {Videox86}
     * @param {boolean} [fSave]
     * @param {boolean} [fShutdown]
     * @returns {Object|boolean} component state if fSave; otherwise, true if successful, false if failure
     */
    powerDown(fSave, fShutdown)
    {
        return fSave? this.save() : true;
    }

    /**
     * reset()
     *
     * @this {Videox86}
     */
    reset()
    {
        let nMonitorType = ChipSet.MONITOR.NONE;

        /**
         * We'll ask the ChipSet what SW1 indicates for monitor type, but we may override it if a specific
         * video card model is set.  For EGA, SW1 is supposed to be set to indicate NO monitor, and we rely
         * on the EGA's own switch settings instead.
         */
        if (this.chipset) {
            nMonitorType = this.chipset.getDIPVideoMonitor();
        }

        /**
         * As we noted in the constructor, when a model is specified, that takes precedence over any monitor
         * switch settings.  Conversely, when no model is specified, the nCard setting is considered provisional,
         * so the monitor switch settings, if any, are allowed to determine the card type.
         */
        if (!Videox86.MODEL[this.model]) {
            this.nCard = (nMonitorType == ChipSet.MONITOR.MONO? Videox86.CARD.MDA : Videox86.CARD.CGA);
        }

        let aMonitors;
        this.nModeDefault = Videox86.MODE.CGA_80X25;

        switch (this.nCard) {
        case Videox86.CARD.VGA:
            nMonitorType = ChipSet.MONITOR.VGACOLOR;
            break;

        case Videox86.CARD.EGA:
            aMonitors = Videox86.aEGAMonitorSwitches[this.bEGASwitches];
            /**
             * TODO: Figure out how to deal with aMonitors[2], the boolean which indicates
             * whether the EGA is driving the primary monitor (true) or the secondary monitor (false).
             */
            if (aMonitors) nMonitorType = aMonitors[0];
            if (!nMonitorType) {
                nMonitorType = ChipSet.MONITOR.EGACOLOR;
                break;
            }
            if (nMonitorType != ChipSet.MONITOR.MONO) break;
            /* falls through */

        case Videox86.CARD.MDA:
            nMonitorType = ChipSet.MONITOR.MONO;
            this.nModeDefault = Videox86.MODE.MDA_80X25;
            break;

        case Videox86.CARD.CGA:
            /* falls through */

        default:
            nMonitorType = ChipSet.MONITOR.COLOR;
            break;
        }

        if (this.nMonitorType !== nMonitorType) {
            this.nMonitorType = nMonitorType;
        }

        this.cardActive = null;
        this.cardMono = this.cardMDA = new Card(this, Videox86.CARD.MDA);
        this.cardColor = this.cardCGA = new Card(this, Videox86.CARD.CGA);

        if (this.nCard < Videox86.CARD.EGA) {
            this.cardEGA = new Card();      // define a dummy (uninitialized) EGA card for now
        }
        else {
            this.cardEGA = new Card(this, this.nCard, null, this.cbMemory);
            this.enableEGA();
        }

        this.nMode = null;
        this.setMode(this.nModeDefault);

        if (this.cardActive.addrBuffer && this.nRandomize) {
            /**
             * On the initial power-on, we initialize the video buffer to random characters, as a way of testing
             * whether our font(s) were successfully loaded.  It's assumed that our default display mode is a text mode,
             * and that since this is a reset, the CRTC.START_ADDR registers are zero as well.
             *
             * If this is an MDA device, then the buffer should reside at 0xB0000 through 0xB0FFF, for a total length
             * of 4Kb (0x1000), where every even byte contains a character code, and every odd byte contains an attribute
             * code.  See the ATTR bit definitions above for applicable color, intensity, and blink values.  On a CGA
             * device, the buffer resides at 0xB8000 through 0xBBFFF, for a total length of 16Kb.
             *
             * Note that the only valid MDA display mode (7) is the 80x25 text mode, which uses 4000 bytes (2000 character
             * bytes + 2000 attribute bytes), not all 4096 bytes; addrScreenLimit reflects the visible limit, not the
             * physical limit.  Also, as noted in updateScreen(), this simplistic calculation of the extent of visible
             * screen memory is valid only for text modes; in general, it's safer to use cardActive.sizeBuffer as the extent.
             */
            let addrScreenLimit = this.cardActive.addrBuffer + this.cbScreen;
            for (let addrScreen = this.cardActive.addrBuffer; addrScreen < addrScreenLimit; addrScreen += 2) {
                let dataRandom = (Math.random() * 0x10000) | 0;
                let bChar, bAttr;
                if (this.nMonitorType == ChipSet.MONITOR.EGACOLOR || this.nMonitorType == ChipSet.MONITOR.VGACOLOR) {
                    /**
                     * For the EGA, we choose sequential characters; for random characters, copy the MDA/CGA code below.
                     */
                    bChar = (addrScreen >> 1) & 0xff;
                    bAttr = (dataRandom >> 8) & ~Videox86.ATTRS.BGND_BLINK;    // TODO: turn blink attributes off unless we can ensure blinking is initially disabled
                    if ((bAttr >> 4) == (bAttr & 0xf)) {
                        bAttr ^= 0x0f;      // if background matches foreground, invert foreground to ensure character visibility
                    }
                } else {
                    bChar = dataRandom & 0xff;
                    bAttr = ((dataRandom & 0x100)?
                        (Videox86.ATTRS.FGND_WHITE | Videox86.ATTRS.BGND_BLACK) :
                        (Videox86.ATTRS.FGND_BLACK | Videox86.ATTRS.BGND_WHITE)) | ((Videox86.ATTRS.FGND_BRIGHT /* | Videox86.ATTRS.BGND_BLINK */) & (dataRandom >> 8));
                }
                this.bus.setShortDirect(addrScreen, bChar | (bAttr << 8));
            }
            this.updateScreen(true);
        }
    }

    /**
     * enableEGA()
     *
     * Redirect cardMono or cardColor to cardEGA as appropriate.
     *
     * @this {Videox86}
     */
    enableEGA()
    {
        if (!(this.cardEGA.regMisc & Card.MISC.IO_SELECT)) {
            this.cardMono = this.cardEGA;
            this.cardColor = this.cardCGA;  // this is done mainly to siphon away any CGA I/O
        } else {
            this.cardMono = this.cardMDA;   // similarly, this is done to siphon away any MDA I/O
            this.cardColor = this.cardEGA;
        }
    }

    /**
     * save()
     *
     * This implements save support for the Video component.
     *
     * @this {Videox86}
     * @returns {Object}
     */
    save()
    {
        let state = new State(this);
        state.set(0, this.cardMDA.saveCard());
        state.set(1, this.cardCGA.saveCard());
        state.set(2, [this.nMonitorType, this.nModeDefault, this.nMode]);
        state.set(3, this.cardEGA.saveCard());
        return state.data();
    }

    /**
     * restore(data)
     *
     * This implements restore support for the Video component.
     *
     * @this {Videox86}
     * @param {Object} data
     * @returns {boolean} true if successful, false if failure
     */
    restore(data)
    {
        let a = data[2];
        this.nMonitorType = a[0];
        this.nModeDefault = a[1];
        this.nMode = a[2];

        this.cardActive = null;
        this.cardMono = this.cardMDA = new Card(this, Videox86.CARD.MDA, data[0]);
        this.cardColor = this.cardCGA = new Card(this, Videox86.CARD.CGA, data[1]);

        /**
         * If no EGA was originally initialized, then cardEGA will remain uninitialized.
         */
        this.cardEGA = new Card(this, this.nCard, data[3], this.cbMemory);
        if (this.cardEGA.fActive) this.enableEGA();

        /**
         * While I could restore the active card here, it's better for setMode() to do it, because
         * setMode() will also take care of mapping the appropriate video buffer.  So, after restore() has
         * finished, we call checkMode(), because the current video mode (nMode) is determined by the
         * active card state.
         *
         * Unfortunately, that creates a chicken-and-egg problem, since I just said I didn't want to select
         * the active card here.
         *
         * So, we'll add some "cop-out" code to checkMode(): if there's no active card, then fall-back
         * to the last known video mode (nMode) and force a call to setMode().
         *
         *      this.cardActive = (this.cardMDA.fActive? this.cardMDA : (this.cardCGA.fActive? this.cardCGA : undefined));
         */
        if (!this.checkMode()) return false;

        this.checkCursor();
        return true;
    }

    /**
     * doneLoad(sURL, sFontData, nErrorCode)
     *
     * @this {Videox86}
     * @param {string} sURL
     * @param {string} sFontData
     * @param {number} nErrorCode (response from server if anything other than 200)
     */
    doneLoad(sURL, sFontData, nErrorCode)
    {
        if (nErrorCode) {
            this.printf(nErrorCode < 0? MESSAGE.STATUS : MESSAGE.NOTICE, "Unable to load font ROM (error %d: %s)\n", nErrorCode, sURL);
            return;
        }

        Component.addMachineResource(this.idMachine, sURL, sFontData);

        try {
            /**
             * The most likely source of any exception will be right here, where we're parsing the JSON-encoded data.
             */
            let abFontData = eval("(" + sFontData + ")");

            let ab = /** @type {Array} */ (abFontData['bytes'] || (abFontData['width'] == 8 && abFontData['values']) || abFontData);

            if (!ab || !ab.length) {
                Component.error("Unsupported font ROM: " + sURL);
                return;
            }
            else if (ab.length == 1) {
                Component.error(ab[0]);
                return;
            }
            /**
             * Translate the character data into separate "fonts", each of which will be a separate canvas object, with all
             * 256 characters arranged in a 16x16 grid.
             */
            if (ab.length == 8192) {
                /**
                 * The assumption here is that we're dealing with the original (IBM) MDA/CGA font data, which apparently
                 * was identical on both MDA and CGA cards (even though the former had no use for the latter, and vice versa).
                 *
                 * First, let's take a look at the MDA portion of the data.  Here are the first few rows of MDA font data,
                 * at the 0K and 2K boundaries:
                 *
                 *      00000000  00 00 00 00 00 00 00 00  00 00 7e 81 a5 81 81 bd  |..........~.....|
                 *      00000010  00 00 7e ff db ff ff c3  00 00 00 36 7f 7f 7f 7f  |..~........6....|
                 *      ...
                 *      00000800  00 00 00 00 00 00 00 00  99 81 7e 00 00 00 00 00  |..........~.....|
                 *      00000810  e7 ff 7e 00 00 00 00 00  3e 1c 08 00 00 00 00 00  |..~.....>.......|
                 *
                 * 8 bytes of data from a row in each of the 2K chunks are combined to form a 8-bit wide character with
                 * a maximum height of 16 bits.  Assembling the bits for character 0x01 (a happy face), we observe the following:
                 *
                 *      0 0 0 0 0 0 0 0  <== 00 from offset 0x0008
                 *      0 0 0 0 0 0 0 0  <== 00 from offset 0x0009
                 *      0 1 1 1 1 1 1 0  <== 7e from offset 0x000A
                 *      1 0 0 0 0 0 0 1  <== 81 from offset 0x000B
                 *      1 0 1 0 0 1 0 1  <== a5 from offset 0x000C
                 *      1 0 0 0 0 0 0 1  <== 81 from offset 0x000D
                 *      1 0 0 0 0 0 0 1  <== 81 from offset 0x000E
                 *      1 0 1 1 1 1 0 1  <== bd from offset 0x000F
                 *      1 0 0 1 1 0 0 1  <== 99 from offset 0x0808
                 *      1 0 0 0 0 0 0 1  <== 81 from offset 0x0809
                 *      0 1 1 1 1 1 1 0  <== 7e from offset 0x080A
                 *      0 0 0 0 0 0 0 0  <== 00 from offset 0x080B
                 *      0 0 0 0 0 0 0 0  <== 00 from offset 0x080C
                 *      0 0 0 0 0 0 0 0  <== 00 from offset 0x080D
                 *      0 0 0 0 0 0 0 0  <== 00 from offset 0x080E
                 *      0 0 0 0 0 0 0 0  <== 00 from offset 0x080F
                 *
                 * In the second 2K chunk, we observe that the last two bytes of every font cell definition are zero;
                 * this confirms our understanding that MDA font cell size is 8x14.
                 *
                 * Finally, there's the issue of screen cell size, which is actually 9x14 on the MDA.  We compensate for that
                 * by building a 9x14 font, even though there's only 8x14 bits of data. As http://www.seasip.info/VintagePC/mda.html
                 * explains:
                 *
                 *      "For characters C0h-DFh, the ninth pixel column is a duplicate of the eighth; for others, it's blank."
                 *
                 * This last point is confirmed by "The IBM Personal Computer From The Inside Out", p.295:
                 *
                 *      "Another unique feature of the monochrome adapter is a set of line-drawing and area-fill characters
                 *      that give continuous lines and filled areas. This is unusual for a display with a 9x14 character box
                 *      because the character generator provides a row only eight dots wide. On most displays, a blank 9th
                 *      dot is then inserted between characters. On the monochrome display, there is circuitry that duplicates
                 *      the 8th dot into the 9th dot position for characters whose ASCII codes are 0xB0 [sic] through 0xDF."
                 *
                 * However, the above text is mistaken about the start of the range.  While there ARE line-drawing characters
                 * in the range 0xB0-0xBF, none of them extend all the way to the right edge; IBM carefully segregated them.
                 * And in fact, characters 0xB0-0xB2 contain hash patterns that you would NOT want extended into the 9th column.
                 *
                 * The CGA font is part of the same ROM.  In fact, there are TWO CGA fonts in the ROM: a thin 5x7 "single dot"
                 * font located at offset 0x1000, and a thick 7x7 "double dot" font at offset 0x1800.  The latter is the default
                 * font, unless overridden by a jumper setting on the CGA card, so it is our default CGA font as well (although
                 * someday we may provide a virtual jumper setting that allows you to select the thinner font).
                 *
                 * The first offset we must pass to setFontData() is the offset of the CGA font; we choose the thicker "double dot"
                 * CGA font at 0x1800 (which was the PC's default font as well), instead of the thinner "single dot" font at 0x1000.
                 * The second offset is for the MDA font.
                 */
                this.setFontData(ab, [0x1800, 0x0000]);
            }
            else if (ab.length == 2048) {
                /**
                 * The assumption here is that we're dealing strictly with CGA (8x8) font data, like the font data found
                 * in the Columbia Data Products (CDP) Font ROM.
                 */
                this.setFontData(ab, [0x0000]);
            }
            else {
                this.printf(MESSAGE.NOTICE, "Unrecognized font data length (%d)\n", ab.length);
                return;
            }

        } catch (e) {
            this.printf(MESSAGE.NOTICE, "Font ROM data error: %s\n", e.message);
            return;
        }
        /**
         * If we're still here, then we're ready!
         *
         * UPDATE: Per issue #21 (https://github.com/jeffpar/pcjs.v1/issues/21), I issued setReady() *only* if a valid
         * contextScreen existed *or* a debugger was attached, and decided to consider a more general-purpose solution for
         * whether or not the user wanted to run in a "headless" mode at a later date.
         *
         * Well, that later date is now, and since pc.js always runs machines in a "headless" mode, we're going to always
         * mark ourselves ready.
         *
         *      if (this.contextScreen || this.dbg) this.setReady();
         */
        this.setReady();
    }

    /**
     * onROMLoad(abRom, aParms)
     *
     * Called by the ROM's copyROM() function whenever a ROM component with a 'notify' attribute containing
     * our component ID has been loaded.
     *
     * @this {Videox86}
     * @param {Array.<number>} abROM
     * @param {Array.<number>} [aParms]
     */
    onROMLoad(abROM, aParms)
    {
        if (this.nCard == Videox86.CARD.EGA) {
            /**
             * TODO: Unlike the MDA/CGA font data, we may want to hang onto this data, so that we can
             * regenerate the color font(s) whenever the foreground and/or background colors have changed.
             */
            if (DEBUG) this.printf("onROMLoad(): EGA fonts loaded\n");
            /**
             * For EGA cards, in the absence of any parameters, we assume that we're receiving the original
             * IBM EGA ROM, which stores its 8x14 font data at 0x2230 as one continuous sequence; the total size
             * of the 8x14 font is 0xE00 bytes.
             *
             * At 0x3030, there is an "ALPHA SUPPLEMENT" table, which contains 15 bytes per row instead of 14,
             * because each row is preceded by one byte containing the corresponding ASCII code; there are 20
             * entries in the supplemental table, for a total size of 0x12C bytes.
             *
             * Finally, at 0x3160, we have the 8x8 font data (also known as the thicker "double dot" CGA font);
             * the total size of the 8x8 font is 0x800 bytes.  No other font data is present in the EGA ROM;
             * the thin 5x7 "single dot" CGA font is notably absent, which is fine, because we never loaded it for
             * the MDA/CGA either.
             *
             * TODO: Determine how the supplemental table is used and whether we need to add some "run-time"
             * font generation to support it (as opposed to "init-time" generation, which is all we do now).
             * There's probably a similar need for user-defined fonts; for now, they're simply not supported.
             */
            this.setFontData(abROM, aParms || [0x3160, 0x2230], 8);
        }
        else if (this.nCard == Videox86.CARD.VGA) {
            if (DEBUG) this.printf("onROMLoad(): VGA fonts loaded\n");
            /**
             * For VGA cards, in the absence of any parameters, we assume that we're receiving the original
             * IBM VGA ROM, which contains an 8x14 font at 0x3F8D (and corresponding supplemental table at 0x4D8D)
             * and an 8x8 font at 0x378D; however, it also contains an 8x16 font at 0x4EBA (and corresponding
             * supplemental table at 0x5EBA).  See our reconstructed source code in:
             *
             *      /machines/pcx86/ibm/video/vga/1986-10-27/IBM-VGA.asm
             */
            this.setFontData(abROM, aParms || [0x378d, 0x3f8d, 0x4eba], 8);
        }
        this.setReady();
    }

    /**
     * setFontData(abFontData, aFontOffsets, cxFontChar)
     *
     * To support partial font rebuilds (required for the EGA), we now preserve the original font data (abFontData),
     * font offsets (aFontOffsets), and font character width (8 for the EGA, undefined for the MDA/CGA).
     *
     * TODO: Ultimately, we want to have exactly one dedicated font for the EGA, the data for which we'll read directly
     * from plane 2 of video memory, instead of relying on the original font data in ROM.  Relying on the ROM data was
     * originally just a crutch to help get EGA support bootstrapped.
     *
     * Also, for the MDA/CGA, we should be discarding the font data after the first buildFont() call, because we
     * should never need to rebuild the fonts for those cards (both their font patterns and colors were hard-coded).
     *
     * @this {Videox86}
     * @param {Array.<number>} abFontData is the raw font data, from the ROM font file
     * @param {Array.<number>} aFontOffsets contains offsets into abFontData: [0] for CGA, [1] for MDA/EGA, and [2] for VGA
     * @param {number} [cxFontChar] is a fixed character width to use for all fonts; undefined to use MDA/CGA defaults
     */
    setFontData(abFontData, aFontOffsets, cxFontChar)
    {
        this.abFontData = abFontData;
        this.aFontOffsets = aFontOffsets;
        this.cxFontChar = cxFontChar;
    }

    /**
     * getCardColors(nBitsPerPixel)
     *
     * @this {Videox86}
     * @param {number} [nBitsPerPixel]
     * @returns {Array}
     */
    getCardColors(nBitsPerPixel)
    {
        if (nBitsPerPixel == 1) {
            /**
             * Only 2 total colors.
             */
            this.aRGB[0] = Videox86.aCGAColors[Videox86.ATTRS.FGND_BLACK];
            this.aRGB[1] = this.getFontColor(Videox86.aCGAColors, Videox86.ATTRS.FGND_WHITE);
            return this.aRGB;
        }

        if (nBitsPerPixel == 2) {
            /**
             * Of the 4 colors returned, the first color comes from regColor and the other 3 come from one of
             * the two hard-coded CGA color sets:
             *
             *      Color Set 0             Color Set 1
             *      -----------------       -----------------
             *      Background (0x00)       Background (0x00)
             *      Green      (0x02)       Cyan       (0x03)
             *      Red        (0x04)       Magenta    (0x05)
             *      Brown      (0x06)       White      (0x07)
             *
             * The numbers in parentheses are the EGA ATC palette register values that the EGA BIOS uses for each
             * color set; I rely on those numbers to synthesize a fake CGA regColor value.
             */
            let regColor = this.cardActive.regColor;
            if (this.cardActive === this.cardEGA) {
                let bBackground = this.cardEGA.regATCData[0];
                regColor = bBackground & Card.CGA.COLOR.BORDER;
                if (bBackground & Card.ATC.PALETTE.BRIGHT) regColor |= Card.CGA.COLOR.BRIGHT;
                if ((this.cardEGA.regATCData[1] & 0x0f) == 0x03) regColor |= Card.CGA.COLOR.COLORSET1;
            }
            this.aRGB[0] = this.getFontColor(Videox86.aCGAColors, regColor & (Card.CGA.COLOR.BORDER | Card.CGA.COLOR.BRIGHT));
            let aColorSet = (regColor & Card.CGA.COLOR.COLORSET1)? Videox86.aCGAColorSet1 : Videox86.aCGAColorSet0;
            for (let iColor = 0; iColor < aColorSet.length; iColor++) {
                this.aRGB[iColor + 1] = this.getFontColor(Videox86.aCGAColors, aColorSet[iColor]);
            }
            return this.aRGB;
        }

        if (this.cardColor === this.cardCGA) {
            for (let iColor = 0; iColor < Videox86.aCGAColors.length; iColor++) {
                this.aRGB[iColor] = this.getFontColor(Videox86.aCGAColors, iColor);
            }
            return this.aRGB;
        }



        if (this.fRGBValid && nBitsPerPixel && !this.aRGB[16]) {
            this.fRGBValid = false;
        }

        if (!this.fRGBValid) {

            let card = this.cardEGA;
            let aDAC = card.regDACData;
            let aRegs, i, dw, b, bRed, bGreen, bBlue;

            if (nBitsPerPixel == 8) {
                /**
                 * The card must be a VGA, and it's using an (8bpp) mode that bypasses the ATC, so we need to pull
                 * RGB data exclusively from the 256-entry DAC; each entry contains 6-bit red, green, and blue values
                 * packed into bits 0-5, 6-11, and 12-17, respectively, each of which we effectively shift left 2 bits:
                 * a crude 6-to-8-bit color conversion.
                 */
                for (i = 0; i < 256; i++) {
                    dw = aDAC[i] || 0;

                    bRed = (dw << 2) & 0xfc;
                    bGreen = (dw >> 4) & 0xfc;
                    bBlue = (dw >> 10) & 0xfc;
                    this.aRGB[i] = [bRed, bGreen, bBlue, 0xff];
                }
            } else {
                /**
                 * We need to pull RGB data from the ATC; moreover, if the ATC hasn't been initialized yet,
                 * we go with a default EGA-compatible 16-color palette.  We'll also use the DAC if there is one
                 * (ie, this is actually a VGA) and it appears to be initialized (ie, the VGA BIOS has been run).
                 */
                let fDAC = (aDAC && aDAC[255] != null);
                aRegs = (card.regATCData[15] != null? card.regATCData : Videox86.aEGAPalDef);
                for (i = 0; i < 16; i++) {
                    b = aRegs[i] & Card.ATC.PALETTE.MASK;
                    /**
                     * If the DAC is valid, we need to supplement the 6 bits of each ATC palette entry with the values
                     * for bits 6 and 7 from the ATC COLORSEL register (and overwrite bits 4 and 5 if ATC.MODE.COLORSEL_ALL
                     * is set as well).
                     *
                     * The only reasons the DAC wouldn't be valid are if 1) we're trying to display an image before the machine
                     * and its BIOS have had a chance to initialize the DAC (because we don't preset it to anything, although
                     * perhaps we should), or 2) this is an EGA, which doesn't have a DAC.
                     */
                    if (fDAC) {
                        b |= (card.regATCData[Card.ATC.COLORSEL.INDX] & (Card.ATC.COLORSEL.DAC_BIT7 | Card.ATC.COLORSEL.DAC_BIT6)) << 4;
                        if (card.regATCData[Card.ATC.MODE.INDX] & Card.ATC.MODE.COLORSEL_ALL) {
                            b &= ~0x30;
                            b |= (card.regATCData[Card.ATC.COLORSEL.INDX] & (Card.ATC.COLORSEL.DAC_BIT5 | Card.ATC.COLORSEL.DAC_BIT4)) << 4;
                        }

                        dw = aDAC[b];

                        bRed = (dw << 2) & 0xfc;
                        bGreen = (dw >> 4) & 0xfc;
                        bBlue = (dw >> 10) & 0xfc;
                    } else {
                        bRed = (((b & 0x04)? 0xaa : 0) | ((b & 0x20)? 0x55 : 0));
                        bGreen = (((b & 0x02)? 0xaa : 0) | ((b & 0x10)? 0x55 : 0));
                        bBlue = (((b & 0x01)? 0xaa : 0) | ((b & 0x08)? 0x55 : 0));
                    }
                    this.aRGB[i] = [bRed, bGreen, bBlue, 0xff];
                }
            }
            this.fRGBValid = true;
        }

        return this.aRGB;
    }

    /**
     * getFontColor(aColors, iColor)
     *
     * If no 'fontColor' property override was specified, then this function simply returns the iColor entry
     * in aColors.
     *
     * Otherwise, we convert iColor to a signed value, where zero represents fontColor, negative values represent
     * darker shades, and positive values represent lighter shades.  Next, since rgbFont already contains the RGB
     * values from 'fontColor', we find the smallest and largest values in rgbFont (NOTE: these min and max values
     * should really be cached).  Those values tell us how many times we can decrement or increment all the RGB
     * values in unison, changing the intensity of the color without changing the hue.  We then calculate an RGB
     * value corresponding to iColor.
     *
     * @this {Videox86}
     * @param {Array} aColors
     * @param {number} iColor
     * @returns {Array}
     */
    getFontColor(aColors, iColor)
    {
        if (!this.colorFont) {
            return aColors[iColor];
        }
        let nColors = aColors.length;
        let nRange = (nColors >> 1);
        /**
         * When nColors is 16, nRange is 8, and iColor (originally 0-15) is now -7 to 8
         */
        iColor = (iColor + 1) - nRange;
        if (!iColor) {
            return this.rgbFont;
        }
        let rgb = [0x00, 0x00, 0x00, 0xff];
        let i, nDelta, nMin = 0xff, nMax = 0;
        for (i = 0; i < 3; i++) {
            if (nMin > this.rgbFont[i]) nMin = this.rgbFont[i];
            if (nMax < this.rgbFont[i]) nMax = this.rgbFont[i];
        }
        if (iColor < 0) {
            nDelta = nMax / (nRange - 1);       // NOTE: Since I now use nMax instead of nMin here, we could just drop nMin
        } else {
            nDelta = (0x100 - nMax) / nRange;
        }
        for (i = 0; i < 3; i++) {
            rgb[i] = (this.rgbFont[i] + nDelta * iColor)|0;
            if (rgb[i] < 0) rgb[i] = 0;
            if (rgb[i] > 0xff) rgb[i] = 0xff;
        }
        return rgb;
    }

    /**
     * getIntenseColor(rgb)
     *
     * Determine the maximum amount we can adjust all RGB entries by without overflowing, and return a new RGB array.
     *
     * @this {Videox86}
     * @param {Array} rgb
     * @returns {Array}
     */
    getIntenseColor(rgb)
    {
        let rgbIntense = rgb.slice();
        let i, j = 0;
        for (i = 0; i < 3; i++) {
            if (j < rgb[i]) {
                j = rgb[i];
            }
        }
        for (i = 0; i < 3; i++) {
            rgbIntense[i] += 0xff - j;
        }
        return rgbIntense;
    }

    /**
     * getSelectedFonts()
     *
     * @this {Videox86}
     * @returns {number} (low byte is "SELB" font number, used when attribute bit 3 is 0; high byte is "SELA" font number)
     */
    getSelectedFonts()
    {
        let bSelect = this.cardEGA.regSEQData[Card.SEQ.CHARMAP.INDX];
        if (this.nCard < Videox86.CARD.VGA) {
            bSelect &= (Card.SEQ.CHARMAP.SELA | Card.SEQ.CHARMAP.SELB);
        }
        if (!(this.cardEGA.regSEQData[Card.SEQ.MEMMODE.INDX] & Card.SEQ.MEMMODE.EXT)) {
            bSelect &= ~(Card.SEQ.CHARMAP.SELA | Card.SEQ.CHARMAP.SELB);
        }
        let nFontSelect0 = (bSelect & Card.SEQ.CHARMAP.SELB) | ((bSelect & Card.SEQ.CHARMAP.SELB_HI) >> 2);
        let nFontSelect1 = ((bSelect & Card.SEQ.CHARMAP.SELA) >> 2) | ((bSelect & Card.SEQ.CHARMAP.SELA_HI) >> 3);
        return nFontSelect0 | (nFontSelect1 << 8);
    }

    /**
     * buildFont(fRebuild)
     *
     * buildFont() is called whenever the Video component is reset or restored; we used to build fonts as soon as
     * the ROM containing them was loaded, and then throw away the underlying font data, but with the EGA's ability
     * to change the color or content of any font, font building must now be deferred until the reset or restore
     * notifications, ensuring we have access to the card's colors and other programmed state.
     *
     * We're also called whenever setDimensions() must update character cell dimensions and whenever EGA palette
     * registers are modified, in case one or more font colors changed.
     *
     * Calls to buildFont() should not be expensive though: the underlying createFont() function rebuilds a font only
     * if one or more of the following is true:
     *
     *  1) the font shape has changed (usually accompanied by a font data change)
     *  2) the font colors have changed (only affected colors are rebuilt, if there are no other changes)
     *  3) the font data has changed (EGA and VGA only, based on plane 2 changes recorded in bitsDirtyBanks)
     *
     * @this {Videox86}
     * @param {boolean} [fRebuild] (true if this is a rebuild; default is false)
     * @returns {boolean}
     */
    buildFont(fRebuild = false)
    {
        let fChanges = false;
        this.nActiveFont = this.nAlternateFont = this.nCardFont;

        /**
         * There's no point building fonts unless we're in a windowed (non-command-line) environment, we're
         * in a font-based mode (nCardFont is set), and font data has been supplied (or can be extracted from RAM).
         */
        if (globals.browser && this.nCardFont) {

            /**
             * Build whatever font(s) we need for the current card.  In the case of the EGA/VGA, that can mean up to
             * 4 fonts, if all four font "banks" in plane 2 have been loaded with font data, but if we don't yet know
             * which bank is active, we'll build the default font, using the available font data (ie, abFontData).
             */
            let nFonts = 0;
            let abFontData = this.abFontData;

            let aRGBColors, aColorMap;
            if (this.nCardFont == Videox86.CARD.MDA || this.nMonitorType == ChipSet.MONITOR.MONO) {
                if (!this.colorFont) {
                    aRGBColors = Videox86.aMDAColors;
                } else {
                    /**
                     * When overriding MDA colors, we take rgbFont to be the "normal" color (aMDAColors indices 1 and 2), and
                     * then calculate the MDA's corresponding "intense" color (aMDAColors indices 3 and 4) using getIntenseColor().
                     */
                    aRGBColors = Videox86.aMDAColors.slice();              // start with a copy of aMDAColors
                    aRGBColors[1] = aRGBColors[2] = this.rgbFont;
                    aRGBColors[3] = aRGBColors[4] = this.getIntenseColor(this.rgbFont);
                }
                aColorMap = Videox86.aMDAColorMap;
            } else {
                aRGBColors = this.getCardColors();
            }

            let cxChar, cyChar, offData, bitsBanks, cx, cy;

            switch (this.nCardFont) {
            case Videox86.CARD.MDA:
                if (this.aFontOffsets[1] != null) {
                    if (this.createFont(this.nCardFont, this.cxFontChar || 9, 14, this.aFontOffsets[1], this.cxFontChar? 0 : 0x0800, abFontData, false, aRGBColors, aColorMap)) {
                        fChanges = true;
                    }
                }
                break;

            case Videox86.CARD.CGA:
                if (this.aFontOffsets[0] != null) {
                    if (this.createFont(this.nCardFont, this.cxFontChar || 8, 8, this.aFontOffsets[0], 0x0000, abFontData, false, aRGBColors, aColorMap)) {
                        fChanges = true;
                    }
                }
                break;

            case Videox86.CARD.VGA:
                nFonts += 4;
                /* falls through */

            case Videox86.CARD.EGA:
                nFonts += 4;
                cxChar = this.cxFontChar || 8;
                cyChar = 14;
                offData = this.aFontOffsets[1];
                if (this.aFontOffsets[2]) {
                    cyChar = 16;
                    offData = this.aFontOffsets[2];
                }
                bitsBanks = 0;
                cx = (this.cardEGA.regSEQData[Card.SEQ.CLKMODE.INDX] & Card.SEQ.CLKMODE.DOTS8)? 8 : 9;
                cy = (this.cardEGA.regCRTData[Card.CRTC.MAXSCAN] & Card.CRTCMASKS[Card.CRTC.MAXSCAN]);
                if (cy++) {
                    cxChar = cx;
                    cyChar = cy;
                    offData = 0;
                    abFontData = null;
                    if ((bitsBanks = this.cardEGA.bitsDirtyBanks)) {
                        if (DEBUG) this.printf("buildFont(%b): dirty font data detected (%#04X)\n", fRebuild, bitsBanks);
                        this.cardEGA.bitsDirtyBanks = 0;
                    }
                    this.nFontSelect = this.getSelectedFonts();
                    this.nActiveFont = this.nCardFont + (this.nFontSelect & 0xff);
                    this.nAlternateFont = this.nCardFont + (this.nFontSelect >> 8);
                }
                if (offData != null) {
                    /**
                     * Logical fonts 0-3 (0-7 on the VGA) refer to banks in the following order: 0, 2, 4, 6, 1, 3, 5, 7.
                     *
                     * Note that we no longer build all possible fonts; we build ONLY those fonts that are currently selectable.
                     */
                    for (let nShift = 0, iFontPrev = -1; nShift < 16; nShift += 8) {
                        let iFont = (this.nFontSelect >> nShift) & 0xff;
                        if (iFont == iFontPrev) continue;
                        iFontPrev = iFont;
                        let iBank = (iFont << 1) - (iFont < 4? 0 : 7);
                        if (!abFontData) offData = iBank * 8192;
                        let fNewData = !!(bitsBanks & (0x1 << iBank));
                        if (this.createFont(this.nCardFont + iFont, cxChar, cyChar, offData, 0, abFontData, fNewData, aRGBColors, aColorMap)) {
                            fChanges = true;
                            if (abFontData || !iFont) continue;
                            for (let iFontPrev = 0; iFontPrev < iFont; iFontPrev++) {
                                this.createFontDiff(iFont, iFontPrev, cyChar);
                            }
                        }
                    }
                }
                break;
            }

            if (!fRebuild) {
                /**
                 * Perform some additional initialization common to both reset() and restore() sequences.
                 */
                this.iCellCursor = -1;  // initially, there is no visible cursor cell
                this.cBlinks = -1;      // initially, blinking is not active
                this.cBlinkVisible = 0; // no visible blinking characters (yet)
            }

            if (DEBUG && fChanges) this.printf("buildFont(%b): font changes detected\n", fRebuild);
        }

        return fChanges;
    }

    /**
     * createFont(nFont, cxChar, cyChar, offData, offSplit, abFontData, fNewData, aRGBColors, aColorMap)
     *
     * All color variations are stored on the same font canvas, arranged vertically as a series of grids, where each
     * grid is a 16x16 character glyph array.
     *
     * Since every character must be drawn first with its background color and then with the foreground shape on top,
     * I used to include a series of empty cells at the top every font canvas containing all supported background colors
     * (ie, before the character grids).  But now createFont() also creates an aCSSColors array that is saved alongside
     * the font canvas, and updateChar() uses that array in conjunction with fillRect() to draw character backgrounds.
     *
     * @this {Videox86}
     * @param {number} nFont
     * @param {number} cxChar is the width of the font characters
     * @param {number} cyChar is the height of the font characters
     * @param {number} offData is the offset of the font data
     * @param {number} offSplit is the offset of any split font data, or zero if not split
     * @param {Array.<number>|null} abFontData is the raw font data, from the ROM font file
     * @param {boolean} fNewData (true if abFontData contains potentially modified data, false if not)
     * @param {Array} aRGBColors is an array of color RGB variations, corresponding to supported FGND attribute values
     * @param {Array} [aColorMap] contains color indexes corresponding to attribute values (if not supplied, the mapping is assumed to be 1-1)
     * @returns {boolean} true if any or all fonts were (re)created, false if nothing changed
     */
    createFont(nFont, cxChar, cyChar, offData, offSplit, abFontData, fNewData, aRGBColors, aColorMap)
    {
        let fChanges = false;
        let font = this.aFonts[nFont];
        let nColors = (aRGBColors.length < 16? aRGBColors.length : 16);

        if (!font || nColors != font.aRGBColors.length) {
            font = {
                cxChar:     cxChar,
                cyChar:     cyChar,
                cxCell:     0,
                cyCell:     0,
                aCSSColors: new Array(nColors),
                aRGBColors: aRGBColors.slice(0, nColors),   // make a copy of aRGBColors using slice()
                aColorMap:  aColorMap,
                aCanvas:    new Array(nColors)
            };
        }

        let nDouble = (this.fDoubleFont? 1 : 0);
        let cxCell = cxChar << nDouble;
        let cyCell = cyChar << nDouble;

        let fNewShape = false;
        if (font.cxCell != cxCell || font.cyCell != cyCell) {
            font.cxChar = cxChar;
            font.cyChar = cyChar;
            font.cxCell = cxCell;
            font.cyCell = cyCell;
            fNewShape = true;
        }

        for (let iColor = 0; iColor < nColors; iColor++) {
            let rgbColor = aRGBColors[iColor];
            /**
             * If any of the font's shape, data, or color has changed, then recreate it.  Also, we don't need to check
             * for a color change if we already know there was a shape or data change.
             */
            let fChanged = fNewShape || fNewData;
            if (!fChanged) {
                let rgbColorOrig = font.aCSSColors[iColor]? font.aRGBColors[iColor] : [];
                fChanged = (rgbColor[0] !== rgbColorOrig[0] || rgbColor[1] !== rgbColorOrig[1] || rgbColor[2] !== rgbColorOrig[2]);
            }
            if (fChanged) {
                if (!this.createFontColor(font, iColor, rgbColor, nDouble, offData, offSplit, cxChar, cyChar, abFontData)) {
                    if (DEBUG) this.printf("createFont(%d): no font data found\n", nFont);

                    font = null;
                    break;
                }
                if (DEBUG) {
                    if (!fChanges) {
                        this.printf("createFont(%d): creating %s font (%d,%d)\n", nFont, Videox86.cardSpecs[this.nCardFont][0], cxChar, cyChar);
                    }
                    this.printf("createFontColor(%d): [%s]\n", iColor, rgbColor);
                }
                fChanges = true;
            }
        }

        if (fChanges || font != this.aFonts[nFont]) {
            if (this.aDiagContexts.length) {
                let contextDst = this.aDiagContexts[nFont - this.nCardFont];
                if (contextDst) {
                    let canvasDst = contextDst.canvas;
                    if (!font) {
                        contextDst.fillStyle = "black";
                        contextDst.fillRect(0, 0, canvasDst.width, canvasDst.height);
                    }
                    else {
                        let cxDstColor = (canvasDst.width / nColors) | 0;
                        let cyDstColor = canvasDst.height;
                        let aspectDst = canvasDst.width / canvasDst.height;
                        for (let iColor = 0; iColor < nColors; iColor++) {
                            let canvasSrc = font.aCanvas[iColor];
                            contextDst.fillStyle = font.aCSSColors[(iColor + 9) % nColors];
                            contextDst.fillRect(iColor * cxDstColor, 0, cxDstColor, cyDstColor);
                            /**
                             * We want to draw whatever vertical slice of the font canvas will fit in the destination slice
                             * without altering the aspect ratio.  So the source and destination heights will be 100% of their
                             * respective canvases, while the source width will be multiplied by the ratio of the heights and
                             * then chopped.
                             */
                            let ratioHeight = canvasDst.height / canvasSrc.height;
                            let cxSrc = (canvasSrc.width * ratioHeight) | 0;
                            if (cxSrc > cxDstColor) cxSrc = cxDstColor;
                            let cySrc = canvasSrc.height;
                            contextDst.drawImage(canvasSrc, 0, 0, cxSrc, cySrc, iColor * cxDstColor, 0, cxDstColor, cyDstColor);
                        }
                    }
                }
            }
        }

        this.aFonts[nFont] = font;
        return fChanges;
    }

    /**
     * createFontColor(font, iColor, rgbColor, nDouble, offData, offSplit, cxChar, cyChar, abFontData)
     *
     * Now we're ready to create a 16x16 character grid for the specified color.  Note that all
     * the character bits are opaque (alpha=0xff) while all the surrounding bits are transparent
     * (alpha=0x00, as specified in the 4th byte of rgbOff).
     *
     * Originally, I created 256 ImageData objects, using context.createImageData(cxChar,cyChar),
     * then setting its pixels to match those of an individual character, and then drawing characters
     * with contextFont.putImageData().  But putImageData() is relatively slow....
     *
     * Now I create a new canvas, with dimensions that allow me to arrange all 256 characters in an
     * 16x16 grid -- much like the "chargen.png" bitmap used in the C1Pjs version of the Video component.
     * Then drawing becomes much the same as before, because it turns out that drawImage() accepts either
     * an image object OR a canvas object.
     *
     * This also yields better performance, since drawImage() is much faster than putImageData().
     * We still have to use putImageData() to build the font canvas, but that's a one-time operation.
     *
     * @this {Videox86}
     * @param {Font} font
     * @param {number} iColor
     * @param {Array} rgbColor contains the RGB values for iColor
     * @param {number} nDouble is 1 to double output font dimensions, 0 to match input dimensions
     * @param {number} offData is the offset of the font data
     * @param {number} offSplit is the offset of any split font data, or zero if not split
     * @param {number} cxChar is the width of the font characters
     * @param {number} cyChar is the height of the font characters
     * @param {Array.<number>|null} abFontData is the raw font data, from the ROM font file
     * @returns {boolean} true if font created, false if not
     */
    createFontColor(font, iColor, rgbColor, nDouble, offData, offSplit, cxChar, cyChar, abFontData)
    {
        /**
         * If abFontData is null, we will use font data from plane 2 of video memory, which has a "hard-wired" layout
         * of 32 bytes per character (which, for 256 characters, amounts to 8Kb).  Note that on an EGA, up to 4 font
         * "banks" can be stored in plane 2, since each EGA font bank has a "hard-wired" length of 16Kb, whereas on a VGA,
         * up to 8 font banks can be stored in plane 2, since each VGA font bank has a "hard-wired" length of 8Kb;
         * for backward compatibility with the EGA, the VGA's additional 4 font banks are interleaved with the EGA's
         * original 4 font banks.
         */
        let iChar;
        let y;
        let x;
        let cyLimit = 32;
        let adwMemory = this.cardActive && this.cardActive.adwMemory;
        if (abFontData) {
            cyLimit = (cyChar < 8 || !offSplit)? cyChar : 8;
        }
        else {
            /**
             * When font data must be extracted from VRAM (instead of the supplied abFontData), we first do a "pre-scan"
             * to see if any font data actually exists.  For example. the video card's BIOS might zero ALL the font banks
             * (thereby making them "dirty") but then load only the first bank.
             *
             * NOTE: While this might also be a good time compare the font data to a cached copy, to see if anything has
             * actually changed, hopefully that won't be necessary, because we should already be skipping the entire font
             * creation process if the font bank (as indicated by offData) hasn't been marked "dirty" and nothing else
             * about the font (eg, shape, color) has changed either.
             */
            for (iChar = 0; iChar < 256; iChar++) {
                let offChar = offData + iChar * cyLimit;
                for (y = 0; y < cyChar; y++) {
                    let b = (adwMemory[offChar + y] >> 16) & 0xff;
                    if (b) break;
                }
                if (y < cyChar) break;
            }
            if (iChar == 256) {
                return false;
            }
        }

        let rgbOff = [0x00, 0x00, 0x00, 0x00];

        /**
         * Let's take a moment to see if we already have a suitable canvasFont that we can simply reuse.
         */
        let canvasFont = font.aCanvas[iColor];
        if (!canvasFont || canvasFont.width != font.cxCell << 4 || canvasFont.height != font.cyCell << 4) {
            canvasFont = document.createElement("canvas");
            canvasFont.width = font.cxCell << 4;
            canvasFont.height = font.cyCell << 4;
        }
        let contextFont = canvasFont.getContext("2d");
        let imageChar = contextFont.createImageData(font.cxCell, font.cyCell);

        for (iChar = 0; iChar < 256; iChar++) {
            let offChar = offData + iChar * cyLimit;
            for (y = 0; y < cyChar; y++) {
                /**
                 * fUnderline should be true only in the FONT_MDA case, and only for the odd color variations
                 * (1 and 3, out of variations 0 to 4), and only for the second-from-bottom row of the character cell
                 * (based on images from actual MDA hardware).
                 */
                let fUnderline = (font.aColorMap && (iColor & 0x1) && y == cyChar - 2);
                let offScan = (y < cyLimit? offChar + y : offSplit + iChar * cyLimit + y - cyLimit);

                /**
                 * If abFontData is null, then we must extract the next byte of font data from plane 2 of video memory.
                 */
                let b = abFontData? abFontData[offScan] : ((adwMemory[offScan] >> 16) & 0xff);

                for (let nRowDoubler = 0; nRowDoubler <= nDouble; nRowDoubler++) {
                    for (x = 0; x < cxChar; x++) {
                        /**
                         * This "bit" of logic takes care of those characters (0xC0-0xDF) whose 9th bit must mirror the 8th bit;
                         * in all other cases, any bit past the 8th bit is automatically zero.  It also takes care of embedding a
                         * solid row of bits whenever fUnderline is true.
                         *
                         * TODO: For EGA/VGA, replication of the 9th dot needs to be based on the TEXT_9DOT bit of the ATC.MODE
                         * register, which is particularly important for user-defined fonts that do not want that bit replicated.
                         */
                        let bit = (fUnderline? 1 : (b & (0x80 >> (x >= 8 && iChar >= 0xC0 && iChar <= 0xDF? 7 : x))));
                        let xDst = (x << nDouble);
                        let yDst = (y << nDouble) + nRowDoubler;
                        let rgb = (bit? rgbColor : rgbOff);
                        this.setPixel(imageChar, xDst, yDst, rgb);
                        if (nDouble) this.setPixel(imageChar, xDst + 1, yDst, rgb);
                    }
                }
            }
            /**
             * (iChar >> 4) is the equivalent of Math.floor(iChar / 16), and (iChar & 0xf) is the equivalent of (iChar % 16).
             */
            contextFont.putImageData(imageChar, x = (iChar & 0xf) * font.cxCell, y = (iChar >> 4) * font.cyCell);
        }
        /**
         * The colors for cell backgrounds and cursor elements must be converted to CSS color strings.
         */
        font.aCSSColors[iColor] = StrLib.sprintf("#%02X%02X%02X", rgbColor[0], rgbColor[1], rgbColor[2]);
        font.aRGBColors[iColor] = rgbColor;
        font.aCanvas[iColor] = canvasFont;
        return true;
    }

    /**
     * createFontDiff(iFont, iFontPrev, cyChar, cyLimit)
     *
     * Since a programmable font was changed, we need to update the aFontDiff array.  For the EGA,
     * that array looks like this:
     *
     *      [0]: diffs between font 1 and 0     0 = 1 * (1 - 1) / 2
     *      [1]: diffs between font 2 and 0     1 = 2 * (2 - 1) / 2
     *      [2]: diffs between font 2 and 1
     *      [3]: diffs between font 3 and 0     3 = 3 * (3 - 1) / 2
     *      [4]: diffs between font 3 and 1
     *      [5]: diffs between font 3 and 2
     *
     * The VGA continues that progression:
     *
     *      [6]: diffs between font 4 and 0     6 = 4 * (4 - 1) / 2
     *      [7]: diffs between font 4 and 1
     *      [8]: diffs between font 4 and 2
     *      [9]: diffs between font 4 and 3
     *      ...
     *
     * So for a given logical font number (0-3 for the EGA or 0-7 for the VGA), the starting index of
     * "differable" fonts is n * (n - 1) / 2.
     *
     * @this {Videox86}
     * @param {number} iFont
     * @param {number} iFontPrev
     * @param {number} cyChar (height of every character in both fonts)
     * @param {number} [cyLimit] (default is 32)
     */
    createFontDiff(iFont, iFontPrev, cyChar, cyLimit = 32)
    {

        let i = ((iFont * (iFont - 1)) >> 1) + iFontPrev;
        let adwMemory = this.cardEGA.adwMemory;
        let aDiff = this.aFontDiff[i] || new Array(256);
        let iBank = (iFont << 1) - (iFont < 4? 0 : 7), offData = iBank * 8192;
        let iBankPrev = (iFontPrev << 1) - (iFontPrev < 4? 0 : 7), offDataPrev = iBankPrev * 8192;
        for (let iChar = 0; iChar < 256; iChar++) {
            aDiff[iChar] = 0;
            let offChar = offData + iChar * cyLimit, offCharPrev = offDataPrev + iChar * cyLimit;
            for (let y = 0; y < cyChar; y++) {
                if (((adwMemory[offChar++] >> 16) & 0xff) !== ((adwMemory[offCharPrev++] >> 16) & 0xff)) {
                    aDiff[iChar] = -1;
                    break;
                }
            }
        }
        this.aFontDiff[i] = aDiff;
    }

    /**
     * getFontDiff(iFont, iFontPrev)
     *
     * Unlike createFontDiff(), where iFontPrev is guaranteed to be less than iFont, that may not be true
     * for getFontDiff(), so we must swap them if iFont < iFontPrev.
     *
     * @this {Videox86}
     * @param {number} iFont
     * @param {number} iFontPrev
     * @returns {Array.<number>}
     */
    getFontDiff(iFont, iFontPrev)
    {
        let a = [];
        if (iFont != iFontPrev) {
            let i;
            if (iFont < iFontPrev) {
                i = iFont;
                iFont = iFontPrev;
                iFontPrev = i;
            }
            i = ((iFont * (iFont - 1)) >> 1) + iFontPrev;
            a = this.aFontDiff[i];

        }
        return a;
    }

    /**
     * checkBlink()
     *
     * Called at the end of every updateScreenText(), which may have updated cBlinkVisible to a non-zero value.
     *
     * Also called at the end of every checkCursor(); ie, whenever the CRT register(s) affecting the position or shape
     * of the hardware cursor have been modified, and any of iCellCursor, yCursor or cyCursor have been modified as a result.
     *
     * Note that the cursor always blinks when it's ON; it can only be turned OFF, moved off-screen, or its rate set to half
     * the normal blink rate (by default, it blinks at the normal blink rate).  Bits 5-6 of the CRTC.CURSCAN register can
     * be set as follows:
     *
     *    00: Cursor blinks at normal blink rate
     *    01: Cursor is off
     *    10: (Same as 00)
     *    11: Cursor blinks at half the normal blink rate
     *
     * According to documentation, the normal blink rate is 1/16 of the frame rate (8 frames on, 8 off).
     *
     * TODO: As an aside, I've observed in the "real world" that the MDA cursor cycles about 3 times per second, and by "cycle"
     * I mean one full off-and-on-again cycle.  I'm assuming that's the normal rate (00), not the slower "half rate" (11).
     * Since that's faster than our current cursor blink rate, we should look into an option to boost our rate, without adversely
     * affecting the attribute blink rate (which is currently hard-coded at half the cursor blink rate), and we should look into
     * supporting "half rate" blinking, too.
     *
     * @this {Videox86}
     * @returns {boolean} true if there are things to blink, false if not
     */
    checkBlink()
    {
        if (this.cBlinkVisible > 0 || this.iCellCursor >= 0) {
            if (this.cBlinks < 0) {
                this.cBlinks = 0;
                /**
                 * At this point, we can either fire up our own timer (doBlink), or rely on updateScreen() being
                 * called by the CPU at regular bursts (eg, Videox86.UPDATES_PER_SECOND = 60) and advance cBlinks at
                 * the start of updateScreen() accordingly.
                 *
                 * doBlink() wants to increment cBlinks every 266ms.  On the other hand, if updateScreen() is being
                 * called 60 times per second, that's about once every 16ms, so if every 16th updateScreen() increments
                 * cBlinks, cBlinks should advance at the same rate.
                 *
                 * One side-effect of relying on the CPU driving our blink count is that whenever the CPU is halted
                 * (eg, by our Debugger) all blinking stops -- all characters with the blink attribute AND the cursor.
                 *
                 * But that's more consistent with how we halt everything else (eg, the PITs, RTC, etc); our Debugger
                 * halts the entire machine, not just the CPU.
                 *
                 *      this.doBlink(true);
                 */
            }
            return true;
        }
        this.cBlinks = -1;
        return false;
    }

    /**
     * checkCursor()
     *
     * Called whenever a CRT data register is updated, since there are multiple registers that can affect the
     * visibility of the cursor (more than these, actually, but I'm going to limit my initial support to standard
     * ROM BIOS controller settings):
     *
     *      CRTC.MAXSCAN
     *      CRTC.CURSCAN
     *      CRTC.CURSCANB
     *      CRTC.STARTHI
     *      CRTC.STARTLO
     *      CRTC.CURSORHI
     *      CRTC.CURSORLO
     *
     * The top of the cursor starts at CURSCAN, and the bottom is CURSCANB - 1, except that if CURSCAN == CURSCANB
     * (or more precisely, if CURSCAN == CURSCANB mod 16), then a single scan line is still drawn.  Also, on cards
     * older than VGA, if CURSCANB < CURSCAN, a split cursor is drawn.
     *
     * Also, at least on the EGA, if CURSCANB is set to a value > MAXSCAN (typically 13 on an EGA), cursor scan line
     * drawing wraps around to zero and does not stop until we reach CURSCAN again.  However, this happens only when
     * CURSCAN is <= MAXSCAN; if CURSCAN > MAXSCAN, then nothing is drawn, regardless of CURSCANB.
     *
     * @this {Videox86}
     * @returns {boolean} true if the cursor is visible, false if not
     */
    checkCursor()
    {
        /**
         * The "hardware cursor" is never visible in graphics modes.
         */
        if (!this.nCardFont) return false;

        let card = this.cardActive;
        for (let i = Card.CRTC.CURSCAN; i <= Card.CRTC.CURSORLO; i++) {
            if (card.regCRTData[i] == null) {
                return false;
            }
        }

        let bCursorFlags = card.regCRTData[Card.CRTC.CURSCAN];
        let bCursorStart = bCursorFlags & Card.CRTC.CURSCAN_SLMASK;
        let bCursorEnd = card.regCRTData[Card.CRTC.CURSCANB] & Card.CRTCMASKS[Card.CRTC.CURSCANB];
        let bCursorMax = card.regCRTData[Card.CRTC.MAXSCAN] & Card.CRTCMASKS[Card.CRTC.MAXSCAN];
        let oCursorStart = bCursorStart, oCursorEnd = bCursorEnd;

        /**
         * Before range-checking CURSCAN and CURSCANB, let's see if the cursor is disabled by a starting value
         * outside the visible range; if so, simulate the condition by pretending the CURSCAN_BLINKOFF bit is set.
         *
         * For example, on a CGA, ThinkTank sets both CURSCAN and CURSCANB to 15, WordStar for PCjr sets CURSCAN and
         * CURSCANB to 12 and 13, respectively, and Rogue sets CURSCAN and CURSCANB to 15 and 0, respectively.
         */
        if (bCursorStart > bCursorMax) {
            bCursorFlags |= Card.CRTC.CURSCAN_BLINKOFF;
        }

        let bCursorWrap = 0;

        if (this.nCard != Videox86.CARD.EGA) {
            /**
             * Live and learn: I originally thought that the EGA introduced funky split cursors, but it turns
             * out that older cards did it, too (well, I've confirmed it on an actual MDA anyway; haven't tried
             * the CGA).  I've also confirmed that the MDA did NOT have the "mod 16" EGA anomaly described below.
             */
            if (bCursorEnd < bCursorStart) {
                bCursorWrap = bCursorEnd + 1;
                bCursorEnd = bCursorMax;
                /**
                 * The VGA didn't support funky split (aka wrap-around) cursors, so as above, we pretend that the
                 * cursor has simply been disabled.
                 */
                if (this.nCard == Videox86.CARD.VGA) {
                    bCursorFlags |= Card.CRTC.CURSCAN_BLINKOFF;
                    bCursorWrap = 0;
                }
            }
            else if (bCursorEnd > bCursorMax) {
                bCursorStart = 0;
                bCursorEnd = bCursorMax;
            }
            bCursorEnd++;
        }
        else {
            /**
             * HACK: The original EGA BIOS has a cursor emulation bug when 43-line mode is enabled; we used to
             * detect that particular combination of bad values and automatically fix them (see below),
             * but in retrospect, that doesn't seem very faithful.  Better to fix things like this 1) only if
             * the user asks, and 2) preferably with a BIOS patch rather than monkeying with the hardware registers.
             *
             *      if (this.nCard == Videox86.CARD.EGA) {
             *          if (bCursorMax == 7 && bCursorStart == 4 && !bCursorEnd) bCursorEnd = 7;
             *      }
             *
             * And here's a strange EGA hardware anomaly: if CURSCAN == CURSCANB mod 16, then it's treated the same
             * as if CURSCAN == CURSCANB.  For example, if you set (CURSCAN,CURSCANB) to either the decimal values
             * (4,19) or (4,21), you'll get a full block cursor, but if you set it to (4,20), you get a single line
             * cursor at row 4.  Go figure!
             */
            if (bCursorStart == bCursorEnd % 16) {
                bCursorEnd = bCursorStart + 1;
            }
            else if (bCursorEnd < bCursorStart) {
                bCursorWrap = bCursorEnd;
                bCursorEnd = bCursorMax + 1;
            }
            else if (bCursorEnd > bCursorMax) {
                bCursorStart = 0;
                bCursorEnd = bCursorMax + 1;
            }
        }

        let bCursorSize = bCursorEnd - bCursorStart;

        /**
         * One way of disabling the cursor is to set bit 5 (Card.CRTC.CURSCAN_BLINKOFF) of the CRTC.CURSCAN flags;
         * another way is setting bCursorStart > bCursorEnd, which implies that bCursorSize <= 0.
         */
        if ((bCursorFlags & Card.CRTC.CURSCAN_BLINKOFF) || bCursorSize <= 0) {
            this.removeCursor();
            return false;
        }

        /**
         * The least tricky way of disabling (ie, hiding) the cursor is to simply move it to an off-screen position.
         */
        let offCursor = card.regCRTData[Card.CRTC.CURSORLO] | ((card.regCRTData[Card.CRTC.CURSORHI] & card.addrMaskHigh) << 8);
        offCursor -= (card.regCRTData[Card.CRTC.STARTLO] | ((card.regCRTData[Card.CRTC.STARTHI] & card.addrMaskHigh) << 8));

        let iCellCursor = Math.trunc(offCursor / this.nColsLogical) * (this.nColsBuffer) + (offCursor % this.nColsLogical);

        if (this.iCellCursor != iCellCursor) {
            if (DEBUG) {
                let rowFrom = (this.iCellCursor / this.nCols)|0;
                let colFrom = (this.iCellCursor % this.nCols);
                let rowTo = (iCellCursor / this.nCols)|0;
                let colTo = (iCellCursor % this.nCols);
                this.printf("checkCursor(): cursor moved from %d,%d to %d,%d\n", rowFrom, colFrom, rowTo, colTo);
            }
            /**
             * I commented out this call on Feb 12, 2018 ("More cursor visibility fixes, especially when dealing with
             * non-zero video buffer start addresses") when I was debugging some Xenix issues, at the same time that I
             * also commented out the above printf(); in hindsight, I'm not sure if I intended to comment both out,
             * but with the change to cBlinkVisible below, I'm assuming removeCursor() really is no longer required here.
             *
             *      this.removeCursor();
             */
            this.iCellCursor = iCellCursor;
            /**
             * We invalidate cBlinkVisible on a cursor position change to ensure the cursor will be redrawn on the
             * next call to updateScreenCells().  It has the downside of requiring ALL cells to be re-examined, not
             * just the old and new cursor cells, but the cell cache should prevent any unnecessary redrawing.
             */
            this.cBlinkVisible = -1;
        }

        /**
         * yCursor and cyCursor are no longer scaled at this point, because the necessary scaling will depend on
         * whether we're drawing the cursor to the on-screen or off-screen buffer, and updateChar() is in the best
         * position to determine that.
         *
         * We also record cyCursorCell, the hardware cell height, since we'll need to know what the yCursor and
         * cyCursor values are relative to when it's time to scale them.
         */
        if (this.yCursor !== bCursorStart || this.cyCursor !== bCursorSize || this.cyCursorWrap !== bCursorWrap) {
            if (DEBUG) {
                this.printf("checkCursor(): cursor shape changed from %d,%d to %d,%d (%#04X-%#04X)\n",
                            this.yCursor, this.cyCursor, bCursorStart, bCursorSize, oCursorStart, oCursorEnd);
            }
            this.yCursor = bCursorStart;
            this.cyCursor = bCursorSize;
            this.cyCursorWrap = bCursorWrap;
            /**
             * The best redraw option for cursor shape changes used to be invalidating the cell cache, since merely
             * invalidating cBlinkVisible wouldn't have the desired effect if the cursor was still in the same location.
             * However, that option was rather drastic.  If the cursor had ALSO just moved (ie, this.cBlinkVisible < 0),
             * we didn't have to worry about it, so we could at least be more selective about when to invalidate the cache:
             *
             * But now we have the option of invalidating just a single cell (and marking the cache as "partially valid"),
             * so that's what we do.  Granted, a lot of hand-wringing over an uncommon operation, but that's how we roll.
             */
            if (this.iCellCacheValid && this.iCellCursor >= 0 && this.iCellCursor < this.aCellCache.length) {
                this.aCellCache[this.iCellCursor] = -1;
                this.iCellCacheValid = 1;
            }
        }

        this.cyCursorCell = bCursorMax + 1;

        /**
         * This next condition is critical; WordStar for PCjr (designed for the CGA) would program CURSCANB to 31,
         * whereas MAXSCAN was 7.  This resulted in cyCursorCell of 8 and cyCursor of 32, producing elongated cursors
         * in updateChar().  By range-checking CURSCAN and CURSCANB against MAXSCAN above, that should no longer happen.
         *
         * This condition can also happen while the CRT controller is in an inconsistent state (ie, in the middle of
         * being completely reprogrammed), so we mustn't freak out.
         */
        if (this.cyCursor > this.cyCursorCell) {
            this.cyCursor = this.cyCursorCell;
        }

        this.checkBlink();
        return true;
    }

    /**
     * removeCursor()
     *
     * @this {Videox86}
     */
    removeCursor()
    {
        if (this.iCellCursor >= 0) {
            if (this.aCellCache !== undefined && this.iCellCursor < this.aCellCache.length) {
                let drawCursor = (Videox86.ATTRS.DRAW_CURSOR << 8);
                let data = this.aCellCache[this.iCellCursor];
                if (data & drawCursor) {
                    data &= ~drawCursor;
                    let col = this.iCellCursor % this.nColsBuffer;
                    let row = (this.iCellCursor / this.nColsBuffer) | 0;
                    if (this.nActiveFont && this.aFonts[this.nActiveFont]) {
                        /**
                         * If we're using an off-screen buffer in text mode, then we need to keep it in sync with "reality".
                         */
                        if (this.contextBuffer) {
                            this.updateChar(col, row, data, this.contextBuffer);
                        }
                        /**
                         * While updating the on-screen canvas directly could open us up to potential subpixel artifacts again,
                         * I'm hopeful that won't be the case, since removeCursor() is called only during certain well-defined
                         * events.  The alternative to this simple updateChar() call is unappealing: redrawing the ENTIRE off-screen
                         * buffer to the on-screen canvas, just as updateScreen() does.
                         */
                        this.updateChar(col, row, data);
                    }
                    if (DEBUG) this.printf("removeCursor(): removed from %d,%d\n", row, col);
                    this.aCellCache[this.iCellCursor] = data;
                }
            }
            this.iCellCursor = -1;
        }
    }

    /**
     * getCardAccess()
     *
     * @this {Videox86}
     * @returns {number} current memory access setting
     */
    getCardAccess()
    {
        let card = this.cardActive;
        let nAccess = Card.READ.PAIRS | Card.WRITE.PAIRS;

        if (card.nCard >= Videox86.CARD.EGA) {
            this.fColor256 = false;
            let regGRCMode = card.regGRCData[Card.GRC.MODE.INDX];
            if (regGRCMode != null) {
                let nReadAccess = Card.READ.MODE0;
                let nWriteAccess = Card.WRITE.MODE0;
                let nWriteMode = regGRCMode & Card.GRC.MODE.WRITE.MASK;
                let regDataRotate = card.regGRCData[Card.GRC.DATAROT.INDX] & Card.GRC.DATAROT.MASK;
                switch (nWriteMode) {
                case Card.GRC.MODE.WRITE.MODE0:
                    if (regDataRotate) {
                        nWriteAccess = Card.WRITE.MODE0 | Card.WRITE.ROT;
                        switch (regDataRotate & Card.GRC.DATAROT.FUNC) {
                        case Card.GRC.DATAROT.AND:
                            nWriteAccess = Card.WRITE.MODE0 | Card.WRITE.AND;
                            break;
                        case Card.GRC.DATAROT.OR:
                            nWriteAccess = Card.WRITE.MODE0 | Card.WRITE.OR;
                            break;
                        case Card.GRC.DATAROT.XOR:
                            nWriteAccess = Card.WRITE.MODE0 | Card.WRITE.XOR;
                            break;
                        default:
                            break;
                        }
                        card.nDataRotate = regDataRotate & Card.GRC.DATAROT.COUNT;
                    }
                    break;
                case Card.GRC.MODE.WRITE.MODE1:
                    nWriteAccess = Card.WRITE.MODE1;
                    break;
                case Card.GRC.MODE.WRITE.MODE2:
                    switch (regDataRotate & Card.GRC.DATAROT.FUNC) {
                    default:
                        nWriteAccess = Card.WRITE.MODE2;
                        break;
                    case Card.GRC.DATAROT.AND:
                        nWriteAccess = Card.WRITE.MODE2 | Card.WRITE.AND;
                        break;
                    case Card.GRC.DATAROT.OR:
                        nWriteAccess = Card.WRITE.MODE2 | Card.WRITE.OR;
                        break;
                    case Card.GRC.DATAROT.XOR:
                        nWriteAccess = Card.WRITE.MODE2 | Card.WRITE.XOR;
                        break;
                    }
                    break;
                case Card.GRC.MODE.WRITE.MODE3:
                    if (this.nCard == Videox86.CARD.VGA) {
                        nWriteAccess = Card.WRITE.MODE3;
                        card.nDataRotate = regDataRotate & Card.GRC.DATAROT.COUNT;
                    }
                    break;
                default:
                    if (DEBUG) this.printf("getCardAccess(): invalid GRC mode (%#04X)\n", regGRCMode);
                    break;
                }
                if (regGRCMode & Card.GRC.MODE.READ.MODE1) {
                    nReadAccess = Card.READ.MODE1;
                }
                /**
                 * I discovered that when the IBM EGA ROM scrolls the screen in graphics modes 0x0D and 0x0E, it
                 * reprograms this register for WRITE.MODE1 (which is fine) *and* EVENODD (which is, um, very odd).
                 * Moreover, it does NOT make the complementary change to the SEQ.MEMMODE.SEQUENTIAL bit; under
                 * normal circumstances, those two bits are always supposed to programmed oppositely.
                 *
                 * Until I can perform some tests on real hardware, I have to assume that the EGA scroll operation
                 * is supposed to actually WORK in modes 0x0D and 0x0E, so I've decided to tie the trigger for my own
                 * EVENODD functions to SEQ.MEMMODE.SEQUENTIAL being clear, instead of GRC.MODE.EVENODD being set.
                 *
                 * It's also possible that my EVENODD read/write functions are not implemented properly; when EVENODD
                 * is in effect, which addresses get latched by a read, and to which addresses are latches written?
                 * If EVENODD has no effect on the effective address used with the latches, then I should change the
                 * EVENODD read/write functions accordingly.
                 *
                 * However, I've also done some limited testing with an emulated VGA running in text mode, and I've
                 * discovered that toggling the GRC.MODE.EVENODD bit *alone* doesn't seem to affect the delivery of
                 * text mode attributes from plane 1.  So maybe this is the wiser change after all.
                 *
                 * TODO: Perform some tests on actual EGA/VGA hardware, to determine the proper course of action.
                 *
                 *  if (regGRCMode & Card.GRC.MODE.EVENODD) {
                 *      nReadAccess |= Card.READ.EVENODD;
                 *      nWriteAccess |= Card.WRITE.EVENODD;
                 *  }
                 */
                let regSEQMode = card.regSEQData[Card.SEQ.MEMMODE.INDX];
                if (regSEQMode != null) {
                    if (!(regSEQMode & Card.SEQ.MEMMODE.SEQUENTIAL)) {
                        nReadAccess |= Card.READ.EVENODD;
                        nWriteAccess |= Card.WRITE.EVENODD;
                    }
                    if (regGRCMode & Card.GRC.MODE.COLOR256) {
                        if (regSEQMode & Card.SEQ.MEMMODE.CHAIN4) {
                            nReadAccess |= Card.READ.CHAIN4;
                            nWriteAccess |= Card.WRITE.CHAIN4;
                        }
                        this.fColor256 = true;
                    }
                }
                nAccess = nReadAccess | nWriteAccess;
            }
        }
        return nAccess;
    }

    /**
     * setCardAccess(nAccess)
     *
     * @this {Videox86}
     * @param {number} nAccess (one of the Card.ACCESS.* constants)
     * @returns {boolean} true if access may have changed, false if not
     */
    setCardAccess(nAccess)
    {
        let card = this.cardActive;
        if (card && nAccess != card.nAccess) {

            if (DEBUG) this.printf("setCardAccess(%#06X)\n", nAccess);

            card.setMemoryAccess(nAccess);

            /**
             * Note that setMemoryAccess() can fail, in which case it will an report error, indicating either a
             * misconfiguration or some sort of internal inconsistency; in any case, there's not much we can do about
             * it at this point, other than possibly reverting the current access setting.  There's probably not much
             * point, however, because there's no guarantee that setMemoryAccess() didn't modify one or more blocks
             * before choking.
             */
            this.bus.setMemoryAccess(card.addrBuffer, card.sizeBuffer, card.getMemoryAccess(), true);
            return true;
        }
        return false;
    }

    /**
     * setDimensions()
     *
     * This is the workhorse of setMode()
     *
     * @this {Videox86}
     */
    setDimensions()
    {
        this.nCardFont = this.nActiveFont = this.nAlternateFont = 0;
        this.nCols = this.nColsDefault;
        this.nRows = this.nRowsDefault;
        this.nPointsPerCell = Videox86.aModeParms[Videox86.MODE.MDA_80X25][2];
        this.nPointsPerByte = Videox86.aModeParms[Videox86.MODE.MDA_80X25][3];
        this.cxScreenCell = this.cyScreenCell = 1;
        this.fOverBuffer = false;

        let cbPadding = 0, cxCell = 1, cyCell = 1;
        let modeParms = Videox86.aModeParms[this.nMode];
        if (modeParms) {

            this.nCols = modeParms[0];
            this.nRows = modeParms[1];
            this.nPointsPerCell = modeParms[2];
            this.nPointsPerByte = modeParms[3];
            cbPadding = modeParms[4];       // undefined for EGA/VGA graphics modes only
            this.nCardFont = modeParms[5];  // this will be undefined for all graphics modes

            if (this.nCardFont) {
                /**
                 * Color text modes originally used an 8x8 font, but beginning with the EGA, they use whatever
                 * font is stored in plane 2, so if the card is "newer" than the default font, update the default
                 * to match the card.
                 */
                if (this.model == "vdu") {
                    this.nCardFont = Videox86.CARD.MDA;
                }
                else if (this.nCard > this.nCardFont) {
                    this.nCardFont = this.nCard;
                }
                this.buildFont();           // this also updates nActiveFont and nAlternateFont
                let font = this.aFonts[this.nActiveFont];
                if (font) {
                    cxCell = font.cxCell;
                    cyCell = font.cyCell;
                    if (this.nCard >= Videox86.CARD.EGA) {
                        /**
                         * Since these cards have programmable font height (font.cyChar), we need to divide that
                         * into the screen height (cyScreen) to determine the effective (ie, visible) number of rows.
                         */
                        let cyScreen = this.cardEGA.getCRTCReg(Card.CRTC.EGA.VDEND);
                        if (cyScreen++) {
                            let nRows = (cyScreen / font.cyChar) | 0;
                            if (nRows) this.nRows = nRows;
                        }
                        this.fOverBuffer = true;
                    }
                }
                this.cxScreenCell = (this.cxScreen / this.nCols) | 0;
                this.cyScreenCell = (this.cyScreen / this.nRows) | 0;
            }
        }

        this.nColsBuffer = this.nColsLogical = this.nCols;
        this.nRowsBuffer = this.nRows;
        if (this.fOverBuffer) {
            this.nColsBuffer++;
            this.nRowsBuffer++;
        }
        this.nCells = (this.nColsBuffer * this.nRowsBuffer) | 0;
        this.nCellCache = (this.nCells / this.nPointsPerCell) | 0;
        this.cbScreen = (this.nCells / this.nPointsPerByte) | 0;
        this.cbSplit = 0;

        if (cbPadding !== undefined) {
            this.cbScreen = (this.cbScreen + cbPadding) | 0;
            this.cbSplit = (this.cbScreen + cbPadding) >> 1;
        }

        this.cxBuffer = this.nColsBuffer * cxCell;
        this.cyBuffer = this.nRowsBuffer * cyCell;

        /**
         * Beyond calculating the theoretical dimensions, there's nothing more to do if we're in a "headless" mode.
         */
        if (!this.contextScreen) return;

        /**
         * Our 'smoothing' parameter defaults to null (which we treat the same as undefined), which means that
         * image smoothing will be selectively enabled (ie, true for text modes, false for graphics modes); otherwise,
         * we'll set image smoothing to whatever value was provided for ALL modes -- assuming the browser supports it.
         */
        if (this.sSmoothing) {
            this.contextScreen[this.sSmoothing] = (this.fSmoothing == null? !!this.nCardFont : this.fSmoothing);
        }

        /**
         * Allocate the off-screen buffers, unless a previous setMode() already cached buffers of the required size.
         */
        if (this.imageCache[this.cxBuffer] && this.imageCache[this.cxBuffer][this.cyBuffer]) {
            this.imageBuffer = this.imageCache[this.cxBuffer][this.cyBuffer];
            this.canvasBuffer = this.canvasCache[this.cxBuffer][this.cyBuffer];
        } else {
            this.imageBuffer = this.contextScreen.createImageData(this.cxBuffer, this.cyBuffer);
            this.canvasBuffer = document.createElement("canvas");
            this.canvasBuffer.width = this.cxBuffer;
            this.canvasBuffer.height = this.cyBuffer;
                if (!this.imageCache[this.cxBuffer]) this.imageCache[this.cxBuffer] = {};
            this.imageCache[this.cxBuffer][this.cyBuffer] = this.imageBuffer;
            if (!this.canvasCache[this.cxBuffer]) this.canvasCache[this.cxBuffer] = {};
            this.canvasCache[this.cxBuffer][this.cyBuffer] = this.canvasBuffer;
        }
        this.contextBuffer = this.canvasBuffer.getContext("2d");

        /**
         * Since cxCell and cyCell were originally defined in terms of cxScreen/nCols and cyScreen/nRows, you might think
         * these border calculations would always be zero, but we used to have code that tried to avoid stretching 40-column
         * modes into an unpleasantly wide shape, so this code is being retained (for now).
         */
        this.xScreenOffset = this.yScreenOffset = 0;
        this.cxScreenOffset = this.cxScreen;
        this.cyScreenOffset = this.cyScreen;

        let cxBorder = this.cxScreen - (this.nCols * this.cxScreenCell);
        let cyBorder = this.cyScreen - (this.nRows * this.cyScreenCell);
        if (cxBorder > 0) {
            this.xScreenOffset = (cxBorder >> 1);
            this.cxScreenOffset -= cxBorder;
        }
        if (cyBorder > 0) {
            this.yScreenOffset = (cyBorder >> 1);
            this.cyScreenOffset -= cyBorder;
        }
        if (cxBorder || cyBorder) {
            this.contextScreen.fillStyle = this.canvasScreen.style.backgroundColor;
            this.contextScreen.fillRect(0, 0, this.cxScreen, this.cyScreen);
        }
    }

    /**
     * checkMode(fForce)
     *
     * Called whenever the MDA/CGA's mode register (eg, Card.MDA.MODE.PORT, Card.CGA.MODE.PORT) is updated,
     * or whenever the EGA/VGA's GRC.MISC register is updated, or when we've just finished a restore().
     *
     * @this {Videox86}
     * @param {boolean} [fForce] is used to force a mode update, if we recognize the current mode
     * @returns {boolean} true if successful, false if not
     */
    checkMode(fForce)
    {
        let fRemap = false;
        let nMode = this.nMode;
        let card = this.cardActive;

        if (!card) {
            /**
             * We are likely being called after a restore(), which needs us to call setMode() to insure the proper video
             * buffer is mapped in.  So we unset this.nMode to guarantee that setMode() will be called, and if it wasn't set
             * to anything before, then we fall-back to the default mode.
             */
            this.nMode = null;
            if (nMode == null) nMode = this.nModeDefault;
        }
        else {
            if (card.nCard == Videox86.CARD.MDA) {
                nMode = Videox86.MODE.MDA_80X25;
            }
            else if (card.nCard >= Videox86.CARD.EGA) {
                /**
                 * The sizeBuffer we choose reflects the amount of physical address space that all 4 planes
                 * of EGA memory normally span, NOT the total amount of EGA memory.  So for a 64Kb EGA card,
                 * we would set card.sizeBuffer to 16Kb (0x4000).
                 *
                 * TODO: Need to take into account modes that "chain" planes together (eg, mode 0x0F, and
                 * presumably mode 0x10, on an EGA card with only 64Kb).
                 */
                nMode = null;
                let cbBuffer = card.cbMemory >> 2;
                let cbBufferText = (cbBuffer > 0x8000? 0x8000 : cbBuffer);

                let regGRCMisc = card.regGRCData[Card.GRC.MISC.INDX];
                if (regGRCMisc != null) {

                    let nCRTCMaxScan = card.regCRTData[Card.CRTC.EGA.MAXSCAN.INDX];

                    switch (regGRCMisc & Card.GRC.MISC.MAPMEM) {
                    case Card.GRC.MISC.MAPA0128:
                        card.addrBuffer = 0xA0000;
                        card.sizeBuffer = cbBuffer;     // 0x20000
                        if ((nCRTCMaxScan & Card.CRTC.EGA.MAXSCAN.SLMASK) <= 1) {
                            nMode = Videox86.MODE.UNKNOWN;     // no BIOS mode uses this mapping, but we don't want to leave nMode null if we've come this far
                        } else {
                            /**
                             * This mapping is used by Fantasy Land.
                             *
                             * TODO: Generalize this logic, outside of the context of the GRC.MISC mapping bits.
                             * For example, can we assume that as long as (MAXSCAN & SLMASK) > 1, we're always in text mode?
                             * And to what extent can we rely on the GRC.MISC.GRAPHICS bit?
                             */
                            nMode = (this.nMonitorType == ChipSet.MONITOR.MONO? Videox86.MODE.CGA_80X25_BW : Videox86.MODE.CGA_80X25);
                        }
                        break;
                    case Card.GRC.MISC.MAPA064:
                        card.addrBuffer = 0xA0000;
                        card.sizeBuffer = cbBuffer;     // 0x10000
                        nMode = (this.nMonitorType == ChipSet.MONITOR.MONO? Videox86.MODE.EGA_640X350_MONO : Videox86.MODE.EGA_640X350);
                        break;
                    case Card.GRC.MISC.MAPB032:
                        card.addrBuffer = 0xB0000;
                        card.sizeBuffer = cbBufferText;
                        nMode = Videox86.MODE.MDA_80X25;
                        break;
                    case Card.GRC.MISC.MAPB832:
                        card.addrBuffer = 0xB8000;
                        card.sizeBuffer = cbBufferText;
                        nMode = (this.nMonitorType == ChipSet.MONITOR.MONO? Videox86.MODE.CGA_80X25_BW : Videox86.MODE.CGA_80X25);
                        break;
                    default:
                        break;
                    }
                    /**
                     * TODO: The following mode discrimination code is all a bit haphazard, a byproduct of its slow evolution
                     * from increasingly greater EGA support to increasingly greater VGA support.  Make it more rational someday,
                     * so that as support is added for even more modes (eg, "Mode X" variations, monochrome modes, etc), it
                     * doesn't get totally out of control.
                     *
                     * One of the problems with the current approach is that it depends on the card's registers being programmed
                     * in at least roughly the same order that the IBM EGA and VGA ROMs program them.
                     */
                    let regGRCMode = card.regGRCData[Card.GRC.MODE.INDX];

                    /**
                     * This text/graphics hybrid test detects the way Windows 95 reprograms the VGA on boot; ie, switching
                     * to graphics mode 0x13 (320x200) without disturbing the text buffer contents, then reprogramming it
                     * to enable graphics mode 0x15 (320x400), then drawing a logo in the 2nd half of the video memory, and
                     * finally reprogramming regGRCMode and regGRCMisc to move the frame buffer back to its original text mode
                     * location.
                     */
                    let fTextGraphicsHybrid = (regGRCMode & (Card.GRC.MODE.COLOR256 | Card.GRC.MODE.EVENODD)) == (Card.GRC.MODE.COLOR256 | Card.GRC.MODE.EVENODD);

                    /**
                     * When fTextGraphicsHybrid is true, we should be at the end of the above process, so addrBuffer
                     * will have changed.  Since we don't (yet) assign a special mode to that configuration, we must at
                     * least set fForce to true, so that setMode() will notice the buffer address change and remap it.
                     *
                     * We have a similar situation when Fantasy Land selects the MAPA0128 buffer mapping, so this test is no
                     * longer limited to fTextGraphicsHybrid being true.
                     */
                    if (card.addrBuffer != this.addrBuffer || card.sizeBuffer != this.sizeBuffer) {
                        fRemap = true;
                    }

                    let nCRTCVertTotal = card.getCRTCReg(Card.CRTC.EGA.VTOTAL);
                    let nCRTCModeCtrl = card.regCRTData[Card.CRTC.EGA.MODECTRL.INDX];
                    let fSEQDotClock = (card.regSEQData[Card.SEQ.CLKMODE.INDX] & Card.SEQ.CLKMODE.DOTCLOCK);

                    if (nMode != Videox86.MODE.UNKNOWN) {
                        if (!(regGRCMisc & Card.GRC.MISC.GRAPHICS)) {
                            /**
                             * Here's where we handle text modes; since nMode will have been assigned a default
                             * of either 0x02 or 0x03, convert that to either 0x05 or 0x04 if we're in a low-res
                             * graphics mode, 0x06 otherwise.
                             */
                            nMode -= (fSEQDotClock? 2 : 0);
                        }
                        else if (card.addrBuffer != 0xA0000 && !fTextGraphicsHybrid && !(nCRTCModeCtrl & Card.CRTC.EGA.MODECTRL.COMPAT_MODE)) {
                            /**
                             * Here's where we handle CGA graphics modes; since nMode will have been assigned a
                             * default of either 0x02 or 0x03, convert that to either 0x05 or 0x04 if we're in a
                             * low-res graphics mode, 0x06 otherwise.
                             *
                             * For Windows 95, I've had to add BOTH the fTextGraphicsHybrid test, to avoid misdetecting
                             * the logo display mode, AND the COMPAT_MODE test, to avoid misinterpreting the VDD's physical
                             * (NOT logical) card reprogramming during windowed VM creation; the latter seems like a VDD bug,
                             * because only the Windows display driver should be *physically* reprogramming the card then.
                             */
                            nMode = fSEQDotClock? (7 - nMode) : Videox86.MODE.CGA_640X200;
                        } else {
                            /**
                             * Here's where we handle EGA/VGA graphics modes, discriminating among modes 0x0D and up;
                             * we've already defaulted to either 0x0F or 0x10.  If COLOR256 is set, then select mode
                             * 0x13 (or greater), else if 200-to-400 scan-line conversion is in effect, select either
                             * mode 0x0D or 0x0E, else if VGA resolution is set, select either mode 0x11 or 0x12.
                             */
                            if (card.regGRCData[Card.GRC.MODE.INDX] & Card.GRC.MODE.COLOR256) {
                                if (nCRTCMaxScan & Card.CRTC.EGA.MAXSCAN.SLMASK) {
                                    /**
                                     * NOTE: Technically, VDEND is one of those CRTC registers that should be read using
                                     * card.getCRTCReg(), because there are overflow bits (8 and 9).  However, all known modes
                                     * always SET bit 8 and CLEAR bit 9, so examining only bits 0-7 is sorta OK.
                                     */
                                    if (card.regCRTData[Card.CRTC.EGA.VDEND] <= 0x8F) {
                                        if (card.regSEQData[Card.SEQ.MEMMODE.INDX] & Card.SEQ.MEMMODE.CHAIN4) {
                                            nMode = Videox86.MODE.VGA_320X200;
                                        } else {
                                            nMode = Videox86.MODE.VGA_320X200P;
                                        }
                                    }
                                    else { /* (card.regCRTData[Card.CRTC.EGA.VDEND] == 0xDF) */
                                        nMode = Videox86.MODE.VGA_320X240P;
                                    }
                                } else {
                                    nMode = Videox86.MODE.VGA_320X400P;
                                }
                            }
                            else if ((nCRTCMaxScan & Card.CRTC.EGA.MAXSCAN.CONVERT400) || nCRTCVertTotal < 350) {
                                nMode = (fSEQDotClock? Videox86.MODE.EGA_320X200 : Videox86.MODE.EGA_640X200);
                            } else if (nCRTCVertTotal >= 480) {
                                nMode = (this.nMonitorType == ChipSet.MONITOR.MONO? Videox86.MODE.VGA_640X480_MONO : Videox86.MODE.VGA_640X480);
                            }
                            if (DEBUG) this.printf("checkMode(%#04X): nCRTCVertTotal=%d\n", nMode, nCRTCVertTotal);
                        }
                    }
                }
            }
            else if (card.regMode & Card.CGA.MODE.VIDEO_ENABLE) {
                /**
                 * NOTE: For the CGA, we precondition any mode change on CGA.MODE.VIDEO_ENABLE being set, otherwise
                 * we'll get spoofed by the ROM BIOS scroll code, which waits for vertical retrace and then turns CGA.MODE.VIDEO_ENABLE
                 * off, using a hard-coded mode value (0x25) that does NOT necessarily match the the CGA video mode currently in effect.
                 */
                if (!(card.regMode & Card.CGA.MODE.GRAPHIC_SEL)) {
                    nMode = ((card.regMode & Card.CGA.MODE._80X25)? Videox86.MODE.CGA_80X25 : Videox86.MODE.CGA_40X25);
                    if (card.regMode & Card.CGA.MODE.BW_SEL) {
                        nMode -= 1;
                    }
                } else {
                    nMode = ((card.regMode & Card.CGA.MODE.HIRES_BW)? Videox86.MODE.CGA_640X200 : Videox86.MODE.CGA_320X200_BW);
                    if (!(card.regMode & Card.CGA.MODE.BW_SEL)) {
                        nMode -= 1;
                    }
                }
                if (this.fOpacityReduced) {
                    this.canvasScreen.style.opacity = "1";
                    this.fOpacityReduced = false;
                }
            }
            else {
                /**
                 * This code is responsible for simulating flicker on a CGA screen.  Note that we have to also
                 * call yieldCPU() to ensure that the browser "comes up for air" and honors the new opacity, otherwise
                 * you'll see very intermittent flicker (which is actually more annoying than regular flicker, believe
                 * it or not).
                 *
                 * You also have the option of setting opacityFlicker to something greater than zero (eg, "0.5") to
                 * make the flicker less obtrusive; in fact, that might be more faithful to the persistence of a CGA
                 * screen's phosphor.  The downside is that if the VIDEO_ENABLE bit is ever turned for off a "long time",
                 * then you'll be treated to a very unnatural persistence effect.
                 */
                if (!this.fOpacityReduced && +this.opacityFlicker < 1) {
                    this.fOpacityReduced = true;
                    this.canvasScreen.style.opacity = this.opacityFlicker;
                    this.cpu.yieldCPU();
                }
            }
        }

        /**
         * NOTE: If setMode() remaps the video memory, that will trigger calls to setCardAccess() to also update the
         * memory's access functions.  However, if the memory access setting is about to change as well, those changes
         * will be moot until the setCardAccess() call that follows.  Basically, whenever both memory mapping AND access
         * functions are changing, the memory will be in an inconsistent state until both setMode() and setCardAccess()
         * are finished.
         *
         * The setMode() call takes precedence; if we called setCardAccess() first, it might attempt to modify memory access
         * functions based on the card's addrBuffer setting, and if that doesn't match what's currently mapped, assertions
         * will be triggered (probably not fatal, but it would defeat the point of the assertions).
         */
        if (!this.setMode(nMode, fForce, fRemap)) return false;

        this.setCardAccess(this.getCardAccess());

        return true;
    }

    /**
     * setMode(nMode, fForce, fRemap)
     *
     * Set fForce to true to update the mode regardless of previous mode, or false to perform a normal update
     * that bypasses updateScreen() but still calls initCellCache().
     *
     * @this {Videox86}
     * @param {number|null} nMode
     * @param {boolean} [fForce] is set when checkMode() wants to force a mode update
     * @param {boolean} [fRemap] is set when checkMode() detects a change in the buffer mapping
     * @returns {boolean} true if successful, false if failure
     */
    setMode(nMode, fForce, fRemap)
    {
        let fReset = nMode != null && (nMode != this.nMode || fForce);
        if (fReset || fRemap) {

            if (DEBUG) this.printf("setMode(%#04X,%b)\n", nMode, fForce);

            this.cUpdates = 0;      // count updateScreen() calls as a means of driving blink updates
            this.nMode = nMode;
            this.fRGBValid = false;

            /**
             * It's CRITICAL that a reset() invalidate cardActive, to ensure that the code below releases the
             * previous video buffer and installs a new one, even if there was no change in the video buffer
             * address or size, because otherwise memory blocks installed at the video buffer address may still
             * be using blocks of the previous memory buffer.
             *
             * When an EGA is reinitialized, a new memory buffer (adwMemory) is allocated (see initEGA()), and
             * this is where the mapping of that EGA memory buffer to the video buffer occurs.  Even if a card
             * (MDA or CGA) never reallocates its memory buffer, it's still a good idea to always force this operation
             * (eg, in case a switch setting changed the active video card).
             */
            let card = this.cardActive || (nMode == Videox86.MODE.MDA_80X25? this.cardMono : this.cardColor);

            if (card != this.cardActive || card.addrBuffer != this.addrBuffer || card.sizeBuffer != this.sizeBuffer) {

                this.removeCursor();

                if (this.addrBuffer) {

                    if (DEBUG) this.printf("setMode(%#04X): removing %#010X bytes from %#010X\n", nMode, this.sizeBuffer, this.addrBuffer);

                    if (!this.bus.removeMemory(this.addrBuffer, this.sizeBuffer)) {
                        /**
                         * TODO: Force this failure case and see how well the Video component deals with it.
                         */
                        return false;
                    }
                    if (this.cardActive) this.cardActive.fActive = false;
                }

                this.cardActive = card;
                card.fActive = true;

                this.addrBuffer = card.addrBuffer;
                this.sizeBuffer = card.sizeBuffer;

                if (DEBUG) this.printf("setMode(%#04X): adding %#010X bytes to %#010X\n", nMode, this.sizeBuffer, this.addrBuffer);

                if (!this.bus.addMemory(card.addrBuffer, card.sizeBuffer, Memoryx86.TYPE.VIDEO, card)) {
                    /**
                     * TODO: Force this failure case and see how well the Video component deals with it.
                     */
                    return false;
                }

                /**
                 * As https://www.seasip.info/VintagePC/mda.html explains, the MDA's 4K buffer address is not
                 * fully decoded; it is also addressible at every 4K interval within a 32K (0x8000) address range.
                 * We simulate that now, and not just for purely theoretical reasons: the original monochrome-
                 * specific version of "Exploring the IBM Personal Computer":
                 *
                 *      https://www.pcjs.org/disks/pcx86/diags/ibm/5150/exploring/1.00/mda/
                 *
                 * has a bug where it attempts to clear one of the intro screens with a faulty INT 10h Scroll Up
                 * call, where the top left (CX) and bottom right (DX) coordinates are reversed, resulting in a
                 * scroll with negative coordinates that the BIOS converts into large positive off-screen coordinates,
                 * which just so happens to clear the video buffer anyway, because it's repeatedly addressible.
                 *
                 * The CGA's 16K buffer has a similar feature, but owing to its larger size, its buffer repeats only
                 * once within a 32K address range.  And yes, the color version of "Exploring the IBM Personal Computer"
                 * has a similar INT 10h scroll bug; the app is using graphics mode 0x04, so it's requesting a graphics
                 * scroll rather than a text scroll to clear the screen, but once again, the coordinates are reversed,
                 * so much of the memory it zeroes is above the first 16K.
                 */
                if (card.nCard < Videox86.CARD.EGA) {
                    let addrBuffer = this.addrBuffer;
                    let aBlocks = this.bus.getMemoryBlocks(addrBuffer, this.sizeBuffer);
                    while ((addrBuffer += this.sizeBuffer) < card.addrBuffer + 0x8000) {
                        this.bus.setMemoryBlocks(addrBuffer, this.sizeBuffer, aBlocks);
                    }
                }
            }

            this.setDimensions();
            this.invalidateCellCache();

            if (fReset) this.updateScreen();
        }
        return true;
    }

    /**
     * setPixel(imageData, x, y, rgb)
     *
     * Worker function used by createFontColor() and updateScreen() (graphics modes only).
     *
     * @this {Videox86}
     * @param {Object} imageData
     * @param {number} x
     * @param {number} y
     * @param {Array.<number>} rgb is a 4-element array containing the red, green, blue and alpha values
     */
    setPixel(imageData, x, y, rgb)
    {
        let index = (x + y * imageData.width) * rgb.length;
        imageData.data[index] = rgb[0];
        imageData.data[index + 1] = rgb[1];
        imageData.data[index + 2] = rgb[2];
        imageData.data[index + 3] = rgb[3];
    }

    /**
     * initCellCache()
     *
     * Initializes the contents of our internal cell cache.
     *
     * TODO: Consider changing this to a cache of RGB values, so that when the buffer is merely being color-cycled,
     * we don't have to update the entire screen.  This would also allow invalidateCellCache() to honor the fColors
     * flag and bypass initCellCache() when it's set.
     *
     * @this {Videox86}
     * @returns {number}
     */
    initCellCache()
    {
        this.cBlinkVisible = -1;                // force updateScreen() to recount visible blinking characters
        this.iCellCacheValid = 0;
        let nCells = this.nCellCache;
        if (this.aCellCache === undefined || this.aCellCache.length != nCells) {
            this.aCellCache = new Array(nCells);
        }
        return nCells;
    }

    /**
     * invalidateCellCache(fColors, nFontSelect, nFontPrev)
     *
     * Ensures the next updateScreen() will examine and update every cell as needed, even if the underlying
     * data in the video buffer has not changed (eg, when the screen is being panned, the page is being flipped,
     * the palette is being cycled, the font is being changed, etc).
     *
     * @this {Videox86}
     * @param {boolean} [fColors] (true if color(s) *may* have changed)
     * @param {number} [nFontSelect] (set along with nFontPrev if font(s) *may* have changed)
     * @param {number} [nFontPrev]
     * @returns {number} (number of cells invalidated; used for diagnostic purposes only)
     */
    invalidateCellCache(fColors, nFontSelect, nFontPrev)
    {
        if (this.iCellCacheValid) {
            if (fColors !== false) {
                this.fRGBValid = false;
            }
            else if (nFontSelect !== undefined) {
                /**
                 * We want to do a "smart" (aka selective) invalidation of the cell cache, invalidating only
                 * those cells containing characters whose current font data differs from the previous font data.
                 */
                if (nFontSelect == nFontPrev) return 0;
                let aCellCache = this.aCellCache;
                let nCells = 0;
                /**
                 * getFontDiff() returns an empty array if the current and previous fonts are the same, which
                 * is OK for the code below, because using the "|" operator with undefined values coerces them
                 * to zero, resulting in no change.  If BOTH FontDiff arrays were empty, then we could skip this
                 * code altogether, but we've already eliminated that possibility above, when we checked for
                 * nFontSelect == nFontPrev, so at least one of these arrays will NOT be empty.
                 */
                let aFontDiff0 = this.getFontDiff(nFontSelect & 0xff, nFontPrev & 0xff);
                let aFontDiff1 = this.getFontDiff(nFontSelect >> 8, nFontPrev >> 8);
                for (let i = 0; i < aCellCache.length; i++) {
                    let data = aCellCache[i];
                    if (data >= 0) {
                        /**
                         * The font referenced by any given cell data *usually* only depends on low 8 bits (ie, the
                         * character data), but when the active and alternate fonts differ, bit 3 of the attribute data
                         * must be examined as well, and if it's set, then the alternate font must be used.
                         */
                        let aFontDiff = (data & 0x800)? aFontDiff1 : aFontDiff0;
                        if ((aCellCache[i] |= aFontDiff[data & 0xff]) < 0) {
                            this.iCellCacheValid = 1;
                            nCells++;
                        }
                    }
                }
                return nCells;
            } else {
                /**
                 * When no color change AND no font change has occurred, since the cache was at least partially
                 * valid already, we make sure it's partially valid.
                 */
                this.iCellCacheValid = 1;
                return 0;
            }
        }
        return this.initCellCache();
    }

    /**
     * updateChar(col, row, data, context)
     *
     * Updates a particular character cell (row,col) in the associated window.
     *
     * The data parameter is the attribute byte from the display buffer (fgnd attribute in the low nibble,
     * bgnd attribute in the high nibble), but updateScreen() supplements data with a couple internal attribute bits:
     *
     *      ATTRS.DRAW_FGND:    set for every cell whose fgnd element is currently on (ie, non-blinking, or whenever blink is on)
     *      ATTRS.DRAW_CURSOR:  set only for the cell containing the cursor, if any
     *
     * To make a character blink, we alternately draw its cell with ATTRS.DRAW_FGND set, and then again with
     * ATTRS.DRAW_FGND clear (meaning only the cell background is drawn).
     *
     * To make the cursor blink, we must alternately draw its entire cell with ATTRS.DRAW_CURSOR set, and then
     * draw it again with ATTRS.DRAW_CURSOR clear.
     *
     * @this {Videox86}
     * @param {number} col
     * @param {number} row
     * @param {number} data (if text mode, character code in low byte, attribute code in high byte)
     * @param {CanvasRenderingContext2D} [context]
     */
    updateChar(col, row, data, context)
    {
        let bChar = data & 0xff;
        let bAttr = data >> 8;
        /**
         * The font referenced by any given cell data *usually* only depends on low 8 bits (ie, the
         * character data), but when the active and alternate fonts differ, bit 3 of the attribute data
         * must be examined as well, and if it's set, then the alternate font must be used.
         */
        let font = this.aFonts[this.nActiveFont];
        if ((bAttr & 0x08) && this.nActiveFont != this.nAlternateFont) {
            font = this.aFonts[this.nAlternateFont];
            bAttr &= ~0x08;
        }

        /**
         * Just as aColorMap maps the foreground attribute to the appropriate foreground character grid,
         * it also maps the background attribute to the appropriate background color.
         *
         * Unfortunately, the MDA card is an exception: the background is always black (color index 0)
         * UNLESS 1) attribute & 0xf7 == 0x70 (color index 2) or 2) attribute & 0xf7 == 0xf0 (color index 4).
         *
         * Similarly, the foreground is NEVER black UNLESS attribute & 0x77 == 0x00 (ie, the attribute is one
         * of 0x00, 0x08, 0x80, or 0x88).
         */
        let xDst;
        let yDst;
        let iFgnd = bAttr & 0x0f;
        let iBgnd = (bAttr >> 4) & 0x0f;
        if (font.aColorMap) {
            if (!(bAttr & 0x7) && (bAttr & 0x70)) {
                iFgnd |= 0x7;
            }
            let b = bAttr & 0xf7;
            if (b == 0x70 || b == 0xf0) {
                iFgnd = 0x0;
            } else {
                iBgnd = 0x0;
            }
            iFgnd = font.aColorMap[iFgnd];
            iBgnd = font.aColorMap[iBgnd];
        }

        if (context) {
            xDst = col * font.cxCell;
            yDst = row * font.cyCell;
            context.fillStyle = font.aCSSColors[iBgnd];
            context.fillRect(xDst, yDst, font.cxCell, font.cyCell);
        } else {
            xDst = col * this.cxScreenCell + this.xScreenOffset;
            yDst = row * this.cyScreenCell + this.yScreenOffset;
            this.contextScreen.fillStyle = font.aCSSColors[iBgnd];
            this.contextScreen.fillRect(xDst, yDst, this.cxScreenCell, this.cyScreenCell);
        }

        if (MAXDEBUG) this.printf(MESSAGE.VIDEO + MESSAGE.BUFFER, "updateCharBgnd(%d,%d,%d): filled %d,%d\n", col, row, bChar, xDst, yDst);

        if (bAttr & Videox86.ATTRS.DRAW_FGND) {
            /**
             * (bChar & 0xf) is the equivalent of (bChar % 16), and (bChar >> 4) is the equivalent of Math.floor(bChar / 16)
             */
            let xSrcFgnd = (bChar & 0xf) * font.cxCell;
            let ySrcFgnd = (bChar >> 4) * font.cyCell;

            if (MAXDEBUG) this.printf(MESSAGE.VIDEO + MESSAGE.BUFFER, "updateCharFgnd(%d,%d,%d): draw from %d,%d (%d,%d) to %d,%d\n", col, row , bChar, xSrcFgnd, ySrcFgnd, font.cxCell, font.cyCell, xDst, yDst);

            if (context) {
                context.drawImage(font.aCanvas[iFgnd], xSrcFgnd, ySrcFgnd, font.cxCell, font.cyCell, xDst, yDst, font.cxCell, font.cyCell);
            } else {
                this.contextScreen.drawImage(font.aCanvas[iFgnd], xSrcFgnd, ySrcFgnd, font.cxCell, font.cyCell, xDst, yDst, this.cxScreenCell, this.cyScreenCell);
            }
        }

        if (bAttr & Videox86.ATTRS.DRAW_CURSOR) {
            if (this.cyCursorWrap) {
                this.drawCursor(0, this.cyCursorWrap, xDst, yDst, iFgnd, font, context);
            }
            this.drawCursor(this.yCursor, this.cyCursor, xDst, yDst, iFgnd, font, context);
        }
    }

    /**
     * drawCursor(yCursor, cyCursor, xDst, yDst, iFgnd, font, context)
     *
     * We have factored the cursor-drawing code out of updateChar() so that we can call this function multiple times,
     * in case we have to draw a "split cursor".
     *
     * @this {Videox86}
     * @param {number} yCursor
     * @param {number} cyCursor
     * @param {number} xDst
     * @param {number} yDst
     * @param {number} iFgnd
     * @param {Font} font
     * @param {CanvasRenderingContext2D} [context]
     */
    drawCursor(yCursor, cyCursor, xDst, yDst, iFgnd, font, context)
    {
        /**
         * Drawing the cursor with lineTo() seemed logical, but it was complicated by the fact that the
         * TOP of the line must appear at "yDst + this.yCursor", whereas lineTo() wants to know the CENTER
         * of the line. So it's simpler to draw the cursor with another fillRect().  Here's the old code:
         *
         *      this.contextScreen.strokeStyle = font.aCSSColors[iFgnd];
         *      this.contextScreen.lineWidth = this.cyCursor;
         *      this.contextScreen.beginPath();
         *      this.contextScreen.moveTo(xDst, yDst + this.yCursor);
         *      this.contextScreen.lineTo(xDst + this.cxScreenCell, yDst + this.yCursor);
         *      this.contextScreen.stroke();
         *
         * Also, note that we're scaling the yCursor and cyCursor values here, instead of in checkCursor(), because
         * this is where we have all the required information: in the first case (off-screen buffer), the scaling must
         * be based on the font cell size (cxCell, cyCell), whereas in the second case (on-screen buffer), the scaling
         * must be based on the screen cell size (cxScreenCell,cyScreenCell).
         *
         * yCursor and cyCursor are actual hardware values, both relative to another hardware value: cyCursorCell.
         */
        if (context) {
            if (this.cyCursorCell && this.cyCursorCell !== font.cyCell) {
                yCursor = Math.round((yCursor * font.cyCell) / this.cyCursorCell);
                cyCursor = Math.round((cyCursor * font.cyCell) / this.cyCursorCell);
            }
            context.fillStyle = font.aCSSColors[iFgnd];
            context.fillRect(xDst, yDst + yCursor, font.cxCell, cyCursor);
        } else {
            if (this.cyCursorCell && this.cyCursorCell !== this.cyScreenCell) {
                yCursor = Math.round((yCursor * this.cyScreenCell) / this.cyCursorCell);
                cyCursor = Math.round((cyCursor * this.cyScreenCell) / this.cyCursorCell);
            }
            this.contextScreen.fillStyle = font.aCSSColors[iFgnd];
            this.contextScreen.fillRect(xDst, yDst + yCursor, this.cxScreenCell, cyCursor);
        }
    }

    /**
     * latchStartAddress()
     *
     * @this {Videox86}
     */
    latchStartAddress()
    {
        let card = this.cardActive;
        let offStart = card.regCRTData[Card.CRTC.STARTLO];
        offStart |= (card.regCRTData[Card.CRTC.STARTHI] & card.addrMaskHigh) << 8;
        if (card.offStart !== offStart) {
            card.offStart = offStart;
            this.invalidateCellCache(false);
        }
        let rowStart = (card == this.cardEGA? (card.regCRTData[Card.CRTC.EGA.PRESCAN] & Card.CRTC.EGA.MAXSCAN.SLMASK) : 0);
        if (card.rowStart !== rowStart) {
            card.rowStart = rowStart;
            this.nShiftUp = 0;
            if (this.fOverBuffer) {
                this.fShifted = true;
                this.nShiftUp = rowStart & Card.CRTC.EGA.MAXSCAN.SLMASK;
            }
        }

    }

    /**
     * updateScreen(fForce)
     *
     * Propagates the video buffer to the cell cache and updates the screen with any changes.  Forced updates
     * are generally internal updates triggered by an I/O operation or other state change, while non-forced updates
     * are the periodic updates coming from the CPU.
     *
     * @this {Videox86}
     * @param {boolean} [fForce] is used by setMode() to reset the cell cache and force a redraw
     * @returns {boolean}
     */
    updateScreen(fForce = false)
    {
        /**
         * Nothing to do for "headless" congfigurations.
         */
        if (!this.canvasScreen) return false;

        /**
         * The Computer component maintains the fPowered setting on our behalf, so we use it.
         */
        if (!this.flags.powered) return false;

        /**
         * If the card's video signal is disabled (eg, during a mode change), then skip the update,
         * unless fForce is set.
         */
        let card = this.cardActive;
        if (!card) return false;

        let fEnabled = false;
        if (card !== this.cardEGA) {
            if (card.regMode & Card.CGA.MODE.VIDEO_ENABLE) fEnabled = true;
        }
        else {
            if (card.regATCIndx & Card.ATC.INDX_PAL_ENABLE) fEnabled = true;
        }

        if (!fEnabled && !fForce) return false;

        if (fForce) {
            this.initCellCache();
        }
        else {
            /**
             * This should never happen, but since updateScreen() is also called by Computer.updateStatus(),
             * better safe than sorry.
             */
            if (this.aCellCache === undefined) return false;
        }

        /**
         * If this is a hardware update (as opposed to, say, a debugger-triggered update, where fForce is set),
         * and cBlinks is "enabled" (ie, >= 0), then advance cBlinks once every 10 updateScreen() calls.
         *
         * Assuming an updateScreen() frequency of roughly 60 times per second (Videox86.UPDATES_PER_SECOND), performing
         * a "blink update" every 10 times is reasonably close to the hardware blink rate.  However, the effective blink
         * rate will also depend on other factors as well, such as the monitorSpecs for the video hardware being simulated.
         */
        let fBlinkUpdate = false;
        if (!fForce && !(++this.cUpdates % 10) && this.cBlinks >= 0) {
            this.cBlinks++;
            fBlinkUpdate = true;
        }

        let iCell = 0;
        let nCells = this.nCells;

        /**
         * Calculate the VISIBLE start of screen memory (addrScreen), not merely the PHYSICAL start,
         * as well as the extent of it (cbScreen) and use those values for all addressing operations to follow.
         * FYI, in these calculations, offScreen does not refer to "off-screen" memory, but rather the "offset"
         * of the start of visible screen memory.
         */
        let addrBuffer = this.addrBuffer;
        let addrScreen = addrBuffer;
        let addrScreenLimit = addrScreen + this.sizeBuffer;

        /**
         * HACK: To deal with the fTextGraphicsHybrid 320x400 mode that Windows 95 uses (ie, when the buffer
         * is mapped to B800:0000 instead of A000:0000 and is configured for text mode access, but graphics are
         * still being displayed from the second half of video memory), we must ignore the programmed address.
         *
         * In that case, the hard-coded address range below isn't actually active either, but it doesn't matter;
         * we just have to get through the rest of this function and make it to the updateScreenGraphicsVGA() call,
         * which will draw from our video buffer (adwMemory) directly; these addresses are only used for bounds
         * checking.
         */
        if (this.nMode >= Videox86.MODE.VGA_320X200) {
            addrBuffer = addrScreen = 0xA0000;
            addrScreenLimit = addrScreen + 0x10000;
        }

        let cbScreen = this.cbScreen;
        this.nColsLogical = this.nCols;

        if (this.nCard < Videox86.CARD.EGA) {
            /**
             * Any screen (aka "page") offset must be doubled for text modes, due to the attribute bytes.
             */
            addrScreen += card.offStart << (this.nCardFont? 1 : 0);
        } else {
            /**
             * For the EGA/VGA, we must make offset-doubling dependent on attribute (odd) byte addressibility.
             * For example, Fantasy Land uses a text-mode buffer mapped at 0xA0000 without odd/even addressing.
             *
             * TODO: Setting nPointsPerByte properly would ideally be taken care of in setDimensions(), but there's
             * no guarantee this particular controller tweak will be made BEFORE we detect and initiate a mode change.
             */
            let shiftAddr = 0;
            let shiftCols = 0;
            let bMemMode = this.cardEGA.regSEQData[Card.SEQ.MEMMODE.INDX] & (Card.SEQ.MEMMODE.ALPHA | Card.SEQ.MEMMODE.SEQUENTIAL);
            if (bMemMode == Card.SEQ.MEMMODE.ALPHA) {
                shiftAddr = shiftCols = 1;
                this.nPointsPerByte = 0.5;
            } else if (bMemMode == (Card.SEQ.MEMMODE.ALPHA | Card.SEQ.MEMMODE.SEQUENTIAL)) {
                shiftCols = 1;
                this.nPointsPerByte = 1.0;
            }
            addrScreen += card.offStart << shiftAddr;
            if (card.regCRTData[Card.CRTC.EGA.OFFSET] && (card.regCRTData[Card.CRTC.EGA.OFFSET] << 1) != card.regCRTData[Card.CRTC.EGA.HDEND] + 1) {
                /**
                 * Pre-EGA, the extent of visible screen memory (cbScreen) was derived from nCols * nRows, but since
                 * then, the logical width of screen memory (nColsLogical) can differ from the visible width (nCols).
                 * We now calculate the logical width, and the compute a new cbScreen in much the same way the original
                 * cbScreen was computed (but without any CGA-related padding considerations).
                 */
                this.nColsLogical = card.regCRTData[Card.CRTC.EGA.OFFSET] << (shiftCols || ((card.regCRTData[Card.CRTC.EGA.UNDERLINE.INDX] & Card.CRTC.EGA.UNDERLINE.DWORD)? 3 : 4));
                cbScreen = ((this.nColsLogical * (this.nRowsBuffer - 1) + this.nColsBuffer) / this.nPointsPerByte)|0;
                /**
                 * If nRowsBuffer is larger than nRows (ie, over-buffering is enabled), we run the risk of attempting
                 * to render past the limit of the frame buffer (addrScreenLimit); we're ONLY over-buffering in case the
                 * the app decides to pan vertically, revealing pixels below the last full row, and obviously if there
                 * isn't an additional row of data below that last full row, then we shouldn't over-buffer this time.
                 */
                if (this.nRowsBuffer > this.nRows && addrScreen + cbScreen > addrScreenLimit) {
                    cbScreen = ((this.nColsLogical * (this.nRows - 1) + this.nColsBuffer) / this.nPointsPerByte)|0;
                }
            }
        }

        /**
         * If the amount of data (cbScreen) we need to display goes beyond the end of the screen buffer
         * (addrScreenLimit), then the assumption is that we will have to do a second update operation that
         * wraps around to addrBuffer.
         */
        let addrScreenWrap = 0;
        let cbScreenWrap = 0;
        if (addrScreen + cbScreen > addrScreenLimit) {
            /**
             * There are two possibilities here: addrScreen itself is at or beyond addrScreenLimit, or just a
             * portion of cbScreen goes beyond the limit.  We'll deal with the first case first.
             */
            cbScreenWrap = cbScreen;
            if (addrScreen >= addrScreenLimit) {
                addrScreenWrap = addrBuffer + (addrScreen - addrScreenLimit);
                cbScreen = 0;
            } else {
                addrScreenWrap = addrBuffer;
                cbScreen = addrScreenLimit - addrScreen;
                cbScreenWrap -= cbScreen;
            }
        }
        else if (this.nCard >= Videox86.CARD.EGA) {
            /**
             * We can leverage our screen wrap support to handle split-screen views as well; we must calculate
             * the number of WHOLE + PARTIAL rows we can draw (which may reduce cbScreen).  TODO: We must also pass
             * along the height of any PARTIAL row, so that pixel-level split-screens can eventually be supported.
             */
            let nRowsHidden = card.getCRTCReg(Card.CRTC.EGA.VDEND) - card.getCRTCReg(Card.CRTC.EGA.LINECOMP);
            if (nRowsHidden > 0) {
                let font = this.aFonts[this.nActiveFont];
                if (font) {
                    nRowsHidden = (nRowsHidden / font.cyChar)|0;
                }
                if (nRowsHidden > 0) {
                    cbScreenWrap = ((this.nColsLogical * (nRowsHidden - 1) + this.nColsBuffer) / this.nPointsPerByte)|0;
                    cbScreen -= ((this.nColsLogical * nRowsHidden) / this.nPointsPerByte)|0;
                    addrScreenWrap = addrBuffer;
                }
            }
        }

        /**
         * updateScreenCells() no longer "scrubs" the screen buffer itself; we call cleanMemory() afterward
         * to take care of that.  This has two benefits: 1) if this was a "forced" updated (or an update to make
         * the cell cache valid), cleaning the screen buffer ourselves reflects the fact that both it and our
         * display are now "in sync"; 2) if screen wrap-around is in effect, we don't want to scrub either subset
         * of the screen until both subsets have been updated, otherwise the second update may erroneously think
         * that nothing changed if it happens to share any blocks with the first.
         */
        let cBlinkOrig = this.cBlinkVisible;
        let cCells = this.updateScreenCells(addrBuffer, addrScreen, cbScreen, iCell, nCells, fForce, fBlinkUpdate);
        if (cbScreenWrap) {
            iCell += cCells;
            let cBlinkNew = this.cBlinkVisible;
            if (cBlinkOrig < 0) this.cBlinkVisible = -1;
            cCells += this.updateScreenCells(addrBuffer, addrScreenWrap, cbScreenWrap, iCell, nCells, fForce, fBlinkUpdate);
            this.cBlinkVisible += cBlinkNew;
            this.bus.cleanMemory(addrScreenWrap, cbScreenWrap, true);
        }
        this.bus.cleanMemory(addrScreen, cbScreen, true);
        if (cCells) this.iCellCacheValid = 2;
        return true;
    }

    /**
     * updateScreenCells(addrBuffer, addrScreen, cbScreen, iCell, nCells, fForce, fBlinkUpdate)
     *
     * @this {Videox86}
     * @param {number} addrBuffer
     * @param {number} addrScreen
     * @param {number} cbScreen
     * @param {number} iCell
     * @param {number} nCells
     * @param {boolean} fForce
     * @param {boolean} fBlinkUpdate
     * @returns {number} (number of cells processed)
     */
    updateScreenCells(addrBuffer, addrScreen, cbScreen, iCell, nCells, fForce, fBlinkUpdate)
    {
        /**
         * When determining the number of cells this update may affect, it is NOT simply cbScreen
         * multiplied by nPointsPerByte, because cbScreen includes any and all off-screen cells, too.
         */
        let cCells = cbScreen * this.nPointsPerByte;
        cCells = Math.trunc(cCells / this.nColsLogical) * this.nColsBuffer + (cCells % this.nColsLogical);
        if (cCells > nCells) cCells = nCells;
        let addrScreenLimit = addrScreen + cbScreen;

        /**
         * This next bit of code can be completely disabled if we discover problems with the dirty
         * memory block tracking feature or we need to remove or disable that feature in the future.
         *
         * We use cleanMemory() to check the video buffer's dirty state.  If the buffer is clean
         * AND there are no visible blinking characters (as of the last updateScreen) AND there is
         * no visible cursor, then we're done; simply return.  Otherwise, if there's only a blinking
         * cursor, then update JUST that one cell.
         */
        if (!fForce && this.iCellCacheValid == 2 && this.bus.cleanMemory(addrScreen, cbScreen)) {
            if (!fBlinkUpdate && this.cBlinkVisible >= 0) {
                if (!this.fShifted) return cCells;
                iCell = nCells;
            }
            else if (!this.cBlinkVisible) {
                /**
                 * iCellCursor may be negative if the cursor is hidden or if it's not on the visible screen.
                 */
                let iCellCursor = this.iCellCursor - iCell;
                if (iCellCursor < 0) {
                    if (!this.fShifted) return cCells;
                    iCell = nCells;
                }
                else {
                    let row = (iCellCursor / this.nColsBuffer)|0;
                    let col = (iCellCursor % this.nColsBuffer);
                    addrScreen += (row * this.nColsLogical + col) << 1;
                    iCell += iCellCursor;
                    nCells = iCell + 1;
                }
            }
            // else if (this.cBlinks & 0x1) return cCells;
        }

        if (this.nActiveFont) {
            /**
             * This is the text-mode update case.
             */
            this.updateScreenText(addrBuffer, addrScreen, addrScreenLimit, iCell, nCells);
        }
        else if (this.cbSplit) {
            /**
             * All CGA graphics modes have the goofy split-buffer layout, hence the simple test above.
             */
            cCells = this.updateScreenGraphicsCGA(addrScreen, addrScreenLimit);
        }
        else if (!this.fColor256) {
            /**
             * All EGA graphics modes are taken care of here, including all 16-color VGA graphics modes.
             */
            cCells = this.updateScreenGraphicsEGA(addrBuffer, addrScreen, addrScreenLimit);
        }
        else {
            /**
             * Finally, all 256-color VGA modes are processed here.
             */
            cCells = this.updateScreenGraphicsVGA(addrBuffer, addrScreen, addrScreenLimit);
        }

        this.fShifted = false;

        return cCells;
    }

    /**
     * updateScreenText(addrBuffer, addrScreen, addrScreenLimit, iCell, nCells)
     *
     * @this {Videox86}
     * @param {number} addrBuffer
     * @param {number} addrScreen
     * @param {number} addrScreenLimit
     * @param {number} iCell
     * @param {number} nCells
     * @returns {number} (number of cells processed)
     */
    updateScreenText(addrBuffer, addrScreen, addrScreenLimit, iCell, nCells)
    {
        let font = this.aFonts[this.nActiveFont];
        if (!font) return 0;

        /**
         * If MDA.MODE.BLINK_ENABLE is set and a cell's blink bit is set, then if (cBlinks & 0x2) != 0,
         * we want the foreground element of the cell to be drawn; otherwise we don't.  So every 16-bit
         * data word we pull from the video buffer will be supplemented with our own special attribute bit
         * (ATTRS.DRAW_FGND = 0x100) accordingly; and to simplify the drawing code, we will also mask the
         * blink bit from the cell's attribute bits.
         *
         * If MDA.MODE.BLINK_ENABLE is clear, then we always set ATTRS.DRAW_FGND and never mask the blink
         * bit in a cell's attributes bits, since it's actually an intensity bit in that case.
         */
        let card = this.cardActive;
        let cCells = 0, cUpdated = 0;
        let dataBlink = 0;
        let dataDraw = (Videox86.ATTRS.DRAW_FGND << 8);
        let dataMask = 0xfffff;
        let adwMemory = card.adwMemory;

        /**
         * Normally, cbCell will be 2, when attribute bytes are addressible (interleaved) with character bytes,
         * but Fantasy Land is an exception.  Which is another great reason why the loop below needs to get both
         * bytes directly from adwMemory, because reading them with bus.getShortDirect(addrScreen) won't always work.
         */
        let cbCell = (1 / this.nPointsPerByte)|0;
        let nShift = (card.nAccess & Card.WRITE.PAIRS)? 1 : 0;

        let fBlinkEnable = (card.regMode & Card.MDA.MODE.BLINK_ENABLE);
        if (this.nCard >= Videox86.CARD.EGA) {
            fBlinkEnable = (card.regATCData[Card.ATC.MODE.INDX] & Card.ATC.MODE.BLINK_ENABLE);
        }

        if (fBlinkEnable) {
            dataBlink = (Videox86.ATTRS.BGND_BLINK << 8);
            dataMask &= ~dataBlink;
            if (!(this.cBlinks & 0x2)) dataMask &= ~dataDraw;
        }

        this.cBlinkVisible = 0;
        let col = iCell % this.nColsBuffer;
        let row = (iCell / this.nColsBuffer) | 0;
        let nbRowExtra = (this.nColsLogical - this.nColsBuffer /* - iCellFirst */) << (cbCell - 1);

        while (addrScreen < addrScreenLimit && iCell < nCells) {

            let idw = (addrScreen - addrBuffer) >>> nShift;


            let data = (adwMemory[idw] & 0xffff);

            data |= dataDraw;
            if (data & dataBlink) {
                this.cBlinkVisible++;
                data &= dataMask;
            }
            if (iCell == this.iCellCursor) {
                data |= ((this.cBlinks & 0x1)? (Videox86.ATTRS.DRAW_CURSOR << 8) : 0);
            }



            if (!this.iCellCacheValid || data !== this.aCellCache[iCell]) {
                this.updateChar(col, row, data, this.contextBuffer);
                this.aCellCache[iCell] = data;
                cUpdated++;
            }

            cCells++;
            iCell++;
            addrScreen += cbCell;
            if (++col >= this.nColsBuffer) {
                col = 0;
                if (++row >= this.nRowsBuffer) break;
                addrScreen += nbRowExtra;
            }
        }

        if (this.contextBuffer && (cUpdated || this.fShifted)) {
            let xBuffer = 0, yBuffer = 0;
            let cxBuffer = this.cxBuffer;
            let cyBuffer = this.cyBuffer;
            if (this.fOverBuffer) {
                let xShift = this.nShiftLeft;
                let yShift = this.nShiftUp;
                if (this.fDoubleFont) {
                    xShift <<= 1;
                    yShift <<= 1;
                }
                xBuffer += xShift;
                yBuffer += yShift;
                cxBuffer -= font.cxCell;
                cyBuffer -= font.cyCell;
            }
            this.contextScreen.drawImage(this.canvasBuffer, xBuffer, yBuffer, cxBuffer, cyBuffer, this.xScreenOffset, this.yScreenOffset, this.cxScreenOffset, this.cyScreenOffset);
        }

        this.checkBlink();
        return cCells;
    }

    /**
     * updateScreenGraphicsCGA(addrScreen, addrScreenLimit)
     *
     * @this {Videox86}
     * @param {number} addrScreen
     * @param {number} addrScreenLimit
     * @returns {number} (number of cells processed)
     */
    updateScreenGraphicsCGA(addrScreen, addrScreenLimit)
    {
        /**
         * This is the CGA graphics-mode update case, where cells are pixels spread across two halves of the buffer.
         */
        let cCells = (addrScreenLimit - addrScreen) >> 1;
        let iCell = 0, nPixelsPerCell = this.nPointsPerCell;
        let addr = addrScreen;
        let wPixelMask = (nPixelsPerCell == 16? 0x10000 : 0x30000);
        let nPixelShift = (nPixelsPerCell == 16? 1 : 2);
        let aPixelColors = this.getCardColors(nPixelShift);

        let x = 0, y = 0;
        let xDirty = this.nCols, xMaxDirty = 0, yDirty = this.nRows, yMaxDirty = 0;

        this.cBlinkVisible = 0;
        while (addr < addrScreenLimit) {
            let data = this.bus.getShortDirect(addr);

            if (this.iCellCacheValid && data === this.aCellCache[iCell]) {
                x += nPixelsPerCell;
            } else {
                this.aCellCache[iCell] = data;
                let wPixels = (data >> 8) | ((data & 0xff) << 8);
                let wMask = wPixelMask, nShift = 16;
                if (x < xDirty) xDirty = x;
                for (let iPixel = 0; iPixel < nPixelsPerCell; iPixel++) {
                    let bPixel = (wPixels & (wMask >>= nPixelShift)) >> (nShift -= nPixelShift);
                    this.setPixel(this.imageBuffer, x++, y, aPixelColors[bPixel]);
                }
                if (x > xMaxDirty) xMaxDirty = x;
                if (y < yDirty) yDirty = y;
                if (y >= yMaxDirty) yMaxDirty = y + 1;
            }
            addr += 2;
            iCell++;
            if (x >= this.nCols) {
                x = 0;
                y += 2;
                if (y > this.nRows) break;
                if (y == this.nRows) {
                    y = 1;
                    addr = addrScreen + this.cbSplit;
                }
            }
        }

        /**
         * Instead of blasting the ENTIRE imageBuffer into contextBuffer, and then blasting the ENTIRE
         * canvasBuffer onto contextScreen, e{ven for the smallest change, let's try to be a bit smarter about
         * the update (well, to the extent that the canvas APIs permit).
         */
        if (xDirty < this.nCols) {
            let cxDirty = xMaxDirty - xDirty;
            let cyDirty = yMaxDirty - yDirty;
            // this.contextBuffer.putImageData(this.imageBuffer, 0, 0);
            this.contextBuffer.putImageData(this.imageBuffer, 0, 0, xDirty, yDirty, cxDirty, cyDirty);
            /**
             * While ideally I would draw only the dirty portion of canvasBuffer, there usually isn't a 1-1 pixel mapping
             * between canvasBuffer and contextScreen.  In fact, the WHOLE POINT of the canvasBuffer is to leverage
             * drawImage()'s scaling ability; for example, a CGA graphics mode might be 640x200, whereas the canvas representing
             * the screen might be 960x400.  In those situations, if we draw interior rectangles, we often end up with subpixel
             * artifacts along the edges of those rectangles.  So it appears I must continue to redraw the entire canvasBuffer
             * on every change.
             *
            let xScreen = (((xDirty * this.cxScreen) / this.nCols) | 0);
            let yScreen = (((yDirty * this.cyScreen) / this.nRows) | 0);
            let cxScreen = (((cxDirty * this.cxScreen) / this.nCols) | 0);
            let cyScreen = (((cyDirty * this.cyScreen) / this.nRows) | 0);
            this.contextScreen.drawImage(this.canvasBuffer, xDirty, yDirty, cxDirty, cyDirty, xScreen, yScreen, cxScreen, cyScreen);
             */
            this.contextScreen.drawImage(this.canvasBuffer, 0, 0, this.nCols, this.nRows, 0, 0, this.cxScreen, this.cyScreen);
        }
        return cCells;
    }

    /**
     * updateScreenGraphicsEGA(addrBuffer, addrScreen, addrScreenLimit)
     *
     * TODO: Add support for blinking graphics (ATC.MODE.BLINK_ENABLE)
     *
     * @this {Videox86}
     * @param {number} addrBuffer
     * @param {number} addrScreen
     * @param {number} addrScreenLimit
     * @returns {number} (number of cells processed)
     */
    updateScreenGraphicsEGA(addrBuffer, addrScreen, addrScreenLimit)
    {
        let iCell = 0;
        let cCells = addrScreenLimit - addrScreen;
        let aPixelColors = this.getCardColors();
        let adwMemory = this.cardActive.adwMemory;

        let x = 0, y = 0;
        let xDirty = this.nCols, xMaxDirty = 0, yDirty = this.nRows, yMaxDirty = 0;
        let iPixelFirst = this.cardActive.regATCData[Card.ATC.HPAN.INDX] & Card.ATC.HPAN.SHIFT_LEFT;

        /**
         * TODO: What should happen if the card is programmed such that nColsLogical is LESS THAN nCols?
         */
        let nRowAdjust = (this.nColsLogical > this.nCols? ((this.nColsLogical - this.nCols - iPixelFirst) >> 3) : 0);

        this.cBlinkVisible = 0;
        while (addrScreen < addrScreenLimit) {
            let idw = addrScreen++ - addrBuffer;

            let data = adwMemory[idw];

            /**
             * Figure out how many visible pixels this data represents; usually 8, unless panning is being used.
             */
            let iPixel;
            let nPixels = 8;

            if (iPixelFirst) {
                /**
                 * Notice that we're not using the cell cache when panning is active, because the cached cell data no
                 * longer aligns with the data we're pulling out of the video buffer, and it's not clear that the effort
                 * to realign the data and make a valid cache comparison would save enough work to make it worthwhile.
                 */
                if (!x) {
                    data <<= iPixelFirst;
                    nPixels -= iPixelFirst;
                    /**
                     * This is as good a place as any to invalidate the cell cache when panning is active; this ensures
                     * we don't rely on stale cache contents once panning stops.
                     */
                    this.iCellCacheValid = 0;
                } else {
                    iPixel = this.nCols - x;
                    if (nPixels > iPixel) nPixels = iPixel;
                }
            } else {

                if (this.iCellCacheValid && data === this.aCellCache[iCell]) {
                    x += nPixels;
                    nPixels = 0;
                } else {
                    this.aCellCache[iCell] = data;
                }
                iCell++;
            }

            if (nPixels) {
                if (x < xDirty) xDirty = x;
                for (iPixel = 0; iPixel < nPixels; iPixel++) {
                    /**
                     * 0x80808080 may LOOK like a 32-bit value, but it is not, because JavaScript treats it as a POSITIVE
                     * number, and therefore outside the normal 32-bit integer range; however, the AND operator guarantees
                     * that the result will be a 32-bit value, so it doesn't matter.
                     */
                    let dwPixel = data & 0x80808080;

                    /**
                     * We now ensure that bPixel will default to 0 if an undefined value ever slips through again.
                     *
                     * How did an undefined value slip through?  We had (incorrectly) initialized entries in aEGADWToByte;
                     * for example, we used to set aEGADWToByte[0x80808080] instead of aEGADWToByte[0x80808080|0].  The
                     * former is a POSITIVE index that is outside the 32-bit integer range, whereas the latter is a NEGATIVE
                     * index, which is what this code requires.
                     */
                    let bPixel = Videox86.aEGADWToByte[dwPixel] || 0;
                    this.setPixel(this.imageBuffer, x++, y, aPixelColors[bPixel]);
                    data <<= 1;
                }
                if (x > xMaxDirty) xMaxDirty = x;
                if (y < yDirty) yDirty = y;
                if (y >= yMaxDirty) yMaxDirty = y + 1;
            }



            if (x >= this.nCols) {
                x = 0;
                if (++y >= this.nRows) break;
                addrScreen += nRowAdjust;
            }
        }

        if (iPixelFirst) cCells = 0;    // zero the cell count to inhibit setting iCellCacheValid

        /**
         * For a fascinating discussion of the best way to update the screen canvas at this point, see updateScreenGraphicsCGA().
         */
        if (xDirty < this.nCols) {
            let cxDirty = xMaxDirty - xDirty;
            let cyDirty = yMaxDirty - yDirty;
            this.contextBuffer.putImageData(this.imageBuffer, 0, 0, xDirty, yDirty, cxDirty, cyDirty);
            this.contextScreen.drawImage(this.canvasBuffer, 0, 0, this.nCols, this.nRows, 0, 0, this.cxScreen, this.cyScreen);
        }
        return cCells;
    }

    /**
     * updateScreenGraphicsVGA(addrBuffer, addrScreen, addrScreenLimit)
     *
     * This function name is a slight misnomer: updateScreenGraphicsEGA() takes care of all the 4bpp video modes
     * (first introduced by the EGA and later expanded by the VGA), where each pixel's bits are spread across the 4
     * planes, whereas this function takes care of just the 8bpp video modes introduced by the VGA, such as mode 0x13
     * (320x200x256), where each pixel's bits are contained within a single plane.  This is essentially all 256-color
     * modes (CHAIN4, "Mode X", etc), hence the hard-coded call to getCardColors(8).
     *
     * TODO: Add support for blinking graphics (ATC.MODE.BLINK_ENABLE)
     *
     * @this {Videox86}
     * @param {number} addrBuffer
     * @param {number} addrScreen
     * @param {number} addrScreenLimit
     * @returns {number} (number of cells processed)
     */
    updateScreenGraphicsVGA(addrBuffer, addrScreen, addrScreenLimit)
    {
        let iCell = 0;
        let cCells = addrScreenLimit - addrScreen;
        let addr = addrScreen;
        let aPixelColors = this.getCardColors(8);
        let adwMemory = this.cardActive.adwMemory;

        let x = 0, y = 0;
        let xDirty = this.nCols, xMaxDirty = 0, yDirty = this.nRows, yMaxDirty = 0;
        let cbInc = (this.cardActive.regSEQData[Card.SEQ.MEMMODE.INDX] & Card.SEQ.MEMMODE.CHAIN4)? 4 : 1;
        let iPixelFirst = this.cardActive.regATCData[Card.ATC.HPAN.INDX] & Card.ATC.HPAN.SHIFT_LEFT;

        /**
         * TODO: What should happen if the card is programmed such that nColsLogical is LESS THAN nCols?
         */
        let nRowAdjust = (this.nColsLogical > this.nCols? ((this.nColsLogical - this.nCols - iPixelFirst) >> 3) : 0);

        this.cBlinkVisible = 0;
        while (addr < addrScreenLimit) {
            let idw = addr - addrBuffer;

            let data = adwMemory[idw];

            /**
             * Figure out how many visible pixels this data represents; usually 4, unless panning is being used.
             */
            let iPixel;
            let nPixels = 4;

            if (iPixelFirst) {
                /**
                 * TODO: Implement support for 8bpp panning
                 */
            } else {

                if (this.iCellCacheValid && data === this.aCellCache[iCell]) {
                    x += nPixels;
                    nPixels = 0;
                } else {
                    this.aCellCache[iCell] = data;
                }
                iCell++;
            }

            if (nPixels) {
                if (x < xDirty) xDirty = x;
                for (iPixel = 0; iPixel < nPixels; iPixel++) {
                    this.setPixel(this.imageBuffer, x++, y, aPixelColors[data & 0xff]);
                    data >>>= 8;
                }
                if (x > xMaxDirty) xMaxDirty = x;
                if (y < yDirty) yDirty = y;
                if (y >= yMaxDirty) yMaxDirty = y + 1;
            }



            addr += cbInc;

            if (x >= this.nCols) {
                x = 0;
                if (++y >= this.nRows) break;
                addr += nRowAdjust;
            }
        }

        if (iPixelFirst) cCells = 0;    // zero the cell count to inhibit setting iCellCacheValid

        /**
         * For a fascinating discussion of the best way to update the screen canvas at this point, see updateScreenGraphicsCGA().
         */
        if (xDirty < this.nCols) {
            let cxDirty = xMaxDirty - xDirty;
            let cyDirty = yMaxDirty - yDirty;
            this.contextBuffer.putImageData(this.imageBuffer, 0, 0, xDirty, yDirty, cxDirty, cyDirty);
            this.contextScreen.drawImage(this.canvasBuffer, 0, 0, this.nCols, this.nRows, 0, 0, this.cxScreen, this.cyScreen);
        }
        return cCells;
    }

    /**
     * getRetraceBits(card)
     *
     * This returns a byte value with two bits set or clear as appropriate: RETRACE and VRETRACE.
     *
     * @this {Videox86}
     * @param {Object} card
     * @returns {number}
     */
    getRetraceBits(card)
    {
        /**
         * NOTE: The bits CGA.STATUS.RETRACE (0x01) and CGA.STATUS.VRETRACE (0x08) match the EGA definitions,
         * and they also correspond to the MDA bits MDA.STATUS.HDRIVE (0x01) and MDA.STATUS.BWVIDEO (0x08); it's
         * unclear why the MDA uses different designations, but the bits appear to serve the same purpose.
         */
        let b = 0;
        let nCycles = this.cpu.getCycles();
        let nCyclesElapsed = nCycles - card.nCyclesVertRetrace;
        /**
         * The following code is a work-around for IBM's VGA diagnostic code starting at C000:01E5,
         * which expects an entire screen refresh (ie, 400 horizontal retraces followed by 1 vertical
         * retrace) to take roughly 1/30 of a second instead of 1/60.  The longer vertical retrace
         * period may be due to some idiosyncrasy of how they programmed the card beforehand, I'm not
         * sure.  But I do know that they've turned on the SEQ.CLKMODE.SCREEN_OFF bit, so I use that
         * bit to trigger this work-around, which involves cutting the number of elapsed cycles in half,
         * as well as skipping every other (odd) vertical retrace in startVerticalRetrace().
         */
        if (card.nCard === Videox86.CARD.VGA) {
            if (card.regSEQData[Card.SEQ.CLKMODE.INDX] & Card.SEQ.CLKMODE.SCREEN_OFF) {
                nCyclesElapsed >>>= 1;
            }
        }
        if (nCyclesElapsed < 0) {       // presumably the CPU cycle count was reset since our last call
            card.nCyclesVertRetrace = nCycles;
            nCyclesElapsed = 0;
        }
        nCyclesElapsed -= card.nCyclesVertPeriod - card.nCyclesVertActive;
        if (nCyclesElapsed < 0) {
            b |= Card.CGA.STATUS.VRETRACE | Card.CGA.STATUS.RETRACE;
        } else {
            let nCyclesHorzRemain = nCyclesElapsed % card.nCyclesHorzPeriod;
            if (nCyclesHorzRemain > card.nCyclesHorzActive) {
                b |= Card.CGA.STATUS.RETRACE;
            }
        }
        return b;
    }

    /**
     * inMDAIndx(port, addrFrom)
     *
     * @this {Videox86}
     * @param {number} port (0x3B4)
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     * @returns {number|undefined}
     */
    inMDAIndx(port, addrFrom)
    {
        return this.inCRTCIndx(this.cardMono, port, addrFrom);
    }

    /**
     * outMDAIndx(port, bOut, addrFrom)
     *
     * @this {Videox86}
     * @param {number} port (0x3B4)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     */
    outMDAIndx(port, bOut, addrFrom)
    {
        this.outCRTCIndx(this.cardMono, port, bOut, addrFrom);
    }

    /**
     * inMDAData(port, addrFrom)
     *
     * @this {Videox86}
     * @param {number} port (0x3B5)
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     * @returns {number|undefined}
     */
    inMDAData(port, addrFrom)
    {
        return this.inCRTCData(this.cardMono, port, addrFrom);
    }

    /**
     * outMDAData(port, bOut, addrFrom)
     *
     * @this {Videox86}
     * @param {number} port (0x3B5)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     */
    outMDAData(port, bOut, addrFrom)
    {
        this.outCRTCData(this.cardMono, port, bOut, addrFrom);
    }

    /**
     * inMDAMode(port, addrFrom)
     *
     * @this {Videox86}
     * @param {number} port (0x3B8)
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     * @returns {number}
     */
    inMDAMode(port, addrFrom)
    {
        return this.inCardMode(this.cardMono, addrFrom);
    }

    /**
     * outMDAMode(port, bOut, addrFrom)
     *
     * @this {Videox86}
     * @param {number} port (0x3B8)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     */
    outMDAMode(port, bOut, addrFrom)
    {
        this.outCardMode(this.cardMono, bOut, addrFrom);
    }

    /**
     * inMDAStatus(port, addrFrom)
     *
     * @this {Videox86}
     * @param {number} port (0x3BA)
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     * @returns {number}
     */
    inMDAStatus(port, addrFrom)
    {
        return this.inCardStatus(this.cardMono, addrFrom);
    }

    /**
     * outFeat(port, bOut, addrFrom)
     *
     * @this {Videox86}
     * @param {number} port (0x3BA or 0x3DA)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     *
     * NOTE: While this port also existed on the MDA and CGA, it existed only as an INPUT port, not an OUTPUT port.
     */
    outFeat(port, bOut, addrFrom)
    {
        this.cardEGA.regFeat = (this.cardEGA.regFeat & ~Card.FEAT_CTRL.BITS) | (bOut & Card.FEAT_CTRL.BITS);
        this.printIO(port, bOut, addrFrom, "FEAT");
    }

    /**
     * inATCIndx(port, addrFrom)
     *
     * Technically, port 0x3C0 is readable only on a VGA, but we allow reads on an EGA as well,
     * primarily for debugging purposes.  Moreover, ATC port reads do NOT toggle the ATC address/data
     * flip-flop; only writes have that effect.
     *
     * @this {Videox86}
     * @param {number} port (0x3C0)
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     * @returns {number}
     */
    inATCIndx(port, addrFrom)
    {
        let b = this.cardEGA.regATCIndx;
        if (!addrFrom || this.messageEnabled()) {
            this.printIO(Card.ATC.PORT, undefined, addrFrom, "ATC.INDX", b, true);
        }
        return b;
    }

    /**
     * inATCData(port, addrFrom)
     *
     * Technically, port 0x3C0 is readable only on a VGA, but we allow reads on an EGA as well,
     * primarily for debugging purposes.  Moreover, ATC port reads do NOT toggle the ATC address/data
     * flip-flop; only writes have that effect.
     *
     * @this {Videox86}
     * @param {number} port (0x3C1)
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     * @returns {number}
     */
    inATCData(port, addrFrom)
    {
        let b = this.cardEGA.regATCData[this.cardEGA.regATCIndx & Card.ATC.INDX_MASK];
        if (!addrFrom || this.messageEnabled()) {
            this.printIO(Card.ATC.PORT, undefined, addrFrom, "ATC." + this.cardEGA.asATCRegs[this.cardEGA.regATCIndx & Card.ATC.INDX_MASK], b, true);
        }
        return b;
    }

    /**
     * outATC(port, bOut, addrFrom)
     *
     * @this {Videox86}
     * @param {number} port (0x3C0)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     */
    outATC(port, bOut, addrFrom)
    {
        let card = this.cardEGA;
        let fPalEnabled = (card.regATCIndx & Card.ATC.INDX_PAL_ENABLE);
        if (!card.fATCData) {
            card.regATCIndx = bOut;
            this.printIO(port, bOut, addrFrom, "ATC.INDX");
            card.fATCData = true;
            if ((bOut & Card.ATC.INDX_PAL_ENABLE) && !fPalEnabled) {
                /**
                 * TODO: Consider whether it's really necessary (or desirable) to immediately update the screen
                 * on a font change, or if it's sufficient to simply wait until the next normal periodic update.
                 */
                if (this.buildFont(true)) {
                    this.updateScreen(true);
                }
            }
            else {
                /**
                 * TODO: We might want a screen blanking function, suitable for any mode, when INDX_PAL_ENABLE is cleared.
                 * powerDown() might like to use such a function, too.  updateScreen() already disables any further screen
                 * updates while INDX_PAL_ENABLE is clear (except when fForce is true), but that's all we currently do.
                 *
                 *      if (!(bOut & Card.ATC.INDX_PAL_ENABLE) && fPalEnabled) this.blankScreen();
                 *
                 * However, there also needs to be a delay, because when the IBM VGA BIOS changes the mode, it updates
                 * the ATC palette registers in such a way that INDX_PAL_ENABLE is constantly toggled; here's one iteration:
                 *
                 *      C000:2B39 EC              IN       AL,DX
                 *      C000:2B3A B2C0            MOV      DL,C0
                 *      C000:2B3C 8BC3            MOV      AX,BX
                 *      C000:2B3E 86C4            XCHG     AL,AH
                 *      C000:2B40 EE              OUT      DX,AL    <-- this ATC index value does NOT contain 0x20
                 *      C000:2B41 86C4            XCHG     AL,AH
                 *      C000:2B43 EE              OUT      DX,AL
                 *      C000:2B44 B020            MOV      AL,20
                 *      C000:2B46 EE              OUT      DX,AL    <-- this ATC index value obviously DOES contain 0x20
                 *
                 * I'm not sure there are any situations where deliberately flickering the screen is a good thing -- unless
                 * someone REALLY wants to recreate the ugly flickering scroll of a CGA...?
                 */
            }
        }
        else {
            card.fATCData = false;
            let iReg = card.regATCIndx & Card.ATC.INDX_MASK;
            if (iReg >= Card.ATC.PALETTE_REGS || !fPalEnabled) {
                let fModified = (card.regATCData[iReg] !== bOut);
                if (Videox86.TRAPALL || fModified) {
                    if (!addrFrom || this.messageEnabled()) {
                        this.printIO(port, bOut, addrFrom, "ATC." + card.asATCRegs[iReg], undefined, true);
                    }
                }
                if (fModified) {
                    card.regATCData[iReg] = bOut;
                    if (iReg == Card.ATC.HPAN.INDX) {
                        if (this.fOverBuffer) {
                            this.fShifted = true;
                            /**
                             * TODO: The SHIFT_LEFT value apparently has a slightly different interpretation in
                             * monochrome mode (ie, when font.cxChar == 9, 8 means no shift and 0-7 means 1-8 shifts).
                             */
                            this.nShiftLeft = bOut & Card.ATC.HPAN.SHIFT_LEFT;
                        }
                    }
                    else if (iReg != Card.ATC.OVERSCAN.INDX) {
                        this.invalidateCellCache(true);
                    }
                }
            }
        }
    }

    /**
     * inStatus0(port, addrFrom)
     *
     * @this {Videox86}
     * @param {number} port (0x3C2)
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     * @returns {number}
     */
    inStatus0(port, addrFrom)
    {
        let bSWBit = 0;
        if (this.nCard == Videox86.CARD.EGA) {
            let iBit = 3 - ((this.cardEGA.regMisc & Card.MISC.CLOCK_SELECT) >> 2);    // this is the desired SW # (0-3)
            bSWBit = (this.bEGASwitches & (1 << iBit)) << (Card.STATUS0.SWSENSE_SHIFT - iBit);
        } else {
            /**
             * The IBM VGA ROM expects the SWSENSE bit to change according to how the DAC is programmed.
             *
             * At C000:0391, the ROM selects the following array at 0x0454:
             *
             *      db  0x12,0x12,0x12,0x10
             *
             * and writes the first 3 bytes to DAC register #0, and then compares SWSENSE to the 4th byte (0x10).
             *
             * If the 4th byte matches, then the ROM clears the BIOS "monochrome monitor" bit, and does the same
             * thing again with 5 more arrays, expecting the 4th byte in all 5 arrays to match SWSENSE, and being
             * very unhappy if they don't:
             *
             *      db  0x14,0x14,0x14,0x10
             *      db  0x2D,0x14,0x14,0x00
             *      db  0x14,0x2D,0x14,0x00
             *      db  0x14,0x14,0x2D,0x00
             *      db  0x2D,0x2D,0x2D,0x00
             *
             * I ensure much happiness by setting SWSENSE unless any of the three 6-bit DAC values contain 0x2D.
             *
             * This hard-coded behavior assumes a color monitor.  If you really want to simulate a monochrome monitor,
             * then the 1st array (above) must mismatch, and a different set of arrays must all match:
             *
             *      db  0x04,0x12,0x04,0x10
             *      db  0x1E,0x12,0x04,0x00
             *      db  0x04,0x2D,0x04,0x00
             *      db  0x04,0x16,0x15,0x00
             *      db  0x00,0x00,0x00,0x10
             *
             * In other words, for a monochrome monitor, set SWSENSE only when DAC register #0 matches the first and last
             * sets of values.
             */
            let dwDAC = this.cardEGA.regDACData[0];
            if ((dwDAC & 0x3f) != 0x2d && (dwDAC & (0x3f << 6)) != (0x2d << 6) && (dwDAC & (0x3f << 12)) != (0x2d << 12)) {
                bSWBit |= Card.STATUS0.SWSENSE;
            }
        }
        let b = ((this.cardEGA.regStatus0 & ~Card.STATUS0.SWSENSE) | bSWBit);
        /**
         * TODO: Figure out where Card.STATUS0.FEAT bits should come from....
         */
        this.cardEGA.regStatus0 = b;
        this.printIO(Card.STATUS0.PORT, undefined, addrFrom, "STATUS0", b);
        return b;
    }

    /**
     * @this {Videox86}
     * @param {number} port (0x3C2)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     */
    outMisc(port, bOut, addrFrom)
    {
        this.cardEGA.regMisc = bOut;
        this.enableEGA();
        this.printIO(Card.MISC.PORT_WRITE, bOut, addrFrom, "MISC");
    }

    /**
     * inVGAEnable(port, addrFrom)
     *
     * @this {Videox86}
     * @param {number} port (0x3C3)
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     * @returns {number}
     */
    inVGAEnable(port, addrFrom)
    {
        let b = this.cardEGA.regVGAEnable;
        this.printIO(Card.VGA_ENABLE.PORT, undefined, addrFrom, "VGA_ENABLE", b);
        return b;
    }

    /**
     * outVGAEnable(port, bOut, addrFrom)
     *
     * @this {Videox86}
     * @param {number} port (0x3C3)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     */
    outVGAEnable(port, bOut, addrFrom)
    {
        this.cardEGA.regVGAEnable = bOut;
        this.printIO(Card.VGA_ENABLE.PORT, bOut, addrFrom, "VGA_ENABLE");
    }

    /**
     * inSEQIndx(port, addrFrom)
     *
     * @this {Videox86}
     * @param {number} port (0x3C4)
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     * @returns {number}
     */
    inSEQIndx(port, addrFrom)
    {
        let b = this.cardEGA.regSEQIndx;
        this.printIO(Card.SEQ.INDX.PORT, undefined, addrFrom, "SEQ.INDX", b);
        return b;
    }

    /**
     * outSEQIndx(port, bOut, addrFrom)
     *
     * @this {Videox86}
     * @param {number} port (0x3C4)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     */
    outSEQIndx(port, bOut, addrFrom)
    {
        this.cardEGA.regSEQIndx = bOut;
        this.printIO(Card.SEQ.INDX.PORT, bOut, addrFrom, "SEQ.INDX");
    }

    /**
     * inSEQData(port, addrFrom)
     *
     * @this {Videox86}
     * @param {number} port (0x3C5)
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     * @returns {number}
     */
    inSEQData(port, addrFrom)
    {
        let b = this.cardEGA.regSEQData[this.cardEGA.regSEQIndx];
        if (!addrFrom || this.messageEnabled()) {
            this.printIO(Card.SEQ.DATA.PORT, undefined, addrFrom, "SEQ." + this.cardEGA.asSEQRegs[this.cardEGA.regSEQIndx], b, true);
        }
        return b;
    }

    /**
     * outSEQData(port, bOut, addrFrom)
     *
     * @this {Videox86}
     * @param {number} port (0x3C5)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     */
    outSEQData(port, bOut, addrFrom)
    {
        if (Videox86.TRAPALL || this.cardEGA.regSEQData[this.cardEGA.regSEQIndx] !== bOut) {
            if (!addrFrom || this.messageEnabled()) {
                this.printIO(Card.SEQ.DATA.PORT, bOut, addrFrom, "SEQ." + this.cardEGA.asSEQRegs[this.cardEGA.regSEQIndx], undefined, true);
            }
            this.cardEGA.regSEQData[this.cardEGA.regSEQIndx] = bOut;
        }

        let nFontSelect;

        switch(this.cardEGA.regSEQIndx) {

        case Card.SEQ.MAPMASK.INDX:
            this.cardEGA.nSeqMapMask = Videox86.aEGAByteToDW[bOut & Card.SEQ.MAPMASK.MAPS];
            break;

        case Card.SEQ.CHARMAP.INDX:
            nFontSelect = this.getSelectedFonts();
            if (nFontSelect != this.nFontSelect) {
                if (DEBUG) {
                    if ((nFontSelect & 0xff) == (nFontSelect >> 8)) {
                        if (this.messageEnabled(MESSAGE.VIDEO + MESSAGE.PORT)) {
                            this.printf("outSEQData(%#04X): font selection changing from %#06X to %#06X\n", bOut, this.nFontSelect, nFontSelect);
                        }
                    } else {
                        this.printf("outSEQData(%#04X): low font (%#04X) differs from high font (%#04X)\n", bOut, nFontSelect & 0xff, nFontSelect >> 8);
                        this.cpu.stopCPU();
                    }
                }
                let nFontPrev = this.nFontSelect;
                this.buildFont(true);

                this.invalidateCellCache(false, nFontSelect, nFontPrev);
                /**
                 * TODO: Consider whether this code should, like outATC(), immediately update the screen
                 * on a font change, or if it's sufficient to simply wait until the next normal periodic update.
                 */
            }
            break;

        case Card.SEQ.MEMMODE.INDX:
            if (this.setCardAccess(this.getCardAccess())) {
                /**
                 * When switching screens (via SysReq) on early revisions of OS/2 (eg, FOOTBALL), the screen would go
                 * blank; this appeared to be because when the card is reprogrammed, we first think the card is going into
                 * graphics mode, then we reverse course when it becomes clear that the card is going back into text mode,
                 * but unfortunately, at that precise moment, the Sequencer hasn't been fully reprogrammed, so when we're
                 * reading screen memory, we're getting back ZEROS for every odd byte (which are the text attribute bytes),
                 * so the screen is redrawn as black-on-black.
                 *
                 * My solution was to change setCardAccess() to indicate whether it actually altered the video buffer
                 * address and/or format, and if so, then force another screen update.
                 *
                 * UPDATE: This change was NOT sufficient to resolve the OS/2 screen-switching bug described above; in fact,
                 * it's apparently not even necessary, because the REAL problem was caused by PAGED blocks with stale
                 * physical video memory blocks; the solution was for the Bus addMemory() and removeMemory() functions to
                 * call the the CPU flushPageBlocks() function.  With that change in place, the window now stays in sync
                 * with the buffer.
                 *
                 * And while calling updateScreen() here might still seem like a good idea, it CAN hurt performance, even
                 * if we're doing it only when setCardAccess() indicates a change, so I'm commenting the call out.
                 */
                // this.updateScreen(true);
            }
            break;

        default:
            break;
        }
    }

    /**
     * inDACMask(port, addrFrom)
     *
     * @this {Videox86}
     * @param {number} port (0x3C6)
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     * @returns {number}
     */
    inDACMask(port, addrFrom)
    {
        let b = this.cardEGA.regDACMask;
        if (!addrFrom || this.messageEnabled()) {
            this.printIO(Card.DAC.MASK.PORT, undefined, addrFrom, "DAC.MASK", b, true);
        }
        return b;
    }

    /**
     * outDACMask(port, bOut, addrFrom)
     *
     * @this {Videox86}
     * @param {number} port (0x3C6)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     */
    outDACMask(port, bOut, addrFrom)
    {
        if (Videox86.TRAPALL || this.cardEGA.regDACMask !== bOut) {
            if (!addrFrom || this.messageEnabled()) {
                this.printIO(Card.DAC.MASK.PORT, bOut, addrFrom, "DAC.MASK", undefined, true);
            }
            this.cardEGA.regDACMask = bOut;
        }
    }

    /**
     * inDACState(port, addrFrom)
     *
     * @this {Videox86}
     * @param {number} port (0x3C7)
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     * @returns {number}
     */
    inDACState(port, addrFrom)
    {
        let b = this.cardEGA.regDACState;
        if (!addrFrom || this.messageEnabled()) {
            this.printIO(Card.DAC.STATE.PORT, undefined, addrFrom, "DAC.STATE", b, true);
        }
        return b;
    }

    /**
     * outDACRead(port, bOut, addrFrom)
     *
     * @this {Videox86}
     * @param {number} port (0x3C7)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     */
    outDACRead(port, bOut, addrFrom)
    {
        if (!addrFrom || this.messageEnabled()) {
            this.printIO(Card.DAC.ADDR.PORT_READ, bOut, addrFrom, "DAC.READ", undefined, true);
        }
        this.cardEGA.regDACAddr = bOut;
        this.cardEGA.regDACState = Card.DAC.STATE.MODE_READ;
        this.cardEGA.regDACShift = 0;
    }

    /**
     * outDACWrite(port, bOut, addrFrom)
     *
     * @this {Videox86}
     * @param {number} port (0x3C8)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     */
    outDACWrite(port, bOut, addrFrom)
    {
        if (!addrFrom || this.messageEnabled()) {
            this.printIO(Card.DAC.ADDR.PORT_WRITE, bOut, addrFrom, "DAC.WRITE", undefined, true);
        }
        this.cardEGA.regDACAddr = bOut;
        this.cardEGA.regDACState = Card.DAC.STATE.MODE_WRITE;
        this.cardEGA.regDACShift = 0;
    }

    /**
     * inDACData(port, addrFrom)
     *
     * @this {Videox86}
     * @param {number} port (0x3C9)
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     * @returns {number}
     */
    inDACData(port, addrFrom)
    {
        let b = (this.cardEGA.regDACData[this.cardEGA.regDACAddr] >> this.cardEGA.regDACShift) & 0x3f;
        if (!addrFrom || this.messageEnabled()) {
            this.printIO(Card.DAC.DATA.PORT, undefined, addrFrom, "DAC.DATA[" + StrLib.toHexByte(this.cardEGA.regDACAddr) + "][" + StrLib.toHexByte(this.cardEGA.regDACShift) + "]", b, true);
        }
        this.cardEGA.regDACShift += 6;
        if (this.cardEGA.regDACShift > 12) {
            this.cardEGA.regDACShift = 0;
            this.cardEGA.regDACAddr = (this.cardEGA.regDACAddr + 1) & (Card.DAC.TOTAL_REGS-1);
        }
        return b;
    }

    /**
     * outDACData(port, bOut, addrFrom)
     *
     * @this {Videox86}
     * @param {number} port (0x3C9)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     */
    outDACData(port, bOut, addrFrom)
    {
        let dw = this.cardEGA.regDACData[this.cardEGA.regDACAddr];
        if (!addrFrom || this.messageEnabled()) {
            this.printIO(Card.DAC.DATA.PORT, bOut, addrFrom, "DAC.DATA[" + StrLib.toHexByte(this.cardEGA.regDACAddr) + "][" + StrLib.toHexByte(this.cardEGA.regDACShift) + "]", undefined, true);
        }
        let dwNew = (dw & ~(0x3f << this.cardEGA.regDACShift)) | ((bOut & 0x3f) << this.cardEGA.regDACShift);
        if (dw !== dwNew) {
            this.cardEGA.regDACData[this.cardEGA.regDACAddr] = dwNew;
            this.invalidateCellCache(true);
        }
        this.cardEGA.regDACShift += 6;
        if (this.cardEGA.regDACShift > 12) {
            this.cardEGA.regDACShift = 0;
            this.cardEGA.regDACAddr = (this.cardEGA.regDACAddr + 1) & (Card.DAC.TOTAL_REGS-1);
        }
    }

    /**
     * inVGAFeat(port, addrFrom)
     *
     * @this {Videox86}
     * @param {number} port (0x3CA)
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     * @returns {number}
     */
    inVGAFeat(port, addrFrom)
    {
        let b = this.cardEGA.regFeat;
        this.printIO(Card.FEAT_CTRL.PORT_READ, undefined, addrFrom, "FEAT", b);
        return b;
    }

    /**
     * outGRCPos2(port, bOut, addrFrom)
     *
     * "The EGA was originally implemented by IBM using two Graphics Controller Chips. This register is used to program
     * the Graphics #2 chip. See the Graphics #1 Position Register for details."
     *
     * "A one should be loaded into this location to map host data bus bits 2 and 3 to display planes 2 and 3, respectively."
     *
     * @this {Videox86}
     * @param {number} port (0x3CA)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     */
    outGRCPos2(port, bOut, addrFrom)
    {
        this.cardEGA.regGRCPos2 = bOut;
        this.printIO(Card.GRC.POS2_PORT, bOut, addrFrom, "GRC2");
    }

    /**
     * inVGAMisc(port, addrFrom)
     *
     * @this {Videox86}
     * @param {number} port (0x3CC)
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     * @returns {number}
     */
    inVGAMisc(port, addrFrom)
    {
        let b = this.cardEGA.regMisc;
        this.printIO(Card.MISC.PORT_READ, undefined, addrFrom, "MISC", b);
        return b;
    }

    /**
     * outGRCPos1(port, bOut, addrFrom)
     *
     * "The EGA was originally implemented by IBM using two Graphics Controller Chips. It was necessary to program
     * each to respond to a different set of two consecutive bits of the 8-bit host data bus. In the IBM EGA implementation,
     * a 0 must be loaded into this register. In the VGA, there is no analogous register."
     *
     * "A zero should be loaded into this location to map host data bus bits 0 and 1 to display planes 0 and 1 respectively."
     *
     * Note that this register was not readable on the EGA, and when the VGA came along, reads of this port read the Misc reg.
     *
     * @this {Videox86}
     * @param {number} port (0x3CC)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     */
    outGRCPos1(port, bOut, addrFrom)
    {
        this.cardEGA.regGRCPos1 = bOut;
        this.printIO(Card.GRC.POS1_PORT, bOut, addrFrom, "GRC1");
    }

    /**
     * inGRCIndx(port, addrFrom)
     *
     * @this {Videox86}
     * @param {number} port (0x3CE)
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     * @returns {number}
     */
    inGRCIndx(port, addrFrom)
    {
        let b = this.cardEGA.regGRCIndx;
        this.printIO(Card.GRC.INDX.PORT, undefined, addrFrom, "GRC.INDX", b);
        return b;
    }

    /**
     * outGRCIndx(port, bOut, addrFrom)
     *
     * @this {Videox86}
     * @param {number} port (0x3CE)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     */
    outGRCIndx(port, bOut, addrFrom)
    {
        this.cardEGA.regGRCIndx = bOut;
        this.printIO(Card.GRC.INDX.PORT, bOut, addrFrom, "GRC.INDX");
    }

    /**
     * inGRCData(port, addrFrom)
     *
     * @this {Videox86}
     * @param {number} port (0x3CF)
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     * @returns {number}
     */
    inGRCData(port, addrFrom)
    {
        let b = this.cardEGA.regGRCData[this.cardEGA.regGRCIndx];
        if (!addrFrom || this.messageEnabled()) {
            this.printIO(Card.GRC.DATA.PORT, undefined, addrFrom, "GRC." + this.cardEGA.asGRCRegs[this.cardEGA.regGRCIndx], b);
        }
        return b;
    }

    /**
     * outGRCData(port, bOut, addrFrom)
     *
     * @this {Videox86}
     * @param {number} port (0x3CF)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     */
    outGRCData(port, bOut, addrFrom)
    {
        if (Videox86.TRAPALL || this.cardEGA.regGRCData[this.cardEGA.regGRCIndx] !== bOut) {
            if (!addrFrom || this.messageEnabled()) {
                this.printIO(Card.GRC.DATA.PORT, bOut, addrFrom, "GRC." + this.cardEGA.asGRCRegs[this.cardEGA.regGRCIndx]);
            }
            this.cardEGA.regGRCData[this.cardEGA.regGRCIndx] = bOut;
        }
        switch(this.cardEGA.regGRCIndx) {
        case Card.GRC.SRESET.INDX:
            this.cardEGA.nSetMapData = Videox86.aEGAByteToDW[bOut & 0xf];
            this.cardEGA.nSetMapBits = this.cardEGA.nSetMapData & ~this.cardEGA.nSetMapMask;
            break;
        case Card.GRC.ESRESET.INDX:
            this.cardEGA.nSetMapMask = ~Videox86.aEGAByteToDW[bOut & 0xf];
            this.cardEGA.nSetMapBits = this.cardEGA.nSetMapData & ~this.cardEGA.nSetMapMask;
            break;
        case Card.GRC.COLORCOMP.INDX:
            this.cardEGA.nColorCompare = Videox86.aEGAByteToDW[bOut & 0xf] & (0x80808080|0);
            break;
        case Card.GRC.DATAROT.INDX:
        case Card.GRC.MODE.INDX:
            this.setCardAccess(this.getCardAccess());
            break;
        case Card.GRC.READMAP.INDX:
            this.cardEGA.nReadMapShift = (bOut & Card.GRC.READMAP.NUM) << 3;
            break;
        case Card.GRC.MISC.INDX:
            this.checkMode();
            break;
        case Card.GRC.COLORDC.INDX:
            this.cardEGA.nColorDontCare = Videox86.aEGAByteToDW[bOut & 0xf] & (0x80808080|0);
            break;
        case Card.GRC.BITMASK.INDX:
            this.cardEGA.nBitMapMask = bOut | (bOut << 8) | (bOut << 16) | (bOut << 24);
            break;
        default:
            break;
        }
    }

    /**
     * inCGAIndx(port, addrFrom)
     *
     * @this {Videox86}
     * @param {number} port (0x3D4)
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     * @returns {number|undefined}
     */
    inCGAIndx(port, addrFrom)
    {
        return this.inCRTCIndx(this.cardColor, port, addrFrom);
    }

    /**
     * outCGAIndx(port, bOut, addrFrom)
     *
     * @this {Videox86}
     * @param {number} port (0x3D4)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     */
    outCGAIndx(port, bOut, addrFrom)
    {
        this.outCRTCIndx(this.cardColor, port, bOut, addrFrom);
    }

    /**
     * inCGAData(port, addrFrom)
     *
     * @this {Videox86}
     * @param {number} port (0x3D5)
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     * @returns {number|undefined}
     */
    inCGAData(port, addrFrom)
    {
        return this.inCRTCData(this.cardColor, port, addrFrom);
    }

    /**
     * outCGAData(port, bOut, addrFrom)
     *
     * @this {Videox86}
     * @param {number} port (0x3D5)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     */
    outCGAData(port, bOut, addrFrom)
    {
        this.outCRTCData(this.cardColor, port, bOut, addrFrom);
    }

    /**
     * inCGAMode(port, addrFrom)
     *
     * @this {Videox86}
     * @param {number} port (0x3D8)
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     * @returns {number}
     */
    inCGAMode(port, addrFrom)
    {
        return this.inCardMode(this.cardColor, addrFrom);
    }

    /**
     * outCGAMode(port, bOut, addrFrom)
     *
     * @this {Videox86}
     * @param {number} port (0x3D8)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     */
    outCGAMode(port, bOut, addrFrom)
    {
        this.outCardMode(this.cardColor, bOut, addrFrom);
    }

    /**
     * inCGAColor(port, addrFrom)
     *
     * @this {Videox86}
     * @param {number} port (0x3D9)
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     * @returns {number}
     */
    inCGAColor(port, addrFrom)
    {
        let b = this.cardColor.regColor;
        if (!addrFrom || this.messageEnabled()) {
            this.printIO(port /* this.cardColor.port + 5 */, undefined, addrFrom, this.cardColor.type + ".COLOR", b);
        }
        return b;
    }

    /**
     * outCGAColor(port, bOut, addrFrom)
     *
     * @this {Videox86}
     * @param {number} port (0x3D9)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     */
    outCGAColor(port, bOut, addrFrom)
    {
        if (!addrFrom || this.messageEnabled()) {
            this.printIO(port /* this.cardColor.port + 5 */, bOut, addrFrom, this.cardColor.type + ".COLOR");
        }
        if (this.cardColor.regColor !== bOut) {
            this.cardColor.regColor = bOut;
            this.invalidateCellCache(true);
        }
    }

    /**
     * inCGAStatus(port, addrFrom)
     *
     * @this {Videox86}
     * @param {number} port (0x3DA)
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     * @returns {number}
     */
    inCGAStatus(port, addrFrom)
    {
        return this.inCardStatus(this.cardColor, addrFrom);
    }

    /**
     * inCRTCIndx(card, port, addrFrom)
     *
     * @this {Videox86}
     * @param {Object} card
     * @param {number} port
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     * @returns {number|undefined}
     */
    inCRTCIndx(card, port, addrFrom)
    {
        let b;
        /**
         * The IBM VGA ROM makes some hardware determinations based on how the CRTC controller responds when
         * the IO_SELECT bit in the Miscellaneous Output Register is cleared; normally, that would mean ports
         * 0x3B? are decoded and ports 0x3D? are ignored.  We didn't used to bother ignoring them, but the
         * VGA ROM's logic requires it, so now we also check fActive.  However, we ignore only CRTC reads;
         * we retain any writes in case that information proves useful later.
         *
         * Note that returning an undefined value now signals the Bus component to return whatever default value
         * it prefers (normally 0xff).
         */
        if (card.fActive) b = card.regCRTIndx;
        this.printIO(port, undefined, addrFrom, "CRTC.INDX", b);
        return b;
    }

    /**
     * outCRTCIndx(card, port, bOut, addrFrom)
     *
     * @this {Videox86}
     * @param {Object} card
     * @param {number} port
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     */
    outCRTCIndx(card, port, bOut, addrFrom)
    {
        card.regCRTPrev = card.regCRTIndx;
        card.regCRTIndx = bOut & Card.CGA.CRTC.INDX.MASK;
        this.printIO(port /* card.port */, bOut, addrFrom, "CRTC.INDX");
    }

    /**
     * inCRTCData(card, port, addrFrom)
     *
     * @this {Videox86}
     * @param {Object} card
     * @param {number} port
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     * @returns {number|undefined}
     */
    inCRTCData(card, port, addrFrom)
    {
        let b;
        /**
         * The IBM VGA ROM makes some hardware determinations based on how the CRTC controller responds when
         * the IO_SELECT bit in the Miscellaneous Output Register is cleared; normally, that would mean ports
         * 0x3B? are decoded and ports 0x3D? are ignored.  We didn't used to bother ignoring them, but the
         * VGA ROM's logic requires it, so now we also check fActive.  However, we ignore only CTRC reads;
         * we retain any writes in case that information proves useful later.
         *
         * For the COMPAQ VDU, we must make an exception, because regardless which "half" of the VDU is currently
         * active (the text side or the graphics side), the COMPAQ Portable ROM expects both halves to always respond;
         * set a breakpoint at F000:E48D to see their code in action.
         *
         * Note that returning an undefined value now signals the Bus component to return whatever default value
         * it prefers (normally 0xff).
         */
        if ((card.fActive || card.video.model == "vdu") && card.regCRTIndx < card.nCRTCRegs) {
            b = card.regCRTData[card.regCRTIndx];
        }
        if (!addrFrom || this.messageEnabled()) {
            this.printIO(port /* card.port + 1 */, undefined, addrFrom, "CRTC." + card.asCRTCRegs[card.regCRTIndx], b, true);
        }
        return b;
    }

    /**
     * outCRTCData(card, port, bOut, addrFrom)
     *
     * @this {Videox86}
     * @param {Object} card
     * @param {number} port
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     */
    outCRTCData(card, port, bOut, addrFrom)
    {
        if (card.regCRTIndx < card.nCRTCRegs) {

            /**
             * To simulate how the 6845 effectively ignores changes to CURSCAN or CURSCANB whenever one is written
             * while the other is currently > MAXSCAN, we check for those writes now, and ignore the write as appropriate.
             *
             * Since CURSCAN == 0xA and CURSCANB == 0xB, we can get the complementary register by XOR'ing the index with 0x1.
             */
            if (card.regCRTIndx == Card.CRTC.CURSCAN || card.regCRTIndx == Card.CRTC.CURSCANB) {
                let bCur = bOut & Card.CRTCMASKS[Card.CRTC.MAXSCAN];
                let bMax = card.regCRTData[Card.CRTC.MAXSCAN] & Card.CRTCMASKS[Card.CRTC.MAXSCAN];
                if (bCur > bMax) {
                    bCur = card.regCRTData[card.regCRTIndx ^ 0x1] & Card.CRTCMASKS[Card.CRTC.MAXSCAN];
                    if (bCur > bMax) {
                        if (DEBUG) this.printf("outCRTCData(%#04X): ignoring write to CRTC[%#04X] since %#04X > %#04X\n", bOut, card.regCRTIndx, bCur, bMax);
                        return;
                    }
                }
            }

            let fModified = (card.regCRTData[card.regCRTIndx] !== bOut);
            if (fModified || Videox86.TRAPALL) {
                if (!addrFrom || this.messageEnabled()) {
                    this.printIO(port /* card.port + 1 */, bOut, addrFrom, "CRTC." + card.asCRTCRegs[card.regCRTIndx]);
                }
                card.regCRTData[card.regCRTIndx] = bOut;
            }

            if (card == this.cardEGA) {
                if (card.regCRTIndx == Card.CRTC.EGA.VREND.INDX) {
                    if (this.nIRQ) {
                        if (!(bOut & Card.CRTC.EGA.VREND.UNCLEAR_VRINT)) {
                            if (this.chipset) this.chipset.clearIRR(this.nIRQ);
                        }
                    }
                }
                else if (fModified) {
                    /**
                     * If the split-screen state has been modified, then partially invalidate the cell cache.
                     *
                     * TODO: This register is also used in conjunction with one overflow bit in the OVERFLOW register
                     * and another overflow bit in the MAXSCAN register (VGA only), so technically, if either of those
                     * bits change, then again, the cache should be invalidated.
                     */
                    if (card.regCRTIndx == Card.CRTC.EGA.LINECOMP) {
                        this.invalidateCellCache(false);
                    }
                }
            }

            /**
             * During mode changes on the EGA, all the CRTC regs are typically programmed in sequence,
             * and if that's all that's happening with Card.CRTC.MAXSCAN, then we don't want to treat
             * it special; let the mode change be detected normally (eg, when the GRC regs are written later).
             *
             * On the other hand, if this was an out-of-sequence write to Card.CRTC.MAXSCAN, then
             * yes, we want to force setMode() to call setDimensions(), which is key to setting the proper
             * number of screen rows.
             *
             * The second part of the check is required to promptly detect a switch to "Mode X"; if we assume
             * that anyone switching to "Mode X" will first switch to mode 0x13, then it's a given that they
             * must reprogram the VDEND register, and that they will probably change it from 0x8F to 0xDF.
             *
             * Originally, I wasn't going to check specifically for 0xDF, to help catch other "Mode X" variations,
             * but if I don't, then some spurious mode changes are triggered (eg, when Windows 1.0 switches from
             * CGA graphics mode 0x06 to an EGA graphics mode).
             */
            if (fModified) {
                if (card.regCRTIndx == Card.CRTC.MAXSCAN && card.regCRTPrev != Card.CRTC.MAXSCAN - 1 || card.regCRTIndx == Card.CRTC.EGA.VDEND && bOut == 0xDF) {
                    this.checkMode(true);
                }
                this.checkCursor();
            }
        }
        else if (DEBUG) {
            this.printf("outCRTCData(%#04X): ignoring unexpected write to CRTC[%#04X]\n", bOut, card.regCRTIndx);
        }
    }

    /**
     * inCardMode(card, addrFrom)
     *
     * @this {Videox86}
     * @param {Object} card
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     * @returns {number}
     */
    inCardMode(card, addrFrom)
    {
        let b = card.regMode;
        this.printIO(card.port + 4, undefined, addrFrom, "MODE", b);
        return b;
    }

    /**
     * outCardMode(card, bOut, addrFrom)
     *
     * @this {Videox86}
     * @param {Object} card
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     */
    outCardMode(card, bOut, addrFrom)
    {
        this.printIO(card.port + 4, bOut, addrFrom, "MODE");
        if ((card.regMode ^ bOut) & Card.MDA.MODE.BLINK_ENABLE) {
            card.video.iCellCacheValid = 0;
        }
        card.regMode = bOut;
        this.checkMode();
    }

    /**
     * inCardStatus(card, addrFrom)
     *
     * On an EGA, this register is called "Status Register One" (0x3BA/0x3DA aka STATUS1), to distinguish it from
     * "Status Register Zero" (0x3C2 aka STATUS0).  One of the side-effects of reading STATUS1 is that it resets the
     * ATC address/data flip-flop to "address" mode, which we emulate by setting cardEGA.fATCData to false, indicating
     * that the ATC is not in "data" mode.
     *
     * @this {Videox86}
     * @param {Object} card
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     * @returns {number}
     */
    inCardStatus(card, addrFrom)
    {
        let b = this.getRetraceBits(card);

        if (card === this.cardEGA) {
            /**
             * STATUS1 diagnostic bits 5 and 4 are set according to the Card.ATC.PLANES.MUX bits:
             *
             *      MUX     Bit 5   Bit 4
             *      ---     ----    ----
             *      00:     Red     Blue
             *      01:     SecBlue Green
             *      10:     SecRed  SecGreen
             *      11:     unused  unused
             *
             * Depending on where we are in the horizontal and vertical periods (which can be inferred from the
             * same elapsed cycle count that we used to simulate the retrace bits above), we could extract 4 bits
             * from a corresponding region of the video buffer, "and" them with Card.ATC.PLANES.MASK, use
             * that to index into the palette registers (cardEGA.regATCData), and use the resulting palette register
             * bits to set these diagnostics bits.  However, that's all rather tedious, and the process of extracting
             * 4 appropriate bits from the video buffer varies depending on the video mode.
             *
             * Why are we even considering this?  Because the EGA BIOS diagnostic code draws a bright reverse-video
             * line of text blocks across the top of the screen, writes 0x3F to palette register 0x0f, and then
             * monitors the STATUS1 diagnostic bits, waiting for those palette bits to show up.  It turns out, however,
             * that we can easily fool the EGA BIOS by simply toggling the diagnostic bits.  So we take the easy way out.
             *
             * TODO: Faithful emulation of these bits is certainly doable, so consider doing that at some point.
             */
            b |= ((card.regStatus & Card.STATUS1.DIAGNOSTIC) ^ Card.STATUS1.DIAGNOSTIC);

            /**
             * Last but not least, we must reset the EGA's ATC flip-flop whenever this register is read.
             */
            card.fATCData = false;
        }
        else {
            /**
             * On the MDA/CGA, to satisfy ROM BIOS testing ("TEST.10"), it's sufficient to do a simple toggle of
             * bits 0 and 3 on every read.
             *
             * Also, according to http://www.seasip.info/VintagePC/mda.html, on an MDA, bits 7-4 are always ON and
             * bits 2-1 are always OFF, hence the "OR" of 0xF0.
             *
             * Currently, I use the retrace bits from getRetraceBits() as-is:
             *
             *      b |= 0xF0;
             *
             * but doing so hurts the performance of code like this in the "FlickerFree" utility:
             *
             *      &0600:079A EC              IN       AL,DX
             *      &0600:079B D0E8            SHR      AL,1
             *      &0600:079D 72FB            JC       079A
             *      &0600:079F FA              CLI
             *      &0600:07A0 EC              IN       AL,DX
             *      &0600:07A1 D0E8            SHR      AL,1
             *      &0600:07A3 73FB            JNC      07A0
             *      &0600:07A5 8BC3            MOV      AX,BX
             *      &0600:07A7 AB              STOSW
             *      &0600:07A8 FB              STI
             *      &0600:07A9 E2EF            LOOP     079A
             *
             * which, oddly, appears to want to write only ONE word to video memory per retrace interval.  Sticking
             * with our older, cruder, toggling code, makes that code run faster and reduce the odds that you'll see
             * old data on appear on the screen before the above code has the chance to store new data over it.
             *
             *      b = (card.regStatus ^= (Card.CGA.STATUS.RETRACE | Card.CGA.STATUS.VRETRACE)) | 0xF0;
             */
            b |= 0xF0;
        }

        card.regStatus = b;
        if (MAXDEBUG) this.printIO(card.port + 6, undefined, addrFrom, (card === this.cardEGA? "STATUS1" : "STATUS"), b);
        return b;
    }

    /**
     * dumpVideo(asArgs)
     *
     * @this {Videox86}
     * @param {Array.<string>} asArgs
     */
    dumpVideo(asArgs)
    {
        if (DEBUGGER) {
            let component = /** @type {Component} */ (this.dbg);
            if (!this.cardActive) {
                component.printf("no active video card\n");
                return;
            }
            if (asArgs[0]) {
                this.cardActive.dumpVideoBuffer(asArgs);
                return;
            }
            component.printf("    MODE: %#04X\n", this.nMode);
            component.printf("  BUFFER: %#010X\n", this.cardActive.addrBuffer);
            this.cardActive.dumpVideoCard();
        }
    }

    /**
     * doBlink()
     *
     * This function is obsolete, now that the checkBlink() function is called on every updateScreen()
     * and checkCursor() call.  updateScreen() is driven by CPU bursts, so piggy-backing on that to drive
     * blink updates seems preferable to having another active timer in the system.
     *
     * @this {Videox86}
     * @param {boolean} [fStart]
     *
     doBlink(fStart)
     {
        if (this.cBlinks >= 0) {
            this.cBlinks++;
            if (this.cBlinkVisible || this.iCellCursor >= 0) {
                if (!fStart && !this.cpu.isRunning()) {
                    this.updateScreen();
                }
                setTimeout(function(video) { return function onBlinkTimeout() {video.doBlink();}; }(this), 266);
                return;
            }
            this.cBlinks = -1;
        }
    },
     */

    /**
     * Videox86.init()
     *
     * This function operates on every HTML element of class "video", extracting the
     * JSON-encoded parameters for the Video constructor from the element's "data-value"
     * attribute, invoking the constructor to create a Video component, and then binding
     * any associated HTML controls to the new component.
     */
    static init()
    {
        let aElement = Component.getElementsByClass(APPCLASS, "video");
        for (let iVideo = 0; iVideo < aElement.length; iVideo++) {

            let element = aElement[iVideo];
            let parmsVideo = Component.getComponentParms(element);

            /**
             * We prefer to let the XSL (or HTML) template create the canvas element for us, so that
             * the page is as fully-formed as possible, keeping disruption of page layout to a minimum.
             */
            let canvas;
            let aCanvas = Component.getElementsByClass("pcjs-canvas", "", element);
            if (aCanvas && aCanvas.length) {
                canvas = /** @type {HTMLCanvasElement} */ (aCanvas[0]);
            } else if (globals.browser) {
                canvas = /** @type {HTMLCanvasElement} */ (document.createElement("canvas"));
                if (canvas) {
                    canvas.setAttribute("class", "pcjs-canvas");
                    canvas.setAttribute("width", parmsVideo['screenWidth']);
                    canvas.setAttribute("height", parmsVideo['screenHeight']);
                    element.appendChild(canvas);
                }
            }

            let context;
            if (canvas && canvas.getContext) {
                context = /** @type {CanvasRenderingContext2D} */ (canvas.getContext("2d"));
            } else {
                element.innerHTML = "<br>Missing &lt;canvas&gt; support. Please try a newer web browser.";
            }

            /**
             * The "contenteditable" attribute on a canvas element NOTICEABLY slows down canvas drawing on
             * Safari as soon as you give the canvas focus (ie, click away from the canvas, and drawing speeds
             * up; click on the canvas, and drawing slows down).  So the "transparent textarea hack" that we
             * once employed as only a work-around for Android devices is now our default.
             *
             *      canvas.setAttribute("contenteditable", "true");
             *
             * HACK: A canvas style of "auto" provides for excellent responsive canvas scaling in EVERY browser
             * except IE9/IE10, so I recalculate the appropriate CSS height every time the parent DIV is resized;
             * IE11 works without this hack, so we take advantage of the fact that IE11 doesn't identify as "MSIE".
             *
             * The other reason it's good to keep this particular hack limited to IE9/IE10 is that most other
             * browsers don't actually support an 'onresize' handler on anything but the window object.
             */
            if (WebLib.getUserAgent().indexOf("MSIE") >= 0) {
                element['onresize'] = function(eParent, eChild, cx, cy) {
                    return function onResizeVideo() {
                        eChild.style.height = (((eParent.clientWidth * cy) / cx) | 0) + "px";
                    };
                }(element, canvas, parmsVideo['screenWidth'], parmsVideo['screenHeight']);
                element['onresize'](null);
            }

            /**
             * The following is a related hack that allows the user to force the screen to use a particular aspect
             * ratio if an 'aspect' attribute or URL parameter is set.  Initially, it's just for testing purposes
             * until we figure out a better UI.  And note that we use our WebLib.addPageEvent() helper function to make
             * sure we don't trample any other 'onresize' handler(s) attached to the window object.
             */
            let aspect = +(WebLib.getURLParm('aspect') || parmsVideo['aspect']);

            /**
             * No 'aspect' parameter yields NaN, which is falsey, and anything else must satisfy my arbitrary
             * constraints of 0.3 <= aspect <= 3.33, to prevent any useless (or worse, browser-blowing) results.
             */
            if (aspect && aspect >= 0.3 && aspect <= 3.33) {
                WebLib.addPageEvent('resize', function(eParent, eChild, aspectRatio) {
                    return function onResizeWindow() {
                        /**
                         * Since aspectRatio is the target width/height, we have:
                         *
                         *      eParent.clientWidth / eChild.style.height = aspectRatio
                         *
                         * which means that:
                         *
                         *      eChild.style.height = eParent.clientWidth / aspectRatio
                         *
                         * so for example, if aspectRatio is 16:9, or 1.78, and clientWidth = 640,
                         * then the calculated height should approximately 360.
                         */
                        eChild.style.height = ((eParent.clientWidth / aspectRatio)|0) + "px";
                    };
                }(element, canvas, aspect));
                globals.window['onresize']();
            }

            /**
             * HACK: Android-based browsers, like the Silk (Amazon) browser and Chrome for Android, don't honor the
             * "contenteditable" attribute; that is, when the canvas receives focus, they don't activate the on-screen
             * keyboard.  So my fallback is to create a transparent textarea on top of the canvas.
             *
             * The parent DIV must have a style of "position:relative" (alternatively, a class of "pcjs-container"),
             * so that we can position the textarea using absolute coordinates.  Also, we don't want the textarea to be
             * visible, but we must use "opacity:0" instead of "visibility:hidden", because the latter seems to prevent
             * the element from receiving events.  These styling requirements are taken care of in components.css
             * (see references to the "pcjs-video-object" class).
             *
             * UPDATE: Unfortunately, Android keyboards like to compose whole words before transmitting any of the
             * intervening characters; our textarea's keyDown/keyUp event handlers DO receive intervening key events,
             * but their keyCode property is ZERO.  Virtually the only usable key event we receive is the Enter key.
             * Android users will have to use machines that include their own on-screen "soft keyboard", or use an
             * external keyboard.
             *
             * The following attempt to use a password-enabled input field didn't work any better on Android.  You could
             * clearly see the overlaid semi-transparent input field, but none of the input characters were passed along,
             * with the exception of the "Go" (Enter) key.
             *
             *      let input = document.createElement("input");
             *      input.setAttribute("type", "password");
             *      input.setAttribute("style", "position:absolute; left:0; top:0; width:100%; height:100%; opacity:0.5");
             *      element.appendChild(input);
             *
             * See this Chromium issue for more information: https://code.google.com/p/chromium/issues/detail?id=118639
             */
            let textarea;
            let aTextArea = Component.getElementsByClass("pcjs-overlay", "", element);
            if (aTextArea && aTextArea.length) {
                textarea = /** @type {HTMLTextAreaElement} */ (aTextArea[0]);
            } else if (globals.browser) {
                textarea = /** @type {HTMLTextAreaElement} */ (document.createElement("textarea"));
                textarea.setAttribute("class", "pcjs-overlay");
                element.appendChild(textarea);
            }

            /**
             * As noted in keyboard.js, the keyboard on an iOS device tends to pop up with the SHIFT key depressed,
             * which is not the initial keyboard state that the Keyboard component expects, so hopefully turning off
             * these "auto" attributes will help.
             *
             * NOTE: We now set these attributes for ALL browsers, not just "iOS", in large part because the new
             * iPadOS agent string no longer contains any "iOS" identifiers (this degree of fakery is somewhat annoying).
             * Perhaps we should set other attributes as well, such as "autocomplete", but that remains to be seen.
             *
             * Unfortunately, in my limited testing, none of these seemed to have any effect on the way Chrome/webkit
             * converts "compose" key sequences (eg, "Alt-E") into dead keys (keyCode 229).
             */
            if (textarea) {
                textarea.setAttribute("autocapitalize", "off");
                textarea.setAttribute("autocorrect", "off");
                textarea.setAttribute("spellcheck", "false");
                /**
                * Another problem on iOS devices was that after a soft-key control was clicked, we needed to give
                * focus back to the above textarea, usually by calling cmp.updateFocus(), but in doing so, iOS could
                * also "zoom" the page rather jarringly.  While it was a simple matter to completely disable zooming,
                * by fiddling with the page's viewport, that prevented the user from intentionally zooming.  A bit of
                * Googling reveals that another way to prevent those jarring unintentional zooms was to simply set
                * the font-size of the text control to 16px.  So that's what we do.
                *
                * NOTE: Not sure if this is still necessary, but changing the code (and then doing a bunch of testing)
                * doesn't sound very appealing right now.
                *
                * UPDATE: Instead of hard-coding the textarea overlay font size to "16px", we now scale it dynamically,
                * so that when the overlay is visible (eg, for machine startup messages), the size of the text is
                * proportional to the overall size of the virtual display.
                */
                // textarea.style.fontSize = "16px";
                let onResizeTextArea = function() {
                    textarea.style.fontSize = ((textarea.clientWidth * 0.01875)|0) + "px";
                };
                onResizeTextArea();
                WebLib.addPageEvent('resize', onResizeTextArea);
            }

            /**
             * See if there are any "diagnostic" elements we should pass along, too.
             */
            let aDiagElements = /** @type {Array.<HTMLElement>} */ (Component.getElementsByClass(APPCLASS + "-video-diagnostic"));

            /**
             * Now we can create the Video object, record it, and wire it up to the associated document elements.
             */
            let container;
            if (element.style) container = element;
            let video = new Videox86(parmsVideo, canvas, context, textarea /* || input */, container, aDiagElements);

            /**
             * Bind any video-specific controls (eg, the Refresh button). There are no essential controls, however;
             * even the "Refresh" button is just a diagnostic tool, to ensure that the screen contents are up-to-date.
             */
            Component.bindComponentControls(video, element, APPCLASS);
        }
    }

    /**
     * Port input/output notification tables
     */
    static aMDAPortInput = {
        0x3B0: Videox86.prototype.inMDAIndx,           // duplicate of 0x3B4
        0x3B1: Videox86.prototype.inMDAData,           // duplicate of 0x3B5
        0x3B2: Videox86.prototype.inMDAIndx,           // duplicate of 0x3B4
        0x3B3: Videox86.prototype.inMDAData,           // duplicate of 0x3B5
        0x3B4: Videox86.prototype.inMDAIndx,           // technically, not actually readable, but I want the Debugger to be able to read this
        0x3B5: Videox86.prototype.inMDAData,           // technically, the only CRTC Data registers that are readable are R14-R17
        0x3B6: Videox86.prototype.inMDAIndx,           // duplicate of 0x3B4
        0x3B7: Videox86.prototype.inMDAData,           // duplicate of 0x3B5
        0x3B8: Videox86.prototype.inMDAMode,           // technically, not actually readable, but I want the Debugger to be able to read this
        0x3BA: Videox86.prototype.inMDAStatus
    };

    static aMDAPortOutput = {
        0x3B0: Videox86.prototype.outMDAIndx,          // duplicate of 0x3B4
        0x3B1: Videox86.prototype.outMDAData,          // duplicate of 0x3B5
        0x3B2: Videox86.prototype.outMDAIndx,          // duplicate of 0x3B4
        0x3B3: Videox86.prototype.outMDAData,          // duplicate of 0x3B5
        0x3B4: Videox86.prototype.outMDAIndx,
        0x3B5: Videox86.prototype.outMDAData,
        0x3B6: Videox86.prototype.outMDAIndx,          // duplicate of 0x3B4
        0x3B7: Videox86.prototype.outMDAData,          // duplicate of 0x3B5
        0x3B8: Videox86.prototype.outMDAMode
    };

    static aCGAPortInput = {
        0x3D4: Videox86.prototype.inCGAIndx,           // technically, not actually readable, but I want the Debugger to be able to read this
        0x3D5: Videox86.prototype.inCGAData,           // technically, the only CRTC Data registers that are readable are R14-R17
        0x3D8: Videox86.prototype.inCGAMode,           // technically, not actually readable, but I want the Debugger to be able to read this
        0x3D9: Videox86.prototype.inCGAColor,          // technically, not actually readable, but I want the Debugger to be able to read this
        0x3DA: Videox86.prototype.inCGAStatus
    };

    static aCGAPortOutput = {
        0x3D4: Videox86.prototype.outCGAIndx,
        0x3D5: Videox86.prototype.outCGAData,
        0x3D8: Videox86.prototype.outCGAMode,
        0x3D9: Videox86.prototype.outCGAColor
    };

    static aEGAPortInput = {
        0x3C0: Videox86.prototype.inATCIndx,           // technically, only readable on a VGA, but I want the Debugger to be able to read this, too
        0x3C1: Videox86.prototype.inATCData,           // technically, only readable on a VGA, but I want the Debugger to be able to read this, too
        0x3C2: Videox86.prototype.inStatus0,
        0x3C4: Videox86.prototype.inSEQIndx,           // technically, only readable on a VGA, but I want the Debugger to be able to read this, too
        0x3C5: Videox86.prototype.inSEQData,           // technically, only readable on a VGA, but I want the Debugger to be able to read this, too
        0x3CE: Videox86.prototype.inGRCIndx,           // technically, only readable on a VGA, but I want the Debugger to be able to read this, too
        0x3CF: Videox86.prototype.inGRCData            // technically, only readable on a VGA, but I want the Debugger to be able to read this, too
    };

    /**
     * WARNING: Unlike the EGA, a standard VGA does not support writes to 0x3C1, but it's easier for me to leave that
     * ability in place, treating the VGA as a superset of the EGA as much as possible; will any code break because word
     * OUTs to port 0x3C0 (and/or byte OUTs to port 0x3C1) actually work?  Possibly, but highly unlikely.
     */
    static aEGAPortOutput = {
        0x3BA: Videox86.prototype.outFeat,
        0x3C0: Videox86.prototype.outATC,
        0x3C1: Videox86.prototype.outATC,              // the EGA BIOS writes to this port (see C000:0416), implying that 0x3C0 and 0x3C1 both decode the same register
        0x3C2: Videox86.prototype.outMisc,             // FYI, since this overlaps with STATUS0.PORT, there's currently no way for the Debugger to read the Misc register
        0x3C4: Videox86.prototype.outSEQIndx,
        0x3C5: Videox86.prototype.outSEQData,
        0x3CA: Videox86.prototype.outGRCPos2,
        0x3CC: Videox86.prototype.outGRCPos1,
        0x3CE: Videox86.prototype.outGRCIndx,
        0x3CF: Videox86.prototype.outGRCData,
        0x3DA: Videox86.prototype.outFeat
    };

    static aVGAPortInput = {
        0x3C3: Videox86.prototype.inVGAEnable,
        0x3C6: Videox86.prototype.inDACMask,
        0x3C7: Videox86.prototype.inDACState,
        0x3C9: Videox86.prototype.inDACData,
        0x3CA: Videox86.prototype.inVGAFeat,
        0x3CC: Videox86.prototype.inVGAMisc
    };

    static aVGAPortOutput = {
        0x3C3: Videox86.prototype.outVGAEnable,
        0x3C6: Videox86.prototype.outDACMask,
        0x3C7: Videox86.prototype.outDACRead,
        0x3C8: Videox86.prototype.outDACWrite,
        0x3C9: Videox86.prototype.outDACData
    };

}

/**
 * Initialize every Video module on the page.
 */
WebLib.onInit(Videox86.init);

/**
 * @copyright https://www.pcjs.org/machines/pcx86/modules/v2/parallel.js (C) 2012-2024 Jeff Parsons
 */

/**
 * NOTE: This class declaration started as a way of informing the code inspector of the controlBuffer property,
 * which remained undefined until a setBinding() call set it later, but I've since decided that explicitly
 * initializing such properties in the constructor is a better way to go -- even though it's more code -- because
 * JavaScript compilers are supposed to be happier when the underlying object structures aren't constantly changing.
 *
 * Besides, I'm not sure I want to get into documenting every property this way, for this or any/every other class,
 * let alone getting into which ones should be considered private or protected, because PCjs isn't really a library
 * for third-party apps.
 *
 * @class ParallelPort
 * @property {number} iAdapter
 * @property {number} portBase
 * @property {number} nIRQ
 * @property {Object} controlBuffer is a DOM element bound to the port (for rudimentary output; see transmitByte())
 * @unrestricted (allows the class to define properties, both dot and named, outside of the constructor)
 */
class ParallelPort extends Component {
    /**
     * The "Data Register" is an input/output register at offset 0 from portBase.  The bit-to-pin mappings are:
     *
     *      Bit     Pin
     *      ---     ---
     *       0       2              // 0x01 (DATA 1)
     *       1       3              // 0x02 (DATA 2)
     *       2       4              // 0x04 (DATA 3)
     *       3       5              // 0x08 (DATA 4)
     *       4       6              // 0x10 (DATA 5)
     *       5       7              // 0x20 (DATA 6)
     *       6       8              // 0x40 (DATA 7)
     *       7       9              // 0x80 (DATA 8)
     */
    static DATA = {                 // (read/write)
        REG:        0
    };

    /**
     * The "Status Register" is an input register at offset 1 from portBase.  The bit-to-pin mappings are:
     *
     *      Bit     Pin
     *      ---     ---
     *       0       -              // 0x01 (always set on MDA printer port)
     *       1       -              // 0x02 (always set on MDA printer port)
     *       2       -              // 0x04 (always set on MDA printer port)
     *       3       !15            // 0x08 (Error)
     *       4       13             // 0x10 (Select)
     *       5       12             // 0x20 (Out of Paper)
     *       6       !10            // 0x40 (Acknowledged)
     *       7       11             // 0x80 (Busy; eg, printer off-line or operation in progress)
     */
    static STATUS = {               // (read)
        REG:        1,
        ALWAYS_SET: 0x07,           // (always set on MDA printer port)
        NERR:       0x08,           // when this bit is clear, I/O error (inverted by the ROM BIOS INT 17h Status function)
        SELECT:     0x10,           // when this bit is set, printer selected
        PAPER:      0x20,           // when this bit is set, out of paper
        NACK:       0x40,           // when this bit is clear, data acknowledged (and optionally, interrupt requested; inverted by the ROM BIOS INT 17h Status function)
        NBUSY:      0x80            // when this bit is clear, printer busy (TODO: Is this really inverted? https://www.seasip.info/VintagePC/mda.htm doesn't show it that way; perhaps it's simply that the signal from the printer is typically inverted)
    };

    /**
     * The "Control Register" is an input/output register at offset 2 from portBase.  The bit-to-pin mappings are:
     *
     *      Bit     Pin
     *      ---     ---
     *       0       !1             // 0x01 (read input data)
     *       1      !14             // 0x02 (automatically feed paper one line)
     *       2       16             // 0x04
     *       3      !17             // 0x08
     *
     * Additionally, bit 4 is the IRQ ENABLE bit, which allows interrupts when pin 10 transitions high to low.
     */
    static CONTROL = {              // (read/write)
        REG:        2,
        NSTROBE:    0x01,           // !Strobe
        NAUTOFEED:  0x02,           // !Auto feed
        INIT:       0x04,           // Initialize printer
        NSELECT:    0x08,           // !Select input
        IRQ_ENABLE: 0x10,           // set to enable interrupts (when printer clears NACK)
        ALWAYS_SET: 0xE0            // (always set on MDA printer port when reading)
    };

    static {
        /**
         * Port input notification table
         */
        ParallelPort.aPortInput = {
            0x0: ParallelPort.prototype.inData,
            0x1: ParallelPort.prototype.inStatus,
            0x2: ParallelPort.prototype.inControl
        };

        /**
         * Port output notification table
         */
        ParallelPort.aPortOutput = {
            0x0: ParallelPort.prototype.outData,
            0x2: ParallelPort.prototype.outControl
        };
    }

    /**
     * ParallelPort(parmsParallel)
     *
     * The ParallelPort component has the following component-specific (parmsParallel) properties:
     *
     *      adapter: 1 (port 0x3BC), 2 (port 0x378), or 3 (port 0x278); 0 if not defined
     *
     *      binding: name of a control (based on its "binding" attribute) to bind to this port's I/O
     *
     * In the future, we may support 'port' and 'irq' properties that allow the machine to define a
     * non-standard parallel port configuration, instead of only our pre-defined 'adapter' configurations.
     *
     * NOTE: Since the XSL file defines 'adapter' as a number, not a string, there's no need to use
     * parseInt(), and as an added benefit, we don't need to worry about whether a hex or decimal format
     * was used.
     *
     * DOS typically names the Primary adapter "LPT1" and the Secondary adapter "LPT2", but I prefer
     * to stick to adapter numbers, since not all operating systems follow those naming conventions.
     *
     * @this {ParallelPort}
     * @param {Object} parmsParallel
     */
    constructor(parmsParallel)
    {
        super("ParallelPort", parmsParallel, MESSAGE.PARALLEL);

        this.iAdapter = parmsParallel['adapter'];

        switch (this.iAdapter) {
        case 1:
            this.portBase = 0x3BC;
            this.nIRQ = ChipSet.IRQ.LPT1;
            break;
        case 2:
            this.portBase = 0x378;
            this.nIRQ = ChipSet.IRQ.LPT1;
            break;
        case 3:
            this.portBase = 0x278;
            this.nIRQ = ChipSet.IRQ.LPT2;
            break;
        default:
            Component.warning("Unrecognized parallel adapter #" + this.iAdapter);
            return;
        }
        /**
         * consoleBuffer becomes a string that records parallel port output if the 'binding' property is set to the
         * reserved name "console".  Nothing is written to the console, however, until a linefeed (0x0A) is output
         * or the string length reaches a threshold (currently, 1024 characters).
         *
         * @type {string|null}
         */
        this.consoleBuffer = null;

        /**
         * controlBuffer is a DOM element bound to the port (currently used for output only; see transmitByte()).
         *
         * @type {Object}
         */
        this.controlBuffer = null;

        let sBinding = parmsParallel['binding'];
        if (sBinding == "console") {
            this.consoleBuffer = "";
        } else {
            /**
             * If the ParallelPort wants to bind to a control (eg, "print") in a DIFFERENT component (eg, "Panel"),
             * then it specifies the name of that control with the 'binding' property.  The ParallelPort constructor
             * will then call bindExternalControl(), which looks up the control, and then passes it to our own
             * setBinding() handler.
             *
             * For bindExternalControl() to succeed, it also need to know the target component; for now, that's
             * been hard-coded to "Panel", in part because that's one of the few components we can rely upon
             * initializing before we do, but it would be a simple matter to include a component type or ID as part
             * of the 'binding' property as well, if we need more flexibility later.
             *
             * NOTE: If sBinding is not the name of a valid Control Panel DOM element, this call does nothing.
             */
            Component.bindExternalControl(this, sBinding);
        }
    }

    /**
     * setBinding(sHTMLType, sBinding, control, sValue)
     *
     * @this {ParallelPort}
     * @param {string} sHTMLType is the type of the HTML control (eg, "button", "list", "text", "submit", "textarea", "canvas")
     * @param {string} sBinding is the value of the 'binding' parameter stored in the HTML control's "data-value" attribute (eg, "buffer")
     * @param {HTMLElement} control is the HTML control DOM object (eg, HTMLButtonElement)
     * @param {string} [sValue] optional data value
     * @returns {boolean} true if binding was successful, false if unrecognized binding request
     */
    setBinding(sHTMLType, sBinding, control, sValue)
    {
        if (!sHTMLType || sHTMLType == "textarea") {
            this.bindings[sBinding] = this.controlBuffer = control;
            return true;
        }
        return false;
    }

    /**
     * initBus(cmp, bus, cpu, dbg)
     *
     * @this {ParallelPort}
     * @param {Computer} cmp
     * @param {Busx86} bus
     * @param {CPUx86} cpu
     * @param {Debuggerx86} dbg
     */
    initBus(cmp, bus, cpu, dbg)
    {
        this.bus = bus;
        this.cpu = cpu;
        this.dbg = dbg;
        this.chipset = cmp.getMachineComponent("ChipSet");
        bus.addPortInputTable(this, ParallelPort.aPortInput, this.portBase);
        bus.addPortOutputTable(this, ParallelPort.aPortOutput, this.portBase);
        this.setReady();
    }

    /**
     * powerUp(data, fRepower)
     *
     * @this {ParallelPort}
     * @param {Object|null} data
     * @param {boolean} [fRepower]
     * @returns {boolean} true if successful, false if failure
     */
    powerUp(data, fRepower)
    {
        if (!fRepower) {
            if (!data || !this.restore) {
                this.reset();
            } else {
                if (!this.restore(data)) return false;
            }
        }
        return true;
    }

    /**
     * powerDown(fSave, fShutdown)
     *
     * @this {ParallelPort}
     * @param {boolean} [fSave]
     * @param {boolean} [fShutdown]
     * @returns {Object|boolean} component state if fSave; otherwise, true if successful, false if failure
     */
    powerDown(fSave, fShutdown)
    {
        return fSave? this.save() : true;
    }

    /**
     * reset()
     *
     * @this {ParallelPort}
     */
    reset()
    {
        this.initState();
    }

    /**
     * save()
     *
     * This implements save support for the ParallelPort component.
     *
     * @this {ParallelPort}
     * @returns {Object}
     */
    save()
    {
        let state = new State(this);
        state.set(0, this.saveRegisters());
        return state.data();
    }

    /**
     * restore(data)
     *
     * This implements restore support for the ParallelPort component.
     *
     * @this {ParallelPort}
     * @param {Object} data
     * @returns {boolean} true if successful, false if failure
     */
    restore(data)
    {
        return this.initState(data[0]);
    }

    /**
     * initState(data)
     *
     * @this {ParallelPort}
     * @param {Array} [data]
     * @returns {boolean} true if successful, false if failure
     */
    initState(data)
    {
        let i = 0;
        if (data === undefined) {
            data = [0, ParallelPort.STATUS.NERR | ParallelPort.STATUS.ALWAYS_SET, ParallelPort.CONTROL.ALWAYS_SET];
        }
        this.bData = data[i++];
        this.bStatus = data[i++];
        this.bControl = data[i];
        return true;
    }

    /**
     * saveRegisters()
     *
     * @this {ParallelPort}
     * @returns {Array}
     */
    saveRegisters()
    {
        let i = 0;
        let data = [];
        data[i++] = this.bData;
        data[i++] = this.bStatus;
        data[i]   = this.bControl;
        return data;
    }

    /**
     * inData(port, addrFrom)
     *
     * @this {ParallelPort}
     * @param {number} port (0x3BC, 0x378, or 0x278)
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     * @returns {number} simulated port value
     */
    inData(port, addrFrom)
    {
        let b = this.bData;
        this.printIO(port, undefined, addrFrom, "DATA", b);
        return b;
    }

    /**
     * inStatus(port, addrFrom)
     *
     * @this {ParallelPort}
     * @param {number} port (0x3BD, 0x379, or 0x279)
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     * @returns {number} simulated port value
     */
    inStatus(port, addrFrom)
    {
        let b = this.bStatus;
        this.bStatus |= (ParallelPort.STATUS.NACK | ParallelPort.STATUS.NBUSY);
        this.printIO(port, undefined, addrFrom, "STAT", b);
        this.updateIRR();
        return b;
    }

    /**
     * inControl(port, addrFrom)
     *
     * @this {ParallelPort}
     * @param {number} port (0x3BE, 0x37A, or 0x27A)
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     * @returns {number} simulated port value
     */
    inControl(port, addrFrom)
    {
        let b = this.bControl;
        this.printIO(port, undefined, addrFrom, "CTRL", b);
        return b;
    }

    /**
     * outData(port, bOut, addrFrom)
     *
     * @this {ParallelPort}
     * @param {number} port (0x3BC, 0x378, or 0x278)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to write the specified port)
     */
    outData(port, bOut, addrFrom)
    {
        let parallel = this;
        this.printIO(port, bOut, addrFrom, "DATA");
        this.bData = bOut;
        this.cpu.nonCPU(function() {
            if (parallel.transmitByte(bOut)) {
                parallel.bStatus |= ParallelPort.STATUS.NERR;
                parallel.bStatus &= ~(ParallelPort.STATUS.NACK | ParallelPort.STATUS.NBUSY);
                return true;
            }
            return false;
        });
        this.updateIRR();
    }

    /**
     * outControl(port, bOut, addrFrom)
     *
     * @this {ParallelPort}
     * @param {number} port (0x3BE, 0x37A, or 0x27A)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to write the specified port)
     */
    outControl(port, bOut, addrFrom)
    {
        this.printIO(port, bOut, addrFrom, "CTRL");
        this.bControl = bOut | ParallelPort.CONTROL.ALWAYS_SET;
        this.updateIRR();
    }

    /**
     * updateIRR()
     *
     * @this {ParallelPort}
     */
    updateIRR()
    {
        if (this.chipset && this.nIRQ) {
            if ((this.bControl & ParallelPort.CONTROL.IRQ_ENABLE) && !(this.bStatus & ParallelPort.STATUS.NACK)) {
                this.chipset.setIRR(this.nIRQ);
            } else {
                this.chipset.clearIRR(this.nIRQ);
            }
        }
    }

    /**
     * transmitByte(b)
     *
     * @this {ParallelPort}
     * @param {number} b
     * @returns {boolean} true if transmitted, false if not
     */
    transmitByte(b)
    {
        let fTransmitted = false;

        this.printf("transmitByte(%#04x)\n", b);

        if (this.controlBuffer) {
            if (b == 0x0D) {
                // this.iLogicalCol = 0;
            }
            else if (b == 0x08) {
                this.controlBuffer.value = this.controlBuffer.value.slice(0, -1);
            }
            else {
                /**
                 * If we assume that the printer being used was the original IBM 80 CPS Matrix Printer,
                 * characters 0x80-0x9F mirror control codes 0x00-0x1F, and characters 0xA0-0xDF are various
                 * block shapes, sort of in the spirit of the line-drawing characters 0xC0-0xDF defined by
                 * IBM Code Page 437, but, no, completely different.  And apparently, characters 0xE0-0xFF
                 * printed nothing at all (see Table 11 on page 2-78 of the original IBM PC 5150 TechRef).
                 *
                 * The only control character we care about is LINE-FEED; for all other control characters,
                 * we'll display the ASCII mnemonic, to make it clear what the software intended.  And as for
                 * any block characters, we'll print an asterisk and call it good, for now.  Beyond that,
                 * we'll just print spaces.
                 */
                if (b >= 0x80) {
                    if (b < 0xA0) {
                        b -= 0x80;
                    } else if (b < 0xE0) {
                        b = 0x2A;       // ASCII code for an asterisk
                    } else {
                        b = 0x20;       // ASCII code for a space
                    }
                }
                this.controlBuffer.value += StrLib.toASCIICode(b);
                this.controlBuffer.scrollTop = this.controlBuffer.scrollHeight;
            }
            fTransmitted = true;
        }
        else if (this.consoleBuffer != null) {
            if (b == 0x0A || this.consoleBuffer.length >= 1024) {
                this.print(this.consoleBuffer);
                this.consoleBuffer = "";
            }
            if (b != 0x0A) {
                this.consoleBuffer += String.fromCharCode(b);
            }
            fTransmitted = true;
        }

        return fTransmitted;
    }

    /**
     * ParallelPort.init()
     *
     * This function operates on every HTML element of class "parallel", extracting the
     * JSON-encoded parameters for the ParallelPort constructor from the element's "data-value"
     * attribute, invoking the constructor to create a ParallelPort component, and then binding
     * any associated HTML controls to the new component.
     */
    static init()
    {
        let aeParallel = Component.getElementsByClass(APPCLASS, "parallel");
        for (let iParallel = 0; iParallel < aeParallel.length; iParallel++) {
            let eParallel = aeParallel[iParallel];
            let parmsParallel = Component.getComponentParms(eParallel);
            let parallel = new ParallelPort(parmsParallel);
            Component.bindComponentControls(parallel, eParallel, APPCLASS);
        }
    }
}

/**
 * Initialize every ParallelPort module on the page.
 */
WebLib.onInit(ParallelPort.init);

/**
 * @copyright https://www.pcjs.org/machines/pcx86/modules/v2/serial.js (C) 2012-2024 Jeff Parsons
 */

/**
 * SerialPort class
 *
 * The class property declarations below started as a way of informing the code inspector of the controlBuffer
 * property, which remained undefined until a setBinding() call set it later, but I've since decided that explicitly
 * initializing such properties in the constructor is a better way to go -- even though it's more code -- because
 * JavaScript compilers are supposed to be happier when the underlying object structures aren't constantly changing.
 *
 * Besides, I'm not sure I want to get into documenting every property this way, for this or any/every other class,
 * let alone getting into which ones should be considered private or protected, because PCjs isn't really a library
 * for third-party apps.
 *
 * @class SerialPort
 * @property {number} iAdapter
 * @property {number} portBase
 * @property {number} nIRQ
 * @property {string|null} consoleBuffer
 * @property {HTMLTextAreaElement} controlBuffer (DOM element bound to the port for rudimentary output; see transmitByte())
 * @unrestricted (allows the class to define properties, both dot and named, outside of the constructor)
 */
class SerialPort extends Component {
    /**
     * 8250 I/O register offsets (add these to a I/O base address to obtain an I/O port address)
     *
     * NOTE: DLL.REG and DLM.REG form a 16-bit divisor into a clock input frequency of 1.8432Mhz.  The following
     * values should be used for the corresponding baud rates.  Rates above 9600 are discouraged by the IBM Tech Ref,
     * but rates as high as 128000 are listed on the NS8250A data sheet.
     *
     *      Divisor     Rate        Percent Error
     *      0x0900      50
     *      0x0600      75
     *      0x0417      110         0.026%
     *      0x0359      134.5       0.058%
     *      0x0300      150
     *      0x0180      300
     *      0x00C0      600
     *      0x0060      1200
     *      0x0040      1800
     *      0x003A      2000        0.69%
     *      0x0030      2400
     *      0x0020      3600
     *      0x0018      4800
     *      0x0010      7200
     *      0x000C      9600
     *      0x0006      19200
     *      0x0003      38400
     *      0x0002      56000       2.86%
     *      0x0001      128000
     */
    static DLL = {REG: 0};          // Divisor Latch LSB (only when SerialPort.LCR.DLAB is set)
    static THR = {REG: 0};          // Transmitter Holding Register (write)
    static DL_DEFAULT = 0x180;      // we select an arbitrary default Divisor Latch equivalent to 300 baud

    /**
     * Receiver Buffer Register (RBR.REG, offset 0; eg, 0x3F8 or 0x2F8) on read, Transmitter Holding Register on write
     */
    static RBR = {REG: 0};          // (read)

    /**
     * Interrupt Enable Register (IER.REG, offset 1; eg, 0x3F9 or 0x2F9)
     */
    static IER = {
        REG:            1,          // Interrupt Enable Register
        RBR_AVAIL:      0x01,
        THR_EMPTY:      0x02,
        LSR_DELTA:      0x04,
        MSR_DELTA:      0x08,
        UNUSED:         0xF0        // always zero
    };

    static DLM = {REG: 1};          // Divisor Latch MSB (only when SerialPort.LCR.DLAB is set)

    /**
     * Interrupt ID Register (IIR.REG, offset 2; eg, 0x3FA or 0x2FA)
     *
     * All interrupt conditions cleared by reading the corresponding register (or, in the case of IIR.INT_THR, writing a new value to THR.REG)
     */
    static IIR = {
        REG:            2,          // Interrupt ID Register (read-only)
        NO_INT:         0x01,
        INT_LSR:        0x06,       // Line Status (highest priority: Overrun error, Parity error, Framing error, or Break Interrupt)
        INT_RBR:        0x04,       // Receiver Data Available
        INT_THR:        0x02,       // Transmitter Holding Register Empty
        INT_MSR:        0x00,       // Modem Status Register (lowest priority: Clear To Send, Data Set Ready, Ring Indicator, or Data Carrier Detect)
        INT_BITS:       0x06,
        UNUSED:         0xF8        // always zero (the ROM BIOS relies on these bits "floating to 1" when no SerialPort is present)
    };

    /**
     * Line Control Register (LCR.REG, offset 3; eg, 0x3FB or 0x2FB)
     */
    static LCR = {
        REG:            3,          // Line Control Register
        DATA_5BITS:     0x00,
        DATA_6BITS:     0x01,
        DATA_7BITS:     0x02,
        DATA_8BITS:     0x03,
        STOP_BITS:      0x04,       // clear: 1 stop bit; set: 1.5 stop bits for LCR_DATA_5BITS, 2 stop bits for all other data lengths
        PARITY_BIT:     0x08,       // if set, a parity bit is inserted/expected between the last data bit and the first stop bit; no parity bit if clear
        PARITY_EVEN:    0x10,       // if set, even parity is selected (ie, the parity bit insures an even number of set bits); if clear, odd parity
        PARITY_STICK:   0x20,       // if set, parity bit is transmitted inverted; if clear, parity bit is transmitted normally
        BREAK:          0x40,       // if set, serial output (SOUT) signal is forced to logical 0 for the duration
        DLAB:           0x80        // Divisor Latch Access Bit; if set, DLL.REG and DLM.REG can be read or written
    };

    /**
     * Modem Control Register (MCR.REG, offset 4; eg, 0x3FC or 0x2FC)
     */
    static MCR = {
        REG:            4,          // Modem Control Register
        DTR:            0x01,       // when set, DTR goes high, indicating ready to establish link (looped back to DSR in loop-back mode)
        RTS:            0x02,       // when set, RTS goes high, indicating ready to exchange data (looped back to CTS in loop-back mode)
        OUT1:           0x04,       // when set, OUT1 goes high (looped back to RI in loop-back mode)
        OUT2:           0x08,       // when set, OUT2 goes high (looped back to RLSD in loop-back mode); must also be set for most UARTs to enable interrupts (but not ours)
        LOOPBACK:       0x10,       // when set, enables loop-back mode
        UNUSED:         0xE0        // always zero
    };

    /**
     * Line Status Register (LSR.REG, offset 5; eg, 0x3FD or 0x2FD)
     *
     * NOTE: I've seen different specs for the LSR_TSRE.  I'm following the IBM Tech Ref's lead here, but the data sheet
     * I have calls it TEMT instead of TSRE, and claims that it is set whenever BOTH the THR and TSR are empty, and clear
     * whenever EITHER the THR or TSR contain data.
     */
    static LSR = {
        REG:            5,          // Line Status Register
        DR:             0x01,       // Data Ready (set when new data in RBR.REG; cleared when RBR.REG read)
        OE:             0x02,       // Overrun Error (set when new data arrives in RBR.REG before previous data read; cleared when LSR.REG read)
        PE:             0x04,       // Parity Error (set when new data has incorrect parity; cleared when LSR.REG read)
        FE:             0x08,       // Framing Error (set when new data has invalid stop bit; cleared when LSR.REG read)
        BI:             0x10,       // Break Interrupt (set when new data exceeded normal transmission time; cleared LSR.REG when read)
        THRE:           0x20,       // Transmitter Holding Register Empty (set when UART ready to accept new data; cleared when THR.REG written)
        TSRE:           0x40,       // Transmitter Shift Register Empty (set when the TSR is empty; cleared when the THR is transferred to the TSR)
        UNUSED:         0x80        // always zero
    };

    /**
     * Modem Status Register (MSR.REG, offset 6; eg, 0x3FE or 0x2FE)
     */
    static MSR = {
        REG:            6,          // Modem Status Register
        DCTS:           0x01,       // when set, CTS (Clear To Send) has changed since last read
        DDSR:           0x02,       // when set, DSR (Data Set Ready) has changed since last read
        TERI:           0x04,       // when set, TERI (Trailing Edge Ring Indicator) indicates RI has changed from 1 to 0
        DRLSD:          0x08,       // when set, RLSD (Received Line Signal Detector) has changed
        CTS:            0x10,       // when set, the modem or data set is ready to exchange data (complement of the Clear To Send input signal)
        DSR:            0x20,       // when set, the modem or data set is ready to establish link (complement of the Data Set Ready input signal)
        RI:             0x40,       // complement of the RI (Ring Indicator) input
        RLSD:           0x80        // complement of the RLSD (Received Line Signal Detect) input
    };

    /**
     * Scratch Register (SCR.REG, offset 7; eg, 0x3FF or 0x2FF)
     */
    static SCR = {REG: 7};

    static {
        /**
         * Port input notification table
         */
        SerialPort.aPortInput = {
            0x0: SerialPort.prototype.inRBR,    // or DLL if DLAB set
            0x1: SerialPort.prototype.inIER,    // or DLM if DLAB set
            0x2: SerialPort.prototype.inIIR,
            0x3: SerialPort.prototype.inLCR,
            0x4: SerialPort.prototype.inMCR,
            0x5: SerialPort.prototype.inLSR,
            0x6: SerialPort.prototype.inMSR
        };

        /**
         * Port output notification table
         */
        SerialPort.aPortOutput = {
            0x0: SerialPort.prototype.outTHR,   // or DLL if DLAB set
            0x1: SerialPort.prototype.outIER,   // or DLM if DLAB set
            0x3: SerialPort.prototype.outLCR,
            0x4: SerialPort.prototype.outMCR
        };
    }

    /**
     * SerialPort(parms)
     *
     * The SerialPort component has the following component-specific (parms) properties:
     *
     *      adapter: 1 (port 0x3F8) or 2 (port 0x2F8); 0 if not defined
     *
     *      binding: name of a control (based on its "binding" attribute) to bind to this port's I/O;
     *      as a special case, it can be set to "console" to direct all output to the component's default
     *      print() handler (eg, the Control Panel's "print" control, if any, or console.log() if using
     *      a DEBUG or non-COMPILED machine)
     *
     *      tabSize: a non-zero number specifies the tab-stop multiple to use for automatic tab-to-space
     *      conversion; it applies only to the above binding, and the default is 0 (no tab conversion)
     *
     *      charBOL: a non-zero number specifies the ASCII code of a character to display at the beginning
     *      of every line; it applies only to the above binding, and the default is 0 (no BOL character)
     *
     * In the future, we may support 'port' and 'irq' properties that allow the machine to define a non-standard
     * serial port configuration, instead of only our pre-defined 'adapter' configurations.
     *
     * NOTE: Since the XSL file defines 'adapter' as a number, not a string, there's no need to use parseInt(),
     * and as an added benefit, we don't need to worry about whether a hex or decimal format was used.
     *
     * This hard-coded approach mimics the original IBM PC Asynchronous Adapter configuration, which contained
     * a pair of "shunt modules" that allowed the user to select a port address/IRQ combo of either 0x3F8/IRQ4
     * ("Primary") or 0x2F8/IRQ3 ("Secondary").
     *
     * DOS names the first adapter listed by the ROM BIOS as "COM1", even if that adapter is a secondary adapter,
     * so don't assume that COM1 always maps to port 0x3F8/IRQ4.  Internally, I try avoid confusion by always
     * starting with a primary adapter and giving that adapter an ID of "com1".  But different operating systems
     * may follow different device enumeration and naming conventions, so don't make too much of my internally
     * assigned IDs.
     *
     * @this {SerialPort}
     * @param {Object} parms
     */
    constructor(parms)
    {
        super("SerialPort", parms, MESSAGE.SERIAL);

        this.iAdapter = +parms['adapter'];

        switch (this.iAdapter) {
        case 1:
            this.portBase = 0x3F8;
            this.nIRQ = ChipSet.IRQ.COM1;
            break;
        case 2:
            this.portBase = 0x2F8;
            this.nIRQ = ChipSet.IRQ.COM2;
            break;
        default:
            if (this.idComponent != "test") {
                Component.warning("Unrecognized serial adapter #" + this.iAdapter);
                return;
            }
            break;
        }

        /**
         * consoleBuffer becomes a string that records serial port output if the 'binding' property is set to the
         * reserved name "console".  Nothing is written to the console, however, until a linefeed (0x0A) is output
         * or the string length reaches a threshold (currently, 1024 characters).
         */
        this.consoleBuffer = null;

        /**
         * controlBuffer is a DOM element bound to the port (currently used for output only; see transmitByte()).
         *
         * Example: CTTY COM2
         *
         * The CTTY DOS command redirects all CON I/O to the specified serial port (eg, COM2), which it assumes is
         * connected to a serial terminal, and therefore anything it *transmits* via COM2 will be displayed by the
         * terminal.  It further assumes that anything typed on such a terminal is NOT displayed, so as DOS *receives*
         * serial input, DOS *transmits* the appropriate characters back to the terminal via COM2.
         *
         * As a result, controlBuffer only needs to be updated by the transmitByte() function.
         */
        this.controlBuffer = null;

        /**
         * If controlBuffer is being used AND 'tabSize' is set, then we make an attempt to monitor the characters
         * being echoed via transmitByte(), maintain a logical column position, and convert any tabs into the appropriate
         * number of spaces.
         *
         * Another controlBuffer feature is charBOL, which, if nonzero, specifies a character to automatically output
         * at the beginning of every line.  This probably isn't generally useful; I use it internally to preformat serial
         * output.
         */
        this.tabSize = +parms['tabSize'] || 0;
        this.charBOL = +parms['charBOL'] || 0;
        this.charPrev = 0;
        this.iLogicalCol = 0;

        this.bMSRInit = SerialPort.MSR.CTS | SerialPort.MSR.DSR;
        this.fNullModem = true;

        /**
         * Normally, any HTML controls defined within the scope of the component's XML element are *implicitly*
         * bound to us.  For example, in the XML below, the textarea control will automatically trigger a call to
         * setBinding() with sBinding set to "serialWindow" and control set to an HTMLTextAreaElement.
         *
	     *      <serial id="com1">
	     *          <control type="container" class="pcjs-textarea">
	     *      	    <control type="textarea" binding="serialWindow"/>
	     *          </control>
	     *      </serial>
	     *
	     * However, this component also supports an *explicit* binding attribute, which can either be the hard-coded
	     * name "console" (for routing all output to the system console) or the name of a control binding that has
	     * been defined in another component (eg, an HTMLTextAreaElement defined as part of the Control Panel layout).
         */
        let sBinding = parms['binding'];
        if (sBinding == "console") {
            this.consoleBuffer = "";
        } else {
            /**
             * If the SerialPort wants to bind to a control (eg, "print") in a DIFFERENT component (eg, "Panel"),
             * then it specifies the name of that control with the 'binding' property.  The SerialPort constructor
             * will then call bindExternalControl(), which looks up the control, and then passes it to our own
             * setBinding() handler.
             *
             * For bindExternalControl() to succeed, it also needs to know the target component; for now, that's
             * been hard-coded to "Panel", in part because that's one of the few components we can rely upon
             * initializing before we do, but it would be a simple matter to include a component type or ID as part
             * of the 'binding' property as well, if we need more flexibility later.
             *
             * NOTE: If sBinding is not the name of a valid Control Panel DOM element, this call does nothing.
             */
            Component.bindExternalControl(this, sBinding);
        }

        /**
         * No connection until initConnection() is called.
         */
        this.sDataReceived = "";
        this.connection = this.sendData = this.updateStatus = null;
        this.fAutoFlow = false;

        /**
         * Export all functions required by bindConnection() or initConnection(), whichever is required.
         */
        this['exports'] = {
            'bind': this.bindConnection,
            'connect': this.initConnection,
            'receiveData': this.receiveData,
            'receiveStatus': this.receiveStatus
        };
    }

    /**
     * bindConnection(connection, receiveData, fAutoFlow)
     *
     * This is basically a lighter-weight version of initConnection(), used by built-in components
     * like TestController, as opposed to components in external machines, which require more work to connect.
     *
     * @this {SerialPort}
     * @param {Component} connection
     * @param {function()} receiveData
     * @param {boolean} [fAutoFlow] (true to enable automatic flow control; default is false)
     * @returns {boolean}
     */
    bindConnection(connection, receiveData, fAutoFlow = false)
    {
        if (!this.connection) {
            this.connection = connection;
            this.sendData = receiveData;
            this.fAutoFlow = fAutoFlow;
            return true;
        }
        return false;
    }

    /**
     * bindMouse(id, mouse, fnUpdate)
     *
     * @this {SerialPort}
     * @param {string} id
     * @param {Mouse} mouse
     * @param {function(number)} fnUpdate
     * @returns {Component|null}
     */
    bindMouse(id, mouse, fnUpdate)
    {
        let component = null;
        if (id == this.idComponent && !this.connection) {
            this.connection = mouse;
            this.updateStatus = fnUpdate;
            this.fNullModem = false;
            component = this;
        }
        return component;
    }

    /**
     * setBinding(sHTMLType, sBinding, control, sValue)
     *
     * @this {SerialPort}
     * @param {string} sHTMLType is the type of the HTML control (eg, "button", "list", "text", "submit", "textarea", "canvas")
     * @param {string} sBinding is the value of the 'binding' parameter stored in the HTML control's "data-value" attribute (eg, "buffer")
     * @param {HTMLElement} control is the HTML control DOM object (eg, HTMLButtonElement)
     * @param {string} [sValue] optional data value
     * @returns {boolean} true if binding was successful, false if unrecognized binding request
     */
    setBinding(sHTMLType, sBinding, control, sValue)
    {
        if (!sHTMLType || sHTMLType == "textarea") {

            let serial = this;
            this.bindings[sBinding] = this.controlBuffer = /** @type {HTMLTextAreaElement} */ (control);

            /**
             * By establishing an onkeypress handler here, we make it possible for DOS commands like
             * "CTTY COM1" to more or less work (use "CTTY CON" to restore control to the DOS console).
             */
            this.controlBuffer.onkeydown = function onKeyDown(event) {
                /**
                 * This is required in addition to onkeypress, because it's the only way to prevent
                 * BACKSPACE (keyCode 8) from being interpreted by the browser as a "Back" operation;
                 * moreover, not all browsers generate an onkeypress notification for BACKSPACE.
                 *
                 * A related problem exists for Ctrl-key combinations in most Windows-based browsers
                 * (eg, IE, Edge, Chrome for Windows, etc), because keys like Ctrl-C and Ctrl-S have
                 * special meanings (eg, Copy, Save).  To the extent the browser will allow it, we
                 * attempt to disable that default behavior when this control receives an onkeydown
                 * event for one of those keys (probably the only event the browser generates for them).
                 */
                event = event || window.event;
                let keyCode = event.keyCode;
                if (keyCode === 0x08 || event.ctrlKey && keyCode >= 0x41 && keyCode <= 0x5A) {
                    if (event.preventDefault) event.preventDefault();
                    if (keyCode > 0x40) keyCode -= 0x40;
                    serial.receiveData(keyCode);
                }
                return true;
            };

            this.controlBuffer.onkeypress = function onKeyPress(event) {
                /**
                 * Browser-independent keyCode extraction; refer to onKeyPress() and the other key event
                 * handlers in keyboard.js.
                 */
                event = event || window.event;
                let keyCode = event.which || event.keyCode;
                serial.receiveData(keyCode);
                /**
                 * Since we're going to remove the "readonly" attribute from the <textarea> control
                 * (so that the soft keyboard activates on iOS), instead of calling preventDefault() for
                 * selected keys (eg, the SPACE key, whose default behavior is to scroll the page), we must
                 * now call it for *all* keys, so that the keyCode isn't added to the control immediately,
                 * on top of whatever the machine is echoing back, resulting in double characters.
                 */
                if (event.preventDefault) event.preventDefault();
                return true;
            };

            /**
             * Now that we've added an onkeypress handler that calls preventDefault() for ALL keys, the control
             * itself no longer needs the "readonly" attribute; we primarily need to remove it for iOS browsers,
             * so that the soft keyboard will activate, but it shouldn't hurt to remove the attribute for all browsers.
             */
            this.controlBuffer.removeAttribute("readonly");
            return true;
        }

        // default:
        //     if (!this.iAdapter) {
        //         control.removeAttribute("readonly");
        //     }
        //     break;
        // }

        return false;
    }

    /**
     * initBus(cmp, bus, cpu, dbg)
     *
     * @this {SerialPort}
     * @param {Computer} cmp
     * @param {Busx86} bus
     * @param {CPUx86} cpu
     * @param {Debuggerx86} dbg
     */
    initBus(cmp, bus, cpu, dbg)
    {
        this.cmp = cmp;

        if (this.iAdapter) {
            this.bus = bus;
            this.cpu = cpu;
            this.dbg = dbg;

            let serial = this;
            this.timerReceiveNext = this.cpu.addTimer(this.id + ".receive", function receiveDataTimer() {
                serial.receiveData();
            });
            this.timerTransmitNext = this.cpu.addTimer(this.id + ".transmit", function transmitDataTimer() {
                serial.transmitData();
            });

            this.chipset = cmp.getMachineComponent("ChipSet");

            bus.addPortInputTable(this, SerialPort.aPortInput, this.portBase);
            bus.addPortOutputTable(this, SerialPort.aPortOutput, this.portBase);
        }
        this.setReady();
    }

    /**
     * initConnection(fNullModem)
     *
     * If a machine 'connection' parameter exists of the form "{sourcePort}->{targetMachine}.{targetPort}",
     * and "{sourcePort}" matches our idComponent, then look for a component with id "{targetMachine}.{targetPort}".
     *
     * If the target component is found, then verify that it has exported functions with the following names:
     *
     *      receiveData(data): called when we have data to transmit; aliased internally to sendData(data)
     *      receiveStatus(pins): called when our control signals have changed; aliased internally to updateStatus(pins)
     *
     * For now, we're not going to worry about communication in the other direction, because when the target component
     * performs its own initConnection(), it will find our receiveData() and receiveStatus() functions, at which point
     * communication in both directions should be established, and the circle of life is complete.
     *
     * For added robustness, if the target machine initializes much more slowly than we do, and our connection attempt
     * fails, that's OK, because when it finally initializes, its initConnection() will call our initConnection();
     * if we've already initialized, no harm done.
     *
     * @this {SerialPort}
     * @param {boolean} [fNullModem] (caller's null-modem setting, to ensure our settings are in agreement)
     */
    initConnection(fNullModem)
    {
        if (!this.connection) {
            let sConnection = this.cmp.getMachineParm('connection');
            if (sConnection) {
                let asParts = sConnection.split('->');
                if (asParts.length == 2) {
                    let sSourceID = StrLib.trim(asParts[0]);
                    if (sSourceID != this.idComponent) return;  // this connection string is intended for another instance
                    let sTargetID = StrLib.trim(asParts[1]);
                    this.connection = Component.getComponentByID(sTargetID, false);
                    if (this.connection) {
                        let exports = this.connection['exports'];
                        if (exports) {
                            let fnConnect = /** @function */ (exports['connect']);
                            if (fnConnect) fnConnect.call(this.connection, this.fNullModem);
                            this.sendData = exports['receiveData'];
                            if (this.sendData) {
                                this.fNullModem = fNullModem;
                                this.updateStatus = exports['receiveStatus'];
                                this.printf(MESSAGE.STATUS, "Connected %s.%s to %s\n", this.idMachine, sSourceID, sTargetID);
                                return;
                            }
                        }
                    }
                }
                /**
                 * Changed from NOTICE to STATUS because sometimes a connection fails simply because one of us is a laggard.
                 */
                this.printf(MESSAGE.STATUS, "Unable to establish connection: %s\n", sConnection);
            }
        }
    }

    /**
     * powerUp(data, fRepower)
     *
     * @this {SerialPort}
     * @param {Object|null} data
     * @param {boolean} [fRepower]
     * @returns {boolean} true if successful, false if failure
     */
    powerUp(data, fRepower)
    {
        if (!fRepower) {
            /**
             * This is as late as we can currently wait to make our first inter-machine connection attempt;
             * even so, the target machine's initialization process may still be ongoing, so any connection
             * may be not fully resolved until the target machine performs its own initConnection(), which will
             * in turn invoke our initConnection() again.
             */
            this.initConnection(this.fNullModem);

            if (!data || !this.restore) {
                this.reset();
            } else {
                if (!this.restore(data)) return false;
            }
        }
        return true;
    }

    /**
     * powerDown(fSave, fShutdown)
     *
     * @this {SerialPort}
     * @param {boolean} [fSave]
     * @param {boolean} [fShutdown]
     * @returns {Object|boolean} component state if fSave; otherwise, true if successful, false if failure
     */
    powerDown(fSave, fShutdown)
    {
        return fSave? this.save() : true;
    }

    /**
     * reset()
     *
     * @this {SerialPort}
     */
    reset()
    {
        this.initState();
    }

    /**
     * save()
     *
     * This implements save support for the SerialPort component.
     *
     * @this {SerialPort}
     * @returns {Object}
     */
    save()
    {
        let state = new State(this);
        state.set(0, this.saveRegisters());
        return state.data();
    }

    /**
     * restore(data)
     *
     * This implements restore support for the SerialPort component.
     *
     * @this {SerialPort}
     * @param {Object} data
     * @returns {boolean} true if successful, false if failure
     */
    restore(data)
    {
        return this.initState(data[0]);
    }

    /**
     * initState(data)
     *
     * @this {SerialPort}
     * @param {Array} [data]
     * @returns {boolean} true if successful, false if failure
     */
    initState(data)
    {
        /**
         * The NS8250A spec doesn't explicitly say what the RBR and THR are initialized to on a reset,
         * but I think we can safely assume zeros.  Similarly, we reset the baud rate Divisor Latch (wDL)
         * to an arbitrary but consistent default (DL_DEFAULT).
         */
        let i = 0;
        if (data === undefined) {
            data = [
                0,                                          // RBR
                0,                                          // THR
                SerialPort.DL_DEFAULT,                      // DL
                0,                                          // IER
                SerialPort.IIR.NO_INT,                      // IIR
                0,                                          // LCR
                0,                                          // MCR
                SerialPort.LSR.THRE | SerialPort.LSR.TSRE,  // LSR
                this.bMSRInit,                              // MSR
                []
            ];
        }
        this.bRBR = data[i++];
        this.bTHR = data[i++];
        this.wDL =  data[i++];
        this.bIER = data[i++];
        this.bIIR = data[i++];
        this.bLCR = data[i++];
        this.bMCR = data[i++];
        this.bLSR = data[i++];
        this.bMSR = data[i++];
        this.abReceive = data[i];
        return true;
    }

    /**
     * saveRegisters()
     *
     * @this {SerialPort}
     * @returns {Array}
     */
    saveRegisters()
    {
        let i = 0;
        let data = [];
        data[i++] = this.bRBR;
        data[i++] = this.bTHR;
        data[i++] = this.wDL;
        data[i++] = this.bIER;
        data[i++] = this.bIIR;
        data[i++] = this.bLCR;
        data[i++] = this.bMCR;
        data[i++] = this.bLSR;
        data[i++] = this.bMSR;
        data[i] = this.abReceive;
        return data;
    }

    /**
     * getBaudTimeout()
     *
     * The 16-bit Divisor Latch is stored in wDL.  If we take the frequency value 1843200 and divide it by wDL*128,
     * we get the maximum number of bytes per second that the SerialPort interface should generate.  For example,
     * if a baud rate of 1200 is being used, the divisor will be 0x60 (96), so we calculate 1843200/(96*128) = 150,
     * which means there should be a 1000ms/150 or 6.667ms delay between bytes delivered.
     *
     * @this {SerialPort}
     * @returns {number} (number of milliseconds per byte)
     */
    getBaudTimeout()
    {
        let nBytesPerSecond = 1843200 / ((this.wDL || 1) << 7);
        return (1000 / nBytesPerSecond)|0;
    }

    /**
     * receiveData(data, flush)
     *
     * This replaces the old sendRBR() function, which expected an Array of bytes.  We still support that,
     * but in order to support connections with other SerialPort components (ie, the PCx80 SerialPort), we
     * have added support for numbers and strings as well.  If no data is specified at all, then all we do
     * is "clock" any remaining data into the receiver.
     *
     * @this {SerialPort}
     * @param {number|string|Array} [data]
     * @param {boolean} [flush]
     * @returns {boolean} true if received, false if not
     */
    receiveData(data, flush)
    {
        if (flush) {
            /**
             * Technically, this component is only emulating an 8250 (not a 16550), so the hardware
             * only has a 1-byte buffer (not a 16-byte buffer), but for debugging/development purposes,
             * I have historically buffered ALL received data.  Unfortunately, that internal buffer can
             * screw up serial mouse hardware detection, so I've added a flush parameter just for the
             * mouse component.
             *
             * Ultimately, we should decide which chip we want to emulate and faithfully implement its
             * buffer, FIFO control register (if any), etc, and get rid of this "infinite" internal buffer.
             */
            this.abReceive = [];
        }
        if (data != null) {
            if (typeof data == "number") {
                this.abReceive.push(data);
            }
            else if (typeof data == "string") {
                for (let i = 0; i < data.length; i++) {
                    this.abReceive.push(data.charCodeAt(i));
                }
            }
            else {
                this.abReceive = this.abReceive.concat(data);
            }
        }
        this.advanceRBR();
        return true;                // for now, return true regardless, since we're buffering everything anyway
    }

    /**
     * receiveStatus(pins)
     *
     * NOTE: Prior to the addition of this interface, the CTS and DSR bits were initialized set and remained set
     * for the life of the machine.  It is entirely appropriate that this is the only way those bits can be changed,
     * because they represent external control signals.
     *
     * @this {SerialPort}
     * @param {number} pins
     */
    receiveStatus(pins)
    {
        let bMSROld = this.bMSR;
        this.bMSR &= ~(SerialPort.MSR.CTS | SerialPort.MSR.DSR);
        if (pins & RS232.CTS.MASK) {
            this.bMSR |= SerialPort.MSR.CTS | SerialPort.MSR.DCTS;
        }
        if (pins & RS232.DSR.MASK) {
            this.bMSR |= SerialPort.MSR.DSR | SerialPort.MSR.DDSR;
        }
        if (bMSROld != this.bMSR) this.updateIIR();
    }

    /**
     * advanceRBR()
     *
     * @this {SerialPort}
     */
    advanceRBR()
    {
        if (this.abReceive.length > 0 && !(this.bLSR & SerialPort.LSR.DR)) {
            if (!this.fAutoFlow || (this.bMCR & SerialPort.MCR.RTS)) {
                this.bRBR = this.abReceive.shift();
                this.bLSR |= SerialPort.LSR.DR;
                if (this.abReceive.length && this.cpu) {
                    this.cpu.setTimer(this.timerReceiveNext, this.getBaudTimeout());
                }
            }
        }
        this.updateIIR();
    }

    /**
     * inRBR(port, addrFrom)
     *
     * @this {SerialPort}
     * @param {number} port (eg, 0x3F8 or 0x2F8)
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     * @returns {number} simulated port value
     */
    inRBR(port, addrFrom)
    {
        let b = ((this.bLCR & SerialPort.LCR.DLAB) ? (this.wDL & 0xff) : this.bRBR);
        this.printIO(port, undefined, addrFrom, (this.bLCR & SerialPort.LCR.DLAB) ? "DLL" : "RBR", b);
        this.bLSR &= ~SerialPort.LSR.DR;
        this.advanceRBR();
        return b;
    }

    /**
     * inIER(port, addrFrom)
     *
     * @this {SerialPort}
     * @param {number} port (eg, 0x3F9 or 0x2F9)
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     * @returns {number} simulated port value
     */
    inIER(port, addrFrom)
    {
        let b = ((this.bLCR & SerialPort.LCR.DLAB) ? (this.wDL >> 8) : this.bIER);
        this.printIO(port, undefined, addrFrom, (this.bLCR & SerialPort.LCR.DLAB) ? "DLM" : "IER", b);
        return b;
    }

    /**
     * inIIR(port, addrFrom)
     *
     * @this {SerialPort}
     * @param {number} port (eg, 0x3FA or 0x2FA)
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     * @returns {number} simulated port value
     */
    inIIR(port, addrFrom)
    {
        let b = this.bIIR;
        /**
         * Reading the IIR is supposed to clear the INT_THR condition (as is another write to the THR).
         */
        if (b == SerialPort.IIR.INT_THR) {
            this.bIIR = SerialPort.IIR.NO_INT;
        }
        this.printIO(port, undefined, addrFrom, "IIR", b);
        return b;
    }

    /**
     * inLCR(port, addrFrom)
     *
     * @this {SerialPort}
     * @param {number} port (eg, 0x3FB or 0x2FB)
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     * @returns {number} simulated port value
     */
    inLCR(port, addrFrom)
    {
        let b = this.bLCR;
        this.printIO(port, undefined, addrFrom, "LCR", b);
        return b;
    }

    /**
     * inMCR(port, addrFrom)
     *
     * @this {SerialPort}
     * @param {number} port (eg, 0x3FC or 0x2FC)
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     * @returns {number} simulated port value
     */
    inMCR(port, addrFrom)
    {
        let b = this.bMCR;
        this.printIO(port, undefined, addrFrom, "MCR", b);
        return b;
    }

    /**
     * inLSR(port, addrFrom)
     *
     * @this {SerialPort}
     * @param {number} port (eg, 0x3FD or 0x2FD)
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     * @returns {number} simulated port value
     */
    inLSR(port, addrFrom)
    {
        let b = this.bLSR;
        this.printIO(port, undefined, addrFrom, "LSR", b);
        return b;
    }

    /**
     * inMSR(port, addrFrom)
     *
     * @this {SerialPort}
     * @param {number} port (eg, 0x3FE or 0x2FE)
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     * @returns {number} simulated port value
     */
    inMSR(port, addrFrom)
    {
        let b = this.bMSR;
        this.bMSR &= ~(SerialPort.MSR.DCTS | SerialPort.MSR.DDSR);
        this.printIO(port, undefined, addrFrom, "MSR", b);
        return b;
    }

    /**
     * outTHR(port, bOut, addrFrom)
     *
     * @this {SerialPort}
     * @param {number} port (eg, 0x3F8 or 0x2F8)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to write the specified port)
     */
    outTHR(port, bOut, addrFrom)
    {
        let serial = this;
        this.printIO(port, bOut, addrFrom, (this.bLCR & SerialPort.LCR.DLAB) ? "DLL" : "THR");
        if (this.bLCR & SerialPort.LCR.DLAB) {
            this.wDL = (this.wDL & ~0xff) | bOut;
        } else {
            this.bTHR = bOut;
            this.bLSR &= ~(SerialPort.LSR.THRE | SerialPort.LSR.TSRE);
            /**
             * If transmitByte() returned success, we used to immediately re-set the transmitter empty bits:
             *
             *      this.bLSR |= (SerialPort.LSR.THRE | SerialPort.LSR.TSRE);
             *
             * But when we're connected to a virtual device that has no measurable delay, that sets the bits
             * too quickly.  We now arm a timer based on the programmed baud rate, and set the above bits only
             * when that timer fires.
             *
             * Additionally, we no longer care if transmitByte() succeeds, because whether or not a connected
             * device or component received the data is irrelevant to the internal mechanics of the serial port.
             *
             * TODO: Determine if we should also flush/zero bTHR after transmission.
             */
            this.cpu.nonCPU(function transmitByteUnclocked() {
                return serial.transmitByte(bOut);
            });
            this.cpu.setTimer(this.timerTransmitNext, this.getBaudTimeout());
            this.updateIIR();
        }
    }

    /**
     * outIER(port, bOut, addrFrom)
     *
     * @this {SerialPort}
     * @param {number} port (eg, 0x3F9 or 0x2F9)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to write the specified port)
     */
    outIER(port, bOut, addrFrom)
    {
        this.printIO(port, bOut, addrFrom, (this.bLCR & SerialPort.LCR.DLAB) ? "DLM" : "IER");
        if (this.bLCR & SerialPort.LCR.DLAB) {
            this.wDL = (this.wDL & 0xff) | (bOut << 8);
        } else {
            this.bIER = bOut;
        }
    }

    /**
     * outLCR(port, bOut, addrFrom)
     *
     * @this {SerialPort}
     * @param {number} port (eg, 0x3FB or 0x2FB)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to write the specified port)
     */
    outLCR(port, bOut, addrFrom)
    {
        this.printIO(port, bOut, addrFrom, "LCR");
        this.bLCR = bOut;
    }

    /**
     * outMCR(port, bOut, addrFrom)
     *
     * @this {SerialPort}
     * @param {number} port (eg, 0x3FC or 0x2FC)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to write the specified port)
     */
    outMCR(port, bOut, addrFrom)
    {
        let delta = (bOut ^ this.bMCR);
        this.printIO(port, bOut, addrFrom, "MCR");
        this.bMCR = bOut;
        /**
         * Whenever DTR or RTS changes, we also need to notify any connected machine or mouse, via updateStatus().
         */
        if (delta & (SerialPort.MCR.DTR | SerialPort.MCR.RTS)) {
            if (this.updateStatus) {
                let pins = 0;
                if (this.fNullModem) {
                    pins |= (bOut & SerialPort.MCR.RTS)? RS232.CTS.MASK : 0;
                    pins |= (bOut & SerialPort.MCR.DTR)? (RS232.DSR.MASK | RS232.CD.MASK): 0;
                } else {
                    pins |= (bOut & SerialPort.MCR.RTS)? RS232.RTS.MASK : 0;
                    pins |= (bOut & SerialPort.MCR.DTR)? RS232.DTR.MASK : 0;
                }
                this.updateStatus.call(this.connection, pins);
            }
            /**
             * Throw in a call to advanceRBR() for good measure, in case fAutoFlow is set and RTS was just enabled.
             */
            this.advanceRBR();
        }
    }

    /**
     * updateIIR()
     *
     * @this {SerialPort}
     */
    updateIIR()
    {
        let bIIR = -1;
        /**
         * We check all the interrupt conditions in priority order.  TODO: Add INT_LSR.
         */
        if ((this.bLSR & SerialPort.LSR.DR) && (this.bIER & SerialPort.IER.RBR_AVAIL)) {
            bIIR = SerialPort.IIR.INT_RBR;
        }
        else if ((this.bLSR & SerialPort.LSR.THRE) && (this.bIER & SerialPort.IER.THR_EMPTY)) {
            bIIR = SerialPort.IIR.INT_THR;
        }
        else if ((this.bMSR & (SerialPort.MSR.DCTS | SerialPort.MSR.DDSR)) && (this.bIER & SerialPort.IER.MSR_DELTA)) {
            bIIR = SerialPort.IIR.INT_MSR;
        }
        if (bIIR >= 0) {
            this.bIIR &= ~(SerialPort.IIR.NO_INT | SerialPort.IIR.INT_BITS);
            this.bIIR |= bIIR;
            /**
             * I still throttle SerialPort interrupts by passing a hard-coded delay of 100 instructions to setIRR(),
             * even though we are now (theoretically) honoring the programmed baud rate.  The setIRR() delay does not
             * ensure any particular baud rate, it simply gives the underlying Interrupt Service Routine (ISR) some
             * breathing room.
             *
             * The Microsoft Windows 1.01 serial mouse driver ISR issues an EOI before it has safely exited, presumably
             * relying on the fact that a 1200 baud serial device would not normally interrupt frequently enough to
             * blow the stack.  However, in PCx86, all you have to do is remove the delay below and enable Debugger
             * messages on every serial interrupt and mouse event, eg:
             *
             *      m serial on;m pic on;m mouse on
             *
             * to slow the machine down to the point where serial mouse interrupts overwhelm the ISR.  The Debugger
             * messages display the current stack pointer, which you can watch drop to zero and then wrap around, no
             * doubt trampling lots of code and data along the way.
             *
             * This problem could also occur without being forced by the Debugger; eg, if your physical machine's mouse
             * was configured for a high interrupt rate, and your browser generated mouse events at a comparable rate.
             */
            if (this.chipset && this.nIRQ) this.chipset.setIRR(this.nIRQ, 100);
        } else {
            this.bIIR = SerialPort.IIR.NO_INT;
            if (this.chipset && this.nIRQ) this.chipset.clearIRR(this.nIRQ);
        }
    }

    /**
     * transmitByte(b)
     *
     * @this {SerialPort}
     * @param {number} b
     * @returns {boolean} true if transmitted, false if not
     */
    transmitByte(b)
    {
        let fTransmitted = false;

        this.printf("transmitByte(%#04x)\n", b);

        if (this.sendData) {
            if (this.sendData.call(this.connection, b)) {
                fTransmitted = true;
            }
        }

        if (this.controlBuffer) {
            if (b == 0x0D) {
                this.iLogicalCol = 0;
            }
            else if (b == 0x08) {
                this.controlBuffer.value = this.controlBuffer.value.slice(0, -1);
                /**
                 * TODO: Back up the correct number of columns if the character erased was a tab.
                 */
                if (this.iLogicalCol > 0) this.iLogicalCol--;
            }
            else {
                let s = StrLib.toASCIICode(b); // formerly: String.fromCharCode(b);
                let nChars = s.length;      // formerly: (b >= 0x20? 1 : 0);
                if (b < 0x20 && nChars == 1) nChars = 0;
                if (b == 0x09) {
                    let tabSize = this.tabSize || 8;
                    nChars = tabSize - (this.iLogicalCol % tabSize);
                    if (this.tabSize) s = StrLib.pad("", -nChars);
                }
                if (!this.iLogicalCol && nChars) {
                    /**
                     * When BASIC.COM outputs a listing to a serial port, it ends every line with a CR (0x0D)
                     * but no LF (0x0A), which seems a bit odd.  We fix that here.
                     */
                    if (this.charPrev != 0x0A) s = "\n" + s;
                    if (this.charBOL) s = String.fromCharCode(this.charBOL) + s;
                }
                this.controlBuffer.value += s;
                this.controlBuffer.scrollTop = this.controlBuffer.scrollHeight;
                this.iLogicalCol += nChars;
            }
            this.charPrev = b;
            fTransmitted = true;
        }
        else if (this.consoleBuffer != null) {
            if (b == 0x0A || this.consoleBuffer.length >= 1024) {
                this.print(this.consoleBuffer);
                this.consoleBuffer = "";
            }
            if (b != 0x0A) {
                this.consoleBuffer += String.fromCharCode(b);
            }
            fTransmitted = true;
        }

        return fTransmitted;
    }

    /**
     * transmitData()
     *
     * Helper for clocking transmitted data at the expected baud rate.
     *
     * @this {SerialPort}
     */
    transmitData()
    {
        this.bLSR |= (SerialPort.LSR.THRE | SerialPort.LSR.TSRE);
        this.updateIIR();
    }

    /**
     * SerialPort.init()
     *
     * This function operates on every HTML element of class "serial", extracting the
     * JSON-encoded parameters for the SerialPort constructor from the element's "data-value"
     * attribute, invoking the constructor to create a SerialPort component, and then binding
     * any associated HTML controls to the new component.
     */
    static init()
    {
        let aeSerial = Component.getElementsByClass(APPCLASS, "serial");
        for (let iSerial = 0; iSerial < aeSerial.length; iSerial++) {
            let eSerial = aeSerial[iSerial];
            let parms = Component.getComponentParms(eSerial);
            let serial = new SerialPort(parms);
            Component.bindComponentControls(serial, eSerial, APPCLASS);
        }
    }
}

/**
 * Initialize every SerialPort module on the page.
 */
WebLib.onInit(SerialPort.init);

/**
 * @copyright https://www.pcjs.org/machines/pcx86/modules/v2/testctl.js (C) 2012-2024 Jeff Parsons
 */

/**
 * This module provides connectivity between the TestMonitor component and whichever PCx86 SerialPort
 * our 'binding' property indicates, if any.
 */


/**
 * TestController class
 *
 * @class TestController
 * @property {string|undefined} urlTests
 * @property {Object|null} tests
 * @property {string|null} consoleBuffer
 * @property {HTMLTextAreaElement|null} controlBuffer
 * @property {function(...)|null} sendData
 * @property {function(number)|null} deliverData
 * @property {function(number)|null} deliverInput
 * @property {function(Object)|null} deliverTests
 * @unrestricted (allows the class to define properties, both dot and named, outside of the constructor)
 */
class TestController extends Component {
    /**
     * TestController(parms)
     *
     * @this {TestController}
     * @param {Object} parms
     */
    constructor(parms)
    {
        super("TestController", parms);

        this.tests = null;
        let fLoading = false;
        this.urlTests = parms['tests'];

        this.consoleBuffer = "";
        this.controlBuffer = null;
        this.sendData = null;
        this.deliverData = this.deliverInput = this.deliverTests = null;

        this.sBinding = parms['binding'];
        if (this.sBinding) {
            this.serialPort = Component.getComponentByID(this.sBinding, this.id);
            if (this.serialPort) {
                let exports = this.serialPort['exports'];
                if (exports) {
                    let bind = /** @function */ (exports['bind']);
                    if (bind && bind.call(this.serialPort, this, this.receiveData, true)) {
                        this.sendData = exports['receiveData'].bind(this.serialPort);
                        if (this.urlTests) {
                            this.loadTests(this.urlTests);
                            fLoading = true;
                        }
                    }
                }
            }
            if (!this.sendData) {
                Component.warning(this.id + ": binding '" + this.sBinding + "' unavailable");
            }
        }
        if (!fLoading) this.setReady();
    }

    /**
     * loadTests(sURL)
     *
     * @this {TestController}
     * @param {string} sURL
     */
    loadTests(sURL)
    {
        let controller = this;
        let sProgress = "Loading " + sURL + "...";
        WebLib.getResource(sURL, null, true, function(sURL, sResponse, nErrorCode) {
            controller.doneLoad(sURL, sResponse, nErrorCode);
        }, function(nState) {
            controller.printf(MESSAGE.PROGRESS, "%s\n", sProgress);
        });

    }

    /**
     * doneLoad(sURL, sTestData, nErrorCode)
     *
     * @this {TestController}
     * @param {string} sURL
     * @param {string} sTestData
     * @param {number} nErrorCode (response from server if anything other than 200)
     */
    doneLoad(sURL, sTestData, nErrorCode)
    {
        if (nErrorCode) {
            this.printf(nErrorCode < 0? MESSAGE.STATUS : MESSAGE.NOTICE, "Unable to load tests (error %d: %s)\n", nErrorCode, sURL);
        }
        else {
            try {
                this.tests = /** @type {Object} */ (JSON.parse(sTestData));
                if (this.deliverTests) {
                    this.deliverTests(this.tests);
                    this.tests = null;
                }
                Component.addMachineResource(this.idMachine, sURL, sTestData);
            } catch (err) {
                this.printf(MESSAGE.NOTICE, "Test parsing error: %s\n", err.message);
            }
        }
        this.setReady();
    }

    /**
     * bindMonitor(monitor, deliverData, deliverInput, deliverTests)
     *
     * @this {TestController}
     * @param {TestMonitor} monitor
     * @param {function(number)} deliverData
     * @param {function(number)} deliverInput
     * @param {function(Object)} deliverTests
     */
    bindMonitor(monitor, deliverData, deliverInput, deliverTests)
    {
        this.deliverData = deliverData.bind(monitor);
        this.deliverInput = deliverInput.bind(monitor);
        this.deliverTests = deliverTests.bind(monitor);
        if (this.tests && this.deliverTests) {
            this.deliverTests(this.tests);
            this.tests = null;
        }
    }

    /**
     * setBinding(sHTMLType, sBinding, control, sValue)
     *
     * @this {TestController}
     * @param {string} sHTMLType is the type of the HTML control (eg, "button", "list", "text", "submit", "textarea", "canvas")
     * @param {string} sBinding is the value of the 'binding' parameter stored in the HTML control's "data-value" attribute (eg, "buffer")
     * @param {HTMLElement} control is the HTML control DOM object (eg, HTMLButtonElement)
     * @param {string} [sValue] optional data value
     * @returns {boolean} true if binding was successful, false if unrecognized binding request
     */
    setBinding(sHTMLType, sBinding, control, sValue)
    {
        let controller = this;

        if (sHTMLType == "textarea" && !this.controlBuffer) {

            this.bindings[sBinding] = control;
            this.controlBuffer = /** @type {HTMLTextAreaElement} */ (control);
            this.consoleBuffer = null;          // we currently use one or the other: control or console

            /**
             * By establishing an onkeypress handler here, we make it possible for DOS commands like
             * "CTTY COM1" to more or less work (use "CTTY CON" to restore control to the DOS console).
             */
            control.onkeydown = function onKeyDown(event) {
                /**
                 * This is required in addition to onkeypress, because it's the only way to prevent
                 * BACKSPACE (keyCode 8) from being interpreted by the browser as a "Back" operation;
                 * moreover, not all browsers generate an onkeypress notification for BACKSPACE.
                 *
                 * A related problem exists for Ctrl-key combinations in most Windows-based browsers
                 * (eg, IE, Edge, Chrome for Windows, etc), because keys like Ctrl-C and Ctrl-S have
                 * special meanings (eg, Copy, Save).  To the extent the browser will allow it, we
                 * attempt to disable that default behavior when this control receives an onkeydown
                 * event for one of those keys (probably the only event the browser generates for them).
                 */
                event = event || window.event;
                let keyCode = event.keyCode;
                if (keyCode === 0x08 || event.ctrlKey && keyCode >= 0x41 && keyCode <= 0x5A) {
                    if (event.preventDefault) event.preventDefault();
                    if (keyCode > 0x40) keyCode -= 0x40;
                    if (controller.deliverInput) controller.deliverInput(keyCode);
                }
                return true;
            };

            control.onkeypress = function onKeyPress(event) {
                /**
                 * Browser-independent keyCode extraction; refer to onKeyPress() and the other key event
                 * handlers in keyboard.js.
                 */
                event = event || window.event;
                let keyCode = event.which || event.keyCode;
                if (controller.deliverInput) controller.deliverInput(keyCode);
                /**
                 * Since we're going to remove the "readonly" attribute from the <textarea> control
                 * (so that the soft keyboard activates on iOS), instead of calling preventDefault() for
                 * selected keys (eg, the SPACE key, whose default behavior is to scroll the page), we must
                 * now call it for *all* keys, so that the keyCode isn't added to the control immediately,
                 * on top of whatever the machine is echoing back, resulting in double characters.
                 */
                if (event.preventDefault) event.preventDefault();
                return true;
            };

            /**
             * Now that we've added an onkeypress handler that calls preventDefault() for ALL keys, the control
             * itself no longer needs the "readonly" attribute; we primarily need to remove it for iOS browsers,
             * so that the soft keyboard will activate, but it shouldn't hurt to remove the attribute for all browsers.
             */
            control.removeAttribute("readonly");

            if (this.sendData) {
                let monitor = new TestMonitor();
                monitor.bindController(this, this.sendData, this.sendOutput, this.printf, this.sBinding);
            }
            return true;
        }
        return false;
    }

    /**
     * sendOutput(data)
     *
     * @this {TestController}
     * @param {number|string|Array} data
     */
    sendOutput(data)
    {
        if (typeof data == "number") {
            this.printf("%c", data);
        }
        else if (typeof data == "string") {
            this.printf("%s", data);
        }
        else {
            for (let i = 0; i < data.length; i++) this.printf("[0x%02x]", data[i]);
        }
    }

    /**
     * printf(format, ...args)
     *
     * @this {TestController}
     * @param {string|number} format
     * @param {...} args
     */
    printf(format, ...args)
    {
        let s = StrLib.sprintf(format.toString(), ...args);

        if (this.controlBuffer != null) {
            if (s != '\r') {
                if (s == '\b' || s == "\b \b") {
                    this.controlBuffer.value = this.controlBuffer.value.slice(0, -1);
                } else {
                    this.controlBuffer.value += s;
                }
                /**
                 * Prevent the <textarea> from getting too large; otherwise, printing becomes slower and slower.
                 */
                if (!DEBUG && this.controlBuffer.value.length > 8192) {
                    this.controlBuffer.value = this.controlBuffer.value.substr(this.controlBuffer.value.length - 4096);
                }
                this.controlBuffer.scrollTop = this.controlBuffer.scrollHeight;
            }
        }

        if (this.consoleBuffer != null) {
            let i = s.lastIndexOf('\n');
            if (i >= 0) {
                console.log(this.consoleBuffer + s.substr(0, i));
                this.consoleBuffer = "";
                s = s.substr(i + 1);
            }
            this.consoleBuffer += s;
        }
    }

    /**
     * receiveData(data)
     *
     * @this {TestController}
     * @param {number|string|Array} data
     */
    receiveData(data)
    {
        if (typeof data == "number") {
            this.deliverData(data);
        }
        else if (typeof data == "string") {
            for (let i = 0; i < data.length; i++) this.deliverData(data.charCodeAt(i));
        }
        else {
            for (let i = 0; i < data.length; i++) this.deliverData(data[i]);
        }
    }

    /**
     * TestController.init()
     *
     * This function operates on every HTML element of class "TestController", extracting the
     * JSON-encoded parameters for the TestController constructor from the element's "data-value"
     * attribute, invoking the constructor to create a TestController component, and then binding
     * any associated HTML controls to the new component.
     */
    static init()
    {
        let aeTest = Component.getElementsByClass(APPCLASS, "testctl");
        for (let iTest = 0; iTest < aeTest.length; iTest++) {
            let eTest = aeTest[iTest];
            let parms = Component.getComponentParms(eTest);
            let test = new TestController(parms);
            Component.bindComponentControls(test, eTest, APPCLASS);
        }
    }
}

/**
 * Initialize every TestController module on the page.
 */
WebLib.onInit(TestController.init);

/**
 * @copyright https://www.pcjs.org/machines/pcx86/modules/v2/testmon.js (C) 2012-2024 Jeff Parsons
 */

/**
 * Overview
 * --------
 *
 * TestMonitor monitors activity on the bound SerialPort and a user I/O device (eg, a terminal,
 * a console window, etc).  It operates in several modes:
 *
 * 1) TERMINAL mode: all data received from the SerialPort is routed the user output device,
 * and all data received from the user input device is routed to the SerialPort.  No special actions
 * are taken, until/unless the ATTENTION key is detected from the user input device (ie, Ctrl-T).
 *
 * 2) PROMPT mode: data from the SerialPort is monitored for specific prompts (eg, "A>"), and
 * when one of those prompts is detected, we enter COMMAND mode, with category set to the appropriate
 * collection of tests.
 *
 * 3) COMMAND mode: CR-terminated lines of user input are checked against the current set of test
 * commands, and if a match is found, the corresponding request is sent to the SerialPort.
 */

/**
 * TestMonitor class
 *
 * @class TestMonitor
 * @property {string} mode
 * @property {string} promptActive
 * @property {string} promptBuffer
 * @property {Object|undefined} tests
 * @property {Object|undefined} category (eg, "DOS")
 * @property {string} commandBuffer
 * @property {function(...)} sendData
 * @property {function(...)} sendOutput
 * @property {function(string,...)} printf
 * @unrestricted (allows the class to define properties, both dot and named, outside of the constructor)
 */
class TestMonitor {
    /**
     * TestMonitor()
     *
     * @this {TestMonitor}
     */
    constructor()
    {
        if (DEBUG) console.log("TestMonitor()");
        /**
         * Operations are added to the following queue by addOperation(), which ensures that as soon as it
         * transitions from empty to non-empty, a timeout handler is established to begin draining the queue.
         *
         * While this approach is more complicated than simply sending operations (via sendData()) as they
         * arrive, it has at least one important advantage: special operations, such as "wait" (eg, wait for a
         * key to be pressed), are easier to implement, because control of the draining process can be switched
         * from a timeout handler to an appropriate event handler.
         */
        this.aOperations = [];
        this.idTimeout = 0;
        this.fnRemoveOperation = this.removeOperation.bind(this);
        this.fWaitPending = false;
    }

    /**
     * bindController(controller, sendData, sendOutput, printf, sBinding)
     *
     * @this {TestMonitor}
     * @param {Object} controller
     * @param {function(...)} sendData
     * @param {function(...)} sendOutput
     * @param {function(string,...)} printf
     * @param {string} [sBinding]
     */
    bindController(controller, sendData, sendOutput, printf, sBinding)
    {
        this.sendData = sendData.bind(controller);
        this.sendOutput = sendOutput.bind(controller);
        this.printf = printf.bind(controller);
        controller.bindMonitor(this, this.receiveData, this.receiveInput, this.receiveTests);
        this.printf("%s TestMonitor v%s\n", APPNAME, APPVERSION);
        this.printf("Use Ctrl-T to toggle terminal mode%s\n", (sBinding? " (" + sBinding.toUpperCase() + ")" : ""));
        this.setMode(TestMonitor.MODE.TERMINAL);
    }

    /**
     * addCommand(commandLine)
     *
     * @this {TestMonitor}
     * @param {string} commandLine
     * @returns {boolean} (true if successful, false if error)
     */
    addCommand(commandLine)
    {
        if (!commandLine) return true;

        let suite = this.tests[this.category];
        let commands = suite['commands'];
        let commandParts = commandLine.split(' ');
        let command = commandParts[0];

        /**
         * Check for a matching command in the current "test suite" category.
         */
        let fExists = false;
        if (commands[command]) {
            fExists = true;
            command = commands[command];
        }

        let op, mode;
        if (typeof command == "string") {
            op = command;
            /**
             * If you don't want any special op processing (eg, for-loop), then use an explicit 'op' property.
             */
            if (this.addForLoop(op)) return true;
        } else {
            op = command['op'];
            mode = command['mode'];
        }

        if (op) {
            let errorMessage = "";
            op = op.replace(/([$%])([0-9]+)/g, function(match, p1, p2, offset, s) {
                let i = +p2;
                let result = "";
                if (i >= commandParts.length) {
                    result = p1 + p2;
                    errorMessage = "missing value for " + result;
                } else if (!i) {
                    result = commandLine;
                } else if (p1 == '$') {
                    result = commandParts[i];
                } else {        // p1 must be '%', which means convert the value to hex
                    result = StrLib.sprintf("%x", commandParts[i]);
                }
                return result;
            });
            if (errorMessage) {
                this.printf("%s\n", errorMessage);
            } else {
                let i = op.indexOf('(');
                command = (i > 0? op.substr(0, i) : "");
                if (TestMonitor.COMMANDS.indexOf(command) >= 0) {
                    if (!fExists) op = commandLine;
                    fExists = true;
                    let j = op.lastIndexOf(')');
                    if (j > 0) {
                        mode = op.substr(i+1, j-i-1);
                        op = command;
                    }
                }
                else if (TestMonitor.COMMANDS.indexOf(op) >= 0) {
                    fExists = true;
                    mode = commandParts[1];
                }
                if (fExists) {
                    if (DEBUG) console.log("TestMonitor.addCommand(" + commandLine + "): op '" + op + "'");
                    this.addOperation(op, mode);
                    return true;
                }
                this.printf("unrecognized command: %s\n", commandLine);
            }
        } else {
            this.printf("missing operation for command: %s\n", commandParts[0]);
        }
        return false;
    }

    /**
     * addForLoop(commandLine)
     *
     * @this {TestMonitor}
     * @param {string} commandLine
     * @returns {boolean}
     */
    addForLoop(commandLine)
    {
        let fSuccess = false;
        let match = commandLine.match(/^\s*for\s+([a-z]+)\s*=\s*([0-9]+)\s+to\s+([0-9]+)\s*{\s*([\s\S]*?)\s*}\s*$/i);
        if (match) {
            fSuccess = true;
            let symbol = match[1];
            let initial = +match[2];
            let final = +match[3];
            let commands = match[4].split(';');
            for (let value = initial; value <= final && fSuccess; value++) {
                for (let i = 0; i < commands.length; i++) {
                    let commandLine = commands[i].trim();
                    if (!commandLine) continue;
                    commandLine = commandLine.replace(new RegExp("\\$" + symbol, 'g'), value.toString());
                    if (!this.addCommand(commandLine)) {
                        fSuccess = false;
                        break;
                    }
                }
            }
        }
        return fSuccess;
    }

    /**
     * addOperation(op, mode)
     *
     * @this {TestMonitor}
     * @param {string} op
     * @param {string} [mode]
     */
    addOperation(op, mode)
    {
        this.aOperations.push(mode? [op, mode] : op);
        this.nextOperation();
    }

    /**
     * flushOperations()
     *
     * @this {TestMonitor}
     */
    flushOperations()
    {
        if (this.idTimeout) {
            clearTimeout(this.idTimeout);
            this.idTimeout = 0;
        }
        this.aOperations = [];
        this.fWaitPending = false;
    }

    /**
     * nextOperation(msDelay)
     *
     * @this {TestMonitor}
     * @param {number} [msDelay]
     * @returns {boolean}
     */
    nextOperation(msDelay)
    {
        this.fWaitPending = false;
        if (this.aOperations.length) {
            if (!this.idTimeout) {
                this.idTimeout = setTimeout(this.fnRemoveOperation, msDelay || 0);
            }
            return true;
        }
        this.printf("done\n");
        return false;
    }

    /**
     * removeOperation()
     *
     * @this {TestMonitor}
     */
    removeOperation()
    {
        this.idTimeout = 0;
        let op = this.aOperations.shift();
        if (op) {
            let mode;
            if (typeof op != "string") {
                mode = op[1]; op = op[0];
            }
            if (op == TestMonitor.COMMAND.PRINTF) {
                let format = "nothing to print", args = [];
                if (mode) {
                    let parms = mode.match(/^\s*(["'])([\s\S]*?)\1\s*,?\s*([\s\S]*)$/);
                    if (parms) {
                        format = parms[2];
                        args = parms[3].split(',');
                    }
                }
                this.printf(format, ...args);
            }
            else if (op == TestMonitor.COMMAND.WAIT) {
                if (mode) {
                    this.nextOperation(+mode);
                    return;
                }
                this.printf("press a key to continue...");
                this.fWaitPending = true;
                return;
            }
            else {
                this.sendData(op);
                if (mode) {
                    this.flushOperations();
                    this.setMode(mode);
                    return;
                }
            }
            this.nextOperation();
        }
    }

    /**
     * setMode(mode, category)
     *
     * @this {TestMonitor}
     * @param {string} mode
     * @param {string} [category]
     */
    setMode(mode, category)
    {
        if (mode != this.mode) {
            switch (mode) {
            case TestMonitor.MODE.TERMINAL:
                this.category = null;
                break;

            case TestMonitor.MODE.PROMPT:
                this.aCategories = [];
                this.aPrompts = [];
                this.cchPromptLongest = 0;
                for (let category in this.tests) {
                    let suite = this.tests[category];
                    let prompt = suite[TestMonitor.MODE.PROMPT];
                    if (prompt) {
                        /**
                         * The 'prompt' property is allowed to contain a string or array of strings.
                         */
                        if (typeof prompt == "string") {
                            prompt = [prompt];
                        }
                        for (let i = 0; i < prompt.length; i++) {
                            this.aCategories.push(category);
                            this.aPrompts.push(prompt[i]);
                            if (this.cchPromptLongest < prompt[i].length) {
                                this.cchPromptLongest = prompt[i].length;
                            }
                        }
                    }
                }
                this.promptActive = this.promptBuffer = "";
                this.category = null;
                break;

            case TestMonitor.MODE.COMMAND:
                if (category) this.category = category;
                this.commandBuffer = "";
                break;

            default:
                this.printf("unrecognized mode: %s\n", mode);
                return;
            }

            this.mode = mode;
            this.printf("mode: %s\n", this.category || this.mode);
        }
    }

    /**
     * receiveTests(tests)
     *
     * @this {TestMonitor}
     * @param {Object} tests
     */
    receiveTests(tests)
    {
        if (DEBUG) console.log("TestMonitor.receiveTests(" + JSON.stringify(tests) + ")");
        this.tests = tests;
        this.setMode(TestMonitor.MODE.PROMPT);
    }

    /**
     * receiveData(data)
     *
     * @this {TestMonitor}
     * @param {number} data
     */
    receiveData(data)
    {
        if (this.mode == TestMonitor.MODE.PROMPT) {
            if (this.promptBuffer.length >= this.cchPromptLongest) {
                this.promptBuffer = this.promptBuffer.slice(-(this.cchPromptLongest - 1));
            }
            if (data == 10) this.promptBuffer = "";
            this.promptBuffer += String.fromCharCode(data);
            if (DEBUG) console.log("TestMonitor.receiveData(" + data + "): checking prompts for '" + this.promptBuffer + "'");
            let i = this.aPrompts.indexOf(this.promptBuffer);
            if (i >= 0) {
                this.setMode(TestMonitor.MODE.COMMAND, this.aCategories[i]);
            }
        } else if (this.mode == TestMonitor.MODE.TERMINAL) {
            this.sendOutput(data);
        } else {
            /**
             * TODO: This is where we need to collect the response to any commands we have issued.
             */
            // this.sendOutput(data);
            if (DEBUG) console.log("TestMonitor.receiveData(" + data + "): ignored while mode is '" + this.mode + "'");
        }
    }

    /**
     * receiveInput(charCode)
     *
     * @this {TestMonitor}
     * @param {number} charCode
     */
    receiveInput(charCode)
    {
        if (DEBUG) console.log("TestMonitor.receiveInput(" + charCode + ")");
        if (charCode == Keys.ASCII.CTRL_T) {
            this.setMode(this.mode == TestMonitor.MODE.TERMINAL? (this.category? TestMonitor.MODE.COMMAND : TestMonitor.MODE.PROMPT) : TestMonitor.MODE.TERMINAL);
            return;
        }
        if (this.mode == TestMonitor.MODE.TERMINAL || this.mode == TestMonitor.MODE.PROMPT) {
            this.sendData(charCode);
        } else if (this.mode == TestMonitor.MODE.COMMAND) {
            if (this.fWaitPending) {
                this.sendOutput(Keys.KEYCODE.LF);
                this.nextOperation();
                return;
            }
            if (charCode == Keys.KEYCODE.CR) {
                this.sendOutput(Keys.KEYCODE.LF);
                this.flushOperations();
                this.addCommand(this.commandBuffer.replace(/\\n/g, "\n"));
                this.commandBuffer = "";
            } else {
                if (charCode == Keys.ASCII.CTRL_H || charCode == Keys.ASCII.DEL) {
                    if (this.commandBuffer.length) {
                        this.commandBuffer = this.commandBuffer.slice(0, -1);
                        this.sendOutput("\b \b");
                    }
                } else if (charCode >= 32 && charCode < 127) {
                    this.commandBuffer += String.fromCharCode(charCode);
                    this.sendOutput(charCode);
                }
            }
        }
    }
}

TestMonitor.MODE = {
    TERMINAL:   "terminal",
    PROMPT:     "prompt",
    COMMAND:    "command"
};

TestMonitor.COMMAND = {
    PRINTF:     "printf",
    WAIT:       "wait"
};

TestMonitor.COMMANDS = [
    TestMonitor.COMMAND.PRINTF,
    TestMonitor.COMMAND.WAIT
];

/**
 * @copyright https://www.pcjs.org/machines/pcx86/modules/v2/mouse.js (C) 2012-2024 Jeff Parsons
 */

/**
 * @class Mouse
 * @unrestricted (allows the class to define properties, both dot and named, outside of the constructor)
 */
class Mouse extends Component {

    static INTERFACE = {
        BUS:    "bus",
        INPORT: "inport",
        SERIAL: "serial"
    };

    static BUTTON = {
        LEFT:   0,
        RIGHT:  2
    };

    /**
     * The Microsoft Bus Mouse supported only one base address: 0x23C.
     *
     * NOTE: Windows v1.01 probes ports 0x23D and 0x23F immediately prior to probing COM2 (and then COM1)
     * for a serial mouse.
     */
    static BUS = {
        DATA: {                     // Mouse Data Register
            PORT:   0x23C
        },
        TPPI: {                     // 8255 (PPI) Test Register
            PORT:   0x23D
        },
        CTRL: {                     // Mouse Control Register
            PORT:   0x23E
        },
        CPPI: {                     // 8255 (PPI) Control Register
            PORT:   0x23F
        }
    };

    /**
     * The retail Microsoft InPort card supported two base addresses, 0x23C and 0x238, through the primary and
     * secondary jumpers, respectively.  However, OEMs may have had InPorts on other base addresses.
     *
     * Here's a typical InPort Mouse detection sequence:
     *
     *      S = IN(Mouse.INPORT.ID.PORT)
     *      ...
     *      VERIFY THAT S EQUALS Mouse.INPORT.ID.CHIP
     *      T = IN(Mouse.INPORT.ID.PORT)
     *      ...
     *      VERIFY ADDITIONAL PAIRS OF READS RETURN MATCHING S AND T VALUES
     *
     * Here's a typical InPort Mouse interrupt sequence:
     *
     *      OUT(Mouse.INPORT.ADDR.PORT, Mouse.INPORT.ADDR.MODE)
     *      OUT(Mouse.INPORT.DATA.PORT, IN(Mouse.INPORT.DATA.PORT) | Mouse.INPORT.DATA.MODE.HOLD)
     *      ...
     *      OUT(Mouse.INPORT.ADDR.PORT, Mouse.INPORT.ADDR.X)
     *      X = IN(Mouse.INPORT.DATA.PORT)
     *      OUT(Mouse.INPORT.ADDR.PORT, Mouse.INPORT.ADDR.Y)
     *      Y = IN(Mouse.INPORT.DATA.PORT)
     *      OUT(Mouse.INPORT.ADDR.PORT, Mouse.INPORT.ADDR.STATUS)
     *      B = IN(Mouse.INPORT.DATA.PORT) & (Mouse.INPORT.DATA.STATUS.B1 | Mouse.INPORT.DATA.STATUS.B2 | Mouse.INPORT.DATA.STATUS.B3)
     *      ...
     *      OUT(Mouse.INPORT.ADDR.PORT, Mouse.INPORT.ADDR.MODE)
     *      OUT(Mouse.INPORT.DATA.PORT, IN(Mouse.INPORT.DATA.PORT) & ~Mouse.INPORT.DATA.MODE.HOLD)
     */
    static INPORT = {
        ADDR: {
            PORT:       0x23C,
            STATUS:     0x00,       // InPort Status Register
            X:          0x01,       // InPort X Movement Register
            Y:          0x02,       // InPort Y Movement Register
            ISTAT:      0x05,       // InPort Interface Status Register
            ICTRL:      0x06,       // InPort Interface Control Register
            MODE:       0x07        // InPort Mode Register
        },
        DATA: {
            /**
             * The internal register read or written via this port is determined by the value written to ADDR.PORT
             */
            PORT:       0x23D,
            STATUS:     {           // InPort Status Register (0)
                B3:     0x01,       // Status button 3
                B2:     0x02,       // Status button 2
                B1:     0x04,       // Status button 1
                DB3:    0x08,       // Delta button 3
                DB2:    0x10,       // Delta button 2
                DB1:    0x20,       // Delta button 1
                MOVE:   0x40,       // Movement
                PACKET: 0x80        // Packet complete
            },
            MODE: {                 // InPort Mode Register (7)
                HOLD:   0x20        // hold the status for reading
            }
        },
        ID: {
            /**
             * The initial read returns the Chip ID; alternate reads return a byte containing the InPort revision number
             * in the low nibble and the InPort version number in the high nibble.
             */
            PORT:       0x23E,
            CHIP:       0xDE        // InPort Chip ID
        },
        TEST: {
            PORT:       0x23F
        }
    };

    /**
     * From http://paulbourke.net/dataformats/serialmouse:
     *
     *      The old MicroSoft serial mouse, while no longer in general use, can be employed to provide a low cost input device,
     *      for example, coupling the internal mechanism to other moving objects. The serial protocol for the mouse is:
     *
     *          1200 baud, 7 bit, 1 stop bit, no parity.
     *
     *      The pinout of the connector follows the standard serial interface, as shown below:
     *
     *          Pin     Abbr    Description
     *          1       DCD     Data Carrier Detect
     *          2       RD      Receive Data            [serial data from mouse to host]
     *          3       TD      Transmit Data
     *          4       DTR     Data Terminal Ready     [used to provide positive voltage to mouse, plus reset/detection]
     *          5       SG      Signal Ground
     *          6       DSR     Data Set Ready
     *          7       RTS     Request To Send         [used to provide positive voltage to mouse]
     *          8       CTS     Clear To Send
     *          9       RI      Ring
     *
     *      Every time the mouse changes state (moved or button pressed) a three byte "packet" is sent to the serial interface.
     *      For reasons known only to the engineers, the data is arranged as follows, most notably the two high order bits for the
     *      x and y coordinates share the first byte with the button status.
     *
     *                      D6  D5  D4  D3  D2  D1  D0
     *          1st byte    1   LB  RB  Y7  Y6  X7  X6
     *          2nd byte    0   X5  X4  X3  X2  X1  X0
     *          3rd byte    0   Y5  Y4  Y3  Y2  Y1  Y0
     *
     *      where:
     *
     *          LB is the state of the left button, 1 = pressed, 0 = released.
     *          RB is the state of the right button, 1 = pressed, 0 = released
     *          X0-7 is movement of the mouse in the X direction since the last packet. Positive movement is toward the right.
     *          Y0-7 is movement of the mouse in the Y direction since the last packet. Positive movement is back, toward the user.
     *
     * From http://www.kryslix.com/nsfaq/Q.12.html:
     *
     *      The Microsoft serial mouse is the most popular 2-button mouse. It is supported by all major operating systems.
     *      The maximum tracking rate for a Microsoft mouse is 40 reports/second * 127 counts per report, in other words, 5080 counts
     *      per second. The most common range for mice is is 100 to 400 CPI (counts per inch) but can be up to 1000 CPI. A 100 CPI mouse
     *      can discriminate motion up to 50.8 inches/second while a 400 CPI mouse can only discriminate motion up to 12.7 inches/second.
     *
     *          9-pin  25-pin    Line    Comments
     *          shell  1         GND
     *          3      2         TD      Serial data from host to mouse (only for power)
     *          2      3         RD      Serial data from mouse to host
     *          7      4         RTS     Positive voltage to mouse
     *          8      5         CTS
     *          6      6         DSR
     *          5      7         SGND
     *          4      20        DTR     Positive voltage to mouse and reset/detection
     *
     *      To function correctly, both the RTS and DTR lines must be positive. DTR/DSR and RTS/CTS must NOT be shorted.
     *      RTS may be toggled negative for at least 100ms to reset the mouse. (After a cold boot, the RTS line is usually negative.
     *      This provides an automatic toggle when RTS is brought positive). When DTR is toggled the mouse should send a single byte
     *      (0x4D, ASCII 'M').
     *
     *      Serial data parameters: 1200bps, 7 data bits, 1 stop bit
     *
     *      Data is sent in 3 byte packets for each event (a button is pressed or released, or the mouse moves):
     *
     *                  D7  D6  D5  D4  D3  D2  D1  D0
     *          Byte 1  X   1   LB  RB  Y7  Y6  X7  X6
     *          Byte 2  X   0   X5  X4  X3  X2  X1  X0
     *          Byte 3  X   0   Y5  Y4  Y3  Y2  Y1  Y0
     *
     *      LB is the state of the left button (1 means down).
     *      RB is the state of the right button (1 means down).
     *      X7-X0 movement in X direction since last packet (signed byte).
     *      Y7-Y0 movement in Y direction since last packet (signed byte).
     *      The high order bit of each byte (D7) is ignored. Bit D6 indicates the start of an event, which allows the software to
     *      synchronize with the mouse.
     */
    static SERIAL = {
        ID:     0x4D
    };

    /**
     * Mouse(parmsMouse)
     *
     * The Mouse component has the following component-specific (parmsMouse) properties:
     *
     *      adapter: 1 (primary) or 2 (secondary); 0 if not defined
     *
     *      binding: name of a corresponding device component (implies type="serial")
     *
     *      scaleMouse: a floating-point number used to scale incoming mouse coordinates; the default is 0.5
     *
     *      serial: the ID of a corresponding serial component (used in lieu of type="serial" and binding="ID")
     *
     *      type: one of "bus", "inport", or "serial"; the default is "serial" if serial or binding properties are set
     *
     * The first version of this component supported ONLY emulation of the original Microsoft serial mouse,
     * so a valid SerialPort component ID using the 'serial' property was required.  Now, using the 'type' property,
     * it's possible to enable support for other types of mouse hardware (eg, 'bus' for the original Microsoft
     * Bus Mouse interface or 'inport' for the Microsoft InPort Mouse interface).  The 'adapter' property is used
     * only when the selected type supports different configurations (eg, primary vs. secondary InPort adapters).
     *
     * If the 'type' property is set to "serial" (or 'type' is not set and either the original 'serial' property
     * or the new 'binding' property is set), then serial communication will be established with the specified
     * SerialPort component, requesting access to the corresponding serial component ID.  If the SerialPort component
     * is not installed and/or the specified serial component ID is not present, a configuration error will be reported.
     *
     * To recap, the following machine XML syntax is still supported:
     *
     *      <mouse serial="com2"/>
     *
     * but going forward, you should stop using the serial attribute and use syntax like this instead:
     *
     *      <mouse type="serial" binding="com2"/>
     *
     * @this {Mouse}
     * @param {Object} parmsMouse
     */
    constructor(parmsMouse)
    {
        super("Mouse", parmsMouse, MESSAGE.MOUSE);

        this.iAdapter = parmsMouse['adapter'] || 0;
        this.idDevice = parmsMouse['serial'] || parmsMouse['binding'];
        this.sType = parmsMouse['type'] || (this.idDevice? Mouse.INTERFACE.SERIAL : Mouse.INTERFACE.BUS);
        this.typeDevice = (this.sType == Mouse.INTERFACE.SERIAL? "SerialPort" : null);
        this.componentDevice = null;

        this.scale = parmsMouse['scaleMouse'];
        this.setActive(false);
        this.fActive = this.fCaptured = this.fLocked = false;

        /**
         * Initially, no video devices, and therefore no screens, are attached.  initBus() will update aVideo,
         * and powerUp() will update aScreens.
         */
        this.aVideo = [];
        this.aScreens = [];
    }

    /**
     * initBus(cmp, bus, cpu, dbg)
     *
     * @this {Mouse}
     * @param {Computer} cmp
     * @param {Busx86} bus
     * @param {CPUx86} cpu
     * @param {Debuggerx86} dbg
     */
    initBus(cmp, bus, cpu, dbg)
    {
        this.cmp = cmp;
        this.bus = bus;
        this.cpu = cpu;
        this.dbg = dbg;
        this.scale = cmp.getMachineParm('scaleMouse') || this.scale;
        /**
         * Enumerate all the Video components that we may need to interact with.
         */
        for (let video = null; (video = cmp.getMachineComponent("Video", video));) {
            this.aVideo.push(video);
        }
        if (this.sType == Mouse.INTERFACE.BUS) {
            bus.addPortInputTable(this, Mouse.aBusInput, Mouse.BUS.DATA.PORT);
            bus.addPortOutputTable(this, Mouse.aBusOutput, Mouse.BUS.DATA.PORT);
        }
        this.setReady();
    }

    /**
     * isActive()
     *
     * @this {Mouse}
     * @returns {boolean} true if active, false if not
     */
    isActive()
    {
        return this.fActive && (this.cpu? this.cpu.isRunning() : false);
    }

    /**
     * setActive(fActive)
     *
     * @this {Mouse}
     * @param {boolean} fActive is true if active, false if not
     */
    setActive(fActive)
    {
        this.fActive = fActive;
        /**
         * It's currently not possible to automatically lock the pointer outside the context of a user action
         * (eg, a button or screen click), so this code is for naught.
         *
         *      if (this.aVideo.length) this.aVideo[0].notifyPointerActive(fActive);
         *
         * We now rely on similar code in clickMouse().
         */
    }

    /**
     * powerUp(data, fRepower)
     *
     * @this {Mouse}
     * @param {Object|null} data
     * @param {boolean} [fRepower]
     * @returns {boolean} true if successful, false if failure
     */
    powerUp(data, fRepower)
    {
        if (!fRepower) {
            if (!data || !this.restore) {
                this.reset();
            } else {
                if (!this.restore(data)) return false;
            }
            if (this.typeDevice && !this.componentDevice) {
                let componentDevice = null;
                while ((componentDevice = this.cmp.getMachineComponent(this.typeDevice, componentDevice))) {
                    if (componentDevice.bindMouse) {
                        this.componentDevice = componentDevice.bindMouse(this.idDevice, this, this.receiveStatus);
                        if (this.componentDevice) {
                            /**
                             * It's possible that the SerialPort we've just attached to might want to bring us "up to speed"
                             * on the device's state, which is why I envisioned a subsequent syncMouse() call.  And you would
                             * want to do that as a separate call, not as part of bindMouse(), because componentDevice
                             * isn't set until bindMouse() returns.
                             *
                             * However, syncMouse() seems unnecessary, given that SerialPort initializes its MCR to an "inactive"
                             * state, and even when restoring a previous state, if we've done our job properly, both SerialPort
                             * and Mouse should be restored in sync, making any explicit attempt at sync'ing unnecessary (or so I hope).
                             *
                             *      this.componentDevice.syncMouse();
                             */
                            break;
                        }
                    }
                }
                if (this.componentDevice) {
                    this.aScreens = [];     // ensure the screen array is empty before (re)filling it
                    for (let i = 0; i < this.aVideo.length; i++) {
                        let screen = this.aVideo[i].getScreen(this);
                        if (screen) this.aScreens.push(screen);
                    }
                } else {
                    Component.warning(this.id + ": " + this.typeDevice + " " + this.idDevice + " unavailable");
                }
            }
            if (this.fActive) {
                this.captureAll();
            } else {
                this.releaseAll();
            }
        }
        return true;
    }

    /**
     * powerDown(fSave, fShutdown)
     *
     * @this {Mouse}
     * @param {boolean} [fSave]
     * @param {boolean} [fShutdown]
     * @returns {Object|boolean} component state if fSave; otherwise, true if successful, false if failure
     */
    powerDown(fSave, fShutdown)
    {
        return fSave? this.save() : true;
    }

    /**
     * reset()
     *
     * @this {Mouse}
     */
    reset()
    {
        this.initState();
    }

    /**
     * save()
     *
     * This implements save support for the Mouse component.
     *
     * @this {Mouse}
     * @returns {Object}
     */
    save()
    {
        let state = new State(this);
        state.set(0, this.saveState());
        return state.data();
    }

    /**
     * restore(data)
     *
     * This implements restore support for the Mouse component.
     *
     * @this {Mouse}
     * @param {Object} data
     * @returns {boolean} true if successful, false if failure
     */
    restore(data)
    {
        return this.initState(data[0]);
    }

    /**
     * initState(data)
     *
     * @this {Mouse}
     * @param {Array} [data]
     * @returns {boolean} true if successful, false if failure
     */
    initState(data)
    {
        let i = 0;
        if (data === undefined) data = [false, -1, -1, 0, 0, false, false, 0];
        this.setActive(data[i++]);
        this.xMouse = data[i++];
        this.yMouse = data[i++];
        this.xDelta = data[i++];
        this.yDelta = data[i++];
        this.fButton1 = data[i++];      // FYI, we consider button1 to be the LEFT button
        this.fButton2 = data[i++];      // FYI, we consider button2 to be the RIGHT button
        this.pins = data[i];
        /**
         * Convert old UART "MCR" data to new RS-232 "pins" data, in case we're loading an old state;
         * detection and conversion relies on the fact that the MCR bits don't overlap with any RS-232 bits.
         */
        if (this.pins & (SerialPort.MCR.DTR | SerialPort.MCR.RTS)) {
            this.pins = ((this.pins & SerialPort.MCR.DTR)? RS232.DTR.MASK : 0) | ((this.pins & SerialPort.MCR.RTS)? RS232.RTS.MASK : 0);
        }
        return true;
    }

    /**
     * saveState()
     *
     * @this {Mouse}
     * @returns {Array}
     */
    saveState()
    {
        let i = 0;
        let data = [];
        data[i++] = this.fActive;
        data[i++] = this.xMouse;
        data[i++] = this.yMouse;
        data[i++] = this.xDelta;
        data[i++] = this.yDelta;
        data[i++] = this.fButton1;
        data[i++] = this.fButton2;
        data[i] = this.pins;
        return data;
    }

    /**
     * notifyPointerLocked()
     *
     * @this {Mouse}
     * @param {boolean} fLocked
     */
    notifyPointerLocked(fLocked)
    {
        this.fLocked = fLocked;
    }

    /**
     * captureAll()
     *
     * @this {Mouse}
     */
    captureAll()
    {
        if (!this.fCaptured) {
            for (let i = 0; i < this.aScreens.length; i++) {
                if (this.captureMouse(this.aScreens[i])) this.fCaptured = true;
            }
        }
    }

    /**
     * releaseAll()
     *
     * @this {Mouse}
     */
    releaseAll()
    {
        if (this.fCaptured) {
            for (let i = 0; i < this.aScreens.length; i++) {
                if (this.releaseMouse(this.aScreens[i])) this.fCaptured = false;
            }
        }
    }

    /**
     * captureMouse(control)
     *
     * NOTE: addEventListener() wasn't supported in Internet Explorer until IE9, but that's OK, because
     * IE9 is the oldest IE we support anyway (since versions prior to IE9 lack the necessary HTML5 support).
     *
     * @this {Mouse}
     * @param {HTMLElement} control from the HTML DOM (eg, the control for the simulated screen)
     * @returns {boolean} true if event handlers were actually added, false if not
     */
    captureMouse(control)
    {
        if (control) {
            let mouse = this;
            control.addEventListener(
                'mousemove',
                function onMouseMove(event) {
                    mouse.processMouseEvent(event);
                },
                false               // we'll specify false for the 'useCapture' parameter for now...
            );
            control.addEventListener(
                'mousedown',
                function onMouseDown(event) {
                    mouse.processMouseEvent(event, true);
                },
                false               // we'll specify false for the 'useCapture' parameter for now...
            );
            control.addEventListener(
                'mouseup',
                function onMouseUp(event) {
                    mouse.processMouseEvent(event, false);
                },
                false               // we'll specify false for the 'useCapture' parameter for now...
            );
            /**
             * None of these tricks seemed to work for IE10, so I'm giving up hiding the browser's mouse pointer in IE for now.
             *
             *      control['style']['cursor'] = "url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAZdEVYdFNvZnR3YXJlAFBhaW50Lk5FVCB2My41LjbQg61aAAAADUlEQVQYV2P4//8/IwAI/QL/+TZZdwAAAABJRU5ErkJggg=='), url('/versions/images/current/blank.cur'), none";
             *
             * Setting the cursor style to "none" may not be a standard, but it works in Safari, Firefox and Chrome, so that's pretty
             * good for a non-standard!
             *
             * TODO: The reference to '/versions/images/current/blank.cur' is also problematic for anyone who might want
             * to run this app from a different server, so think about that as well.
             */
            control['style']['cursor'] = "none";
            return true;
        }
        return false;
    }

    /**
     * releaseMouse(control)
     *
     * TODO: Use removeEventListener() to clean up our handlers; since I'm currently using anonymous functions,
     * and since I'm not seeing any compelling reason to remove the handlers once they've been established, it's
     * less code to leave them in place.
     *
     * @this {Mouse}
     * @param {HTMLElement} control from the HTML DOM
     * @returns {boolean} true if event handlers were actually released, false if not
     */
    releaseMouse(control)
    {
        if (control) {
            control['style']['cursor'] = "auto";
        }
        return false;
    }

    /**
     * processMouseEvent(event, fDown)
     *
     * @this {Mouse}
     * @param {Object} event object from a 'mousemove', 'mousedown' or 'mouseup' event (ie, a MouseEvent object)
     * @param {boolean} [fDown] (undefined if neither a down nor up event)
     */
    processMouseEvent(event, fDown)
    {
        if (fDown !== undefined) {
            if (this.fLocked === false) {
                /**
                 * If there's no support for automatic pointer locking in the Video component, notifyPointerActive()
                 * will return false, and we will set fLocked to null, ensuring that we never attempt this again.
                 */
                if (!this.aVideo.length || !this.aVideo[0].notifyPointerActive(true)) {
                    this.fLocked = null;
                }
            }
            this.clickMouse(event.button, fDown);
        } else {
            /**
             * All we really care about are deltas.  We record screenX and screenY (as xMouse and yMouse)
             * merely to calculate xDelta and yDelta.
             */
            let xDelta;
            let yDelta;
            if (this.xMouse < 0 || this.yMouse < 0) {
                this.xMouse = event.screenX;
                this.yMouse = event.screenY;
            }
            if (this.fLocked) {
                xDelta = event['movementX'] || event['mozMovementX'] || event['webkitMovementX'] || 0;
                yDelta = event['movementY'] || event['mozMovementY'] || event['webkitMovementY'] || 0;
            } else {
                xDelta = event.screenX - this.xMouse;
                yDelta = event.screenY - this.yMouse;
            }
            this.xMouse = event.screenX;
            this.yMouse = event.screenY;
            this.moveMouse(xDelta, yDelta, this.xMouse, this.yMouse);
        }
    }

    /**
     * clickMouse(iButton, fDown)
     *
     * @this {Mouse}
     * @param {number} iButton is Mouse.BUTTON.LEFT (0) for fButton1, Mouse.BUTTON.RIGHT (2) for fButton2
     * @param {boolean} fDown
     */
    clickMouse(iButton, fDown)
    {
        if (this.isActive()) {
            let sDiag = DEBUGGER? ("mouse button" + iButton + ' ' + (fDown? "dn" : "up")) : null;
            switch (iButton) {
            case Mouse.BUTTON.LEFT:
                if (this.fButton1 != fDown) {
                    this.fButton1 = fDown;
                    this.sendPacket(sDiag);
                    return;
                }
                break;
            case Mouse.BUTTON.RIGHT:
                if (this.fButton2 != fDown) {
                    this.fButton2 = fDown;
                    this.sendPacket(sDiag);
                    return;
                }
                break;
            default:
                break;
            }
            this.printf("%s: ignored\n", sDiag);
        }
    }

    /**
     * moveMouse(xDelta, yDelta, xDiag, yDiag)
     *
     * @this {Mouse}
     * @param {number} xDelta
     * @param {number} yDelta
     * @param {number} [xDiag]
     * @param {number} [yDiag]
     */
    moveMouse(xDelta, yDelta, xDiag, yDiag)
    {
        if (this.isActive()) {
            /**
             * I would prefer to simply say "Math.round(xDelta * this.scale)", but JavaScript's round() function
             * rounds negative numbers toward +infinity if the fraction is exactly 0.5.  All positive numbers are
             * rounded correctly, so we convert the value to positive and restore its sign afterward.  Additionally,
             * if the scaling factor turns a non-zero value into zero, we restore the value to its smallest legal
             * non-zero value (thanks to Math.sign() again).  This ensures that the tiniest movement of the physical
             * mouse always results in at least the tiniest movement of the virtual mouse.
             */
            let xScaled = (Math.round(Math.abs(xDelta) * this.scale) * Math.sign(xDelta)) || Math.sign(xDelta);
            let yScaled = (Math.round(Math.abs(yDelta) * this.scale) * Math.sign(yDelta)) || Math.sign(yDelta);
            if (xScaled || yScaled) {
                this.printf(MESSAGE.MOUSE, "moveMouse(%s,%s)\n", xScaled, yScaled);
                /**
                 * As sendPacket() indicates, any x and y coordinates we supply are for diagnostic purposes only.
                 * sendPacket() only cares about the xDelta and yDelta properties we provide above, which it then zeroes
                 * on completion.
                 */
                this.xDelta = xScaled;
                this.yDelta = yScaled;
                this.sendPacket(null, xDiag, yDiag);
            }
        }
    }

    /**
     * sendPacket(sDiag, xDiag, yDiag)
     *
     * If we're called, something changed.
     *
     * Let's review the 3-byte packet format:
     *
     *              D7  D6  D5  D4  D3  D2  D1  D0
     *      Byte 1  X   1   LB  RB  Y7  Y6  X7  X6
     *      Byte 2  X   0   X5  X4  X3  X2  X1  X0
     *      Byte 3  X   0   Y5  Y4  Y3  Y2  Y1  Y0
     *
     * @this {Mouse}
     * @param {string|null|*} [sDiag] diagnostic message
     * @param {number} [xDiag] original x-coordinate (optional; for diagnostic use only)
     * @param {number} [yDiag] original y-coordinate (optional; for diagnostic use only)
     */
    sendPacket(sDiag, xDiag, yDiag)
    {
        let b1 = 0x40 | (this.fButton1? 0x20 : 0) | (this.fButton2? 0x10 : 0) | ((this.yDelta & 0xC0) >> 4) | ((this.xDelta & 0xC0) >> 6);
        let b2 = this.xDelta & 0x3F;
        let b3 = this.yDelta & 0x3F;
        this.printf(MESSAGE.SERIAL + MESSAGE.ADDR, "%s%sserial packet [%#04x,%#04x,%#04x]\n", (sDiag? (sDiag + ": ") : ""), (yDiag !== undefined? ("mouse (" + xDiag + "," + yDiag + "): ") : ""), b1, b2, b3);
        this.componentDevice.receiveData([b1, b2, b3]);
        this.xDelta = this.yDelta = 0;
    }

    /**
     * receiveStatus(pins)
     *
     * The SerialPort notifies us whenever SerialPort.MCR.DTR or SerialPort.MCR.RTS changes.
     *
     * During normal serial mouse operation, both RTS and DTR must be "positive".
     *
     * Setting RTS "negative" for 100ms resets the mouse.  Toggling DTR requests an identification byte (SERIAL.ID).
     *
     * NOTES: The above 3rd-party information notwithstanding, I've observed that Windows v1.01 initially writes 0x01
     * to the MCR (DTR on, RTS off), spins in a loop that reads the RBR (probably to avoid a bogus identification byte
     * sitting in the RBR), and then writes 0x0B to the MCR (DTR on, RTS on).  This last step is consistent with making
     * the mouse "active", but it is NOT consistent with "toggling DTR", so I conclude that a reset is ALSO sufficient
     * for sending the identification byte.  Right or wrong, this gets the ball rolling for Windows v1.01.
     *
     * @this {Mouse}
     * @param {number} pins
     */
    receiveStatus(pins)
    {
        let fActive = ((pins & (RS232.DTR.MASK | RS232.RTS.MASK)) == (RS232.DTR.MASK | RS232.RTS.MASK));
        if (fActive) {
            if (!this.fActive) {
                let fIdentify = false;
                if (!(this.pins & RS232.RTS.MASK)) {
                    this.reset();
                    this.printf("serial mouse reset\n");
                    fIdentify = true;
                }
                if (!(this.pins & RS232.DTR.MASK)) {
                    this.printf("serial mouse ID requested\n");
                    fIdentify = true;
                }
                if (fIdentify) {
                    /**
                     * HEADS UP: Everything I'd read about the (original) Microsoft Serial Mouse "reset" protocol says
                     * that the device sends a single byte (0x4D aka 'M').  It's not surprising to think that newer mice
                     * might send additional bytes, but you would think that newer mouse drivers (eg, MOUSE.COM v8.20)
                     * would always be able to deal with mice that sent only one byte.
                     *
                     * You would be wrong.  On an INT 0x33 reset, the v8.20 driver looks for an 'M', then it waits for
                     * another byte (0x42 aka 'B').  If it doesn't receive a 'B', it will accept another 'M'.  But if it
                     * receives something else (or nothing at all), it will spend a long time waiting for it, and then
                     * return an error.
                     *
                     * It's entirely possible that I've done something wrong and inadvertently "tricked" MOUSE.COM into
                     * using the wrong detection logic.  But given the other problems I've seen in MOUSE.COM v8.20, including
                     * its failure to properly terminate-and-stay-resident when its initial INT 0x33 reset returns an error,
                     * I'm not in the mood to give it the benefit of the doubt.
                     *
                     * So, anyway, I solve the terminate-and-stay-resident bug in MOUSE.COM v8.20 by feeding it *two* SERIAL.ID
                     * bytes on a reset.  This doesn't seem to adversely affect serial mouse emulation for Windows 1.01, so
                     * I'm calling this good enough for now.
                     */
                    this.componentDevice.receiveData([Mouse.SERIAL.ID, Mouse.SERIAL.ID], true);
                    this.printf("serial mouse ID sent\n");
                }
                this.captureAll();
                this.setActive(fActive);
            }
        } else {
            if (this.fActive) {
                /**
                 * Although this would seem nice (ie, for the Windows v1.01 mouse driver to turn RTS off when its mouse
                 * driver shuts down and Windows exits, since it DID turn RTS on), that doesn't appear to actually happen.
                 * At the very least, Windows will have (re)masked the serial port's IRQ, so what does it matter?  Not much,
                 * I just would have preferred that fActive properly reflect whether we should continue dispatching mouse
                 * events, displaying MOUSE messages, etc.
                 *
                 * We could ask the ChipSet component to notify the SerialPort component whenever its IRQ is masked/unmasked,
                 * and then have the SerialPort pass that notification on to us, but I'm assuming that in the real world,
                 * a mouse device that's still powered may still send event data to the serial port, and if there was software
                 * polling the serial port, it might expect to see that data.  Unlikely, but not impossible.
                 */
                this.printf("serial mouse inactive\n");
                this.releaseAll();
                this.setActive(fActive);
            }
        }
        this.pins = pins;
    }

    /**
     * inBusData(port, addrFrom)
     *
     * @this {Mouse}
     * @param {number} port (eg, 0x23C)
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     * @returns {number} simulated port value
     */
    inBusData(port, addrFrom)
    {
        let b = 0;
        this.printIO(port, undefined, addrFrom, "DATA", b);
        return b;
    }

    /**
     * inBusTPPI(port, addrFrom)
     *
     * @this {Mouse}
     * @param {number} port (eg, 0x23D)
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     * @returns {number} simulated port value
     */
    inBusTPPI(port, addrFrom)
    {
        let b = 0;
        this.printIO(port, undefined, addrFrom, "TPPI", b);
        return b;
    }

    /**
     * inBusCtrl(port, addrFrom)
     *
     * @this {Mouse}
     * @param {number} port (eg, 0x23E)
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     * @returns {number} simulated port value
     */
    inBusCtrl(port, addrFrom)
    {
        let b = 0;
        this.printIO(port, undefined, addrFrom, "CTRL", b);
        return b;
    }

    /**
     * inBusCPPI(port, addrFrom)
     *
     * @this {Mouse}
     * @param {number} port (eg, 0x23F)
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     * @returns {number} simulated port value
     */
    inBusCPPI(port, addrFrom)
    {
        let b = 0;
        this.printIO(port, undefined, addrFrom, "CPPI", b);
        return b;
    }

    /**
     * outBusData(port, bOut, addrFrom)
     *
     * @this {Mouse}
     * @param {number} port (eg, 0x23C)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to write the specified port)
     */
    outBusData(port, bOut, addrFrom)
    {
        this.printIO(port, bOut, addrFrom, "DATA");
    }

    /**
     * outBusTPPI(port, bOut, addrFrom)
     *
     * @this {Mouse}
     * @param {number} port (eg, 0x23D)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to write the specified port)
     */
    outBusTPPI(port, bOut, addrFrom)
    {
        this.printIO(port, bOut, addrFrom, "TPPI");
    }

    /**
     * outBusCtrl(port, bOut, addrFrom)
     *
     * @this {Mouse}
     * @param {number} port (eg, 0x23E)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to write the specified port)
     */
    outBusCtrl(port, bOut, addrFrom)
    {
        this.printIO(port, bOut, addrFrom, "CTRL");
    }

    /**
     * outBusCPPI(port, bOut, addrFrom)
     *
     * @this {Mouse}
     * @param {number} port (eg, 0x23F)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to write the specified port)
     */
    outBusCPPI(port, bOut, addrFrom)
    {
        this.printIO(port, bOut, addrFrom, "CPPI");
    }

    /**
     * Mouse.init()
     *
     * This function operates on every HTML element of class "mouse", extracting the
     * JSON-encoded parameters for the Mouse constructor from the element's "data-value"
     * attribute, invoking the constructor to create a Mouse component, and then binding
     * any associated HTML controls to the new component.
     */
    static init()
    {
        let aeMouse = Component.getElementsByClass(APPCLASS, "mouse");
        for (let iMouse = 0; iMouse < aeMouse.length; iMouse++) {
            let eMouse = aeMouse[iMouse];
            let parmsMouse = Component.getComponentParms(eMouse);
            let mouse = new Mouse(parmsMouse);
            Component.bindComponentControls(mouse, eMouse, APPCLASS);
        }
    }
}

Mouse.aBusInput = {
    0x0:    Mouse.prototype.inBusData,
    0x1:    Mouse.prototype.inBusTPPI,
    0x2:    Mouse.prototype.inBusCtrl,
    0x3:    Mouse.prototype.inBusCPPI
};

Mouse.aBusOutput = {
    0x0:    Mouse.prototype.outBusData,
    0x1:    Mouse.prototype.outBusTPPI,
    0x2:    Mouse.prototype.outBusCtrl,
    0x3:    Mouse.prototype.outBusCPPI
};

/**
 * Initialize every Mouse module on the page.
 */
WebLib.onInit(Mouse.init);

/**
 * @copyright https://www.pcjs.org/machines/pcx86/modules/v2/disk.js (C) 2012-2024 Jeff Parsons
 */

/**
 *  The Disk component provides methods for:
 *
 *      1) creating an empty disk: create()
 *      2) loading a disk image: load()
 *      3) getting disk information: info()
 *      4) seeking a disk sector: seek()
 *      5) reading data from a sector: read()
 *      6) writing data to a sector: write()
 *      7) save disk deltas: save()
 *      8) restore disk deltas: restore()
 *      9) converting disk contents: convertToJSON()
 *
 *  More functionality may be factored out of the FDC and HDC components later and moved here, to
 *  further reduce some of the duplication between them, but the above functionality is a good start.
 */

/**
 * Client/Server Disk I/O
 *
 * To support large disks without consuming large amounts of client-side memory, and to push
 * client-side disk changes back the server, we need a DiskIO API that can be used in place of
 * the DiskDump API.
 *
 * Use of the DiskIO API and any associated disk images must be tightly coupled to per-user
 * storage and specific machine configurations, to prevent the disk images from being corrupted
 * by inconsistent I/O operations.  Our basic User API (userapi.js) already provides some
 * per-user storage that we can use to get the design rolling.
 *
 * The DiskIO API must also provide the ability to create new (empty) hard disk images in per-user
 * storage and automatically associate them with the machine configurations that requested them.
 */

/**
 * Principles
 *
 * Originally, when the Disk class was given a disk image to load and mount, it would request the
 * ENTIRE disk image from the DiskDump module.  That works well for small (floppy) disk images, but
 * for larger disks -- let's just say anything stored on the server as an "img" file -- we'd prefer
 * to interact with that disk using "On-Demand I/O".  Any "img" file on the same server as the PCjs
 * application should be a candidate for on-demand access.
 *
 * On-Demand I/O means that nothing is initially transferred from the server.  As sectors are
 * requested by the PCx86 machine, PCx86 requests them from the server, and maintains an MRU cache
 * of sectors, periodically discarding the least-used clean sectors above a certain memory limit.
 * Dirty sectors (ie, those that the PCx86 machine has written to) must be periodically sent
 * back to the server and then marked as clean, so that they can be discarded like any other
 * sector.
 *
 * We also support "local" init-only disk images, which means that dirty sectors are never sent
 * back to the server and are instead retained by the client for the lifetime of the app; such
 * images are "read-only" as far as the server is concerned, but "read-write" as far as the client
 * is concerned.  Reloading/restarting an app with an "local" disk will return the disk to its
 * initial state.
 *
 * Practice
 *
 * Let's first look at what we *already* do for the HDC component:
 *
 *  1) Creating new (empty) disk images
 *  2) Pre-loading pre-built JSON-encoded disk images (converting them to JSON on the fly as needed)
 *
 * An example of #1 is in /devices/pc/machine/5160/cga/256kb/demo/machine.xml:
 *
 *      <hdc id="hdcXT" drives='[{name:"10Mb Hard Drive",type:3}]'/>
 *
 * and an example of #2 is in /disks/pc/fixed/win101.xml:
 *
 *      <hdc id="hdcXT" drives='[{name:"10Mb Hard Drive",path:"/disks/pc/fixed/win101/10mb.json",type:3}]'/>
 *
 * The HDC component expects an array of drive entries.  Array position determines drive numbering
 * (the first entry is drive 0, the second is drive 1, etc), and each entry contains the following
 * properties:
 *
 *      'name': user-friendly name for the disk, if any
 *      'path': URL of the disk image, if any
 *      'type': a drive type
 *
 * Of those properties, only 'type' is required, which provides an index into an HDC "Drive Type"
 * table that determines disk geometry and therefore disk size.  As we add support for larger disks and
 * newer disk controllers, the 'type' parameter will be superseded by either a user-defined 'geometry'
 * parameter that will define number of heads, cylinders, tracks, sectors per track, and (max) bytes per
 * sector, or perhaps a generic 'size' parameter that leaves geometry choices to the HDC component,
 * which will then pass those decisions on to the Disk component.
 *
 * We will enable on-demand I/O for a disk image with a new 'mode' parameter that looks like:
 *
 *      'mode': one of "local", "preload", "demandrw", "demandro"
 *
 * "preload" means the disk image will be completely preloaded, exactly as before; "demandrw" enables
 * full on-demand I/O support; and "demandro" enables on-demand I/O for reads only (all writes are retained
 * and never written back to the server).
 *
 * "ro" will be the fallback for "rw" unless TWO other important criteria are met: 1) the user has a
 * private user key, and therefore per-user storage; and 2) the disk image 'path' contains an asterisk (*)
 * that the server can internally remap to a directory in the user's storage; eg:
 *
 *      'path': <asterisk>/10mb.img (path components following the asterisk are optional)
 *
 * If the disk image does not already exist, it will be created (but not formatted).
 *
 * This preserves the promise that EVERYTHING a user does within a PCx86 machine is private (ie, not
 * visible to any other PCjs users).  I don't want to be in the business of saving any user machine
 * states or disk changes, but at least those operations are limited to users who have asked for (and
 * received) a private user key.
 *
 * Another important consideration at this stage is dealing with multiple machines writing to the same
 * disk image; even though we're limiting the "demandrw" mode to per-user images, a single user may still
 * inadvertently start up multiple machines that refer to the same disk image.
 *
 * So, every PCx86 machine needs to generate a unique token and include that token with every Disk I/O API
 * operation, so that the server can revoke a previous machine's "rw" access to a disk image when a new
 * machine requests "rw" access to the same disk image.
 *
 * From the client's perspective, revocation can be quietly dealt with by reverting to "demandro" mode;
 * that client becomes stuck with all their dirty sectors until they can reclaim "rw" access, which should
 * only happen if no intervening writes to the disk image on the server have occurred (if I bother allowing
 * reclamation at all).
 *
 * The real challenge here is avoiding revocation of a machine that still has critical changes to commit,
 * but since we can't even solve the problem of a user closing their browser at an inopportune time
 * and potentially leaving a disk image in an inconsistent state, premature revocation is the least of
 * our problems.  Since a real hard drive could suffer the same fate if the machine's power was turned off
 * at the wrong time, you could say that we're simply providing a faithful simulation of reality.
 */

/** @typedef {{ c: number, h: number, s: number, l: number, d: Array.<number>, f: number, o: number, iCylinder: number, iHead: number, sector: number, length: number, data: Array.<number>, pattern: (number|null), file: FileInfo, offFile: number, dataCRC: number, dataError: boolean, dataMark: number, headCRC: number, headError: boolean, iModify: number, cModify: number, fDirty: boolean }} */
let Sector;

/** @typedef {{ hash: string, path: string, attr: string, date: string, size: number, module: (FileModule|undefined) }} */
let FileDesc;

/** @typedef {{ name: string, description: string, segments: (Object.<FileSegment>|undefined) }} */
let FileModule;

/** @typedef {{ offStart: number, offEnd: number, ordinals: (Object.<FileOrdinal>|undefined) }} */
let FileSegment;

/** @typedef {{ o: number, s: string }} */
let FileOrdinal;

/**
 * @class Disk
 * @unrestricted (allows the class to define properties, both dot and named, outside of the constructor)
 */
class Disk extends Component {
    /**
     * Sector object "public" properties.
     */
    static SECTOR = {
        CYLINDER:   'c',                // cylinder number (0-based) [formerly iCylinder]
        HEAD:       'h',                // head number (0-based) [formerly iHead]
        ID:         's',                // sector ID (generally 1-based, except for unusual/copy-protected disks) [formerly 'sector']
        LENGTH:     'l',                // sector length, in bytes (generally 512, except for unusual/copy-protected disks) [formerly 'length']
        DATA:       'd',                // array of signed 32-bit values (if less than length/4, the last value is repeated) [formerly 'data']
        FILE_INDEX: 'f',                // "extended" JSON disk images only [formerly file]
        FILE_OFFSET:'o',                // "extended" JSON disk images only [formerly offFile]
        PATTERN:    'pattern',          // deprecated (no longer used in external images, still used internally)
        /**
         * The following properties occur very infrequently (and usually only in copy-protected or damaged disk images),
         * hence the longer, more meaningful IDs.
         */
        DATA_CRC:   'dataCRC',
        DATA_ERROR: 'dataError',
        DATA_MARK:  'dataMark',
        HEAD_CRC:   'headCRC',
        HEAD_ERROR: 'headError'
    };

    /**
     * The default number of milliseconds to wait before writing a dirty sector back to a remote disk image
     *
     * @const {number}
     */
    static REMOTE_WRITE_DELAY = 2000;   // 2-second delay

    /**
     * A global disk count, used to form unique Disk component IDs (totally optional; for debugging purposes only)
     */
    static nDisks = 0;

    /**
     * Disk(controller, drive, mode)
     *
     * Disk contents are stored as an array (diskData) of cylinders, each of which is an array of
     * heads, each of which is an array of sector objects; the latter contain sector numbers and
     * sector data, where sector data is an array of dwords.  The format does not impose any
     * limitations on number of cylinders, number of heads, sectors per track, or bytes per sector.
     *
     * WARNING: All accesses to disk sector properties must be via their string names, not their
     * "dot" names, otherwise code will break after it's been processed by the Closure Compiler,
     * and any dumped disks may be unmountable.  This is a side-effect of how we mount and dump
     * disk images (ie, as JSON-encoded streams).
     *
     * This means, for example, that all references to "track[iSector].data" must actually appear as
     * "track[iSector][Disk.SECTOR.DATA]".
     *
     * @this {Disk}
     * @param {HDC|FDC} controller
     * @param {Object} drive
     * @param {string} mode
     */
    constructor(controller, drive, mode)
    {
        super("Disk", {'id': controller.idMachine + ".disk" + StrLib.toHex(++Disk.nDisks, 4)}, MESSAGE.DISK);

        this.controller = controller;

        /**
         * Route all printing through this.controller (eg, controller.print()), because
         * the Computer component is unaware of any Disk objects and therefore will not set
         * up the usual overrides when a Control Panel is installed.
         */
        this.print = controller.print;

        this.cmp = controller.cmp;
        this.dbg = controller.dbg;
        this.drive = drive;

        /**
         * We pull out a number of drive properties that we may or may not need as defaults
         */
        this.sDiskName = drive.name;
        this.fRemovable = drive.fRemovable;
        this.fOnDemand = this.fRemote = false;

        /**
         * Initialize the disk contents
         */
        this.create(mode, drive.nCylinders, drive.nHeads, drive.nSectors, drive.cbSector);

        /**
         * The following dirty sector and timer properties are used only with fOnDemand disks,
         * assuming fRemote was successfully set.
         */
        this.aDirtySectors = [];
        this.aDirtyTimestamps = [];         // this array is parallel to aDirtySectors
        this.timerWrite = null;             // REMOTE_WRITE_DELAY timer in effect, if any
        this.msTimerWrite = 0;              // the time that the write timer, if any, is set to fire
        this.fWriteInProgress = false;

        /**
         * To make getModuleInfo() more reliable, we use aModules to cache any modules we see as
         * sectors are read.
         */
        this.aModules = {};

        this.setReady();
    }

    /**
     * initBus(cmp, bus, cpu, dbg)
     *
     * We have no real interest in this notification, other than to obtain a reference to the Debugger
     * for every disk loaded BEFORE the initBus() phase; any disk loaded AFTER that point will get its Debugger
     * reference, if any, from the disk controller passed to the Disk() constructor.
     *
     * @this {Disk}
     * @param {Computer} cmp
     * @param {Busx86} bus
     * @param {CPUx86} cpu
     * @param {Debuggerx86} dbg
     */
    initBus(cmp, bus, cpu, dbg)
    {
        this.dbg = dbg;
    }

    /**
     * isRemote()
     *
     * @this {Disk}
     * @returns {boolean} true if remote disk, false if not
     */
    isRemote()
    {
        /**
         * Ironically, we can't rely on fRemote, because that is cleared and set across disconnect and
         * reconnect operations.  fOnDemand is the next best thing.
         */
        return this.fOnDemand;
    }

    /**
     * powerUp(data, fRepower)
     *
     * As with powerDown(), our sole concern here is for REMOTE disks: if a powerDown() call disconnected an
     * "on-demand" disk, we need to get reconnected.  Calling our own load() function should get the job done.
     *
     * The HDC component could have triggered this as well, but its powerUp() function only calls autoMount()
     * in case of page (ie, application) reload, which is fine for local disks but insufficient for remote disks,
     * which have a server connection that must be re-established.
     *
     * @this {Disk}
     * @param {Object|null} data
     * @param {boolean} [fRepower]
     * @returns {boolean} true if successful, false if failure
     */
    powerUp(data, fRepower)
    {
        if (!fRepower) {
            if (this.fOnDemand && !this.fRemote) {
                this.setReady(false);
                this.load(this.sDiskName, this.sDiskPath, null, this.donePowerUp, this);
            }
        }
        return true;
    }

    /**
     * donePowerUp(drive, disk, sDiskName, sDiskPath)
     *
     * This is a callback issued by the Disk component once the load() from powerUp() has finished.
     *
     * @this {Disk}
     * @param {Object} drive
     * @param {Disk} disk is set if the disk was successfully mounted, null if not
     * @param {string} sDiskName
     * @param {string} sDiskPath
     */
    donePowerUp(drive, disk, sDiskName, sDiskPath)
    {
        this.setReady(true);
    }

    /**
     * powerDown(fSave, fShutdown)
     *
     * Our sole concern here is for REMOTE disks, making sure any unwritten changes get flushed to
     * the server during a shutdown.  No local state is ever returned, so fSave is ignored.
     *
     * Local disks are managed by the controller (ie, FDC or HDC) that mounted them; the controller's
     * powerDown() handler will take care of calling save() as needed.
     *
     * TODO: Consider taking responsibility for saving the state of local disks as well; the only reason
     * the controllers still take care of them is historical, because this component originally didn't
     * exist, and even after it was created, it didn't originally receive powerDown() notifications.
     *
     * @this {Disk}
     * @param {boolean} [fSave]
     * @param {boolean} [fShutdown]
     * @returns {Object|boolean}
     */
    powerDown(fSave, fShutdown)
    {
        /**
         * If we're connected to a remote disk, take this opportunity to flush any remaining unwritten
         * changes and then close the connection.
         */
        if (this.fRemote) {
            let response;
            let nErrorCode = 0;
            if (this.fWriteInProgress) {
                /**
                 * TODO: Verify that the Computer's powerOff() handler will actually honor a false return value.
                 */
                if (!Component.confirmUser("Disk writes are still in progress, shut down anyway?")) {
                    return false;
                }
            }
            while ((response = this.findDirtySectors(false))) {
                if ((nErrorCode = response[0])) {
                    this.printf(MESSAGE.NOTICE, "Unable to save \"%s\" (error %d)\n", this.sDiskName, nErrorCode);
                    break;
                }
            }
            if (fShutdown) {
                this.disconnectRemoteDisk();
            }
            /**
             * I only report that changes to the disk have been "saved" if fSave is true, to avoid confusing
             * users who might not understand the difference between discarding local changes (which should restore
             * all diskettes to their original state) and discarding remote changes (which could leave the remote disk
             * in a bad state).
             */
            if (!nErrorCode && fSave) this.printf(MESSAGE.NOTICE, "\"%s\" saved\n", this.sDiskName);
        }
        return true;
    }

    /**
     * create()
     *
     * @this {Disk}
     * @param {string} mode
     * @param {number} nCylinders
     * @param {number} nHeads
     * @param {number} nSectors (per track)
     * @param {number} cbSector
     *
     * Initializes the disk contents according to the current drive mode and parameters.
     */
    create(mode, nCylinders, nHeads, nSectors, cbSector)
    {
        this.mode = mode;
        this.nCylinders = nCylinders;
        this.nHeads = nHeads;
        this.nSectors = nSectors;
        this.cbSector = cbSector;
        this.diskData = [];
        /**
         * If the drive is using PRELOAD mode, then it will use the load()/mount() process to initialize the disk contents;
         * it wouldn't hurt to let create() do its thing, too, but it's a waste of time.
         */
        if (this.mode != DiskAPI.MODE.PRELOAD) {

            this.printf(MESSAGE.DISK, "blank disk for \"%s\": %d cylinders, %d head(s)\n", this.sDiskName, this.nCylinders, this.nHeads);

            let aCylinders = new Array(this.nCylinders);
            for (let iCylinder = 0; iCylinder < aCylinders.length; iCylinder++) {
                let aHeads = new Array(this.nHeads);
                for (let iHead = 0; iHead < aHeads.length; iHead++) {
                    let aSectors = new Array(this.nSectors);
                    for (let iSector = 1; iSector <= aSectors.length; iSector++) {
                        /**
                         * Now that our read() and write() functions can deal with unallocated data
                         * arrays, and can read/write the specified pattern on-the-fly, we no longer need
                         * to pre-allocate and pre-initialize the DATA array.
                         *
                         * For "local" disks, we can assume a 'pattern' of 0, but for "demandrw" and "demandro"
                         * disks, 'pattern' is set to null, as yet another indication that I/O is required to load
                         * the sector from the server (or to write it back to the server).
                         */
                        aSectors[iSector - 1] = this.initSector(null, iCylinder, iHead, iSector, this.cbSector, (this.mode == DiskAPI.MODE.LOCAL? 0 : null));
                    }
                    aHeads[iHead] = aSectors;
                }
                aCylinders[iCylinder] = aHeads;
            }
            this.diskData = aCylinders;
        }
        this.dwChecksum = null;
    }

    /**
     * load(sDiskName, sDiskPath, file, fnNotify)
     *
     * TODO: Figure out how we can strongly type fnNotify, because the Closure Compiler has issues with:
     *
     *      param {function(Component,Object,Disk,string,string)} fnNotify
     *
     * for:
     *
     *     this.fnNotify.call(this.controller, this.drive, disk, this.sDiskName, this.sDiskPath);
     *
     * Also, while we're at it, learn if there are ways to:
     *
     *      1) declare a function taking NO parameters (ie, generate a warning if any parameters are specified)
     *      2) declare a type for a function's return value
     *
     * @this {Disk}
     * @param {string} sDiskName
     * @param {string} sDiskPath
     * @param {File} [file] is set if there's an associated File object
     * @param {function(...)} [fnNotify]
     * @param {Component} [controller]
     * @returns {boolean} true if load completed (successfully or not), false if queued
     */
    load(sDiskName, sDiskPath, file, fnNotify, controller)
    {
        let sDiskURL = sDiskPath;

        this.printf(MESSAGE.DISK, 'load("%s","%s")\n', sDiskName, sDiskPath);

        if (this.fnNotify) {
            this.printf(MESSAGE.DISK, 'too many load requests for "%s" (%s)\n', sDiskName, sDiskPath);
            return true;
        }

        this.sDiskName = sDiskName;
        this.sDiskPath = sDiskPath;
        this.sDiskFile = StrLib.getBaseName(sDiskPath);
        this.sFormat = "json";

        let disk = this;
        this.fnNotify = fnNotify;
        this.controllerNotify = controller || this.controller;

        if (file) {
            let reader = new FileReader();
            if (file.type == "application/json") {
                reader.onload = function() {
                    disk.doneLoad(sDiskURL, /** @type {string} */ (reader.result), 0);
                };
                reader.onerror = function() {
                    disk.buildDisk(null, false, reader.error.message);
                };
                reader.readAsText(file);
            } else {
                reader.onload = function() {
                    disk.buildDisk(/** @type {ArrayBuffer} */ (reader.result), true);
                };
                reader.onerror = function() {
                    disk.buildDisk(null, false, reader.error.message);
                };
                reader.readAsArrayBuffer(file);
            }
            return true;
        }

        /**
         * If there's an occurrence of API_ENDPOINT anywhere in the path, we assume we can use it as-is;
         * ie, that the user has already formed a URL of the type we use ourselves for unconverted disk images.
         */
        if (sDiskPath.indexOf(DumpAPI.ENDPOINT) < 0) {
            /**
             * If the selected disk image has a "json" extension, then we assume it's a pre-converted
             * JSON-encoded disk image, so we load it as-is; otherwise, we ask our server-side disk image
             * converter to return the corresponding JSON-encoded data.
             */
            let sDiskExt = StrLib.getExtension(sDiskPath);
            if (sDiskExt != DumpAPI.FORMAT.JSON && sDiskExt != DumpAPI.FORMAT.JSON_GZ) {
                if (this.mode == DiskAPI.MODE.DEMANDRW || this.mode == DiskAPI.MODE.DEMANDRO) {
                    sDiskURL = this.connectRemoteDisk(sDiskPath);
                    this.fOnDemand = true;
                } else {
                    this.sFormat = "arraybuffer";
                }
            }
        }
        let sProgress = "Loading " + sDiskURL + "...";
        return !!WebLib.getResource(sDiskURL, this.sFormat, true, function loadDone(sURL, sResponse, nErrorCode) {
            disk.doneLoad(sURL, sResponse, nErrorCode);
        }, function(nState) {
            disk.printf(MESSAGE.PROGRESS, "%s\n", sProgress);
        });
    }

    /**
     * buildDisk(buffer, fModified, message)
     *
     * Builds a disk image from an ArrayBuffer (eg, from a FileReader object), rather than from JSON-encoded data.
     *
     * @this {Disk}
     * @param {ArrayBuffer|null} buffer
     * @param {boolean} [fModified] is true if we should mark the entire disk modified (to ensure that we save/restore it)
     * @param {string} [message] (usually only set if there was an error, and therefore buffer is null or undefined)
     */
    buildDisk(buffer, fModified, message)
    {
        let cbDiskData = 0, dv = null, disk;
        if (buffer) {
            cbDiskData = buffer.byteLength;
            dv = new DataView(buffer, 0, cbDiskData);
        }
        /**
         * Hard drive images using the PCJS MBR will have a special signature, and if that MBR also contains
         * a non-zero DiskInfo.MBR.DRIVE0PARMS.CYLS value, then we'll use the geometry stored in the MBR.
         */
        let nCylinders = 0;
        if (dv && dv.getUint32(0x199, true) == 0x534a4350) {    // if DiskInfo.MBR.PCJS_SIG == PCJS_VALUE
            nCylinders = dv.getUint16(0x19E, true);             // DiskInfo.MBR.DRIVE0PARMS.CYLS
        }
        if (nCylinders) {
            this.nCylinders = nCylinders;
            this.nHeads = dv.getUint8(0x1A0);                   // DiskInfo.MBR.DRIVE0PARMS.HEADS
            this.nSectors = dv.getUint8(0x1AC);                 // DiskInfo.MBR.DRIVE0PARMS.SECTORS
            this.cbSector = 512;
        }
        else {
            let diskFormat = DiskAPI.GEOMETRIES[cbDiskData];
            if (diskFormat) {
                /**
                 * This geometry lookup is primarily intended for diskette images, because there are a wide variety
                 * of diskette formats that can work within a drive's parameters.  So, I used to assert the number
                 * of cylinders match, but the assertion has been relaxed (we require only that the image have no
                 * MORE than the number of cylinders and heads than the drive can handle).
                 *
                 * For example, a 40-cylinder diskette image should be fine with an 80-cylinder high-capacity drive.
                 *
                 * There are also a couple of standard hard drive formats that PCjs likes to use (10Mb and 20Mb), which
                 * I could treat specially (based on diskFormat[4]), but since PCjs can use its own MBR for non-standard
                 * hard disk images now, I'd rather not do that.
                 */
                if (diskFormat[0] <= this.nCylinders && diskFormat[1] <= this.nHeads /* || !diskFormat[4] */) {
                    this.nCylinders = diskFormat[0];
                    this.nHeads = diskFormat[1];
                    this.nSectors = diskFormat[2];
                    this.cbSector = (diskFormat[3] || 512);
                } else {
                    this.nCylinders = 0;                        // we don't know what's going on here...
                }
            }
        }
        if (dv && this.nCylinders) {
            let ib = 0;
            let cdw = this.cbSector >> 2, dwPattern = 0, dwChecksum = 0;
            this.diskData = new Array(this.nCylinders);
            for (let iCylinder = 0; iCylinder < this.diskData.length; iCylinder++) {
                let cylinder = this.diskData[iCylinder] = new Array(this.nHeads);
                for (let iHead = 0; iHead < cylinder.length; iHead++) {
                    let head = cylinder[iHead] = new Array(this.nSectors);
                    for (let iSector = 0; iSector < head.length; iSector++) {
                        let sector = this.initSector(null, iCylinder, iHead, iSector + 1, this.cbSector, dwPattern);
                        let adw = sector[Disk.SECTOR.DATA];
                        for (let idw = 0; idw < cdw; idw++, ib += 4) {
                            let dw = adw[idw] = dv.getInt32(ib, true);
                            dwChecksum = (dwChecksum + dw) & (0xffffffff|0);
                        }
                        if (fModified) sector.cModify = cdw;
                        head[iSector] = sector;
                    }
                }
            }
            this.dwChecksum = dwChecksum;
            disk = this;
        } else {
            this.printf(MESSAGE.NOTICE, "%s\n", message || ("Unrecognized disk format (" + cbDiskData + " bytes)"));
        }

        if (this.fnNotify) {
            this.fnNotify.call(this.controller, this.drive, disk, this.sDiskName, this.sDiskPath);
            this.fnNotify = null;
        }
    }

    /**
     * doneLoad(sURL, imageData, nErrorCode)
     *
     * This function was originally called mount().  If the mount is successful, we pass the Disk object to the
     * caller's fnNotify handler; otherwise, we pass null.
     *
     * @this {Disk}
     * @param {string} sURL
     * @param {string|ArrayBuffer} imageData
     * @param {number} nErrorCode (response from server if anything other than 200)
     */
    doneLoad(sURL, imageData, nErrorCode)
    {
        let disk = null;
        this.fWriteProtected = false;
        let idMessage = (nErrorCode < 0 && this.cmp && !this.cmp.flags.powered)? MESSAGE.STATUS : MESSAGE.NOTICE;

        if (this.fOnDemand) {
            if (!nErrorCode) {
                disk = this;
                this.printf(MESSAGE.DISK, "doneLoad(\"%s\")\n", this.sDiskPath);
                this.fRemote = true;
            } else {
                this.printf(idMessage, "Unable to connect to disk \"%s\" (error %d: %s)\n", this.sDiskPath, nErrorCode, imageData);
            }
        }
        else if (nErrorCode) {
            /**
             * This can happen for innocuous reasons, such as the user switching away too quickly, forcing
             * the request to be cancelled.  And unfortunately, the browser cancels XMLHttpRequest requests
             * BEFORE it notifies any page event handlers, so if the Computer's being powered down, we won't know
             * that yet.  For now, we rely on the lack of a specific error (nErrorCode < 0), and suppress the
             * notify() alert if there's no specific error AND the computer is not powered up yet.
             */
            this.printf(idMessage, "Unable to load disk \"%s\" (error %d: %s)\n", this.sDiskName, nErrorCode, sURL);
        } else {
            this.printf(MESSAGE.DISK, "doneLoad(\"%s\")\n", this.sDiskPath);

            /**
             * If we received binary data instead of JSON, we can use the same buildDisk() function that
             * our FileReader code uses.
             */
            if (typeof imageData != "string") {
                this.buildDisk(imageData);
                return;
            }

            try {
                /**
                 * The following code was a hack to turn on write-protection for a disk image if there was
                 * an initial comment line containing the string "write-protected".  However, since comments
                 * are technically not allowed in JSON, I needed an alternative solution.  So, if the basename
                 * contains the suffix "-readonly", then I'll turn on write-protection for that disk as well.
                 *
                 * TODO: Provide some UI for turning write-protection on/off for disks at will, and provide
                 * an XML-based solution (ie, a per-disk XML configuration option) for controlling it as well.
                 */
                let sBaseName = StrLib.getBaseName(this.sDiskFile, true).toLowerCase();
                if (sBaseName.indexOf("-readonly") > 0) {
                    this.fWriteProtected = true;
                } else {
                    let iEOL = imageData.indexOf("\n");
                    if (iEOL > 0 && iEOL < 1024) {
                        let sConfig = imageData.substring(0, iEOL);
                        if (sConfig.indexOf("write-protected") > 0) {
                            this.fWriteProtected = true;
                        }
                    }
                }
                let diskData, fileTable, imageInfo;
                /**
                 * The most likely source of any exception will be here, where we're parsing the disk data.
                 */
                if (imageData.substr(0, 1) == "<") {    // if the "data" begins with a "<"...
                    /**
                     * Early server configs reported an error (via the nErrorCode parameter) if a disk URL was invalid,
                     * but more recent server configs now display a somewhat friendlier HTML error page.  The downside,
                     * however, is that the original error has been buried, and we've received "data" that isn't actually
                     * disk data.
                     *
                     * So, if the data we've received appears to be "HTML-like", all we can really do is assume that the
                     * disk image is missing.  And so we pretend we received an error message to that effect.
                     */
                    diskData = ["Missing disk image: " + this.sDiskName];
                } else {
                    /**
                     * TODO: IE9 is rather unfriendly and restrictive with regard to how much data it's willing to
                     * eval().  In particular, the 10Mb disk image we use for the Windows 1.01 demo config fails in
                     * IE9 with an "Out of memory" exception.  One work-around would be to chop the data into chunks
                     * (perhaps one track per chunk, using regular expressions) and then manually re-assemble it.
                     *
                     * However, it turns out that using JSON.parse(imageData) instead of eval("(" + imageData + ")")
                     * is a much easier fix. The only drawback is that we must first quote any unquoted property names
                     * and remove any comments, because while eval() was cool with them, JSON.parse() is more particular;
                     * the following RegExp replacements take care of those requirements.
                     *
                     * The use of hex values is something else that eval() was OK with, but JSON.parse() is not, and
                     * while I've stopped using hex values in DumpAPI responses (at least when "format=json" is specified),
                     * I can't guarantee they won't show up in "legacy" images, and there's no simple RegExp replacement
                     * for transforming hex values into decimal values, so I cop out and fall back to eval() if I detect
                     * any hex prefixes ("0x") in the sequence.  Ditto for error messages, which appear like so:
                     *
                     *      ["unrecognized disk path: test.img"]
                     */
                    if (imageData[0] == '{') {
                        let image = JSON.parse(imageData);
                        diskData = image['diskData'];
                        fileTable = image['fileTable'];
                        imageInfo = image['imageInfo'];
                    } else if (imageData.indexOf("0x") < 0 && imageData.substr(0, 2) != "[\"") {
                        diskData = JSON.parse(imageData.replace(/([a-z]+):/gm, "\"$1\":").replace(/\/\/[^\n]*/gm, ""));
                    } else {
                        diskData = eval("(" + imageData + ")");
                    }
                }

                if (!diskData.length) {
                    Component.error("Empty disk image: " + this.sDiskName);
                }
                else if (diskData.length == 1) {
                    Component.error(diskData[0]);
                }
                /**
                 * diskData is an array of cylinders, each of which is an array of heads, each of which
                 * is an array of sector objects.  The format does not impose any limitations on number of
                 * cylinders, number of heads, or number of bytes in any of the sector object byte-arrays.
                 *
                 * WARNING: All accesses to sector object properties must be via their string names, not their
                 * "dot" names, otherwise code will break after it's been processed by the Closure Compiler.
                 *
                 * Sector object properties (from Disk.SECTOR) include:
                 *
                 *      [ID]        the sector ID (1-based, not required to be sequential)
                 *      [LENGTH]    the byte-length (ie, formatted length) of the sector
                 *      [DATA]      the dword-array containing the sector data
                 *
                 * We still support the older JSON encoding, where sector data was encoded as an array of 'bytes'
                 * rather than a dword DATA array.  However, our support is strictly limited to an on-the-fly
                 * conversion to a forward-compatible DATA array.
                 */
                else {
                    if (DEBUG && this.messageEnabled(MESSAGE.DISK + MESSAGE.DATA)) {
                        let sCylinders = diskData.length + " track" + (diskData.length > 1 ? "s" : "");
                        let nHeads = diskData[0].length;
                        let sHeads = nHeads + " head" + (nHeads > 1 ? "s" : "");
                        let nSectorsPerTrack = diskData[0][0].length;
                        let sSectorsPerTrack = nSectorsPerTrack + " sector" + (nSectorsPerTrack > 1 ? "s" : "") + "/track";
                        this.printf("%s, %s, %s\n", sCylinders, sHeads, sSectorsPerTrack);
                    }
                    /**
                     * Before the image is usable, we must "normalize" all the sectors.  In the past, this meant
                     * "inflating" them all.  However, that's no longer strictly necessary.  Mainly, it just means
                     * setting LENGTH and DATA properties, so that all the sectors are well-defined.
                     *
                     * This includes detecting sector data in older formats (eg, the old array of 'bytes' instead
                     * of the new DATA array of dwords) and converting them on-the-fly to the current format.
                     */
                    this.nCylinders = diskData.length;
                    this.nHeads = diskData[0].length;
                    this.nSectors = diskData[0][0].length;
                    let sector = diskData[0][0][0];
                    this.cbSector = (sector && (sector[Disk.SECTOR.LENGTH] || sector['length'])) || 512;

                    let dwChecksum = 0;
                    for (let iCylinder = 0; iCylinder < this.nCylinders; iCylinder++) {
                        for (let iHead = 0; iHead < this.nHeads; iHead++) {
                            for (let iSector = 0; iSector < this.nSectors; iSector++) {
                                sector = diskData[iCylinder][iHead][iSector];
                                if (!sector) continue;          // non-standard (eg, XDF) disk images may have "unused" (null) sectors
                                /**
                                 * "Upgrade" all sector object properties.
                                 */
                                let idSector = sector[Disk.SECTOR.ID];
                                if (idSector == undefined) {
                                    idSector = sector['sector'];
                                    sector[Disk.SECTOR.ID] = idSector;
                                    delete sector['sector'];
                                }
                                let length = sector[Disk.SECTOR.LENGTH];
                                if (length == undefined) {
                                    length = sector['length'] || 512;
                                    sector[Disk.SECTOR.LENGTH] = length;
                                    delete sector['length'];
                                }
                                let dwPattern = sector['pattern'];
                                if (dwPattern == undefined) {
                                    dwPattern = 0;
                                } else {
                                    delete sector['pattern'];
                                }
                                let adw = sector[Disk.SECTOR.DATA];
                                if (adw == undefined) {
                                    adw = sector['data'];
                                    if (adw != undefined) {
                                        sector[Disk.SECTOR.DATA] = adw;
                                        delete sector['data'];
                                    }
                                    else {
                                        let ab = sector['bytes'];
                                        if (ab === undefined || !ab.length) {
                                            /**
                                             * If there is neither a 'bytes' nor 'data' array, then our job is simple:
                                             * create an empty 'data' array; it will be filled in with the dword pattern
                                             * as needed later.
                                             *
                                             * The only wrinkle is if there *is* a 'bytes' array but it's empty, in which
                                             * case we must assume that the pattern was a byte pattern, so convert it to a
                                             * dword pattern.
                                             */
                                            sector[Disk.SECTOR.DATA] = adw = [];
                                            if (ab) {

                                                dwPattern = (dwPattern | (dwPattern << 8) | (dwPattern << 16) | (dwPattern << 24));
                                            }
                                        }
                                        else {
                                            /**
                                             * To keep the conversion code simple, we'll do any necessary pattern-filling first,
                                             * to fully "inflate" the sector, eliminating the possibility of partial dwords and
                                             * saving any code downstream from dealing with byte-size patterns.
                                             */

                                            for (let ib = ab.length; ib < length; ib++) {
                                                ab[ib] = dwPattern;         // the pattern for byte-arrays was only a byte
                                            }
                                            this.fill(sector, ab, 0);
                                        }
                                        delete sector['bytes'];
                                    }
                                }
                                else {
                                    if (adw.length < (length >> 2)) {
                                        /**
                                         * To minimize breakage and changes, I opted to convert new data arrays to the old format,
                                         * where the data array is just the non-repeating data and dwPattern is the repeating value,
                                         * like so:
                                         *
                                         *      dwPattern = adw[--adw.length];
                                         *
                                         * But that was a bone-headed move, because that line will ALWAYS return undefined, since the
                                         * array gets shortened BEFORE the fetch of the final value.
                                         */
                                        dwPattern = adw[adw.length - 1];
                                        if (adw.length) adw.length--;
                                    }
                                }

                                this.initSector(sector, iCylinder, iHead, idSector, this.cbSector, dwPattern);

                                /**
                                 * For the disk as a whole, we maintain a checksum of the original unmodified data:
                                 *
                                 *      dwChecksum: summation of all dwords in all non-empty sectors
                                 *
                                 * Pattern-filling of sectors is deferred until absolutely necessary (eg, when a sector is
                                 * being written).  So all we need to do at this point is checksum all the initial sector data.
                                 */
                                for (let idw = 0; idw < adw.length; idw++) {
                                    dwChecksum = (dwChecksum + adw[idw]) & (0xffffffff|0);
                                }
                            }
                        }
                    }
                    this.diskData = diskData;
                    this.dwChecksum = dwChecksum;
                    this.imageInfo = imageInfo;
                    if (BACKTRACK || SYMBOLS) this.buildFileTable(fileTable);
                    disk = this;
                }
            } catch (e) {
                Component.error("Disk image error (" + sURL + "): " + e.message);
                imageData = null;
            }

            if (imageData) {
                Component.addMachineResource(this.controller.idMachine, sURL, imageData);
            }
        }

        if (this.fnNotify) {
            this.fnNotify.call(this.controllerNotify, this.drive, disk, this.sDiskName, this.sDiskPath, nErrorCode);
            this.fnNotify = null;
        }
    }

    /**
     * buildFileTable(fileTable)
     *
     * This function builds a table of FileInfo objects from any and all file descriptors present in the
     * "extended" JSON disk image, and updates all the sector objects to point back to the corresponding FileInfo.
     * Used for BACKTRACK and SYMBOLS support.
     *
     * @this {Disk}
     * @param {Array.<FileDesc>} [fileTable] (array of FileDescs, if any, stored in the JSON disk image)
     */
    buildFileTable(fileTable)
    {
        if (BACKTRACK || SYMBOLS) {
            if (fileTable) {
                let diskData = this.diskData;
                this.aFileTable = [];
                for (let iCylinder = 0; iCylinder < diskData.length; iCylinder++) {
                    for (let iHead = 0; iHead < diskData[iCylinder].length; iHead++) {
                        for (let iSector = 0; iSector < diskData[iCylinder][iHead].length; iSector++) {
                            let sector = diskData[iCylinder][iHead][iSector];
                            if (sector) {
                                let index = sector[Disk.SECTOR.FILE_INDEX];
                                if (index != undefined) {
                                    let file = this.aFileTable[index];
                                    if (!file) {
                                        let desc = fileTable[index];
                                        file = new FileInfo(this, desc.path, StrLib.getBaseName(desc.path), +desc.attr, desc.size || 0, desc.module);
                                        this.aFileTable[index] = file;
                                    }
                                    sector.file = file;
                                    sector.offFile = sector[Disk.SECTOR.FILE_OFFSET];
                                }
                                delete sector[Disk.SECTOR.FILE_INDEX];
                                delete sector[Disk.SECTOR.FILE_OFFSET];
                            }
                        }
                    }
                }
            }
        }
    }

    /**
     * getFileInfo(sector)
     *
     * @this {Disk}
     * @param {Sector} sector
     * @returns {string}
     */
    getFileInfo(sector)
    {
        //
        // The following code would work if we retained the FILE_INDEX and FILE_OFFSET properties
        // from the original JSON data, but buildFileTable() converts those to file (FileInfo) and
        // offFile (number) properties and then discards them.  However, I may decide to leave
        // FILE_INDEX and FILE_OFFSET in place, and use this code in the future.  It would be a little
        // less overhead per sector (ie, using numbers of instead object references).
        //
        // if (this.aFileTable) {
        //     let iFile = sector[Disk.SECTOR.FILE_INDEX];
        //     if (iFile !== undefined) {
        //         let file = this.aFileTable[iFile];
        //         return file.path + "[" + StrLib.toHex(sector[Disk.SECTOR.FILE_OFFSET], 0, true) + "]";
        //     }
        // }
        return sector.file? (sector.file.path + "[" + StrLib.toHex(sector.offFile, 0, true) + "]") : "unknown";
    }

    /**
     * addModuleInfo(sector)
     *
     * @this {Disk}
     * @param {Sector|null} sector
     */
    addModuleInfo(sector)
    {
        if (SYMBOLS && sector && sector.file) {
            let module = sector.file.module;
            if (module) {
                this.aModules[module.name] = module;
            }
        }
    }

    /**
     * getModuleInfo(sModule, nSegment)
     *
     * If the given module and segment number is found, we return an Array of symbol offsets, indexed by symbol name.
     *
     * NOTE: Originally, this function simply iterated over the disk's file table, looking for a file with a matching
     * module name, but not only was that inefficient (since most files on a disk are not modules), it could actually
     * match the wrong file, since module names are not unique (eg, KRNL286.EXE and KRNL386.EXE are both named "KERNEL").
     *
     * By restricting the search to the most recent module that has actually been read from the disk, we should have much
     * more accurate results.
     *
     * @this {Disk}
     * @param {string} sModule
     * @param {number} nSegment
     * @returns {Object|null}
     */
    getModuleInfo(sModule, nSegment)
    {
        let aSymbols = null;
        if (SYMBOLS) {
            let module = this.aModules[sModule];
            if (module) {
                let segment = module['segments'] && module['segments'][nSegment];
                if (segment) {
                    aSymbols = {};
                    for (let ord in segment['ordinals']) {
                        let entry = segment['ordinals'][ord];
                        /**
                         * entry[1] is the symbol name, which becomes the index, and entry[0] is the offset.
                         */
                        aSymbols[entry['s']] = entry['o'];
                    }
                }
            }
        }
        return aSymbols;
    }

    /**
     * getSymbolInfo(sSymbol)
     *
     * For all whole or partial symbol matches, return them in an Array of entries:
     *
     *      [symbol, file name, segment number, segment offset, segment size].
     *
     * TODO: This function has many limitations (ie, slow, case-sensitive), but it gets the job done for now.
     *
     * @this {Disk}
     * @param {string} sSymbol
     * @returns {Array}
     */
    getSymbolInfo(sSymbol)
    {
        let aInfo = [];
        if (SYMBOLS && this.aFileTable) {
            let sSymbolUpper = sSymbol.toUpperCase();
            for (let iFile = 0; iFile < this.aFileTable.length; iFile++) {
                let file = this.aFileTable[iFile];
                /**
                 * NOTE: Given how we now build the file table based on file indexes in the sector
                 * data, there could well be "holes" in the file table (ie, entries that were used to
                 * describe a volume label or some other directory entry that has no associated sectors).
                 */
                if (!file || !file.module) continue;
                for (let seg in file.module['segments']) {
                    let segment = file.module['segments'][seg];
                    for (let ord in segment['ordinals']) {
                        let entry = segment['ordinals'][ord];
                        if (entry['s'] && entry['s'].indexOf(sSymbolUpper) >= 0) {
                            aInfo.push([entry['s'], file.name, +seg, entry['o'], segment['offEnd'] - segment['offStart']]);
                        }
                    }
                }
            }
        }
        return aInfo;
    }

    /**
     * getSector(lba)
     *
     * @this {Disk}
     * @param {number} lba (logical block address)
     * @returns {Sector|null} sector
     */
    getSector(lba)
    {
        let nSectorsPerCylinder = this.nHeads * this.nSectors;
        let iCylinder = (lba / nSectorsPerCylinder) | 0;
        if (iCylinder < this.nCylinders) {
            let nSectorsRemaining = (lba % nSectorsPerCylinder);
            let iHead = (nSectorsRemaining / this.nSectors) | 0;
            /**
             * LBAs are 0-based, but the sector numbers in CHS addressing are 1-based, so add one to iSector
             */
            let iSector = (nSectorsRemaining % this.nSectors) + 1;
            return this.seek(iCylinder, iHead, iSector);
        }
        return null;
    }

    /**
     * getSectorData(sector, off, len)
     *
     * WARNING: This function is restricted to reading data contained ENTIRELY within the specified sector.
     *
     * NOTE: Yes, this function is not the most efficient way to read a byte/word/dword value from within a sector,
     * but given the different states a sector may be in, it's certainly the simplest and safest, and since this is
     * only used by buildFileTable() and its progeny, it's not clear that we need to be superfast anyway.
     *
     * @this {Disk}
     * @param {Sector} sector
     * @param {number} off (byte offset)
     * @param {number} len (1 to 4 bytes)
     * @returns {number}
     */
    getSectorData(sector, off, len)
    {
        let dw = 0;
        let nShift = 0;

        while (len--) {

            let b = this.read(sector, off++);

            if (b < 0) break;
            dw |= (b << nShift);
            nShift += 8;
        }
        return dw;
    }

    /**
     * initSector(sector, iCylinder, iHead, idSector, cbSector, dwPattern)
     *
     * Ensures every sector has ALL the properties of a proper Sector object.
     *
     * In addition, we will maintain the following information on a per-sector basis,
     * as sectors are modified:
     *
     *      dwPattern:  pattern used to fill partial sectors
     *      iModify:    index of first modified dword in sector
     *      cModify:    number of modified dwords in sector
     *      fDirty:     true if sector is dirty, false if clean (or cleaning in progress)
     *
     * @this {Disk}
     * @param {Sector|null} sector
     * @param {number} iCylinder
     * @param {number} iHead
     * @param {number} idSector
     * @param {number} cbSector
     * @param {number|null} dwPattern
     * @returns {Sector}
     */
    initSector(sector, iCylinder, iHead, idSector, cbSector, dwPattern)
    {
        if (!sector) {
            sector = /** @type {Sector} */ ({
                [Disk.SECTOR.CYLINDER]: iCylinder,
                [Disk.SECTOR.HEAD]: iHead,
                [Disk.SECTOR.ID]: idSector,
                [Disk.SECTOR.LENGTH]: cbSector,
                [Disk.SECTOR.DATA]: []
            });
        } else {
            sector[Disk.SECTOR.CYLINDER] = iCylinder;
            sector[Disk.SECTOR.HEAD] = iHead;
            //
            // These asserts will fail on disks with non-standard formats (eg, copy-protected disks
            // like "ZORK1-READONLY.json"), so they have been disabled.
            //
            //
            //
        }
        sector[Disk.SECTOR.PATTERN] = dwPattern;
        sector.iModify = sector.cModify = 0;
        sector.fDirty = false;
        return sector;
    }

    /**
     * connectRemoteDisk(sDiskPath)
     *
     * Unlike disconnect(), we don't issue the connect request ourselves; instead, we piggyback on the existing
     * preload code in load() to establish the connection.  That, in turn, will trigger a call to mount(), which
     * will check fOnDemand and set fRemote if the connection was successful.
     *
     * @this {Disk}
     * @param {string} sDiskPath
     * @returns {string} is the URL connection string required to connect to sDiskPath
     */
    connectRemoteDisk(sDiskPath)
    {
        let sParms = DiskAPI.QUERY.ACTION + '=' + DiskAPI.ACTION.OPEN;
        sParms += '&' + DiskAPI.QUERY.VOLUME + '=' + sDiskPath;
        sParms += '&' + DiskAPI.QUERY.MODE + '=' + this.mode;
        sParms += '&' + DiskAPI.QUERY.CHS + '=' + this.nCylinders + ':' + this.nHeads + ':' + this.nSectors + ':' + this.cbSector;
        sParms += '&' + DiskAPI.QUERY.MACHINE + '=' + this.controller.getMachineID();
        sParms += '&' + DiskAPI.QUERY.USER + '=' + this.controller.getUserID();
        return WebLib.getHostOrigin() + DiskAPI.ENDPOINT + '?' + sParms;
    }

    /**
     * readRemoteSectors(iCylinder, iHead, iSector, nSectors, fAsync, done)
     *
     * @this {Disk}
     * @param {number} iCylinder
     * @param {number} iHead
     * @param {number} iSector
     * @param {number} nSectors (to read)
     * @param {boolean} fAsync
     * @param {function(number,boolean)} [done]
     */
    readRemoteSectors(iCylinder, iHead, iSector, nSectors, fAsync, done)
    {
        this.printf(MESSAGE.DEBUG, "readRemoteSectors(CHS=%d:%d:%d,N=%d)\n", iCylinder, iHead, iSector, nSectors);

        if (this.fRemote) {
            let sParms = DiskAPI.QUERY.ACTION + '=' + DiskAPI.ACTION.READ;
            sParms += '&' + DiskAPI.QUERY.VOLUME + '=' + this.sDiskPath;
            sParms += '&' + DiskAPI.QUERY.CHS + '=' + this.nCylinders + ':' + this.nHeads + ':' + this.nSectors + ':' + this.cbSector;
            sParms += '&' + DiskAPI.QUERY.ADDR + '=' + iCylinder + ':' + iHead + ':' + iSector + ':' + nSectors;
            sParms += '&' + DiskAPI.QUERY.MACHINE + '=' + this.controller.getMachineID();
            sParms += '&' + DiskAPI.QUERY.USER + '=' + this.controller.getUserID();
            let disk = this;
            let sDiskURL = WebLib.getHostOrigin() + DiskAPI.ENDPOINT + '?' + sParms;
            WebLib.getResource(sDiskURL, null, fAsync, function(sURL, sResponse, nErrorCode) {
                disk.doneReadRemoteSectors(sURL, sResponse, nErrorCode, [iCylinder, iHead, iSector, nSectors, fAsync, done]);
            });
            return;
        }
        if (done) done(-1, false);
    }

    /**
     * doneReadRemoteSectors(sURLName, sURLData, nErrorCode, aRequest)
     *
     * @this {Disk}
     * @param {string} sURLName
     * @param {string} sURLData
     * @param {number} nErrorCode
     * @param {Array} aRequest ([iCylinder, iHead, iSector, nSectors, fAsync, done])
     */
    doneReadRemoteSectors(sURLName, sURLData, nErrorCode, aRequest)
    {
        let fAsync = false;

        let iCylinder = aRequest[0];
        let iHead = aRequest[1];
        let iSector = aRequest[2];
        let nSectors = aRequest[3];

        if (!nErrorCode) {
            let abData = JSON.parse(sURLData);
            let offData = 0;
            while (nSectors--) {
                /**
                 * We call seek with fWrite == true to prevent seek() from triggering another call
                 * to readRemoteSectors() and endlessly recursing.  That also forces seek() to:
                 *
                 *  1) zero the sector's 'pattern'
                 *  2) disable warning about reading an uninitialized sector
                 *
                 * We KNOW this is an uninitialized sector, because we're about to initialize it.
                 */
                let sector = this.seek(iCylinder, iHead, iSector, null, true);
                if (!sector) {
                    this.printf(MESSAGE.DEBUG, "doneReadRemoteSectors(): seek(CHS=%d:%d:%d) failed\n", iCylinder, iHead, iSector);
                    break;
                }
                this.fill(sector, abData, offData);
                offData += sector[Disk.SECTOR.LENGTH];
                /**
                 * We happen to know that when seek() calls readRemoteSectors(), it limits the number of sectors
                 * to the current track, so the only variable we need to advance is iSector.
                 */
                iSector++;
            }
            fAsync = aRequest[4];
        } else {
            this.printf(MESSAGE.DEBUG, "doneReadRemoteSectors(CHS=%d:%d:%d,N=%d) returned error %d\n", iCylinder, iHead, iSector, nSectors, nErrorCode);
        }
        let done = aRequest[5];
        if (done) done(nErrorCode, fAsync);
    }

    /**
     * writeRemoteSectors(iCylinder, iHead, iSector, nSectors, abSectors, fAsync)
     *
     * Writes to a remote disk are performed on a timer-driven basis.  When a sector is modified for the first time,
     * a reference to that sector is "pushed" onto (ie, appended to the end of) aDirtySectors, and if aDirtySectors was
     * originally empty, then a REMOTE_WRITE_DELAY timer is set.
     *
     * When the timer fires, the first batch of contiguous sectors is sent off the server, and when the server responds
     * (ie, when cleanDirtySectors() is called), if the response indicates success, every sector that was sent is marked
     * clean -- unless one or more writes to the sector occurred in the meantime, which we track through a per-sector
     * fDirty flag.
     *
     * @this {Disk}
     * @param {number} iCylinder
     * @param {number} iHead
     * @param {number} iSector
     * @param {number} nSectors (to write)
     * @param {Array.<number>} abSectors
     * @param {boolean} fAsync
     * @returns {boolean|Array}
     */
    writeRemoteSectors(iCylinder, iHead, iSector, nSectors, abSectors, fAsync)
    {
        this.printf(MESSAGE.DEBUG, "writeRemoteSectors(CHS=%d:%d:%d,N=%d)\n", iCylinder, iHead, iSector, nSectors);

        if (this.fRemote) {
            let dataPost = {};
            this.fWriteInProgress = true;
            dataPost[DiskAPI.QUERY.ACTION] = DiskAPI.ACTION.WRITE;
            dataPost[DiskAPI.QUERY.VOLUME] = this.sDiskPath;
            dataPost[DiskAPI.QUERY.CHS] = this.nCylinders + ':' + this.nHeads + ':' + this.nSectors + ':' + this.cbSector;
            dataPost[DiskAPI.QUERY.ADDR] = iCylinder + ':' + iHead + ':' + iSector + ':' + nSectors;
            dataPost[DiskAPI.QUERY.MACHINE] = this.controller.getMachineID();
            dataPost[DiskAPI.QUERY.USER] = this.controller.getUserID();
            dataPost[DiskAPI.QUERY.DATA] = JSON.stringify(abSectors);
            let disk = this;
            let sDiskURL = WebLib.getHostOrigin() + DiskAPI.ENDPOINT;
            WebLib.getResource(sDiskURL, dataPost, fAsync, function(sURL, sResponse, nErrorCode) {
                disk.doneWriteRemoteSectors(sURL, sResponse, nErrorCode, [iCylinder, iHead, iSector, nSectors, fAsync]);
            });
        }
        return false;
    }

    /**
     * doneWriteRemoteSectors(sURLName, sURLData, nErrorCode, aRequest)
     *
     * @this {Disk}
     * @param {string} sURLName
     * @param {string} sURLData
     * @param {number} nErrorCode
     * @param {Array} aRequest ([iCylinder, iHead, iSector, nSectors, fAsync])
     */
    doneWriteRemoteSectors(sURLName, sURLData, nErrorCode, aRequest)
    {
        let iCylinder = aRequest[0];
        let iHead = aRequest[1];
        let iSector = aRequest[2];
        let nSectors = aRequest[3];
        let fAsync = aRequest[4];
        this.fWriteInProgress = false;

        if (iCylinder >= 0 && iCylinder < this.diskData.length && iHead >= 0 && iHead < this.diskData[iCylinder].length) {
            for (let i = iSector - 1; nSectors-- > 0 && i >= 0 && i < this.diskData[iCylinder][iHead].length; i++) {
                let sector = this.diskData[iCylinder][iHead][i];

                if (!nErrorCode) {
                    if (!sector.fDirty) {
                        sector.iModify = sector.cModify = 0;
                    }
                } else {
                    this.printf(MESSAGE.DEBUG, "doneWriteRemoteSectors(CHS=%d:%d:%d) returned error %d\n", iCylinder, iHead, sector[Disk.SECTOR.ID], nErrorCode);
                    this.queueDirtySector(sector, false);
                }
            }
        }
        if (fAsync) this.updateWriteTimer();
    }

    /**
     * disconnectRemoteDisk()
     *
     * This is called by our powerDown() notification handler.  If fRemote is true, we issue the disconnect
     * request and then immediately set fRemote to false; we don't wait for (or test) the response.
     *
     * @this {Disk}
     */
    disconnectRemoteDisk()
    {
        if (this.fRemote) {
            let sParms = DiskAPI.QUERY.ACTION + '=' + DiskAPI.ACTION.CLOSE;
            sParms += '&' + DiskAPI.QUERY.VOLUME + '=' + this.sDiskPath;
            sParms += '&' + DiskAPI.QUERY.MACHINE + '=' + this.controller.getMachineID();
            sParms += '&' + DiskAPI.QUERY.USER + '=' + this.controller.getUserID();
            let sDiskURL = WebLib.getHostOrigin() + DiskAPI.ENDPOINT + '?' + sParms;
            WebLib.getResource(sDiskURL, null, true);
            this.fRemote = false;
        }
    }

    /**
     * queueDirtySector(sector, fAsync)
     *
     * Mark the specified sector as dirty, add it to the queue (aDirtySectors) if not already added,
     * and establish a timeout handler (findDirtySectors) if not already established.
     *
     * A freshly dirtied sector should sit in the queue for a short period of time (eg, 2 seconds)
     * before we attempt to write it; that is, a REMOTE_WRITE_DELAY timer should start ticking again
     * for any sector that is rewritten.  However, there will be exceptions; for example, when a sector
     * is finally written, we want to take advantage of the write request to write any additional dirty
     * sectors that follow it, even if those additional sectors were written less than 2 seconds ago.
     *
     * @this {Disk}
     * @param {Sector} sector
     * @param {boolean} fAsync (true to update write timer, false to not)
     * @returns {boolean} true if write timer set, false if not
     */
    queueDirtySector(sector, fAsync)
    {
        sector.fDirty = true;

        let j = this.aDirtySectors.indexOf(sector);
        if (j >= 0) {
            this.aDirtySectors.splice(j, 1);
            this.aDirtyTimestamps.splice(j, 1);
        }
        this.aDirtySectors.push(sector);
        this.aDirtyTimestamps.push(Component.getTime());

        this.printf(MESSAGE.DEBUG, "queueDirtySector(CHS=%d:%d:%d): %d dirty\n", sector[Disk.SECTOR.CYLINDER], sector[Disk.SECTOR.HEAD], sector[Disk.SECTOR.ID], this.aDirtySectors.length);

        return fAsync && this.updateWriteTimer();
    }

    /**
     * updateWriteTimer()
     *
     * If a timer is already active, make sure it's still valid (ie, the time the timer is scheduled to fire is
     * >= the timestamp of the next dirty sector + REMOTE_WRITE_DELAY); if not, cancel the timer and start a new one.
     *
     * @this {Disk}
     * @returns {boolean} true if write timer set, false if not
     */
    updateWriteTimer()
    {
        if (this.aDirtySectors.length) {
            let msWrite = this.aDirtyTimestamps[0] + Disk.REMOTE_WRITE_DELAY;
            if (this.timerWrite) {
                if (this.msTimerWrite < msWrite) {
                    clearTimeout(this.timerWrite);
                    this.timerWrite = null;
                }
            }
            if (!this.timerWrite) {
                let obj = this;
                let msNow = Component.getTime();
                let msDelay = msWrite - msNow;
                if (msDelay < 0) msDelay = 0;
                if (msDelay > Disk.REMOTE_WRITE_DELAY) msDelay = Disk.REMOTE_WRITE_DELAY;
                this.timerWrite = setTimeout(function() {
                    obj.findDirtySectors(true);
                }, msDelay);
                this.msTimerWrite = msNow + msDelay;
            }
        } else {
            if (this.timerWrite) {
                clearTimeout(this.timerWrite);
                this.timerWrite = null;
            }
        }
        return this.timerWrite !== null;
    }

    /**
     * findDirtySectors(fAsync)
     *
     * Starting with the oldest dirty sector in the queue (aDirtySectors), determine the longest contiguous stretch of
     * dirty sectors (currently limited to the same track), mark them all as not dirty, and then call writeRemoteSectors().
     *
     * @this {Disk}
     * @param {boolean} fAsync is true if this function is being called asynchronously, false otherwise
     * @returns {boolean|Array} false if no dirty sectors, otherwise true (or a response array if not fAsync)
     */
    findDirtySectors(fAsync)
    {
        if (fAsync) {
            this.timerWrite = null;
        }
        let sector = this.aDirtySectors[0];
        if (sector) {
            let iCylinder = sector[Disk.SECTOR.CYLINDER];
            let iHead = sector[Disk.SECTOR.HEAD];
            let iSector = sector[Disk.SECTOR.ID];
            let nSectors = 0;
            let abSectors = [];
            for (let i = iSector - 1; i < this.diskData[iCylinder][iHead].length; i++) {
                let sectorNext = this.diskData[iCylinder][iHead][i];
                if (!sectorNext.fDirty) break;
                let j = this.aDirtySectors.indexOf(sectorNext);

                this.printf(MESSAGE.DEBUG, "findDirtySectors(CHS=%d:%d:%d)\n", iCylinder, iHead, sectorNext[Disk.SECTOR.ID]);
                this.aDirtySectors.splice(j, 1);
                this.aDirtyTimestamps.splice(j, 1);
                abSectors = abSectors.concat(this.toBytes(sectorNext));
                sectorNext.fDirty = false;
                nSectors++;
            }

            let response = this.writeRemoteSectors(iCylinder, iHead, iSector, nSectors, abSectors, fAsync);
            return fAsync || response;
        }
        return false;
    }

    /**
     * info()
     *
     * @this {Disk}
     * @returns {Array} containing: [nCylinders, nHeads, nSectorsPerTrack, nBytesPerSector]
     */
    info()
    {
        if (!this.diskData.length) {
            return [0, 0, 0, 0];
        }
        return [this.diskData.length, this.diskData[0].length, this.diskData[0][0].length, this.diskData[0][0][0][Disk.SECTOR.LENGTH]];
    }

    /**
     * seek(iCylinder, iHead, iSector, sectorPrev, fWrite, done)
     *
     * TODO: There's some dodgy code in seek() that allows floppy images to be dynamically
     * reconfigured with more heads and/or sectors/track, and it does so by peeking at more drive
     * properties.  That code used to be in the FDC component, where it was perfectly reasonable
     * to access those properties.  We need a cleaner interface back to the drive, similar to the
     * info() interface we provide to the controller.
     *
     * Whether or not the "dynamic reconfiguration" feature itself is perfectly reasonable is,
     * of course, a separate question.
     *
     * @this {Disk}
     * @param {number} iCylinder
     * @param {number} iHead
     * @param {number} iSector
     * @param {Sector|null} [sectorPrev]
     * @param {boolean} [fWrite]
     * @param {function(Sector,boolean)} [done]
     * @returns {Sector|null} is the requested sector, or null if not found (or not available yet)
     */
    seek(iCylinder, iHead, iSector, sectorPrev, fWrite, done)
    {
        let sector = null;
        let drive = this.drive;
        let cylinder = this.diskData[iCylinder];
        if (cylinder) {
            let i;
            let track = cylinder[iHead];
            /**
             * The following code allows a single-sided diskette image to be reformatted (ie, "expanded")
             * as a double-sided image, provided the drive has more than one head (see drive.nHeads).
             *
             * NOTE: Strangely, we must ignore the number of drive heads both here and in doFormat(); otherwise,
             * PC DOS 1.10 "FORMAT /1" will fail.  Even though "/1" means format as a single-sided diskette, FORMAT
             * still attempts to format the first track with head 1.
             */
            if (!track && drive.bFormatting && iHead < 2 /* drive.nHeads */) {
                track = new Array(drive.bSectorEnd);
                for (i = 0; i < track.length; i++) {
                    track[i] = this.initSector(null, iCylinder, iHead, i + 1, drive.nBytes, 0);
                }
                /**
                 * TODO: This is more dodginess, because we can't be certain that every cylinder on the disk
                 * will receive the same "expanded" treatment, but functions like getSector() rely on instance
                 * properties (eg, this.nHeads), on the assumption that the disk's geometry is homogeneous.
                 */
                if (iHead < drive.nHeads) {
                    cylinder[iHead] = track;
                    this.nHeads = iHead + 1;
                }
            }
            if (track) {
                for (i = 0; i < track.length; i++) {
                    if (track[i] && track[i][Disk.SECTOR.ID] == iSector) {
                        sector = track[i];
                        /**
                         * When confronted with a series of sectors with the same sector ID (as found, for example, on
                         * the 1984 King's Quest copy-protected diskette), we're supposed to advance to another sector in
                         * the series.  So if the current sector matches the previous sector, we'll peek at the next sector
                         * (if any), and if it has the same sector ID, then we'll choose that sector instead.
                         */
                        if (sectorPrev && sectorPrev == sector) {
                            let j = i, sectorNext;
                            while (true) {
                                if (++j >= track.length) j = 0;
                                sectorNext = track[j];
                                if (!sectorNext || sectorNext == sector) break;
                                if (sectorNext[Disk.SECTOR.ID] == iSector) {
                                    sector = sectorNext;
                                    i = j;
                                    break;
                                }
                            }
                        }
                        /**
                         * If the sector's pattern is null, then this sector's true contents have not yet
                         * been fetched from the server.
                         */
                        if (sector[Disk.SECTOR.PATTERN] === null) {
                            if (fWrite) {
                                /**
                                 * Optimization: if the caller has explicitly told us that they're about to WRITE to the
                                 * sector, then we shouldn't need to read it from the server; assume a zero pattern and return.
                                 */
                                sector[Disk.SECTOR.PATTERN] = 0;
                            } else {
                                let nSectors = 1;
                                /**
                                 * We know we need to read at least 1 sector, but let's count the number of trailing sectors
                                 * on the same track that may also be required.
                                 */
                                while (++i < track.length) {
                                    if (track[i][Disk.SECTOR.PATTERN] === null) nSectors++;
                                }
                                this.readRemoteSectors(iCylinder, iHead, iSector, nSectors, done != null, function onReadRemoteComplete(err, fAsync) {
                                    if (err) sector = null;
                                    if (done) { //noinspection JSReferencingMutableVariableFromClosure
                                        done(sector, fAsync);
                                    }
                                });
                                return done? null : sector;
                            }
                        }
                        break;
                    }
                }
                /**
                 * The following code allows an 8-sector track to be reformatted (ie, "expanded") as a 9-sector track.
                 */
                if (!sector && drive.bFormatting && drive.bSector == 9) {
                    sector = track[i] = this.initSector(null, iCylinder, iHead, drive.bSector, drive.nBytes, 0);
                    /**
                     * TODO: This is more dodginess, because we can't be certain that every track on the disk
                     * will receive the same "expanded" treatment, but functions like getSector() rely on instance
                     * properties (eg, this.nSectors), on the assumption that the disk's geometry is homogeneous.
                     */
                    if (this.nSectors < drive.bSector) this.nSectors = drive.bSector;
                }
            }
        }
        if (done) done(sector, false);
        this.addModuleInfo(sector);
        return sector;
    }

    /**
     * fill(sector, ab, off)
     *
     * @this {Disk}
     * @param {Sector} sector
     * @param {*} ab (technically, this should be typed as Array.<number> but I'm having trouble coercing JSON.parse() to that)
     * @param {number} off
     */
    fill(sector, ab, off)
    {
        let cdw = sector[Disk.SECTOR.LENGTH] >> 2;
        let adw = new Array(cdw);
        for (let idw = 0; idw < cdw; idw++) {
            adw[idw] = ab[off] | (ab[off + 1] << 8) | (ab[off + 2] << 16) | (ab[off + 3] << 24);
            off += 4;
        }
        sector[Disk.SECTOR.DATA] = adw;
        /**
         * TODO: Consider taking this opportunity to shrink DATA down by the number of dwords at the end of the buffer that
         * contain the same pattern, and setting dwPattern accordingly.
         */
    }

    /**
     * toBytes(sector)
     *
     * @this {Disk}
     * @param {Sector} sector
     * @returns {Array.<number>} is an array of bytes
     */
    toBytes(sector)
    {
        let cb = sector[Disk.SECTOR.LENGTH];
        let ab = new Array(cb);
        let ib = 0;
        let cdw = cb >> 2;
        let adw = sector[Disk.SECTOR.DATA];
        let dwPattern = sector[Disk.SECTOR.PATTERN];
        for (let idw = 0; idw < cdw; idw++) {
            let dw = (idw < adw.length? adw[idw] : dwPattern);
            ab[ib++] = dw & 0xff;
            ab[ib++] = (dw >> 8) & 0xff;
            ab[ib++] = (dw >> 16) & 0xff;
            ab[ib++] = (dw >> 24) & 0xff;
        }
        return ab;
    }

    /**
     * read(sector, iByte, fCompare)
     *
     * @this {Disk}
     * @param {Sector} sector (returned from a previous seek)
     * @param {number} iByte (byte index within the given sector)
     * @param {boolean} [fCompare] is true if this write-compare read
     * @returns {number} the specified (unsigned) byte, or -1 if no more data in the sector
     */
    read(sector, iByte, fCompare)
    {
        let b = -1;
        if (sector) {
            if (DEBUG && !iByte && !fCompare) {
                this.printf(MESSAGE.DISK + MESSAGE.ADDR, "read(\"%s\",CHS=%d:%d:%d): %s\n", this.sDiskFile, sector[Disk.SECTOR.CYLINDER], sector[Disk.SECTOR.HEAD], sector[Disk.SECTOR.ID], this.getFileInfo(sector));
            }
            if (iByte < sector[Disk.SECTOR.LENGTH]) {
                let adw = sector[Disk.SECTOR.DATA];
                let idw = iByte >> 2;
                let dw = (idw < adw.length ? adw[idw] : sector[Disk.SECTOR.PATTERN]);
                b = ((dw >> ((iByte & 0x3) << 3)) & 0xff);
            }
        }
        return b;
    }

    /**
     * write(sector, iByte, b)
     *
     * @this {Disk}
     * @param {Sector} sector (returned from a previous seek)
     * @param {number} iByte (byte index within the given sector)
     * @param {number} b the byte value to write
     * @returns {boolean|null} true if write successful, false if write-protected, null if out of bounds
     */
    write(sector, iByte, b)
    {
        if (this.fWriteProtected) {
            return false;
        }

        if (DEBUG && !iByte) {
            this.printf(MESSAGE.DISK + MESSAGE.ADDR, "write(\"%s\",CHS=%d:%d:%d)\n", this.sDiskFile, sector[Disk.SECTOR.CYLINDER], sector[Disk.SECTOR.HEAD], sector[Disk.SECTOR.ID]);
        }

        if (iByte < sector[Disk.SECTOR.LENGTH]) {
            if (b != this.read(sector, iByte, true)) {
                let adw = sector[Disk.SECTOR.DATA];
                let dwPattern = sector[Disk.SECTOR.PATTERN];
                let idw = iByte >> 2;
                let nShift = (iByte & 0x3) << 3;

                /**
                 * Ensure every byte up to the specified byte is properly initialized.
                 */
                for (let i = adw.length; i <= idw; i++) adw[i] = dwPattern;

                if (!sector.cModify) {
                    sector.iModify = idw;
                    sector.cModify = 1;
                } else if (idw < sector.iModify) {
                    sector.cModify += sector.iModify - idw;
                    sector.iModify = idw;
                } else if (idw >= sector.iModify + sector.cModify) {
                    sector.cModify += idw - (sector.iModify + sector.cModify) + 1;
                }
                adw[idw] = (adw[idw] & ~(0xff << nShift)) | (b << nShift);

                if (this.fRemote) this.queueDirtySector(sector, true);
            }
            return true;
        }
        return null;
    }

    /**
     * encodeAsBase64()
     *
     * @this {Disk}
     * @returns {string}
     */
    encodeAsBase64()
    {
        let s = "", lba = 0, sector;
        /**
         * Gross, but simple; more importantly, it works -- at least for disks of typical floppy magnitude.
         */
        while ((sector = this.getSector(lba++))) {
            for (let off = 0, len = sector[Disk.SECTOR.LENGTH]; off < len; off++) {
                s += String.fromCharCode(this.getSectorData(sector, off, 1));
            }
        }
        return btoa(s);
    }

    /**
     * encodeAsBinary()
     *
     * @this {Disk}
     * @returns {Uint8Array}
     */
    encodeAsBinary() {
        let s = [], lba = 0, sector;
        while ((sector = this.getSector(lba++))) {
            for (let off = 0, len = sector[Disk.SECTOR.LENGTH]; off < len; off++) {
                s.push(this.getSectorData(sector, off, 1));
            }
        }
        return new Uint8Array(s);
    }

    /**
     * save()
     *
     * The first array entry contains some disk information:
     *
     *      [sDiskPath, dwChecksum, nCylinders, nHeads, nSectors, cbSector]
     *
     * Each subsequent entry in the returned array contains the following:
     *
     *      [iCylinder, iHead, iSector, iModify, [...]]
     *
     * where [...] is an array of modified dword(s) in the corresponding sector.
     *
     * @this {Disk}
     * @returns {Array} of modified sectors
     */
    save()
    {
        let i = 0;
        let deltas = [];
        deltas[i++] = [this.sDiskPath, this.dwChecksum, this.nCylinders, this.nHeads, this.nSectors, this.cbSector];
        if (!this.fRemote && !this.fWriteProtected) {
            let diskData = this.diskData;
            for (let iCylinder = 0; iCylinder < diskData.length; iCylinder++) {
                for (let iHead = 0; iHead < diskData[iCylinder].length; iHead++) {
                    for (let iSector = 0; iSector < diskData[iCylinder][iHead].length; iSector++) {
                        let sector = diskData[iCylinder][iHead][iSector];
                        if (sector && sector.cModify) {
                            let mods = [], n = 0;
                            let iModify = sector.iModify, iModifyLimit = sector.iModify + sector.cModify;
                            while (iModify < iModifyLimit) {
                                mods[n++] = sector[Disk.SECTOR.DATA][iModify++];
                            }
                            deltas[i++] = [iCylinder, iHead, iSector, sector.iModify, mods];
                        }
                    }
                }
            }
        }
        this.printf(MESSAGE.DEBUG, "save(\"%s\"): saved %d change(s)\n", this.sDiskName, (deltas.length - 1));
        return deltas;
    }

    /**
     * restore(deltas)
     *
     * The first array entry contains some disk information:
     *
     *      [sDiskPath, dwChecksum, nCylinders, nHeads, nSectors, cbSector]
     *
     * Each subsequent entry in the supplied array contains the following:
     *
     *      [iCylinder, iHead, iSector, iModify, [...]]
     *
     * where [...] is an array of modified dword(s) in the corresponding sector.
     *
     * @this {Disk}
     * @param {Array} deltas
     * @returns {number} 0 if no changes applied, -1 if an error occurred, otherwise the number of sectors modified
     */
    restore(deltas)
    {
        /**
         * If deltas is undefined, that's not necessarily an error;  the controller may simply be (re)initializing
         * itself (although neither controller should be calling restore() under those conditions anymore).
         */
        let nChanges = 0;
        let sReason = "unsupported restore format";
        /**
         * I originally added a check for diskData here on the assumption that if there was an error loading
         * a disk image, we will have already notified the user, so any additional errors about differing checksums,
         * failure to restore the disk state, etc, would just be annoying.  HOWEVER, HDC will create an empty disk
         * image if its initialization code discovers that no disk was loaded earlier (see verifyDrive).  So while
         * checking diskData is still a good idea, be aware that it won't necessarily avoid redundant error messages
         * (at least in the case of HDC).
         */
        if (deltas && deltas.length > 0) {

            let i = 0;
            let aDiskInfo = deltas[i++];

            if (aDiskInfo && aDiskInfo.length >= 2) {
                /**
                 * Before getting to the checksum, we have to deal with a new situation: restoring an uninitialized
                 * disk image from a complete set of deltas.  And that is only possible if the disk was saved with the
                 * original disk geometry.
                 */
                if (!this.diskData.length && aDiskInfo.length >= 6) {
                    this.create(DiskAPI.MODE.LOCAL, aDiskInfo[2], aDiskInfo[3], aDiskInfo[4], aDiskInfo[5]);
                    /**
                     * TODO: Consider setting a flag here that we can check at the end of the restore() function
                     * that indicates we should recalculate dwChecksum, because we currently have an inconsistency
                     * between local disks that are mounted via buildDisk() and the same disks that are "remounted"
                     * later by this code; the former has the correct checksum, while the latter has a null checksum.
                     *
                     * As you can see below, we currently deal with this by simply ignoring null checksums....
                     */
                }
                /**
                 * v1.01 failed to indicate an error if either one of these failure conditions occurred.  Although maybe
                 * that's just as well, since v1.01 also failed to properly deal with situations where the user mounted
                 * different diskette(s) prior to exiting (hopefully fixed in v1.02).
                 *
                 * UPDATE: We also check aDiskInfo[0] first, because if it's null, then presumably there was no previous
                 * disk, and I'd like the addition of a disk to a machine to not be fatal to the restoration process.
                 */
                else if (aDiskInfo[0] != null) {
                    if (aDiskInfo[1] != null && this.dwChecksum != null && aDiskInfo[1] != this.dwChecksum) {
                        sReason = "original checksum (" + aDiskInfo[1] + ") differs from current checksum (" + this.dwChecksum + ")";
                        nChanges = -2;
                    }
                    /**
                     * Checksum is more important than disk path, and for now, I want the flexibility to move disk images.
                     *
                     *  else if (aDiskInfo[0] != this.sDiskPath) {
                     *      sReason = "original path '" + aDiskInfo[0] + "' differs from current path '" + this.sDiskPath + "'";
                     *      nChanges = -1;
                     *  }
                     */
                }
            }

            if (!this.diskData.length) nChanges = -1;

            while (i < deltas.length && nChanges >= 0) {
                let m = 0;
                let mod = deltas[i++];
                let iCylinder = mod[m++];
                let iHead = mod[m++];
                let iSector = mod[m++];
                /**
                 * Note the buried test for write-protection.  Yes, an invariant condition should be tested
                 * outside the loop, not inside, but (a) it's a trivial test, (b) the test should never fail
                 * because save() should never generate any mods for a write-protected disk, and (c) it
                 * centralizes all the failure conditions we're currently checking (which, admittedly, ain't much).
                 */
                if (iCylinder >= this.diskData.length || iHead >= this.diskData[iCylinder].length || iSector >= this.diskData[iCylinder][iHead].length) {
                    sReason = "sector (CHS=" + iCylinder + ':' + iHead + ':' + iSector + ") out of range (" + nChanges + " changes applied)";
                    nChanges = -1;
                    break;
                }
                if (this.fWriteProtected) {
                    sReason = "unable to modify write-protected disk";
                    nChanges = -1;
                    break;
                }
                let iModify = mod[m++];
                let mods = mod[m++];
                let iModifyLimit = iModify + mods.length;
                let sector = this.diskData[iCylinder][iHead][iSector];
                if (!sector) continue;
                /**
                 * Since write() now deals with empty/partial sectors, we no longer need to completely "inflate"
                 * the sector prior to applying modifications.  So let's just make sure that the sector is "inflated"
                 * up to iModify.
                 */
                let idw = sector[Disk.SECTOR.DATA].length;
                while (idw < iModify) {
                    sector[Disk.SECTOR.DATA][idw++] = sector[Disk.SECTOR.PATTERN];
                }
                let n = 0;
                sector.iModify = iModify;
                sector.cModify = mods.length;
                while (iModify < iModifyLimit) {
                    sector[Disk.SECTOR.DATA][iModify++] = mods[n++];
                }
                nChanges++;
            }
        }

        if (nChanges < 0) {
            /**
             * We're suppressing checksum messages for the general public for now....
             */
            if (DEBUG || nChanges != -2) {
                this.printf(MESSAGE.NOTICE, "Unable to restore disk \"%s\": %s\n", this.sDiskName, sReason);
            }
        } else {
            this.printf(MESSAGE.DEBUG, "restore(\"%s\"): restored %d change(s)\n", this.sDiskName, nChanges);
            /**
             * Last but not least, rebuild the disk's file table if BACKTRACK or SYMBOLS support is enabled.
             */
            if (BACKTRACK || SYMBOLS) this.buildFileTable();
        }
        return nChanges;
    }

    /**
     * convertToJSON(fFormatted)
     *
     * We perform some RegExp massaging on the JSON data to eliminate (old) unnecessary properties
     * (eg, 'length' values of 512, empty 'data' arrays), since those were defaults.
     *
     * In addition, we first check every sector to see if it can be "deflated".  Sectors that were
     * initially "deflated" should remain that way unless/until they were modified, so technically,
     * we could call deflateSector() just for modified sectors, but this isn't a common operation,
     * so it doesn't hurt to check every sector.
     *
     * @this {Disk}
     * @param {boolean} [fFormatted]
     * @returns {string} containing the entire disk image as JSON-encoded data
     */
    convertToJSON(fFormatted)
    {
        let s, lba = 0, sector, sectorLast;

        while ((sector = this.getSector(lba++))) {
            this.deflateSector(sector);
        }

        s = JSON.stringify(this.diskData, function(key, value) {
            /**
             * If BACKTRACK support is enabled, we have to filter out any 'file' properties that may
             * be attached to the sector objects, lest we risk blowing the stack due to circular references.
             */
            if (key == 'file') {
                return undefined;
            }
            return value;
        });

        /**
         * Eliminate old default properties (eg, 'length' values of 512, empty 'data' arrays, etc).
         */
        s = s.replace(/,"length":512/g, "").replace(/,"data":\[]/g, "");

        /**
         * I don't really want to strip quotes from disk image property names, since I would have to put them
         * back again during mount() -- or whenever JSON.parse() is used instead of eval().  But I still remove
         * them temporarily, so that any remaining property names (eg, "iModify", "cModify", "fDirty") can
         * easily be stripped out, by virtue of their being the only quoted properties left.  We then "requote"
         * all the property names that remain.
         */
        s = s.replace(/"(c|h|s|l|d|sector|length|data|pattern)":/g, "$1:");

        /**
         * The next line will remove any other numeric or boolean properties that were added at runtime, although
         * they may have completely different ("minified") names if the code has been compiled.
         */
        s = s.replace(/,"[^"]*":([0-9]+|true|false)/g, "");
        s = s.replace(/(c|h|s|l|d|sector|length|data|pattern):/g, "\"$1\":");

        /**
         * Last but not least, insert line breaks after every object definition, to improve human readability
         * (but only if the caller asks for it).
         */
        if (fFormatted) s = s.replace(/([\]}]),/g, "$1,\n");
        return s;
    }

    /**
     * deflateSector(sector)
     *
     * This is just the first revision: it currently looks only at fully inflated sectors.
     *
     * @this {Disk}
     * @param {Sector} sector
     */
    deflateSector(sector)
    {
        let adw = sector[Disk.SECTOR.DATA];
        let cdw = adw.length;
        if ((cdw << 2) == sector[Disk.SECTOR.LENGTH]) {
            let idw = cdw - 1;
            let dwPattern = adw[idw], cDupes = 0;
            while (idw--) {
                if (adw[idw] !== dwPattern) break;
                cDupes++;
            }
            if (cDupes++) {
                adw.length = cdw - cDupes;
                sector[Disk.SECTOR.PATTERN] = dwPattern;
            }
        }
    }

    /**
     * dumpSector(sector, lba, sDesc)
     *
     * @this {Disk}
     * @param {Sector|null} sector (returned from a previous seek)
     * @param {number} [lba]
     * @param {string} [sDesc]
     * @returns {string}
     */
    dumpSector(sector, lba, sDesc)
    {
        let sDump = "";
        if (DEBUG && sector) {
            if (lba != null) sDump += "sector " + lba + (sDesc? (" for " + sDesc) : "") + ':';
            let sBytes = "", sChars = "";
            let cbSector = sector[Disk.SECTOR.LENGTH];
            let cdwData = sector[Disk.SECTOR.DATA].length;
            let dw = 0;
            for (let i = 0; i < cbSector; i++) {
                if ((i % 16) === 0) {
                    if (sDump) sDump += sBytes + ' ' + sChars + '\n';
                    sDump += StrLib.toHex(i, 4) + ": ";
                    sBytes = sChars = "";
                }
                if ((i % 4) === 0) {
                    let idw = i >> 2;
                    dw = (idw < cdwData? sector[Disk.SECTOR.DATA][idw] : sector[Disk.SECTOR.PATTERN]);
                }
                let b = dw & 0xff;
                dw >>>= 8;
                sBytes += StrLib.toHex(b, 2) + (i % 16 == 7? "-" : " ");
                sChars += (b >= 32 && b < 128? String.fromCharCode(b) : ".");
            }
            if (sBytes) sDump += sBytes + ' ' + sChars;
        }
        return sDump;
    }
}

/**
 * @class FileInfo
 * @unrestricted (allows the class to define properties, both dot and named, outside of the constructor)
 */
class FileInfo {
    /**
     * FileInfo(disk, path, name, attr, size, module)
     *
     * @this {FileInfo}
     * @param {Disk} disk
     * @param {string} path
     * @param {string} name
     * @param {number} attr
     * @param {number} size
     * @param {Object} [module]
     */
    constructor(disk, path, name, attr, size, module)
    {
        this.disk = disk;
        this.path = path;
        this.name = name;
        this.attr = attr;
        this.size = size;
        this.module = module;
    }

    /**
     * getSymbol(off, fNearest)
     *
     * @this {FileInfo}
     * @param {number} off (offset relative to start of file)
     * @param {boolean} [fNearest] (true to return nearest symbol if a segment with symbols is found)
     * @returns {string} symbol corresponding to file offset (of the file name + offset if no symbol found)
     */
    getSymbol(off, fNearest)
    {
        let sSymbol = null;
        if (this.module) {
            let segments = this.module['segments'];
            for (let seg in segments) {
                let segment = segments[seg];
                if (off >= segment['offStart'] && off <= segment['offEnd']) {
                    /**
                     * This is the one and only segment we need to check, so we can make off segment-relative now.
                     */
                    off -= segment['offStart'];
                    let cbNearest = off, entryNearest;
                    /**
                     * To support fNearest, save the entry where (off - entry[0]) yields the smallest positive result.
                     */
                    for (let ord in segment['ordinals']) {
                        let entry = segment['ordinals'][ord];
                        let cb = off - entry['o'];
                        if (!cb) {
                            sSymbol = this.module['name'] + '!' + entry['s'];
                            break;
                        }
                        if (fNearest && cb > 0 && cb < cbNearest) {
                            entryNearest = entry;
                            cbNearest = cb;
                        }
                    }
                    if (!sSymbol && entryNearest) {
                        sSymbol = this.module['name'] + '!' + entryNearest[1] + "+" + StrLib.toHex(cbNearest, 0, true);
                    }
                    break;
                }
            }
        }
        return sSymbol || this.name + '+' + StrLib.toHex(off, 0, true);
    }
}

/**
 * @copyright https://www.pcjs.org/machines/pcx86/modules/v2/fdc.js (C) 2012-2024 Jeff Parsons
 */

/**
 * FDC Terms (see FDC.TERMS)
 *
 *      C       Cylinder Number         the current or selected cylinder number
 *
 *      D       Data                    the data pattern to be written to a sector
 *
 *      DS      Drive Select            the selected driver number encoded the same as bits 0 and 1 of the Digital Output
 *                                      Register (DOR); eg, DS0, DS1, DS2, or DS3
 *
 *      DTL     Data Length             when N is 00, DTL is the data length to be read from or written to a sector
 *
 *      EOT     End Of Track            the final sector number on a cylinder
 *
 *      GPL     Gap Length              the length of gap 3 (spacing between sectors excluding the VCO synchronous field)
 *
 *      H       Head Address            the head number, either 0 or 1, as specified in the ID field
 *
 *      HD      Head                    the selected head number, 0 or 1 (H = HD in all command words)
 *
 *      HLT     Head Load Time          the head load time in the selected drive (2 to 256 milliseconds in 2-millisecond
 *                                      increments for the 1.2M-byte drive and 4 to 512 milliseconds in 4 millisecond increments
 *                                      for the 320K-byte drive)
 *
 *      HUT     Head Unload Time        the head unload time after a read or write operation (0 to 240 milliseconds in
 *                                      16-millisecond increments for the 1.2M-byte drive and 0 to 480 milliseconds in
 *                                      32-millisecond increments for the 320K-byte drive)
 *
 *      MF      FM or MFM Mode          0 selects FM mode and 1 selects MFM (MFM is selected only if it is implemented)
 *
 *      MT      Multitrack              1 selects multitrack operation (both HD0 and HD1 will be read or written)
 *
 *      N       Number                  the number of data bytes written in a sector
 *
 *      NCN     New Cylinder Number     the new cylinder number for a SEEK operation
 *
 *      ND      Non-Data Mode           indicates an operation in the non-data mode
 *
 *      PCN     Present Cylinder Number the cylinder number at the completion of a SENSE INTERRUPT STATUS command
 *                                      (present position of the head)
 *
 *      R       Record                  the sector number to be read or written
 *
 *      SC      Sectors Per Cylinder    the number of sectors per cylinder
 *
 *      SK      Skip                    this stands for skip deleted-data address mark
 *
 *      SRT     Stepping Rate           this 4 bit byte indicates the stepping rate for the diskette drive as follows:
 *                                      1.2M-Byte Diskette Drive: 1111=1ms, 1110=2ms, 1101=3ms
 *                                      320K-Byte Diskette Drive: 1111=2ms, 1110=4ms, 1101=6ms
 *
 *      STP     STP Scan Test           if STP is 1, the data in contiguous sectors is compared with the data sent
 *                                      by the processor during a scan operation; if STP is 2, then alternate sections
 *                                      are read and compared
 */

/** @typedef {{ name: string, path: string }} */
let DiskImage;

/** @typedef {{ heads: number, tracks: number, boot: boolean }} */
let DriveType;

 /** @typedef {{ iDrive: number, name: string, nCylinders: number, nHeads: number, nSectors: number, cbSector: number, fBusy: boolean, fLocal: boolean, fBootable: boolean, fRemovable: boolean, fWritable: boolean, nDiskCylinders: number, nDiskHeads: number, nDiskSectors: number, bHead: number, bCylinder: number, bCylinderSeek: number, bSector: number, bSectorEnd: number, nBytes: number, iByte: number }} */
let DriveInfo;

/**
 * @class FDC
 * @property {Array.<DriveInfo>} aDrives
 * @property {Array.<DriveType>|null} aDriveTypes
 * @unrestricted (allows the class to define properties, both dot and named, outside of the constructor)
 */
class FDC extends Component {

    static DEFAULT_DRIVE_NAME = "Floppy Drive";

    static TERMS = {
        C:   "C",       // Cylinder Number
        D:   "D",       // Data (eg, pattern to be written to a sector)
        H:   "H",       // Head Address
        R:   "R",       // Record (ie, sector number to be read or written)
        N:   "N",       // Number (ie, number of data bytes to write)
        DS:  "DS",      // Drive Select
        SC:  "SC",      // Sectors per Cylinder
        DTL: "DTL",     // Data Length
        EOT: "EOT",     // End of Track
        GPL: "GPL",     // Gap Length
        HLT: "HLT",     // Head Load Time
        NCN: "NCN",     // New Cylinder Number
        PCN: "PCN",     // Present Cylinder Number
        SRT: "SRT",     // Stepping Rate
        ST0: "ST0",     // Status Register 0
        ST1: "ST1",     // Status Register 1
        ST2: "ST2",     // Status Register 2
        ST3: "ST3"      // Status Register 3
    };

    /**
     * FDC Digital Output Register (DOR) (0x3F2, write-only)
     *
     * NOTE: Reportedly, a drive's MOTOR had to be ON before the drive could be selected; however, outFDCOutput() no
     * longer verifies that.  Also, motor start time for original drives was 500ms, but we make no attempt to simulate that.
     *
     * On the MODEL_5170 "PC AT Fixed Disk and Diskette Drive Adapter", this port is called the Digital Output Register
     * or DOR.  It uses the same bit definitions as the original FDC Output Register, except that only two diskette drives
     * are supported, hence bit 1 is always 0 (ie, FDC.REG_OUTPUT.DS2 and FDC.REG_OUTPUT.DS3 are not supported) and bits
     * 6 and 7 are unused (FDC.REG_OUTPUT.MOTOR_D2 and FDC.REG_OUTPUT.MOTOR_D3 are not supported).
     */
    static REG_OUTPUT = {
        PORT:      0x3F2,
        DS:         0x03,   // drive select bits
        DS0:        0x00,
        DS1:        0x01,
        DS2:        0x02,   // reserved on the MODEL_5170
        DS3:        0x03,   // reserved on the MODEL_5170
        ENABLE:     0x04,   // clearing this bit resets the FDC
        INT_ENABLE: 0x08,   // enables both FDC and DMA (Channel 2) interrupt requests (IRQ 6)
        MOTOR_D0:   0x10,
        MOTOR_D1:   0x20,
        MOTOR_D2:   0x40,   // reserved on the MODEL_5170
        MOTOR_D3:   0x80    // reserved on the MODEL_5170
    };

    /**
     * FDC Main Status Register (0x3F4, read-only)
     *
     * On the MODEL_5170 "PC AT Fixed Disk and Diskette Drive Adapter", bits 2 and 3 are reserved, since that adapter
     * supported a maximum of two diskette drives.
     */
    static REG_STATUS = {
        PORT:      0x3F4,
        BUSY_A:     0x01,
        BUSY_B:     0x02,
        BUSY_C:     0x04,   // reserved on the MODEL_5170
        BUSY_D:     0x08,   // reserved on the MODEL_5170
        BUSY:       0x10,   // a read or write command is in progress
        NON_DMA:    0x20,   // FDC is in non-DMA mode
        READ_DATA:  0x40,   // transfer is from FDC Data Register to processor (if clear, then transfer is from processor to the FDC Data Register)
        RQM:        0x80    // indicates FDC Data Register is ready to send or receive data to or from the processor (Request for Master)
    };

    /**
     * FDC Data Register (0x3F5, read-write)
     */
    static REG_DATA = {
        PORT:      0x3F5,
        /**
         * FDC Commands
         *
         * NOTE: FDC command bytes need to be masked with FDC.REG_DATA.CMD.MASK before comparing to the values below, since a
         * number of commands use the following additional bits as follows:
         *
         *      SK (0x20): Skip Deleted Data Address Mark
         *      MF (0x40): Modified Frequency Modulation (as opposed to FM or Frequency Modulation)
         *      MT (0x80): multi-track operation (ie, data processed under both head 0 and head 1)
         *
         * We don't support MT (Multi-Track) operations at this time, and the MF and SK designations cannot be supported as long
         * as our diskette images contain only the original data bytes without any formatting information.
         */
        CMD: {
            READ_TRACK:     0x02,
            SPECIFY:        0x03,
            SENSE_DRIVE:    0x04,
            WRITE_DATA:     0x05,
            READ_DATA:      0x06,
            RECALIBRATE:    0x07,
            SENSE_INT:      0x08,           // this command is used to clear the FDC interrupt following the clearing/setting of FDC.REG_OUTPUT.ENABLE
            WRITE_DEL_DATA: 0x09,
            READ_ID:        0x0A,
            READ_DEL_DATA:  0x0C,
            FORMAT_TRACK:   0x0D,
            SEEK:           0x0F,
            SCAN_EQUAL:     0x11,
            SCAN_LO_EQUAL:  0x19,
            SCAN_HI_EQUAL:  0x1D,
            MASK:           0x1F,
            SK:             0x20,           // SK (Skip Deleted Data Address Mark)
            MF:             0x40,           // MF (Modified Frequency Modulation)
            MT:             0x80            // MT (Multi-Track; ie, data under both heads will be processed)
        },
        /**
         * FDC status/error results, generally assigned according to the corresponding ST0, ST1, ST2 or ST3 status bit.
         *
         * TODO: Determine when EQUIP_CHECK is *really* set; also, "77 step pulses" sounds suspiciously like a typo (it's not 79?)
         */
        RES: {
            NONE:           0x00000000,     // ST0 (IC): Normal termination of command (NT)
            NOT_READY:      0x00000008,     // ST0 (NR): When the FDD is in the not-ready state and a read or write command is issued, this flag is set; if a read or write command is issued to side 1 of a single sided drive, then this flag is set
            EQUIP_CHECK:    0x00000010,     // ST0 (EC): If a fault signal is received from the FDD, or if the track 0 signal fails to occur after 77 step pulses (recalibrate command), then this flag is set
            SEEK_END:       0x00000020,     // ST0 (SE): When the FDC completes the Seek command, this flag is set to 1 (high)
            INCOMPLETE:     0x00000040,     // ST0 (IC): Abnormal termination of command (AT); execution of command was started, but was not successfully completed
            RESET:          0x000000C0,     // ST0 (IC): Abnormal termination because during command execution the ready signal from the drive changed state
            INVALID:        0x00000080,     // ST0 (IC): Invalid command issue (IC); command which was issued was never started
            ST0:            0x000000FF,
            NO_ID_MARK:     0x00000100,     // ST1 (MA): If the FDC cannot detect the ID Address Mark, this flag is set; at the same time, the MD (Missing Address Mark in Data Field) of Status Register 2 is set
            NOT_WRITABLE:   0x00000200,     // ST1 (NW): During Execution of a Write Data, Write Deleted Data, or Format a Cylinder command, if the FDC detects a write protect signal from the FDD, then this flag is set
            NO_DATA:        0x00000400,     // ST1 (ND): FDC cannot find specified sector (or specified ID if READ_ID command)
            DMA_OVERRUN:    0x00001000,     // ST1 (OR): If the FDC is not serviced by the main systems during data transfers within a certain time interval, this flag is set
            CRC_ERROR:      0x00002000,     // ST1 (DE): When the FDC detects a CRC error in either the ID field or the data field, this flag is set
            END_OF_CYL:     0x00008000,     // ST1 (EN): When the FDC tries to access a sector beyond the final sector of a cylinder, this flag is set
            ST1:            0x0000FF00,
            NO_DATA_MARK:   0x00010000,     // ST2 (MD): When data is read from the medium, if the FDC cannot find a Data Address Mark or Deleted Data Address Mark, then this flag is set
            BAD_CYL:        0x00020000,     // ST2 (BC): This bit is related to the ND bit, and when the contents of C on the medium are different from that stored in the ID Register, and the content of C is FF, then this flag is set
            SCAN_FAILED:    0x00040000,     // ST2 (SN): During execution of the Scan command, if the FDC cannot find a sector on the cylinder which meets the condition, then this flag is set
            SCAN_EQUAL:     0x00080000,     // ST2 (SH): During execution of the Scan command, if the condition of "equal" is satisfied, this flag is set
            WRONG_CYL:      0x00100000,     // ST2 (WC): This bit is related to the ND bit, and when the contents of C on the medium are different from that stored in the ID Register, this flag is set
            DATA_FIELD:     0x00200000,     // ST2 (DD): If the FDC detects a CRC error in the data, then this flag is set
            STRL_MARK:      0x00400000,     // ST2 (CM): During execution of the Read Data or Scan command, if the FDC encounters a sector which contains a Deleted Data Address Mark, this flag is set
            ST2:            0x00FF0000,
            DRIVE:          0x03000000,     // ST3 (Ux): Status of the "Drive Select" signals from the diskette drive
            HEAD:           0x04000000,     // ST3 (HD): Status of the "Side Select" signal from the diskette drive
            TWOSIDE:        0x08000000,     // ST3 (TS): Status of the "Two Side" signal from the diskette drive
            TRACK0:         0x10000000,     // ST3 (T0): Status of the "Track 0" signal from the diskette drive
            READY:          0x20000000,     // ST3 (RY): Status of the "Ready" signal from the diskette drive
            WRITEPROT:      0x40000000,     // ST3 (WP): Status of the "Write Protect" signal from the diskette drive
            FAULT:          0x80000000|0,   // ST3 (FT): Status of the "Fault" signal from the diskette drive
            ST3:            0xFF000000|0
        }
    };

    /**
     * FDC "Fixed Disk" Register (0x3F6, write-only)
     *
     * Since this register's functions are all specific to the Hard Drive Controller, see the HDC component for details.
     * The fact that this HDC register is in the middle of the FDC I/O port range is an oddity of the "HFCOMBO" controller.
     */

    /**
     * FDC Digital Input Register (0x3F7, read-only, MODEL_5170 only)
     *
     * Bit 7 indicates a diskette change (the MODEL_5170 introduced change-line support).  Bits 0-6 are for the selected
     * hard drive, so this port must be shared with the HDC; bits 0-6 are valid for 50 microseconds after a write to the
     * Drive Head Register.
     */
    static REG_INPUT = {
        PORT:      0x3F7,
        DS0:        0x01,   // Drive Select 0
        DS1:        0x02,   // Drive Select 1
        HS0:        0x04,   // Head Select 0
        HS1:        0x08,   // Head Select 1
        HS2:        0x10,   // Head Select 2
        HS3:        0x20,   // Head Select 3
        WRITE_GATE: 0x40,   // Write Gate
        DISK_CHANGE:0x80    // Diskette Change
    };

    /**
     * FDC Diskette Control Register (0x3F7, write-only, MODEL_5170 only)
     *
     * Only bits 0-1 are used; bits 2-7 are reserved.
     */
    static REG_CONTROL = {
        PORT:      0x3F7,
        RATE500K:   0x00,   // 500,000 bps
        RATE300K:   0x02,   // 300,000 bps
        RATE250K:   0x01,   // 250,000 bps
        RATEUNUSED: 0x03
    };

    /**
     * FDC Command Sequences
     *
     * For each command, cbReq indicates the total number of bytes in the command request sequence,
     * including the first (command) byte; cbRes indicates total number of bytes in the response sequence.
     */
    static CMDS = {
        READ_TRACK:   "READ TRACK",
        SPECIFY:      "SPECIFY",
        SENSE_DRIVE:  "SENSE DRIVE",
        WRITE_DATA:   "WRITE DATA",
        READ_DATA:    "READ DATA",
        RECALIBRATE:  "RECALIBRATE",
        SENSE_INT:    "SENSE INTERRUPT",
        READ_ID:      "READ ID",
        FORMAT:       "FORMAT",
        SEEK:         "SEEK"
    };

    static aCmdInfo = {
        0x02: {cbReq: 9, cbRes: 7, name: FDC.CMDS.READ_TRACK},
        0x03: {cbReq: 3, cbRes: 0, name: FDC.CMDS.SPECIFY},
        0x04: {cbReq: 2, cbRes: 1, name: FDC.CMDS.SENSE_DRIVE},
        0x05: {cbReq: 9, cbRes: 7, name: FDC.CMDS.WRITE_DATA},
        0x06: {cbReq: 9, cbRes: 7, name: FDC.CMDS.READ_DATA},
        0x07: {cbReq: 2, cbRes: 0, name: FDC.CMDS.RECALIBRATE},
        0x08: {cbReq: 1, cbRes: 2, name: FDC.CMDS.SENSE_INT},
        0x0A: {cbReq: 2, cbRes: 7, name: FDC.CMDS.READ_ID},
        0x0D: {cbReq: 6, cbRes: 7, name: FDC.CMDS.FORMAT},
        0x0F: {cbReq: 3, cbRes: 0, name: FDC.CMDS.SEEK}
    };

    static {
        /**
         * Port input notification table
         *
         * TODO: Even though port 0x3F7 was not present on controllers prior to MODEL_5170, I'm taking the easy
         * way out and always emulating it.  So, consider an FDC parameter to disable that feature for stricter compatibility.
         */
        FDC.aPortInput = {
            0x3F1: FDC.prototype.inFDCDiagnostic,
            0x3F4: FDC.prototype.inFDCStatus,
            0x3F5: FDC.prototype.inFDCData,
            0x3F7: FDC.prototype.inFDCInput
        };

        /**
         * Port output notification table
         *
         * TODO: Even though port 0x3F7 was not present on controllers prior to MODEL_5170, I'm taking the easy
         * way out and always emulating it.  So, consider an FDC parameter to disable that feature for stricter compatibility.
         */
        FDC.aPortOutput = {
            0x3F2: FDC.prototype.outFDCOutput,
            0x3F5: FDC.prototype.outFDCData,
            0x3F7: FDC.prototype.outFDCControl
        };
    }

    /**
     * FDC(parmsFDC)
     *
     * The FDC component simulates a NEC ÂµPD765A or Intel 8272A compatible floppy disk controller, and has one
     * component-specific property:
     *
     *      autoMount: one or more JSON-encoded objects, each containing 'name' and 'path' properties
     *      diskettes: an array of DiskImage objects, or the name of a JSON file containing disk descriptors
     *      server: name of the diskette server, if any
     *      drives: an array of DriveType objects, each containing 'heads', 'tracks', and 'boot' properties
     *      sortBy: "name" to sort disks by name, "path" to sort by path, or "none" to leave as-is (default is "name")
     *
     * Regarding early diskette drives: the IBM PC Model 5150 originally shipped with single-sided drives,
     * and therefore supported only 160Kb diskettes.  That's the only diskette format PC-DOS 1.00 supported, too.
     *
     * At some point, 5150's started shipping with double-sided drives, but I'm not sure whether the ROMs changed;
     * they probably did NOT change, because the original ROM BIOS already supported drives with multiple heads.
     * However, what the ROM BIOS did NOT do was provide any indication of drive type, which as far as I can tell,
     * meant you had to simply read/write/format tracks with the second head and check for errors.
     *
     * Presumably at the same time double-sided drives started shipping, PC-DOS 1.10 shipped, which added
     * support for 320Kb diskettes.  And the FORMAT command changed as well, defaulting to a double-sided format
     * operation UNLESS you specified "FORMAT /1".  If I run PC-DOS 1.10 and try to simulate a single-sided drive
     * (by setting drive.nHeads = 1 in initDrive), FORMAT will balk with "Track 0 bad - disk unusable".  I have to
     * wonder if everyone with single-sided drives who upgraded to PC-DOS 1.10 also got that error, forcing them
     * to always specify "FORMAT /1", or if I'm doing something wrong wrt single-sided drive simulation.
     *
     * I've noticed that if I turn FDC messages on ("m fdc on"), and then run "FORMAT B:/1", the command still
     * tries to format head 1/track 0, followed by head 0/track 0, and then the FDC is reset, and the format operation
     * proceeds with only head 0 for all tracks 0 through 39.  FORMAT successfully creates a 160Kb single-sided diskette,
     * but why it also tries to initially format track 0 using the second head remains a bit of a mystery.
     *
     * @this {FDC}
     * @param {Object} parmsFDC
     */
    constructor(parmsFDC)
    {
        /**
         * TODO: Indicate the type of diskette image being loaded (this might help folks understand what's going
         * on when they try to load a diskette image that's larger than what the selected operating system supports).
         */
        super("FDC", parmsFDC, MESSAGE.FDC);

        this['dmaRead'] = FDC.prototype.doDMARead;
        this['dmaWrite'] = FDC.prototype.doDMAWrite;
        this['dmaFormat'] = FDC.prototype.doDMAFormat;

        this.aDriveTypes = null;
        this.aDiskettes = parmsFDC['diskettes'];
        this.sDisketteServer = parmsFDC['server'] || "";

        /**
         * We don't eval() sDriveTypes until initBus() is called, so that we can check for any machine overrides;
         * note that the override, if any, must be named 'floppyDrives' to avoid conflicting with the HDC's 'drives'
         * setting.
         */
        this.sDriveTypes = parmsFDC['drives'];

        /**
         * We record any 'autoMount' object now, but we no longer parse it until initBus(), because the Computer's
         * getMachineParm() service may have an override for us.
         */
        this.configMount = this.parseMount(parmsFDC['autoMount']);

        /**
         * This establishes "name" as the default; if we decide we'd prefer "none" to be the default (ie, the order
         * to use when no sortBy value is specified), we can just drop the '|| "name"', because an undefined value is
         * just as falsy as null.
         *
         * The code that actually performs the sorting (in setBinding()) first checks that sortBy is not falsy, and
         * then assumes that the non-falsy value must be either "path" or "name", and since it explicitly checks for
         * "path" first, any nonsensical value will be treated as "name" (which is fine, since that's our current default).
         */
        this.sortBy = parmsFDC['sortBy'] || "name";
        if (this.sortBy == "none") this.sortBy = null;

        /**
         * The following array keeps track of every disk image we've ever mounted.  Each entry in the
         * array is another array whose elements are:
         *
         *      [0]: name of disk
         *      [1]: path of disk
         *      [2]: array of deltas, uninitialized until the disk is unmounted and/or all state is saved
         *
         * See functions addDiskHistory() and updateDiskHistory().
         */
        this.aDiskHistory = [];

        /**
         * Support for local disk images is currently limited to desktop browsers with FileReader support;
         * when this flag is set, setBinding() allows local disk bindings and informs initBus() to update the
         * "listDisks" binding accordingly.
         */
        this.fLocalDisks = (!WebLib.isMobile() && 'FileReader' in globals.window);

        /**
         * If the HDC component is configured for removable discs (ie, if it's configured as a CD-ROM drive),
         * it may prefer to overload our drive control for easier disc selection, in which case this will contain
         * drive name properties mapped to external disc lists.
         */
        this.driveActive = null;
        this.externalDrives = {};
        this.externalActive = null;

        /**
         * The remainder of FDC initialization now takes place in our initBus() handler, largely because we
         * want initController() to have access to the ChipSet component, so that it can query switches and/or CMOS
         * settings that determine the number of drives and their characteristics (eg, 40-track vs. 80-track),
         * which it can then pass on to initDrive().
         */
        this.fAutoScroll = false;
        this['exports'] = {
            'loadDisk':     this.loadSelectedDisk,
            'wait':         this.waitDrives
        };
    }

    /**
     * setBinding(sHTMLType, sBinding, control, sValue)
     *
     * @this {FDC}
     * @param {string} sHTMLType is the type of the HTML control (eg, "button", "list", "text", "submit", "textarea", "canvas")
     * @param {string} sBinding is the value of the 'binding' parameter stored in the HTML control's "data-value" attribute (eg, "listDisks")
     * @param {HTMLElement} control is the HTML control DOM object (eg, HTMLButtonElement)
     * @param {string} [sValue] optional data value
     * @returns {boolean} true if binding was successful, false if unrecognized binding request
     */
    setBinding(sHTMLType, sBinding, control, sValue)
    {
        let fdc = this;
        /**
         * TODO: Making copies of control that are simply cast to different types seems silly, but it doesn't
         * really cost anything and it's cleaner than doing a lot MORE type overrides inline.  However, it still
         * doesn't solve all my problems: controlForm should really be cast as HTMLFormElement, but JavaScript
         * inspections refuse to believe there's an 'onsubmit' property on an HTMLFormElement that I can override.
         */
        let controlForm = /** @type {Object} */ (control);
        let controlSelect = /** @type {HTMLSelectElement} */ (control);

        switch (sBinding) {

        case "listDisks":
            this.bindings[sBinding] = controlSelect;
            controlSelect.onchange = function onChangeListDisks(event) {
                fdc.updateSelectedDiskette();
            };
            return true;

        case "descDisk":
        case "listDrives":
            this.bindings[sBinding] = controlSelect;
            /**
             * I tried going with onclick instead of onchange, so that if you wanted to confirm what's
             * loaded in a particular drive, you could click the drive control without having to change it.
             * However, that doesn't seem to work for all browsers, so I've reverted to onchange.
             */
            controlSelect.onchange = function onChangeListDrives(event) {
                let iDrive = StrLib.parseInt(controlSelect.value, 10);
                if (iDrive != null) fdc.displayDiskette(iDrive, true);
            };
            return true;

        case "loadDisk":
            this.bindings[sBinding] = control;
            control.onclick = function onClickLoadDisk(event) {
                if (!fdc.externalActive) {
                    fdc.loadSelectedDisk();
                } else {
                    let externalDrive = fdc.externalDrives[fdc.externalActive];
                    externalDrive.controller.loadSelectedDisk(externalDrive.drive.iDrive, externalDrive.controlDisks);
                }
            };
            return true;

        case "saveDisk":
            /**
             * Yes, technically, this feature does not require "Local disk support" (which is really a reference
             * to FileReader support), but since fLocalDisks is also false for all mobile devices, and since there
             * is an "orthogonality" to disabling both features in tandem, let's just let it slide, OK?
             */
            if (!this.fLocalDisks) {
                if (DEBUG) this.printf(MESSAGE.LOG, "Local disk support not available");
                /**
                 * We could also simply remove the control; eg:
                 *
                 *      control.parentNode.removeChild(@type {Node} (control));
                 *
                 * but as long as the parentNode remains, with its accompanying style, the visual layout of the machine
                 * could look odd.  So let's change the parent's style instead.
                 */
                control.parentNode.style.display = "none";
                return false;
            }
            this.bindings[sBinding] = control;
            control.onclick = function onClickSaveDisk(event) {
                let controlDrives = fdc.bindings["listDrives"];
                if (controlDrives && controlDrives.options && fdc.aDrives) {
                    let iDriveSelected = StrLib.parseInt(controlDrives.value, 10) || 0;
                    let drive = fdc.aDrives[iDriveSelected];
                    if (drive) {
                        /**
                         * Note the similarity (and hence factoring opportunity) between this code and the HDC's
                         * "saveHD*" binding.
                         */
                        let disk = drive.disk;
                        if (disk) {
                            if (DEBUG) fdc.printf("saving diskette %s...\n", disk.sDiskPath);
                            let sAlert = WebLib.downloadFile(disk.encodeAsBinary(), "octet-stream", true, disk.sDiskFile.replace(".json", ".img"));
                            Component.alertUser(sAlert);
                        } else {
                            fdc.printf(MESSAGE.NOTICE, "No diskette loaded in drive\n");
                        }
                    } else {
                        fdc.printf(MESSAGE.NOTICE, "No diskette drive selected\n");
                    }
                }
            };
            return true;

        case "mountDisk":
            if (!this.fLocalDisks) {
                if (DEBUG) this.printf(MESSAGE.LOG, "Local disk support not available\n");
                /**
                 * We could also simply hide the control; eg:
                 *
                 *      controlForm.style.display = "none";
                 *
                 * but removing the control altogether seems better.
                 */
                controlForm.parentNode.removeChild(/** @type {Node} */ (controlForm));
                return false;
            }
            this.bindings[sBinding] = controlForm;
            /**
             * Enable "Mount" button only if a file is actually selected
             */
            controlForm.onchange = function onChangeMountDisk() {
                let fieldset = controlForm.children[0];
                let files = fieldset.children[0].files;
                let submit = fieldset.children[1];
                submit.disabled = !files.length;
            };
            controlForm.onsubmit = function onSubmitMountDisk(event) {
                let file = event.currentTarget[1].files[0];
                if (file) {
                    let sDiskPath = file.name;
                    let sDiskName = StrLib.getBaseName(sDiskPath, true);
                    fdc.loadSelectedDrive(sDiskName, sDiskPath, file);
                }
                /**
                 * Prevent reloading of web page after form submission
                 */
                return false;
            };
            return true;

        default:
            break;
        }
        return false;
    }

    /**
     * initBus(cmp, bus, cpu, dbg)
     *
     * @this {FDC}
     * @param {Computer} cmp
     * @param {Busx86} bus
     * @param {CPUx86} cpu
     * @param {Debuggerx86} dbg
     */
    initBus(cmp, bus, cpu, dbg)
    {
        this.bus = bus;
        this.cpu = cpu;
        this.dbg = dbg;
        this.cmp = cmp;

        let aDriveTypes = cmp.getMachineParm('floppyDrives');
        if (aDriveTypes) {
            if (typeof aDriveTypes == "string") {
                this.sDriveTypes = aDriveTypes;
            } else {
                this.aDriveTypes = aDriveTypes;
                this.sDriveTypes = "";
            }
        }

        if (this.sDriveTypes) {
            try {
                /**
                 * We must take care when parsing user-supplied JSON-encoded drive data.
                 */
                this.aDriveTypes = eval("(" + this.sDriveTypes + ")");
                this.sDriveTypes = "";
            } catch (e) {
                Component.error("FDC drive configuration error: " + e.message + " (" + this.sDriveTypes + ")");
            }
        }

        this.chipset = cmp.getMachineComponent("ChipSet");
        this.configMount = this.parseMount(this.cmp.getMachineParm('autoMount'), this.configMount);

        this.panel = cmp.getMachineComponent("Panel", false);

        /**
         * If we didn't need auto-mount support, we could defer controller initialization until we received
         * a powerUp() notification, at which point reset() would call initController(), or restore() would
         * restore the controller; in that case, all we'd need to do here is call setReady().
         */
        this.initController();

        bus.addPortInputTable(this, FDC.aPortInput);
        bus.addPortOutputTable(this, FDC.aPortOutput);

        /**
         * We now allow the FDC's 'diskettes' parameter to be overridden with a machine parameter;
         * fortunately, that's not a problem, since we weren't doing anything with the parameter until
         * this point (initBus()) anyway, and it's just a comma-delimited list of "diskettes.json" files,
         * the default one being "/machines/pcx86/diskettes.json".
         */
        this.aDiskettes = this.cmp.getMachineParm('diskettes') || this.aDiskettes;

        if (this.aDiskettes && typeof this.aDiskettes == "string") {
            let fdc = this;
            let hostName = WebLib.getHostName();
            let limits = fdc.getDriveLimits();
            let urls = fdc.aDiskettes.split(',');
            let cLoaded = 0, cSuccessful = 0;
            /**
             * Preprocess the list of URLs, removing any that are not appropriate for the current host.
             */
            for (let i = 0; i < urls.length; i++) {
                if (hostName != "localhost" && urls[i].indexOf("private") >= 0) {
                    urls.splice(i--, 1);
                }
            }
            fdc.aDiskettes = [];
            for (let i = 0; i < urls.length; i++) {
                let url = urls[i];
                let sProgress = "Loading " + url + "...";
                WebLib.getResource(url, "json", true, function loadDone(url, sResponse, nErrorCode) {
                    let privateURL = url.indexOf("private") >= 0;
                    if (sResponse && !nErrorCode) {
                        try {
                            JSONLib.parseDiskettes(fdc.aDiskettes, /** @type {Object} */ (JSON.parse(sResponse)), "/pcx86", fdc.sDisketteServer, hostName, limits);
                            cSuccessful++;
                        } catch(err) {
                            if (!privateURL || sResponse[0] != '<') fdc.printf(MESSAGE.WARNING, "Unable to parse %s: %s\n", url, err.message);
                        }
                    } else {
                        if (!privateURL) fdc.printf(MESSAGE.WARNING, "Unable to open %s (%d)\n", url, nErrorCode);
                    }
                    if (++cLoaded == urls.length) fdc.addDiskettes(!cSuccessful);
                }, function(nState) {
                    fdc.printf(MESSAGE.PROGRESS, "%s\n", sProgress);
                });
            }
            return;
        }
        this.addDiskettes();
    }

    /**
     * setLED(color)
     *
     * @this {FDC}
     * @param {string} [color]
     */
    setLED(color)
    {
        if (this.panel) {
            this.panel.setLED("fdcState", color);
        }
    }

    /**
     * parseMount(config, configMerge)
     *
     * @this {FDC}
     * @param {Object|string|undefined} config
     * @param {Object} [configMerge]
     * @returns {Object}
     */
    parseMount(config, configMerge)
    {
        if (config) {
            if (typeof config == "string") {
                try {
                    /**
                     * We must take care when parsing user-supplied JSON-encoded diskette data.
                     */
                    config = /** @type {Object} */ (eval("(" + config + ")"));
                } catch (e) {
                    Component.error("FDC auto-mount error: " + e.message + " (" + config + ")");
                    config = {};
                }
            }
        } else {
            config = {};
        }
        /**
         * Instead of modifying configMerge, we merely import anything in configMerge that doesn't exist in the new config.
         */
        if (configMerge) {
            for (let sDrive in configMerge) {
                if (!config[sDrive]) config[sDrive] = configMerge[sDrive];
            }
        }
        /**
         * We now allow "shorthand" configs, where each drive property can simply be a string (ie, the implied 'name' of a diskette)
         * instead of an object containing 'name' and/or 'path' strings.
         */
        for (let sDrive in config) {
            let drive = config[sDrive];
            if (typeof drive == "string") config[sDrive] = {'name': drive};
        }
        return config;
    }

    /**
     * powerUp(data, fRepower)
     *
     * @this {FDC}
     * @param {Object|null} data
     * @param {boolean} [fRepower]
     * @returns {boolean} true if successful, false if failure
     */
    powerUp(data, fRepower)
    {
        if (!fRepower) {
            if (!data) {
                this.reset(true);
                if (this.cmp.fReload) {
                    /**
                     * If the computer's fReload flag is set, we're required to toss all currently
                     * loaded disks and remount all disks specified in the auto-mount configuration.
                     */
                    this.unloadAllDrives(true);
                    this.autoMount(true);
                }
            } else {
                if (!this.restore(data)) return false;
            }
            this.resetDriveList();
        }
        return true;
    }

    /**
     * powerDown(fSave, fShutdown)
     *
     * @this {FDC}
     * @param {boolean} [fSave]
     * @param {boolean} [fShutdown]
     * @returns {Object|boolean} component state if fSave; otherwise, true if successful, false if failure
     */
    powerDown(fSave, fShutdown)
    {
        return fSave? this.save() : true;
    }

    /**
     * reset()
     *
     * NOTE: initController() establishes the maximum possible number of drives, but it's not until
     * initController() interrogates the current SW1 settings that we will have an ACTUAL number of drives
     * (nDrives), at which point we can also update the contents of the "listDrives" HTML control, if any.
     *
     * @this {FDC}
     * @param {boolean} [fPowerUp] (this isn't set by a computer reset(), only by our powerUp() handler)
     */
    reset(fPowerUp)
    {
        /**
         * NOTE: The controller is also initialized by the constructor, to assist with auto-mount support,
         * so think about whether we can skip powerUp initialization.
         */
        this.initController();
        /**
         * Don't bother resetting the drive list if we're being called by powerUp(), because powerUp() will.
         */
        if (!fPowerUp) this.resetDriveList();
    }

    /**
     * addDrive(drive, controller, controlDisks)
     *
     * @this {FDC}
     * @param {DriveInfo} drive
     * @param {Component} controller
     * @param {HTMLSelectElement} controlDisks
     */
    addDrive(drive, controller, controlDisks)
    {
        this.externalDrives[drive.name] = {drive, controller, controlDisks};
    }

    /**
     * resetDriveList()
     *
     * @this {FDC}
     */
    resetDriveList()
    {
        /**
         * Populate the HTML controls to match the actual (well, um, specified) number of floppy drives.
         */
        let controlDrives;
        if ((controlDrives = this.bindings['listDrives'])) {
            while (controlDrives.firstChild) {
                controlDrives.removeChild(controlDrives.firstChild);
            }
            let iDrive = 0;
            controlDrives.value = "";
            while (iDrive < this.nDrives) {
                let controlOption = document.createElement("option");
                controlOption.value = iDrive.toString();
                controlOption.text = String.fromCharCode(0x41 + iDrive) + ":";
                controlDrives.appendChild(controlOption);
                /**
                 * Add a second element for the drive that will automatically "write-protect" the selected diskette.
                 */
                controlOption = document.createElement("option");
                controlOption.value = iDrive.toString();
                controlOption.text = String.fromCharCode(0x41 + iDrive) + "*";
                controlOption.title = "write-protected";        // NOTE: this "tooltip" attribute does not work on all browsers (eg, Chrome)
                controlDrives.appendChild(controlOption);
                iDrive++;
            }
            for (let name in this.externalDrives) {
                let controlOption = document.createElement("option");
                controlOption.value = iDrive.toString();
                controlOption.text = name;
                controlDrives.appendChild(controlOption);
                iDrive++;
            }
            if (this.nDrives > 0) {
                controlDrives.value = "0";
                this.displayDiskette(0, false);
            }
        }
    }

    /**
     * save()
     *
     * This implements save support for the FDC component.
     *
     * @this {FDC}
     * @returns {Object}
     */
    save()
    {
        let state = new State(this);
        state.set(0, this.saveController());
        return state.data();
    }

    /**
     * restore(data)
     *
     * This implements restore support for the FDC component.
     *
     * @this {FDC}
     * @param {Object} data
     * @returns {boolean} true if successful, false if failure
     */
    restore(data)
    {
        return this.initController(data[0]);
    }

    /**
     * initController(data)
     *
     * @this {FDC}
     * @param {Array} [data]
     * @returns {boolean} true if successful, false if failure
     */
    initController(data)
    {
        let i = 0, iDrive;
        let fSuccess = true;

        if (!data) {
            data = [0, 0, FDC.REG_STATUS.RQM, new Array(9), 0, 0, 0, []];
        }

        /**
         * Selected drive (from regOutput), which can only be selected if its motor is on (see regOutput).
         */
        this.iDrive = data[i++];
        i++;                        // unused slot (if reused, bias by +4, since it was formerly a unit #)

        /**
         * Defaults to FDC.REG_STATUS.RQM set (ready for command) and FDC.REG_STATUS.READ_DATA clear (data direction
         * is from processor to the FDC Data Register).
         */
        this.regStatus = data[i++];

        /**
         * There can be up to 9 command bytes, and 7 result bytes, so 9 data registers are sufficient for communicating
         * in both directions (hence, the new Array(9) default above).
         */
        this.regDataArray = data[i++];

        /**
         * Determines the next data byte to be received.
         */
        this.regDataIndex = data[i++];

        /**
         * Determines the next data byte to be sent (internally, we use regDataIndex to read data bytes, up to this total).
         */
        this.regDataTotal = data[i++];
        this.regOutput = data[i++];
        let dataDrives = data[i++];

        /**
         * Initialize the disk history (if available) before initializing the drives, so that any disk deltas can be
         * applied to disk images that are already loaded.
         */
        let aDiskHistory = data[i++];
        if (aDiskHistory != null) this.aDiskHistory = aDiskHistory;

        /**
         * Default to the maximum number of drives unless ChipSet can give us a specific number of drives.
         */
        this.nDrives = this.aDriveTypes? this.aDriveTypes.length : (this.chipset? this.chipset.getDIPFloppyDrives() : 4);

        /**
         * I would prefer to allocate only nDrives, but as discussed in the handling of the FDC.REG_DATA.CMD.SENSE_INT
         * command, we're faced with situations where the controller must respond to any drive in the range 0-3, regardless
         * how many drives are actually installed.  We still rely upon nDrives to determine the number of drives displayed
         * to the user, however.
         */
        if (this.aDrives === undefined) {
            this.aDrives = new Array(4);
        }

        for (iDrive = 0; iDrive < this.aDrives.length; iDrive++) {
            let fInit = false;
            let drive = this.aDrives[iDrive];
            if (drive === undefined) {
                /**
                 * The first time each drive is initialized, we query its capacity (based on switches or CMOS) and set
                 * the drive's physical limits accordingly (ie, max tracks, max heads, and max sectors/track).
                 */
                fInit = true;
                drive = this.aDrives[iDrive] = {};
                let nKb = (this.chipset? this.chipset.getDIPFloppyDriveSize(iDrive) : 0);
                switch(nKb) {
                case 160:
                case 180:
                    drive.nHeads = 1;       // required for single-sided drives only (all others default to double-sided)
                    /* falls through */
                case 320:
                case 360:
                    /* falls through */
                default:                    // drives that don't have a recognized capacity default to 360
                    drive.nCylinders = 40;
                    drive.nSectors = 9;     // drives capable of writing 8 sectors/track can also write 9 sectors/track
                    break;
                case 720:
                    drive.nCylinders = 80;
                    drive.nSectors = 9;
                    break;
                case 1200:
                    drive.nCylinders = 80;
                    drive.nSectors = 15;
                    break;
                case 1440:
                    drive.nCylinders = 80;
                    drive.nSectors = 18;
                    break;
                }
            }
            if (!this.initDrive(drive, iDrive, this.aDriveTypes? this.aDriveTypes[iDrive] : null, dataDrives[iDrive], fInit)) {
                fSuccess = false;
            }
        }

        /**
         * regInput and regControl (port 0x3F7) were not present on controllers prior to MODEL_5170, which is why
         * we don't include initializers for them in the default data array; we could eliminate them on older models,
         * but we don't have access to the model info right now, and there's no real cost to always including them
         * in the FDC state.
         *
         * The bigger compatibility question is whether to always include hooks for them (see aPortInput and aPortOutput).
         */
        this.regInput = data[i++] || 0;                             // TODO: Determine if we should default to FDC.REG_INPUT.DISK_CHANGE instead of 0
        this.regControl = data[i] || FDC.REG_CONTROL.RATE500K;      // default to maximum data rate

        this.printf("FDC initialized for %d drive(s)\n", this.aDrives.length);

        return fSuccess;
    }

    /**
     * saveController()
     *
     * @this {FDC}
     * @returns {Array}
     */
    saveController()
    {
        let i = 0;
        let data = [];
        data[i++] = this.iDrive;
        data[i++] = 0;
        data[i++] = this.regStatus;
        data[i++] = this.regDataArray;
        data[i++] = this.regDataIndex;
        data[i++] = this.regDataTotal;
        data[i++] = this.regOutput;
        data[i++] = this.saveDrives();
        data[i++] = this.saveDeltas();
        data[i++] = this.regInput;
        data[i] = this.regControl;
        return data;
    }

    /**
     * initDrive(drive, iDrive, driveType, data, fInit)
     *
     * TODO: Consider a separate Drive class that both FDC and HDC can use, since there's a lot of commonality
     * between the drive objects created by both controllers.  This will clean up overall drive management and allow
     * us to factor out some common Drive methods (eg, advanceSector()).
     *
     * @this {FDC}
     * @param {DriveInfo} drive
     * @param {number} iDrive
     * @param {DriveType|null} driveType
     * @param {Array|undefined} data
     * @param {boolean} fInit
     * @returns {boolean} true if successful, false if failure
     */
    initDrive(drive, iDrive, driveType, data, fInit)
    {
        let i = 0;
        let fSuccess = true;

        drive.iDrive = iDrive;
        drive.fBusy = drive.fLocal = false;
        drive.fnCallReady = null;

        let nHeads = driveType && driveType['heads'];
        drive.fBootable = driveType && driveType['boot'];
        if (drive.fBootable == null) drive.fBootable = true;

        if (fInit) {
            drive.fWritable = true;
            if (nHeads) this.printf(MESSAGE.STATUS, "drive %d configured with %d head%s\n", iDrive, nHeads, nHeads > 1? 's' : '');
            if (!drive.fBootable) this.printf(MESSAGE.STATUS, "drive %d configured as non-bootable\n", iDrive);
        }

        if (data === undefined) {
            /**
             * We set a default of two heads (MODEL_5150 PCs originally shipped with single-sided drives,
             * but the ROM BIOS appears to have always supported both drive types).
             */
            data = [FDC.REG_DATA.RES.RESET, true, 0, nHeads || 2, 0];
        }

        if (typeof data[1] == "boolean") {
            /**
             * Note that when no data is provided (eg, when the controller is being reinitialized), we now take
             * care to preserve any drive defaults that initController() already obtained for us, falling back to
             * bare minimums only when all else fails.
             */
            data[1] = [
                FDC.DEFAULT_DRIVE_NAME, // a[0]
                drive.nCylinders || 40, // a[1]
                drive.nHeads || data[3],// a[2]
                drive.nSectors || 9,    // a[3]
                drive.cbSector || 512,  // a[4]
                data[1],                // a[5]
                drive.nDiskCylinders,   // a[6]
                drive.nDiskHeads,       // a[7]
                drive.nDiskSectors      // a[8]
            ];
        }

        /**
         * resCode used to be an FDC global, but in order to insulate FDC state from the operation of various functions
         * that operate on drive objects (eg, readData and writeData), I've made it a per-drive variable.  This choice,
         * similar to my choice for handling PCN, may be contrary to how the actual hardware works, but I prefer this
         * approach, as long as it doesn't expose any incompatibilities that any software actually cares about.
         */
        drive.resCode = data[i++];

        /**
         * Some additional drive properties/defaults that are largely for the Disk component's benefit.
         */
        let a = data[i++];
        drive.name = a[0];
        drive.nCylinders = a[1];          // cylinders
        drive.nHeads = a[2];              // heads/cylinders
        drive.nSectors = a[3];            // sectors/track
        drive.cbSector = a[4];            // bytes/sector
        drive.fRemovable = a[5];
        /**
         * If we have current media parameters, restore them; otherwise, default to the drive's physical parameters.
         */
        if ((drive.nDiskCylinders = a[6])) {
            drive.nDiskHeads = a[7];
            drive.nDiskSectors = a[8];
        } else {
            drive.nDiskCylinders = drive.nCylinders;
            drive.nDiskHeads = drive.nHeads;
            drive.nDiskSectors = drive.nSectors;
        }

        /**
         * The next group of properties are set by various FDC command sequences.
         *
         * We initialize this.iDrive (above) and drive.bHead and drive.bCylinder (below) to zero, but leave the rest undefined,
         * awaiting their first FDC command.  We do this because the initial SENSE_INT command returns a PCN, which will also
         * be undefined unless we have at least zeroed both the current drive and the "present" cylinder on that drive.
         *
         * Alternatively, I could make PCN a global FDC variable.  That may be closer to how the actual hardware operates,
         * but I'm using per-drive variables so that the FDC component can be a good client to both the CPU and other components.
         *
         * COMPATIBILITY ALERT: The MODEL_5170 BIOS ("DSKETTE_SETUP") attempts to discern the drive type (double-density vs.
         * high-capacity) by "slapping" the heads around -- literally (it uses a constant named "TRK_SLAP" equal to 48).
         * After seeking to "TRK_SLAP", the BIOS performs a series of seeks, looking for the precise point where the heads
         * return to track 0.
         *
         * Here's how it works: the BIOS seeks to track 48 (which is fine on an 80-track 1.2Mb high-capacity drive, but 9 tracks
         * too far on a 40-track 360Kb double-density drive), then seeks to track 10, and then seeks in single-track increments
         * up to 10 more times until the SENSE_DRIVE command returns ST3 with the TRACK0 bit set.
         *
         * This implies that SEEK isn't really seeking to a specified cylinder, but rather it is calculating a delta from
         * the previous cylinder to the specified cylinder, and stepping over that number of tracks.  Which means that SEEK
         * is updating a "logical" cylinder number, not the "physical" (actual) cylinder number.  Presumably a RECALIBRATE
         * command will bring the logical and physical values into sync, but once an out-of-bounds cylinder is requested, they
         * will be out of sync.
         *
         * To simulate this, bCylinder is now treated as the "physical" cylinder (since that's how it's ALWAYS been used here),
         * and bCylinderSeek will now track (pun intended) the "logical" cylinder that's programmed via SEEK commands.
         */
        drive.bHead = data[i++];
        drive.bCylinderSeek = data[i++];        // the data[] slot where we used to store drive.nHeads (or -1)
        drive.bCylinder = data[i++];
        if (drive.bCylinderSeek >= 100) {       // verify that the saved bCylinderSeek is valid, otherwise sync it with bCylinder
            drive.bCylinderSeek -= 100;
        } else {
            drive.bCylinderSeek -= drive.bCylinder;
        }
        drive.bSector = data[i++];
        drive.bSectorEnd = data[i++];           // aka EOT
        drive.nBytes = data[i++];

        /**
         * The next group of properties are managed by worker functions (eg, doRead()) to maintain state across DMA requests.
         */
        drive.iByte = data[i++];                // location of the next byte to be accessed in the current sector
        drive.sector = null;
        drive.sectorPrev = null;                // used to remember the last sector read (or written)

        /**
         * We no longer reinitialize drive.disk, in order to retain previously mounted diskette across resets;
         * however, we do ensure that sDiskPath is initialized to a default that displayDiskette() can deal with.
         */
        if (!drive.disk) drive.sDiskPath = "";

        let deltas = data[i++];
        if (deltas == 102) deltas = false;      // v1.02 backward-compatibility

        if (typeof deltas == "boolean") {
            let fLocal = deltas;
            let sDiskName = data[i++];
            let sDiskPath = data[i++];
            if (data[i] != null) drive.fWritable = data[i];
            /**
             * If we're restoring a local disk image, then the entire disk contents should be captured in aDiskHistory,
             * so all we have to do is mount a blank diskette and let disk.restore() do the rest; ie, there's nothing to
             * "load" (it's a purely synchronous operation).
             *
             * Otherwise, we must call loadDrive(); in the common case, loadDrive() will have already "auto-mounted"
             * the diskette, so it will return true, and then we restore any deltas to the current image.
             *
             * However, if loadDrive() returns false, then it has initiated the load for a *different* disk image,
             * so we must mark ourselves as "not ready" again, and add another "wait for ready" test in Computer before
             * finally powering the CPU.
             */
            if (fLocal) {
                this.mountDrive(iDrive, sDiskName, sDiskPath);
            }
            else if (this.loadDrive(iDrive, sDiskName, sDiskPath, true)) {
                if (drive.disk) {
                    if (sDiskPath) {
                        this.addDiskHistory(sDiskName, sDiskPath, drive.disk);
                    } else {
                        if (MAXDEBUG) Component.warning("Disk '" + (drive.disk.sDiskName || sDiskName) + "' not recorded properly in drive " + iDrive);
                    }
                }
            } else {
                this.setReady(false);
            }
        } else if (deltas !== undefined) {
            /**
             * If there's any data at all (ie, if this is a restore and not a reset), then it must be in the
             * pre-v1.02 save/restore format, so we'll restore as best we can, but be aware that if disk.restore()
             * notices that the currently mounted disk image differs from the disk image that these deltas belong to,
             * it will return false, and the restore operation will be aborted.
             */
            if (drive.disk && drive.disk.restore(deltas) < 0) {
                fSuccess = false;
            }
        }

        /**
         * TODO: If loadDrive() returned true, then this can happen immediately.  Otherwise, loadDrive()
         * will have merely "queued up" the load request and drive.disk won't be ready yet, so figure out how/when
         * we can properly restore drive.sector in that case.
         */
        if (fSuccess && drive.disk && drive.iByte !== undefined) {
            drive.sector = drive.disk.seek(drive.bCylinder, drive.bHead, drive.bSector);
        }
        return fSuccess;
    }

    /**
     * getDriveLimits()
     *
     * @this {FDC}
     * @returns {Array} ([0] is max heads, and [1] is max cylinders)
     */
    getDriveLimits()
    {
        let i = 0;
        let limits = [0, 0];
        for (let iDrive = 0; iDrive < this.aDrives.length; iDrive++) {
            let drive = this.aDrives[i];
            if (limits[0] > drive.nHeads || !limits[0]) {
                limits[0] = drive.nHeads;
            }
            if (limits[1] > drive.nCylinders || !limits[1]) {
                limits[1] = drive.nCylinders;
            }
        }
        return limits;
    }

    /**
     * saveDrives()
     *
     * @this {FDC}
     * @returns {Array}
     */
    saveDrives()
    {
        let i = 0;
        let data = [];
        for (let iDrive = 0; iDrive < this.aDrives.length; iDrive++) {
            data[i++] = this.saveDrive(this.aDrives[iDrive]);
        }
        return data;
    }

    /**
     * saveDrive(drive)
     *
     * @this {FDC}
     * @param {Object} drive
     * @returns {Array}
     */
    saveDrive(drive)
    {
        let i = 0;
        let data = [];
        data[i++] = drive.resCode;
        data[i++] = [drive.name, drive.nCylinders, drive.nHeads, drive.nSectors, drive.cbSector, drive.fRemovable, drive.nDiskCylinders, drive.nDiskHeads, drive.nDiskSectors];
        data[i++] = drive.bHead;
        /**
         * We used to store drive.nHeads in the next slot, but now we store bCylinderSeek,
         * and we bias it by +100 so that initDrive() can distinguish it from older values.
         */
        data[i++] = drive.bCylinderSeek + 100;
        data[i++] = drive.bCylinder;
        data[i++] = drive.bSector;
        data[i++] = drive.bSectorEnd;
        data[i++] = drive.nBytes;
        data[i++] = drive.iByte;
        /**
         * Now we deviate from the 1.01a save format: instead of next storing all the deltas for the
         * currently mounted disk (if any), we store only the name and path of the currently mounted disk
         * (if any).  Deltas for ALL disks, both currently mounted and previously mounted, are stored later.
         *
         *      data[i++] = drive.disk? drive.disk.save() : null;
         *
         * To indicate this deviation, we store neither a null nor a delta array, but a boolean (fLocal);
         * if that boolean is not present, then the restore code will know it's dealing with a pre-v1.02 state.
         */
        data[i++] = drive.fLocal;
        data[i++] = drive.sDiskName;
        data[i++] = drive.sDiskPath;
        data[i] = drive.fWritable;
        if (DEBUG && !drive.sDiskPath && drive.disk && drive.disk.sDiskPath) {
            Component.warning("Disk '" + drive.disk.sDiskName + "' not saved properly in drive " + drive.iDrive);
        }
        return data;
    }

    /**
     * saveDeltas()
     *
     * This returns an array of entries, one for each disk image we've ever mounted, including any deltas; ie:
     *
     *      [name, path, deltas]
     *
     * aDiskHistory contains exactly that, except that deltas may not be up-to-date for any currently mounted
     * disk image(s), so we call updateHistory() for all those disks, and then aDiskHistory is ready to be saved.
     *
     * @this {FDC}
     * @returns {Array}
     */
    saveDeltas()
    {
        for (let iDrive = 0; iDrive < this.aDrives.length; iDrive++) {
            let drive = this.aDrives[iDrive];
            if (drive.disk) {
                this.updateDiskHistory(drive.sDiskName, drive.sDiskPath, drive.disk);
            }
        }
        return this.aDiskHistory;
    }

    /**
     * copyDrive(iDrive)
     *
     * @this {FDC}
     * @param {number} iDrive
     * @returns {Object|undefined} drive (which may be undefined if the requested drive does not exist)
     */
    copyDrive(iDrive)
    {
        let driveNew;
        let driveOld = this.aDrives[iDrive];
        if (driveOld !== undefined) {
            driveNew = {};
            for (let p in driveOld) {
                driveNew[p] = driveOld[p];
            }
        }
        return driveNew;
    }

    /**
     * seekDrive(drive, iSector, nSectors)
     *
     * The FDC doesn't need this function, since all FDC requests from the CPU are handled by doCmd().  This function
     * is used by other components (eg, Debugger) to mimic an FDC request, using a drive object obtained from copyDrive(),
     * to avoid disturbing the internal state of the FDC's drive objects.
     *
     * Also note that in an actual FDC request, drive.nBytes is initialized to the size of a single sector; the extent
     * of the entire transfer is actually determined by a count that has been pre-loaded into the DMA controller.  The FDC
     * isn't even aware of the extent of the transfer, so in the case of a read request, all readData() can do is return
     * bytes until the current track (or, in the case of a multi-track request, the current cylinder) has been exhausted.
     *
     * Since seekDrive() is for use with non-DMA requests, we use nBytes to specify the length of the entire transfer.
     *
     * @this {FDC}
     * @param {Object} drive
     * @param {number} iSector (a "logical" sector number, relative to the entire disk, NOT a physical sector number)
     * @param {number} nSectors
     * @returns {boolean} true if successful, false if invalid position request
     */
    seekDrive(drive, iSector, nSectors)
    {
        if (drive.disk) {
            let aDiskInfo = drive.disk.info();
            let nCylinders = aDiskInfo[0];
            let nHeads = aDiskInfo[1];
            let nSectorsPerTrack = aDiskInfo[2];
            let nSectorsPerCylinder = nHeads * nSectorsPerTrack;
            let nSectorsPerDisk = nCylinders * nSectorsPerCylinder;
            if (iSector + nSectors <= nSectorsPerDisk) {
                drive.bCylinder = Math.floor(iSector / nSectorsPerCylinder);
                iSector %= nSectorsPerCylinder;
                drive.bHead = Math.floor(iSector / nSectorsPerTrack);
                drive.bSector = (iSector % nSectorsPerTrack) + 1;
                drive.nBytes = nSectors * aDiskInfo[3];
                /**
                 * NOTE: We don't set bSectorEnd, as an FDC command would, but it's irrelevant, because we don't actually
                 * do anything with bSectorEnd at this point.  Perhaps someday, when we faithfully honor/restrict requests
                 * to a single track (or a single cylinder, in the case of multi-track requests).
                 */
                drive.resCode = FDC.REG_DATA.RES.NONE;
                /**
                 * At this point, we've finished simulating what an FDC.REG_DATA.CMD.READ_DATA command would have performed,
                 * up through doRead().  Now it's the caller responsibility to call readData(), just like the DMA Controller would.
                 */
                return true;
            }
        }
        return false;
    }

    /**
     * autoMount(fRemount)
     *
     * @this {FDC}
     * @param {boolean} [fRemount] is true if we're remounting all auto-mounted diskettes
     * @returns {boolean} true if one or more diskette images are being auto-mounted, false if none
     */
    autoMount(fRemount)
    {
        if (!fRemount) this.cAutoMount = 0;
        for (let sDrive in this.configMount) {
            let configDrive = this.configMount[sDrive];
            let sDiskPath = configDrive['path'] || this.findDisketteByName(configDrive['name']);
            if (sDiskPath) {
                /**
                 * WARNING: This conversion of drive letter to drive number, starting with A:, is very simplistic
                 * and is not guaranteed to match the drive mapping that DOS ultimately uses.
                 */
                let iDrive = sDrive.charCodeAt(0) - 0x41;
                if (iDrive >= 0 && iDrive < this.aDrives.length) {
                    let sDiskName = configDrive['name'] || this.findDisketteByPath(sDiskPath) || StrLib.getBaseName(sDiskPath, true);
                    if (!this.loadDrive(iDrive, sDiskName, sDiskPath, true) && fRemount) {
                        this.setReady(false);
                    }
                    continue;
                }
                this.printf(MESSAGE.NOTICE, "Incorrect auto-mount settings for drive %s (%s)\n", sDrive, JSON.stringify(configDrive));
            }
        }
        return !!this.cAutoMount;
    }

    /**
     * loadSelectedDisk(...args)
     *
     * NOTE: Since this can be called via script command (eg, 'loadDisk FDC'), additional parameters can be
     * passed; use the args array to access them if necessary.
     *
     * @this {FDC}
     * @param {...} args
     * @returns {boolean}
     */
    loadSelectedDisk(...args)
    {
        let controlDisks = this.bindings["listDisks"];
        if (controlDisks) {
            let sDiskName = controlDisks.options[controlDisks.selectedIndex].text;
            let sDiskPath = controlDisks.value;
            this.fAutoScroll = (args[0] == "scroll");
            return this.loadSelectedDrive(sDiskName, sDiskPath);
        }
        return false;
    }

    /**
     * loadSelectedDrive(sDiskName, sDiskPath, file)
     *
     * @this {FDC}
     * @param {string} sDiskName
     * @param {string} sDiskPath
     * @param {File} [file] is set if there's an associated File object
     * @returns {boolean}
     */
    loadSelectedDrive(sDiskName, sDiskPath, file)
    {
        let iDrive;
        let controlDrives = this.bindings["listDrives"];
        if (controlDrives && !isNaN(iDrive = StrLib.parseInt(controlDrives.value, 10)) && iDrive >= 0 && iDrive < this.aDrives.length) {

            if (!sDiskPath) {
                this.unloadDrive(iDrive);
                return true;
            }

            if (sDiskPath == "?") {
                this.printf(MESSAGE.NOTICE, "Use \"Choose File\" and \"Mount\" to select and load a local disk\n");
                return false;
            }

            /**
             * If the special path of "??" is selected, then we want to prompt the user for a URL.  Oh, and
             * make sure we pass an empty string as the 2nd parameter to prompt(), so that IE won't display
             * "undefined" -- because after all, undefined and "undefined" are EXACTLY the same thing, right?
             *
             * TODO: This is literally all I've done to support remote disk images. There's probably more
             * I should do, like dynamically updating "listDisks" to include new entries, and adding new entries
             * to the save/restore data.
             */
            if (sDiskPath == "??") {
                sDiskPath = "";
                if (globals.window.prompt) {
                    sDiskPath = globals.window.prompt("Enter the URL of a remote disk image.", "") || "";
                }
                if (!sDiskPath) return false;
                sDiskName = StrLib.getBaseName(sDiskPath);
                this.printf(MESSAGE.DEBUG, "Attempting to load %s as \"%s\"\n", sDiskPath, sDiskName);
            }

            while (this.loadDrive(iDrive, sDiskName, sDiskPath, false, file) < 0) {
                /**
                 * I got tired of the "reload" warning when running locally, so I've disabled it there.
                 */
                if (WebLib.getHostName() != "localhost" && (!globals.window.confirm || !globals.window.confirm("Click OK to reload the original disk and discard any changes."))) {
                    this.printf(MESSAGE.DEBUG, "load cancelled\n");
                    return false;
                }
                /**
                 * So here's the story: loadDrive() returned -1, which it does ONLY if the specified disk is
                 * already mounted AND the user clicked OK to reload the original disk image.  So at the user's
                 * request, we toss any disk history, unload the disk, and then loop back around to loadDrive().
                 *
                 * loadDrive() should NEVER return -1 the second time, since no disk should be loaded, so this
                 * isn't really a loop, just a one-time retry operation.
                 */
                this.removeDiskHistory(sDiskName, sDiskPath);
                this.unloadDrive(iDrive, false, true);
            }
            return true;
        }
        this.printf(MESSAGE.NOTICE, "Unable to load the selected drive\n");
        return false;
    }

    /**
     * mountDrive(iDrive, sDiskName, sDiskPath)
     *
     * @this {FDC}
     * @param {number} iDrive
     * @param {string} sDiskName
     * @param {string} sDiskPath
     */
    mountDrive(iDrive, sDiskName, sDiskPath)
    {
        let drive = this.aDrives[iDrive];
        this.unloadDrive(iDrive, true, true);
        drive.fLocal = true;
        let disk = new Disk(this, drive, DiskAPI.MODE.PRELOAD);
        this.doneLoadDrive(drive, disk, sDiskName, sDiskPath, true);
    }

    /**
     * loadDrive(iDrive, sDiskName, sDiskPath, fAutoMount, file)
     *
     * NOTE: If sDiskPath is already loaded in the drive, nothing needs to be done.
     *
     * @this {FDC}
     * @param {number} iDrive
     * @param {string} sDiskName
     * @param {string} sDiskPath
     * @param {boolean} [fAutoMount]
     * @param {File} [file] is set if there's an associated File object
     * @param {function(Disk,number)} [done] optional callback on completion of the load request
     * @returns {number} 1 if diskette loaded, 0 if queued up (or busy), -1 if already loaded
     */
    loadDrive(iDrive, sDiskName, sDiskPath, fAutoMount, file, done)
    {
        let result = -1;
        let doneLoadDisk = (drive, disk, sDiskName, sDiskPath, error) => {
            this.doneLoadDrive(drive, disk, sDiskName, sDiskPath);
            if (done) done(disk, error);
        };
        let drive = this.aDrives[iDrive];
        if (!drive) {
            result = Errors.DOS.INVALID_DRIVE;
        }
        else if (sDiskPath) {
            sDiskPath = WebLib.redirectResource(sDiskPath);
            /**
             * TODO: Machines with saved states may be using lower-case disk image names, whereas we now use
             * UPPER-CASE names for disk images, so we upper-case both before comparing.  The only problem with
             * removing these hacks is that we can never be sure when all saved states in the wild have been updated.
             */
            if (drive.sDiskPath.toUpperCase() != sDiskPath.toUpperCase()) {
                result = 1;
                this.unloadDrive(iDrive, fAutoMount, true);
                if (drive.fBusy) {
                    this.printf(MESSAGE.NOTICE, "Drive %d busy\n", iDrive);
                    return 0;
                }
                drive.fBusy = true;
                if (fAutoMount) {
                    drive.fAutoMount = true;
                    this.cAutoMount++;
                    this.printf("loading diskette \"%s\"\n", sDiskName);
                }
                drive.fLocal = !!file;
                let disk = new Disk(this, drive, DiskAPI.MODE.PRELOAD);
                if (!disk.load(sDiskName, sDiskPath, file, doneLoadDisk)) {
                    result = 0;
                }
                return result;
            }
        }
        if (done) {
            done(drive && drive.disk, result);
        }
        return result;
    }

    /**
     * doneLoadDrive(drive, disk, sDiskName, sDiskPath, fAutoMount)
     *
     * @this {FDC}
     * @param {Object} drive
     * @param {Disk} disk (set if the disk was successfully loaded, null if not)
     * @param {string} sDiskName
     * @param {string} sDiskPath
     * @param {boolean} [fAutoMount]
     */
    doneLoadDrive(drive, disk, sDiskName, sDiskPath, fAutoMount)
    {
        let aDiskInfo;

        drive.fBusy = false;

        if (disk) {
            /**
             * We shouldn't mount the diskette unless the drive is able to handle it; for example, FD360 (40-track)
             * drives cannot read FD1200 (80-track) diskettes.  However, I no longer require that the diskette's
             * sectors/track fall within the drive's standard maximum, because XDF diskettes use 19 physical sectors/track
             * on the first cylinder (1 more than the typical 18 sectors/track found on 1.44Mb diskettes) but declare
             * a larger logical size (23 512-byte sectors/track) to reflect the actual capacity of XDF tracks beyond the
             * first cylinder (ie, one 8Kb sector, one 2Kb sector, one 1Kb sector, and one 512-byte sector).
             */
            aDiskInfo = disk.info();
            if (disk && aDiskInfo[0] > drive.nCylinders || aDiskInfo[1] > drive.nHeads /* || aDiskInfo[2] > drive.nSectors */) {
                this.printf(MESSAGE.NOTICE, "Diskette \"%s\" too large for drive %s\n", sDiskName, String.fromCharCode(0x41 + drive.iDrive));
                disk = null;
            }
        }

        if (disk) {
            drive.disk = disk;
            drive.sDiskName = sDiskName;
            drive.sDiskPath = sDiskPath;

            /**
             * Since we allow a diskette image to be auto-mounted even if it isn't in the machine's list of disks,
             * let's add it to the list now, since the disk apparently exists.
             */
            if (!this.findDisketteByPath(sDiskPath)) {
                this.addDiskette(sDiskName, sDiskPath);
            }

            /**
             * Adding local disk image names to the disk list seems like a nice idea, but it's too confusing,
             * because then it looks like the "Mount" button should be able to (re)load them, and that can NEVER
             * happen, for security reasons; local disk images can ONLY be loaded via the "Mount" button after
             * the user has selected them via the "Choose File" button.
             *
             *      this.addDiskette(sDiskName, sDiskPath);
             *
             * So we're going to take a different approach: when displayDiskette() is asked to display the name
             * of a local disk image, it will map all such disks to "Local Disk", and any attempt to "Mount" such
             * a disk, will essentially result in a "Disk not found" error.
             */
            this.addDiskHistory(sDiskName, sDiskPath, disk);

            /**
             * For a local disk (ie, one loaded via mountDrive()), the disk.restore() performed by addDiskHistory()
             * may have altered the disk geometry, so refresh the disk info.
             */
            aDiskInfo = disk.info();

            /**
             * Clearly, a successful mount implies a disk change, and I suppose that, technically, an *unsuccessful*
             * mount should imply the same, but what would the real-world analog be?  Inserting a piece of cardboard
             * instead of an actual diskette?  In any case, if we can do the user a favor by pretending (as far as the
             * disk change line is concerned) that an unsuccessful mount never happened, let's do it.
             *
             * Successful unmounts are a different story, however; those *do* trigger a change. See unloadDrive().
             */
            this.regInput |= FDC.REG_INPUT.DISK_CHANGE;

            /**
             * With the addition of notify(), users are now "alerted" whenever a diskette has finished loading;
             * notify() is selective about its output, using print() if a print window is open, alert() otherwise.
             *
             * TODO: Consider adding support for non-modal notices that appear briefly over the machine and then fade,
             * because these modal alerts quickly become annoying.  In the meantime, I now set fPrintOnly to true, on the
             * theory no message is a good sign, while load errors in disk.js should continue to trigger notifications.
             */
            if (!drive.fnCallReady) {
                this.printf(MESSAGE.STATUS, "Mounted \"%s\" (format %s) in drive %s\n", sDiskName, (disk.imageInfo && disk.imageInfo.format || "unknown"), String.fromCharCode(0x41 + drive.iDrive));
            }

            /**
             * Update the drive's current media parameters to match the disk's.
             */
            drive.nDiskCylinders = aDiskInfo[0];
            drive.nDiskHeads = aDiskInfo[1];
            drive.nDiskSectors = aDiskInfo[2];

            /**
             * Since you usually want the Computer to have focus again after loading a new diskette, let's try automatically
             * updating the focus after a successful load.
             */
            if (this.cmp) this.cmp.updateFocus(this.fAutoScroll);
        }
        else {
            drive.fLocal = false;
        }

        if (drive.fAutoMount) {
            drive.fAutoMount = false;
            if (!--this.cAutoMount) this.setReady();
        }

        this.displayDiskette(drive.iDrive);

        if (drive.fnCallReady) {
            drive.fnCallReady();
            drive.fnCallReady = null;
        }

        this.fAutoScroll = false;
    }

    /**
     * addDiskette(sName, sPath, fTop)
     *
     * @this {FDC}
     * @param {string} sName
     * @param {string} sPath
     * @param {boolean} [fTop] (default is bottom)
     */
    addDiskette(sName, sPath, fTop)
    {
        let controlDisks = this.bindings["listDisks"];
        if (controlDisks && controlDisks.options) {
            for (let i = 0; i < controlDisks.options.length; i++) {
                if (controlDisks.options[i].value == sPath) return;
            }
            let controlOption = document.createElement("option");
            controlOption.text = sName;
            controlOption.value = sPath;
            if (fTop && controlDisks.childNodes[0]) {
                controlDisks.insertBefore(controlOption, controlDisks.childNodes[0]);
            } else {
                controlDisks.appendChild(controlOption);
            }
        }
    }

    /**
     * addDiskettes(fSilent)
     *
     * @this {FDC}
     * @param {boolean} [fSilent]
     */
    addDiskettes(fSilent)
    {
        if (this.aDiskettes) {
            for (let i = 0; i < this.aDiskettes.length; i++) {
                let diskette = this.aDiskettes[i];
                this.addDiskette(diskette['name'], diskette['path']);
            }
        }
        /**
         * Why didn't we sort aDiskettes before adding them to the controlDisks list control?
         * Because that wouldn't handle any prepopulated entries already stored in the list control.
         */
        if (this.sortBy) {
            let i, aOptions = [], fdc = this;
            let controlDisks = this.bindings["listDisks"];
            if (controlDisks) {
                /**
                 * NOTE: All this monkeying around with copying the elements from control.options to aOptions
                 * and then back again is necessary because control.options isn't a *real* Array (at least not
                 * in all browsers); consequently, it may have no sort() method.  It has a length property,
                 * along with numeric properties 0 to length-1, but it's still probably just an Object, not
                 * an Array.
                 *
                 * Also note that changing the order of the control's options would ordinarily mean that the
                 * control's selectedIndex may now be incorrect, but in our case, it doesn't matter, because
                 * we have a special function, displayDiskette(), that will be called at LEAST once during
                 * initialization, ensuring that selectedIndex is set correctly.
                 */
                for (i = 0; i < controlDisks.options.length; i++)  {
                    aOptions.push(controlDisks.options[i]);
                }
                aOptions.sort(function(a, b) {
                    /**
                     * I've switched to localeCompare() because it offers case-insensitivity by default;
                     * I'm still a little concerned that we could somehow end up with list elements whose text
                     * and/or value properties are undefined (because calling a method on an undefined variable
                     * will throw an exception), but maybe I'm being overly paranoid....
                     */
                    if (fdc.sortBy != "path") {
                        return a.text.localeCompare(b.text);
                    } else {
                        return a.value.localeCompare(b.value);
                    }
                });
                for (i = 0; i < aOptions.length; i++)  {
                    try {
                        /**
                         * TODO: Determine why this line blows up in IE8; are the properties of an options object not settable in IE8?
                         */
                        controlDisks.options[i] = aOptions[i];
                    } catch(e) {
                        break;
                    }
                }
            }
        }

        this.addDiskette("None", "", true);
        if (this.fLocalDisks) this.addDiskette("Local Disk", "?");
        this.addDiskette("Remote Disk", "??");

        if (fSilent || !this.autoMount()) this.setReady();
    }

    /**
     * findDisketteByPath(sPath)
     *
     * This is used to deal with mount requests (eg, autoMount) that supply a path without a name;
     * if we can find the path in the "listDisks" control, then we return the associated disk name.
     *
     * @this {FDC}
     * @param {string} sPath
     * @returns {string|null}
     */
    findDisketteByPath(sPath)
    {
        let controlDisks = this.bindings["listDisks"];
        if (controlDisks) {
            if (controlDisks.options) {
                for (let i = 0; i < controlDisks.options.length; i++) {
                    let control = controlDisks.options[i];
                    if (control.value == sPath) return control.text;
                }
            }
        } else if (this.aDiskettes) {
            for (let i = 0; i < this.aDiskettes.length; i++) {
                let diskette = this.aDiskettes[i];
                if (diskette['path'] == sPath) return diskette['name'];
            }
        }
        return null;
    }

    /**
     * findDisketteByName(sName)
     *
     * This is used to deal with mount requests (eg, autoMount) that supply a name without a path;
     * if we can find the name in the "listDisks" control, then we return the associated disk path.
     *
     * @this {FDC}
     * @param {string|undefined} sName
     * @returns {string}
     */
    findDisketteByName(sName)
    {
        if (sName && sName != "None") {
            let controlDisks = this.bindings["listDisks"];
            if (controlDisks) {
                if (controlDisks.options) {
                    for (let i = 0; i < controlDisks.options.length; i++) {
                        let control = controlDisks.options[i];
                        if (control.text == sName) return control.value;
                    }
                }
            } else if (this.aDiskettes) {
                for (let i = 0; i < this.aDiskettes.length; i++) {
                    let diskette = this.aDiskettes[i];
                    if (diskette['name'] == sName) return diskette['path'];
                }
            }
            this.printf(MESSAGE.NOTICE, "Unable to find diskette \"%s\"\n", sName);
        }
        return "";
    }

    /**
     * getDiskList(controlDrives)
     *
     * In "the old days", the HTML control containing the list of all available diskettes was stored in:
     *
     *      this.bindings["listDisks"]
     *
     * and it still is.  But now, if the HDC component decides to overload our drive list with one or more
     * of its own drives (eg, "CD"), then our drive/diskette controls must be thought of as general-purpose
     * "Removable Media" controls that the FDC just happens to manage for historical reasons.  This avoids
     * cluttering the UI with multiple drop-downs when there are multiple types of removable disk drives.
     *
     * To detect that situation, the name of the selected drive must be checked against the list of external
     * drives, and if there's a match, then we "swap" the disks control normally used by the FDC with the one
     * provided by the HDC; similarly, if there's no longer a match BUT externalActive is set, when we know
     * that a swap is still active and that we must "unswap" them, putting the FDC's original diskette control
     * back in place.
     *
     * TODO: It would be nice to generalize this someday, and support separate diskette lists for separate
     * diskette drive types; for example, if a machine wants to have a 1.2Mb floppy drive for A: and a 360Kb
     * or 1.44Mb floppy drive for B:, it would be nice to have the diskettes segregated by type as well.
     * The FDC will try to alert you whenever you attempt to mount a diskette in a drive that can't support it,
     * but it would be even better if those diskette images weren't listed for that drive in the first place.
     *
     * @this {FDC}
     * @param {number} iDrive
     * @returns {HTMLSelectElement|undefined}
     */
    getDiskList(iDrive)
    {
        let drive;
        let controlDisks1, controlDisks2;
        let controlDrives = this.bindings["listDrives"];
        if (controlDrives && controlDrives.options) {
            let option = controlDrives.options[controlDrives.selectedIndex];
            if (option) {
                let driveName = option.textContent;
                controlDisks1 = this.bindings["listDisks"];
                if (this.externalDrives[driveName]) {
                    if (!this.externalActive) {
                        controlDisks2 = this.externalDrives[driveName].controlDisks;
                        this.externalActive = driveName;
                    }
                    drive = this.externalDrives[driveName].drive;
                } else {
                    if (this.externalActive) {
                        controlDisks2 = controlDisks1;
                        controlDisks1 = this.externalDrives[this.externalActive].controlDisks;
                        this.externalActive = null;
                    }
                    drive = this.aDrives[iDrive];
                }
            }
        }
        if (controlDisks1 && controlDisks2) {           // swap controlDisks1 and controlDisks2
            let next2 = controlDisks2.nextSibling;      // save the location of controlDisks2
            let parent2 = controlDisks2.parentNode;
            if (next2 === controlDisks1) {              // if controlDisks1 is the next sibling of controlDisks2,
                parent2.insertBefore(                   // just put controlDisks1 before controlDisks2
                    controlDisks1, controlDisks2
                );
            } else {                                    // otherwise, insert controlDisks2 right before controlDisks1
                controlDisks1.parentNode.insertBefore(  // and insert controlDisks1 where controlDisks2 was
                    controlDisks2, controlDisks1
                );
                if (next2) {                            // if there was an element after controlDisks2, insert controlDisks1 right before that
                    parent2.insertBefore(controlDisks1, next2);
                } else {                                // otherwise, just append as last child
                    parent2.appendChild(controlDisks1);
                }
            }
            /**
             * Propagate the actual width (scrollWidth) of the currently visible control to the control we're
             * about to make visible in its place, so that there's no discernable change in the overall layout.
             */
            controlDisks2.style.width = controlDisks1.scrollWidth + "px";
            controlDisks1.style.display = "none";
            controlDisks2.style.display = "inline-block";
            controlDisks1 = controlDisks2;
        }
        /**
         * We need to return multiple values: the requested disk list (controlDisks1) AND the associated drive,
         * since both may now be managed by the HDC; we cheat and return the drive as an FDC property (driveActive).
         *
         * The "Active" designations are a bit of a misnomer; externalActive and driveActive refer only to the
         * drive that's currently displayed in the drive list.  Let's just say they're being "actively" displayed.
         */
        if (drive) {
            this.driveActive = drive;
        } else {
            controlDisks1 = undefined;
        }
        return controlDisks1;
    }

    /**
     * displayDiskette(iDrive, fDriveChange)
     *
     * @this {FDC}
     * @param {number} iDrive (unvalidated)
     * @param {boolean} [fDriveChange] (true if selected drive was changed, false if selected drive should be updated)
     */
    displayDiskette(iDrive, fDriveChange)
    {
        let controlDisks = this.getDiskList(iDrive);
        if (controlDisks) {
            /**
             * Next, make sure the drive whose disk we're updating is the currently selected drive.
             */
            let drive = this.driveActive;
            let controlDrives = this.bindings["listDrives"];
            let i, iDriveSelected = StrLib.parseInt(controlDrives.value, 10);
            let sTargetPath = (drive.fLocal? "?" : drive.sDiskPath);
            if (!isNaN(iDriveSelected) && iDriveSelected == iDrive) {
                for (i = 0; i < controlDisks.options.length; i++) {
                    if (controlDisks.options[i].value == sTargetPath) {
                        if (controlDisks.selectedIndex != i) {
                            controlDisks.selectedIndex = i;
                        }
                        break;
                    }
                }
                if (i == controlDisks.options.length) controlDisks.selectedIndex = 0;
            }
            if (fDriveChange === false) {
                /**
                 * Update the selected drive to match the specified drive (and its write-protected state, if any).
                 */
                for (i = 0; i < controlDrives.options.length; i++) {
                    if (+controlDrives.options[i].value == drive.iDrive) {
                        if (controlDrives.selectedIndex != i) {
                            controlDrives.selectedIndex = i;
                        }
                        if (drive.fWritable === false) controlDrives.selectedIndex++;
                        break;
                    }
                }
            }
            else if (fDriveChange === true && drive.fWritable !== undefined) {
                /**
                 * Odd drive entries are asterisked (eg, "A*" rather than "A:"), providing the user with a mechanism for
                 * automatically write-protecting all disk images mounted in the drive.  External drives (eg, CD-ROM drives)
                 * don't define fWritable, not because the drive's writability isn't known but rather because we don't want
                 * separate (write-protected) drive entries defined for them.
                 */
                if (controlDrives.selectedIndex >= 0) {
                    if (drive.fWritable != !(controlDrives.selectedIndex & 0x1)) {
                        drive.fWritable = !drive.fWritable;
                        if (!drive.fWritable) {
                            this.printf(MESSAGE.NOTICE, "Any diskette loaded in this drive will now be write-protected.");
                        }
                    }
                }
            }
        }
    }

    /**
     * updateSelectedDiskette()
     *
     * @this {FDC}
     */
    updateSelectedDiskette()
    {
        let control = this.bindings["listDisks"];
        let controlDesc = this.bindings["descDisk"];
        let controlOption = control.options[control.selectedIndex];
        if (controlDesc && controlOption) {
            let dataValue = {};
            let sValue = controlOption.getAttribute("data-value");
            if (sValue) {
                try {
                    dataValue = eval("(" + sValue + ")");
                } catch (e) {
                    Component.error(this.type + " option error: " + e.message);
                }
            }
            let sHTML = dataValue['desc'];
            if (sHTML === undefined) sHTML = "";
            let sHRef = dataValue['href'];
            if (sHRef !== undefined) sHTML = "<a href=\"" + sHRef + "\" target=\"_blank\">" + sHTML + "</a>";
            controlDesc.innerHTML = sHTML;
        }
    }

    /**
     * waitDrives(fnCallReady)
     *
     * @this {FDC}
     * @param {function()|null} fnCallReady
     * @returns {boolean} false if wait required, true otherwise
     */
    waitDrives(fnCallReady)
    {
        for (let iDrive = 0; iDrive < this.aDrives.length; iDrive++) {
            let drive = this.aDrives[iDrive];
            if (drive && drive.fBusy) {
                if (!drive.fnCallReady) drive.fnCallReady = fnCallReady;
                return false;
            }
        }
        return true;
    }

    /**
     * unloadDrive(iDrive, fAutoUnload, fQuiet)
     *
     * @this {FDC}
     * @param {number} iDrive (pre-validated)
     * @param {boolean} [fAutoUnload] is true if this unload is being forced as part of an automount and/or restored mount
     * @param {boolean} [fQuiet]
     * @returns {boolean} true if diskette unloaded, false if not
     */
    unloadDrive(iDrive, fAutoUnload, fQuiet)
    {
        let drive = this.aDrives[iDrive];
        if (drive.disk) {
            /**
             * Before we toss the disk's information, capture any deltas that may have occurred.
             */
            this.updateDiskHistory(drive.sDiskName, drive.sDiskPath, drive.disk);
            drive.sDiskName = "";
            drive.sDiskPath = "";
            drive.disk = null;
            drive.fLocal = false;

            this.regInput |= FDC.REG_INPUT.DISK_CHANGE;

            /**
             * TODO: Consider adding support for non-modal notices that appear briefly over the machine and then fade,
             * because these modal alerts quickly become annoying.  In the meantime, I now set fPrintOnly to true, on the
             * theory no message is a good sign, while load errors in disk.js should continue to trigger notifications.
             */
            if (!fQuiet) {
                this.printf(MESSAGE.STATUS, "Drive %s unloaded\n", String.fromCharCode(0x41 + iDrive));
            }
            /**
             * Try to avoid any unnecessary hysteresis regarding the diskette display if this unload is merely
             * a prelude to another load.
             */
            if (!fAutoUnload && !fQuiet) {
                this.displayDiskette(iDrive);
            }
            return true;
        }
        return false;
    }

    /**
     * unloadAllDrives(fDiscard)
     *
     * @this {FDC}
     * @param {boolean} fDiscard to discard all disk history before unloading
     */
    unloadAllDrives(fDiscard)
    {
        if (fDiscard) {
            this.aDiskHistory = [];
        }
        for (let iDrive = 0; iDrive < this.aDrives.length; iDrive++) {
            this.unloadDrive(iDrive, true);
        }
    }

    /**
     * addDiskHistory(sDiskName, sDiskPath, disk)
     *
     * @this {FDC}
     * @param {string} sDiskName
     * @param {string} sDiskPath
     * @param {Disk} disk containing corresponding disk image
     */
    addDiskHistory(sDiskName, sDiskPath, disk)
    {
        let i;
        //
        for (i = 0; i < this.aDiskHistory.length; i++) {
            if (this.aDiskHistory[i][1] == sDiskPath) {
                let nChanges = disk.restore(this.aDiskHistory[i][2]);
                if (DEBUG) this.printf("disk '%s' restored from history (%d changes)\n", sDiskName, nChanges);
                return;
            }
        }
        if (DEBUG) this.printf("disk '%s' added to history (nothing to restore)\n", sDiskName);
        this.aDiskHistory[i] = [sDiskName, sDiskPath, []];
    }

    /**
     * removeDiskHistory(sDiskName, sDiskPath)
     *
     * @this {FDC}
     * @param {string} sDiskName
     * @param {string} sDiskPath
     */
    removeDiskHistory(sDiskName, sDiskPath)
    {
        let i;
        for (i = 0; i < this.aDiskHistory.length; i++) {
            if (this.aDiskHistory[i][1] == sDiskPath) {
                this.aDiskHistory.splice(i, 1);
                if (DEBUG) this.printf("disk '%s' removed from history\n", sDiskName);
                return;
            }
        }
        if (DEBUG) this.printf("unable to remove disk '%s' from history (%s)\n", sDiskName, sDiskPath);
    }

    /**
     * updateDiskHistory(sDiskName, sDiskPath, disk)
     *
     * @this {FDC}
     * @param {string} sDiskName
     * @param {string} sDiskPath
     * @param {Disk} disk containing corresponding disk image, with possible deltas
     */
    updateDiskHistory(sDiskName, sDiskPath, disk)
    {
        let i;
        for (i = 0; i < this.aDiskHistory.length; i++) {
            if (this.aDiskHistory[i][1] == sDiskPath) {
                this.aDiskHistory[i][2] = disk.save();
                if (DEBUG) this.printf("disk '%s' updated in history\n", sDiskName);
                return;
            }
        }
        /**
         * I used to report this as an error (at least in the DEBUG release), but it's no longer really
         * an error, because if we're trying to re-mount a clean copy of a disk, we toss its history, then
         * unload, and then reload/remount.  And since unloadDrive's normal behavior is to call updateDiskHistory()
         * before unloading, the fact that the disk is no longer listed here can't be treated as an error.
         */
        if (DEBUG) this.printf("unable to update disk '%s' in history (%s)\n", sDiskName, sDiskPath);
    }

    /**
     * outFDCOutput(port, bOut, addrFrom)
     *
     * @this {FDC}
     * @param {number} port (0x3F2, output only)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     */
    outFDCOutput(port, bOut, addrFrom)
    {
        this.printIO(port, bOut, addrFrom, "OUTPUT");
        if (!(bOut & FDC.REG_OUTPUT.ENABLE)) {
            this.initController();
            /**
             * initController() resets, among other things, the selected drive (this.iDrive), so if we were
             * still updating this.iDrive below based on the "drive select" bits in regOutput, we would want
             * to make sure those bits now match what initController() set.  But since we no longer do that
             * (see below), this is no longer needed either.
             *
             *      bOut = (bOut & ~FDC.REG_OUTPUT.DS) | this.iDrive;
             */
        }
        else if (!(this.regOutput & FDC.REG_OUTPUT.ENABLE)) {
            /**
             * When FDC.REG_OUTPUT.ENABLE transitions from 0 to 1, generate an interrupt (assuming INT_ENABLE is set).
             */
            this.regOutput = bOut;      // this may look redundant but requestInterrupt() needs to see regOutput set
            this.requestInterrupt();
        }
        /**
         * This no longer updates the internally selected drive (this.iDrive) based on regOutput, because (a) there seems
         * to be no point, as all drive-related commands include their own "drive select" bits, and (b) it breaks the
         * MODEL_5170 boot code.  Here's why:
         *
         * Unlike previous models, the MODEL_5170 BIOS probes all installed diskette drives to determine drive type;
         * ie, FD360 (40-track) or FD1200 (80-track).  So if there are two drives, the last selected drive will be drive 1.
         * Immediately before booting, the BIOS issues an INT 0x13/AH=0 reset, which writes regOutput two times: first
         * with FDC.REG_OUTPUT.ENABLE clear, and then with it set.  However, both times, it ALSO loads the last selected
         * drive number into regOutput's "drive select" bits.
         *
         * If we switched our selected drive to match regOutput, then the ST0 value we returned on an SENSE_INT command
         * following the regOutput reset operation would indicate drive 1 instead of drive 0.  But the BIOS requires
         * the ST0 result from the SENSE_INT command ALWAYS be 0xC0 (not 0xC1), so the controller must not be propagating
         * regOutput's "drive select" bits in the way I originally assumed.
         *
         *      let iDrive = bOut & FDC.REG_OUTPUT.DS;
         *      if (bOut & (FDC.REG_OUTPUT.MOTOR_D0 << iDrive)) this.iDrive = iDrive;
         */
        this.regOutput = bOut;
    }

    /**
     * inFDCDiagnostic(port, addrFrom)
     *
     * It turns out that any 5170 configuration without an HDC component that attempts to use either the REV2 or REV3
     * PC AT ROM BIOS will fail with error "601-Diskette Error", unless we also provide this "D/S/P DIAGNOSTIC REGISTER".
     * The original 5170 REV1 BIOS didn't have this requirement.
     *
     * I'm unable to find any documentation on this so-called "D/S/P DIAGNOSTIC REGISTER" (port 0x3F1) or the "D/S/P CARD"
     * to which the ROM BIOS refers.  But it seems clear that if we don't provide the expected response from the DIAGNOSTIC
     * REGISTER, and there's no HDC to respond to the MULTIPLE DATA RATE CAPABLE test that follows, then an error is
     * inevitable.  Clearly, there is a very intimate relationship between the FDC and HDC portions of this card.
     *
     * Here's the relevant code from the REV3 PC AT ROM BIOS (TEST2.ASM):
     *
     *      ;-----  CHECK FOR MULTIPLE DATA RATE CAPABILITY
     *
     *      J_OK:
     *              MOV     DX,03F1H                ; D/S/P DIAGNOSTIC REGISTER
     *              IN      AL,DX                   ; READ D/S/P TYPE CODE
     *              AND     AL,11111000B            ; KEEP ONLY UNIQUE CODE FOR D/S/P
     *              CMP     AL,01010000B            ; D/S/P CARD - MULTIPLE DATA RATE?
     *              JZ      J_OK3                   ; IF SO JUMP
     *
     *              MOV     DX,05F7H                ; FIXED DISK DIAGNOSTIC REGISTER
     *              IN      AL,DX                   ; READ FIXED DISK TYPE CODE
     *              AND     AL,11110000B            ; KEEP ONLY UNIQUE CODE FOR F/D
     *              CMP     AL,10100000B            ; FIXED DISK ADAPTER ?
     *              JZ      J_FAIL                  ; MUST BE COMBO ELSE ERROR
     *
     *              MOV     BL,0FH                  ; OUTER LOOP COUNT WAIT FOR BUSY OFF
     *              SUB     CX,CX
     *              MOV     DX,01F7H                ; HARD FILE STATUS PORT
     *      J_OK1:
     *              IN      AL,DX                   ; GET THE STATUS
     *              TEST    AL,080H                 ; IS THE CONTROLLER BUSY?
     *              JZ      J_OK2                   ; CONTINUE IF NOT
     *              LOOP    J_OK1                   ; TRY AGAIN
     *              DEC     BL                      ; DECREMENT OUTER LOOP
     *              JNZ     J_OK1                   ; TRY AGAIN IF NOT ZERO
     *              AND     AL,0CH                  ; BITS 2 & 3 = 0 IF MULTI DATA CAPABLE
     *              JZ      J_OK3                   ; GO IF YES
     *              JMP     SHORT J_FAIL            ; NO MULTIPLE DATA RATE CAPABILITY
     *      J_OK2:
     *              MOV     DX,1F4H                 ; VERIFY MULTIPLE DATA RATE CAPABLE
     *              MOV     AL,055H                 ; WRITE TO THE CYLINDER BYTE
     *              OUT     DX,AL
     *              JMP     $+2                     ; I/O DELAY
     *              IN      AL,DX                   ; CHECK DATA WRITTEN = DATA READ
     *              CMP     AL,055H
     *              JNZ     J_FAIL                  ; GO IF NOT
     *              MOV     AL,0AAH                 ; WRITE ANOTHER PATTERN
     *              OUT     DX,AL
     *              JMP     $+2                     ; I/O DELAY
     *              IN      AL,DX
     *              CMP     AL,0AAH                 ; IS DATA PATTERN THE SAME?
     *              JZ      J_OK3                   ; GO IF SO
     *
     *      J_FAIL:
     *              OR      @MFG_ERR_FLAG+1,DSK_FAIL;       <><><><><><><><><><><><><>
     *                                              ;       <><> DISKETTE FAILED  <><>
     *              MOV     SI,OFFSET E601          ; GET ADDRESS OF MESSAGE
     *              CALL    E_MSG                   ; GO PRINT ERROR MESSAGE
     *              JMP     SHORT F15C              ; SKIP SETUP IF ERROR
     *
     *      J_OK3:
     *              OR      @LASTRATE,DUAL          ; TURN ON DSP/COMBO FLAG
     *
     * @this {FDC}
     * @param {number} port (0x3F1, input only)
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     * @returns {number} simulated port value
     */
    inFDCDiagnostic(port, addrFrom)
    {
        let b = 0x50;       // we simply return the expected pattern (01010000B); see code excerpt above
        this.printIO(port, undefined, addrFrom, "DIAG", b);
        return b;
    }

    /**
     * inFDCStatus(port, addrFrom)
     *
     * @this {FDC}
     * @param {number} port (0x3F4, input only)
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     * @returns {number} simulated port value
     */
    inFDCStatus(port, addrFrom)
    {
        this.printIO(port, undefined, addrFrom, "STATUS", this.regStatus);
        return this.regStatus;
    }

    /**
     * inFDCData(port, addrFrom)
     *
     * @this {FDC}
     * @param {number} port (0x3F5, input/output)
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     * @returns {number} simulated port value
     */
    inFDCData(port, addrFrom)
    {
        let bIn = 0;
        if (this.regDataIndex < this.regDataTotal) {
            bIn = this.regDataArray[this.regDataIndex];
        }
        /**
         * As per the discussion in doCmd(), once the first byte of the Result Phase has been read, the interrupt must be cleared.
         */
        if (this.regOutput & FDC.REG_OUTPUT.INT_ENABLE) {
            if (this.chipset) this.chipset.clearIRR(ChipSet.IRQ.FDC);
        }
        if (this.messageEnabled()) {
            this.printIO(port, undefined, addrFrom, "DATA[" + this.regDataIndex + "]", bIn);
        }
        if (++this.regDataIndex >= this.regDataTotal) {
            this.regStatus &= ~(FDC.REG_STATUS.READ_DATA | FDC.REG_STATUS.BUSY);
            this.regDataIndex = this.regDataTotal = 0;
        }
        return bIn;
    }

    /**
     * outFDCData(port, bOut, addrFrom)
     *
     * @this {FDC}
     * @param {number} port (0x3F5, input/output)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     */
    outFDCData(port, bOut, addrFrom)
    {
        if (this.messageEnabled()) {
            this.printIO(port, bOut, addrFrom, "DATA[" + this.regDataTotal + "]");
        }

        if (this.regDataTotal < this.regDataArray.length) {
            this.regDataArray[this.regDataTotal++] = bOut;
        }
        let bCmd = this.regDataArray[0];
        let bCmdMasked = bCmd & FDC.REG_DATA.CMD.MASK;
        if (FDC.aCmdInfo[bCmdMasked] !== undefined) {
            if (this.regDataTotal >= FDC.aCmdInfo[bCmdMasked].cbReq) {
                this.doCmd();
            }
            return;
        }
        this.printf("unsupported FDC command: %02x\n", bCmd);
        if (MAXDEBUG) this.dbg.stopCPU();
    }

    /**
     * inFDCInput(port, addrFrom)
     *
     * TODO: We're never actually setting any of the head or drive select bits.  I would guess
     * that the latter, at least, should mirror the drive select value written to port 0x3F2.
     *
     * @this {FDC}
     * @param {number} port (0x3F7, input only, MODEL_5170 only)
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     * @returns {number} simulated port value
     */
    inFDCInput(port, addrFrom)
    {
        let bIn = this.regInput;
        /**
         * TODO: Determine when the DISK_CHANGE bit is *really* cleared (this is just a guess)
         */
        this.regInput &= ~FDC.REG_INPUT.DISK_CHANGE;
        this.printIO(port, undefined, addrFrom, "INPUT", bIn);
        return bIn;
    }

    /**
     * outFDCControl(port, bOut, addrFrom)
     *
     * @this {FDC}
     * @param {number} port (0x3F7, output only, MODEL_5170 only)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     */
    outFDCControl(port, bOut, addrFrom)
    {
        this.printIO(port, bOut, addrFrom, "CONTROL");
        this.regControl  = bOut;
    }

    /**
     * doCmd()
     *
     * @this {FDC}
     */
    doCmd()
    {
        let fIRQ = false;
        this.regDataIndex = 0;
        let bCmd = this.popCmd();
        let drive, bDrive, bHead, c, h, r, n;

        /**
         * NOTE: We currently ignore the FDC.REG_DATA.CMD.SK, FDC.REG_DATA.CMD.MF and FDC.REG_DATA.CMD.MT bits of every command.
         * The only command bit of possible interest down the road might be the FDC.REG_DATA.CMD.MT (Multi-Track); the rest relate
         * to storage format details that we cannot emulate as long as our diskette images contain nothing more than sector
         * data without any formatting data.
         *
         * Similarly, we ignore parameters like SRT, HUT, HLT and the like, since our "motors" don't require physical delays;
         * however, if timing issues become compatibility issues, we'll have to revisit those delays.  In any case, the maximum
         * speed of the simulation will still be limited by various spin-loops in the ROM BIOS that wait prescribed times, so even
         * with infinitely fast hardware, the simulation will never run as fast as it theoretically could, unless we opt to identify
         * those spin-loops and either patch them or skip over them.
         */
        let ledState;
        let bCmdMasked = bCmd & FDC.REG_DATA.CMD.MASK;

        switch (bCmdMasked) {
        case FDC.REG_DATA.CMD.SPECIFY:                      // 0x03
            this.popSRT();                                  // SRT and HUT (encodings?)
            this.popHLT();                                  // HLT and ND (encodings?)
            this.beginResult();
            /**
             * No results are provided by this command, and fIRQ should remain false
             */
            break;

        case FDC.REG_DATA.CMD.SENSE_DRIVE:                  // 0x04
            bDrive = this.popCmd(FDC.TERMS.DS);
            bHead = (bDrive >> 2) & 0x1;
            this.iDrive = (bDrive & 0x3);
            drive = this.aDrives[this.iDrive];
            this.beginResult();
            this.pushST3(drive);
            break;

        case FDC.REG_DATA.CMD.WRITE_DATA:                   // 0x05
            ledState = Panel.STATE.WRITE;
            /* fall through */

        case FDC.REG_DATA.CMD.READ_DATA:                    // 0x06
        case FDC.REG_DATA.CMD.READ_TRACK:                   // 0x02
            if (!ledState) ledState = Panel.STATE.READ;
            bDrive = this.popCmd(FDC.TERMS.DS);             // Drive Select
            bHead = (bDrive >> 2) & 0x1;                    // isolate HD (Head Select) bits
            this.iDrive = (bDrive & 0x3);                   // isolate DS (Drive Select, aka Unit Select) bits
            drive = this.aDrives[this.iDrive];
            drive.bHead = bHead;
            c = drive.bCylinder = this.popCmd(FDC.TERMS.C); // C
            h = this.popCmd(FDC.TERMS.H);                   // H
            /**
             * Controller docs say that H should always match HD, so I assert that, but what if someone
             * made a mistake and didn't program them identically -- what would happen?  Which should we honor?
             */

            r = drive.bSector = this.popCmd(FDC.TERMS.R);   // R
            n = this.popCmd(FDC.TERMS.N);                   // N
            drive.nBytes = 128 << n;                        // 0 => 128, 1 => 256, 2 => 512, 3 => 1024
            drive.bSectorEnd = this.popCmd(FDC.TERMS.EOT);  // EOT (final sector number on a cylinder)
            this.popCmd(FDC.TERMS.GPL);                     // GPL (spacing between sectors, excluding VCO Sync Field; 3)
            this.popCmd(FDC.TERMS.DTL);                     // DTL (when N is 0, DTL stands for the data length to read out or write into the sector)
            this.setLED(ledState);
            if (drive.disk && drive.disk.nSectors >= 15 && this.regControl != FDC.REG_CONTROL.RATE500K) {
                /**
                 * Originally, I only set RES.INCOMPLETE (which is an ST0 result byte), because that's all that MINIX 1.1
                 * relied upon to differentiate 1.2M media from 360K media, but the COMPAQ DeskPro 386 ROM has a similar
                 * dependency AND requires that an error appear in the ST1 result byte as well -- so I added RES.NO_DATA to
                 * the result code.
                 *
                 * The change for the DeskPro had a further impact: after it issues an INT 13h to read the boot sector, it
                 * probes the diskette to look for any inconsistency between the presumed drive type and the CMOS setting;
                 * for example, when I booted a 1.2M disk (which has 15 sectors/track) in a "1200" drive, the DeskPro 386 ROM
                 * would then attempt to read sector 16, which it assumes would only work in "1440" drives, but since I didn't
                 * return an error (the ROM was using DMA_MODE.TYPE_VERIFY, which doesn't trigger any FDC I/O and consequently
                 * no error), the ROM decided there was a drive type inconsistency and reported a setup error.
                 *
                 * I eliminated the error by changing all DeskPro 386 machine configs to use the "1440" floppy drive type,
                 * which has the added benefit of allowing any size floppy to work with those machines, but that solution is
                 * "papering over" the FDC's failure to report an error reading non-existent sectors when the DMA mode is
                 * TYPE_VERIFY instead of TYPE_READ or TYPE_WRITE.
                 */
                drive.resCode = FDC.REG_DATA.RES.INCOMPLETE | FDC.REG_DATA.RES.NO_DATA;
                fIRQ = true;
            } else {
                if (bCmdMasked != FDC.REG_DATA.CMD.WRITE_DATA) {
                    fIRQ = this.doRead(drive);
                } else {
                    fIRQ = this.doWrite(drive);
                }
            }
            this.pushResults(drive, bCmd, bHead, c, h, r, n);
            break;

        case FDC.REG_DATA.CMD.RECALIBRATE:                  // 0x07
            bDrive = this.popCmd(FDC.TERMS.DS);
            this.iDrive = (bDrive & 0x3);
            drive = this.aDrives[this.iDrive];
            drive.bCylinder = drive.bCylinderSeek = 0;
            drive.resCode = FDC.REG_DATA.RES.SEEK_END | FDC.REG_DATA.RES.TRACK0;
            this.beginResult();                             // no results provided; this command is typically followed by FDC.REG_DATA.CMD.SENSE_INT
            fIRQ = true;
            break;

        case FDC.REG_DATA.CMD.SENSE_INT:                    // 0x08
            drive = this.aDrives[this.iDrive];
            drive.bHead = 0;                                // this command is documented as ALWAYS returning a head address of 0 in ST0; see pushST0()
            this.beginResult();
            this.pushST0(drive);
            this.pushResult(drive.bCylinder, FDC.TERMS.PCN);
            /**
             * For some strange reason, the "DISK_RESET" function in the MODEL_5170_REV3 BIOS resets the
             * adapter and then issues FOUR -- that's right, not ONE but FOUR -- SENSE INTERRUPT STATUS commands
             * in a row, and expects ST0 to contain a different drive number after each command (first 0, then 1,
             * then 2, and finally 3).  What makes this doubly weird is SENSE INTERRUPT STATUS (unlike SENSE
             * DRIVE STATUS) is a drive-agnostic command.
             *
             * Didn't the original PC AT "HFCOMBO" controller limit support to TWO diskette drives max?
             * And even if the PC AT supported other FDC controllers that DID support up to FOUR diskette drives,
             * why should "DISK_RESET" hard-code a 4-drive loop?
             *
             * Well, whatever.  All this head-scratching doesn't change the fact that I apparently have to
             * "auto-increment" the internal drive number (this.iDrive) after each SENSE INTERRUPT STATUS command.
             */
            this.iDrive = (this.iDrive + 1) & 0x3;
            /**
             * No interrupt is generated by this command, so fIRQ should remain false.
             */
            break;

        case FDC.REG_DATA.CMD.READ_ID:                      // 0x0A
            /**
             * This command is used by "SETUP_DBL" in the MODEL_5170_REV3 BIOS to determine if a double-density
             * (40-track) diskette has been inserted in a high-density (80-track) drive; ie, whether "double stepping"
             * is required, since only 40 of the 80 possible "steps" are valid for a double-density diskette.
             *
             * To start, we'll focus on making this work in the normal case (80-track diskette in 80-track drive).
             */
            bDrive = this.popCmd(FDC.TERMS.DS);
            bHead = (bDrive >> 2) & 0x1;
            this.iDrive = (bDrive & 0x3);
            drive = this.aDrives[this.iDrive];
            c = drive.bCylinder;
            h = drive.bHead = bHead;
            r = drive.bSector = 1;
            n = 0;
            drive.resCode = FDC.REG_DATA.RES.NONE;
            if (drive.disk && (drive.sector = drive.disk.seek(drive.bCylinder, drive.bHead, drive.bSector))) {
                n = (drive.sector['length'] >> 8);
            } else {
                /**
                 * TODO: Determine the appropriate response code(s) for the possible errors that can occur here.
                 */
                drive.resCode = FDC.REG_DATA.RES.NOT_READY | FDC.REG_DATA.RES.INCOMPLETE;
            }
            this.pushResults(drive, bCmd, bHead, c, h, r, n);
            fIRQ = true;
            break;

        case FDC.REG_DATA.CMD.FORMAT_TRACK:                 // 0x0D
            bDrive = this.popCmd(FDC.TERMS.DS);
            bHead = (bDrive >> 2) & 0x1;
            this.iDrive = (bDrive & 0x3);
            drive = this.aDrives[this.iDrive];
            c = drive.bCylinder;
            h = drive.bHead = bHead;
            r = 1;
            n = this.popCmd(FDC.TERMS.N);                   // N
            drive.nBytes = 128 << n;                        // 0 => 128, 1 => 256, 2 => 512, 3 => 1024 (bytes/sector)
            drive.bSectorEnd = this.popCmd(FDC.TERMS.SC);   // SC (sectors/track)
            this.popCmd(FDC.TERMS.GPL);                     // GPL (spacing between sectors, excluding VCO Sync Field; 3)
            drive.bFiller = this.popCmd(FDC.TERMS.D);       // D (filler byte)
            this.doFormat(drive);
            this.pushResults(drive, bCmd, bHead, c, h, r, n);
            fIRQ = true;
            break;

        case FDC.REG_DATA.CMD.SEEK:                         // 0x0F
            bDrive = this.popCmd(FDC.TERMS.DS);
            bHead = (bDrive >> 2) & 0x1;
            this.iDrive = (bDrive & 0x3);
            drive = this.aDrives[this.iDrive];
            drive.bHead = bHead;
            /**
             * As discussed in initDrive(), we can no longer simply set bCylinder to the specified NCN;
             * instead, we must calculate the delta between bCylinderSeek and the NCN, and adjust bCylinder
             * by that amount.  Then we simply move the NCN into bCylinderSeek without any range checking.
             *
             * Since bCylinder is now expressly defined as the "physical" cylinder number, it must never
             * be allowed to exceed the physical boundaries of the drive (ie, never lower than 0, and never
             * greater than or equal to nCylinders).
             */
            c = this.popCmd(FDC.TERMS.NCN);
            drive.bCylinder += c - drive.bCylinderSeek;
            if (drive.bCylinder < 0) drive.bCylinder = 0;
            if (drive.bCylinder >= drive.nCylinders) drive.bCylinder = drive.nCylinders - 1;
            drive.bCylinderSeek = c;
            drive.resCode = FDC.REG_DATA.RES.SEEK_END;
            /**
             * TODO: To properly support ALL the ST3 result bits (not just TRACK0), we need a resCode
             * update() function that all FDC commands can use.  This code is merely sufficient to get us
             * through the "DSKETTE_SETUP" gauntlet in the MODEL_5170 BIOS.
             */
            if (!drive.bCylinder) {
                drive.resCode |= FDC.REG_DATA.RES.TRACK0;
            }
            this.beginResult();                             // like FDC.REG_DATA.CMD.RECALIBRATE, no results are provided
            fIRQ = true;
            break;

        default:
            this.printf("unsupported FDC operation: %02x\n", bCmd);
            if (MAXDEBUG) this.dbg.stopCPU();
            break;
        }

        if (this.regDataTotal > 0) {
            this.regStatus |= (FDC.REG_STATUS.READ_DATA | FDC.REG_STATUS.BUSY);
        }

        /**
         * After the Execution Phase (eg, DMA Terminal Count has occurred, or the EOT sector has been read/written),
         * an interrupt is supposed to occur, signaling the beginning of the Result Phase.  Once the first byte of the
         * result has been read, the interrupt is cleared (see inFDCData).
         *
         * TODO: Technically, interrupt request status should be cleared by the FDC.REG_DATA.CMD.SENSE_INT command; in fact,
         * if that command is issued and no interrupt was pending, then FDC.REG_DATA.RES.INVALID should be returned (via ST0).
         *
         * NOTE: When the COMPAQ DeskPro 386 BIOS attempts to read from an empty diskette drive, it waits quite a while
         * before giving up waiting for an interrupt, which results in a rather lengthy boot time.  That's probably my fault,
         * but without an actual DeskPro 386 to play with, I'm not sure what I might be doing wrong.
         *
         * However, it turns out there's a simple work-around: always deliver an interrupt after the READ command on the
         * the DeskPro 386, because it appears to actually pay attention to the NOT_READY bit in the ST0 result byte.  On
         * IBM machines, I still do not deliver an interrupt in the NOT_READY case, because for the IBM BIOS to return
         * a "not ready" (aka TIME_OUT) error, its WAIT_INT function has to actually time out (ie, no interrupt can occur).
         */
        if (!drive || (drive.resCode & FDC.REG_DATA.RES.NOT_READY) && this.chipset.model < ChipSet.MODEL_COMPAQ_DESKPRO386) {
            fIRQ = false;
        }

        /**
         * When the Windows 95 HSFLOP ("High-Speed Floppy") VxD performs its diskette change-line detection logic
         * ("determine_changeline"), it sets a special callback ("dcl_callback_int_entry") for its interrupt handler
         * to invoke, then issues a READ_ID command, and then sets a bit telling its interrupt handler to expect an
         * interrupt ("FLP_NEC_INT_EXPECTED").
         *
         * Technically, it should have set *both* "dcl_callback_int_entry" *and* "FLP_NEC_INT_EXPECTED" *before*
         * issuing the READ_ID command, but I imagine the author assumed all was fine, since interrupts had been
         * disabled with a "cli" beforehand and had not been re-enabled with an "sti" yet.  But alas, the function
         * used to the issue the READ_ID command ("NecOut") immediately re-enabled interrupts.
         *
         * So, if we request an interrupt immediately after the READ_ID command, the interrupt handler will think
         * our interrupt is spurious (ie, not EXPECTED).  In this particular case, there are only about 10 instructions
         * executed from the time READ_ID is issued until the "FLP_NEC_INT_EXPECTED" bit is set, but I'm going to
         * add a little padding to that, in part because I wouldn't be surprised if there are other places where a
         * similar assumption exists (ie, either that "NecOut" leaves interrupts disabled, or simply that the floppy
         * controller is an inherently slow device).
         *
         * TODO: Determine why the Football prototype disk fails to boot if we specify a larger delay (eg, 32) and
         * why TopView 1.10 hangs when the delay is set to 16.  I've worked around those questions for now, by simply
         * limiting the delay to the READ_ID command.
         *
         * UPDATE: Those aforementioned issues with Football and TopView may have been entirely due to a problem
         * with an earlier version of requestInterrupt(), which had an additional fCondition parameter into which I
         * was passing the entire "drive && fIRQ && !(drive.resCode & FDC.REG_DATA.RES.NOT_READY)" expression.  Note
         * that if "drive" was undefined, the entire expression would be "undefined", which I assumed would translate
         * to a "falsy" fCondition, but the fCondition parameter was also declared with a default value of true,
         * and default values are used whenever NO value is supplied OR an "undefined" value is supplied.  Oops.
         */
        if (fIRQ) {
            this.requestInterrupt(bCmdMasked == FDC.REG_DATA.CMD.READ_ID? 16 : 0);
        }
    }

    /**
     * pushResults(drive, bCmd, bHead, c, h, r, n)
     *
     * @this {FDC}
     * @param {Object} drive
     * @param {number} bCmd
     * @param {number} bHead
     * @param {number} c
     * @param {number} h
     * @param {number} r
     * @param {number} n
     */
    pushResults(drive, bCmd, bHead, c, h, r, n)
    {
        this.beginResult();
        this.pushST0(drive);
        this.pushST1(drive);
        this.pushST2(drive);
        /**
         * NOTE: I used to set the following C/H/R/N results using the values that advanceSector() had "advanced"
         * them to, which seemed logical but was technically incorrect.  For non-multi-track reads, they should match
         * the programmed C/H/R/N values, except when EOT has been reached, in which case C = C + 1 and R = 1.
         *
         * For multi-track, the LSB of H should be complemented whenever EOT has been reached, which I "informally"
         * detect by testing if the drive's current bCylinder and/or bHead positions advanced to a new cylinder or head,
         * and apparently, C should never be advanced if H was initially 0.
         *
         * I don't do strict EOT comparisons here or elsewhere, because it allows the controller to work with a wider
         * range of disks (eg, "fake" XDF disk images that contain 23 512-byte sectors/track).
         *
         * Original version of this function:
         * https://github.com/jeffpar/pcjs.v1/commit/6110bb6a9f2eb992acb476707376ef5116afeee5#diff-d97e0120475cfb16e63a3ca1fa0e0c49121a314e80e9039081371730e6f2631b
         */
        let i = 0;
        if (c != drive.bCylinder || h != drive.bHead) {
            i = r = 1;
        }
        if (bCmd & FDC.REG_DATA.CMD.MT) {
            h ^= i;
            if (!bHead) i = 0;
            r = drive.bSector;                          // REQUIRED in order for MINIX 1.1 to load ROOT diskette
            if (drive.disk && drive.disk.diskData && drive.disk.diskData[c] && drive.disk.diskData[c][h] && drive.disk.diskData[c][h][r-1]) {
                r = drive.disk.diskData[c][h][r-1][Disk.SECTOR.ID];
            }
        }
        c += i;
        this.pushResult(c, FDC.TERMS.C);                // formerly drive.bCylinder
        this.pushResult(h, FDC.TERMS.H);                // formerly drive.bHead
        this.pushResult(r, FDC.TERMS.R);                // formerly drive.bSector
        this.pushResult(n, FDC.TERMS.N);
    }

    /**
     * popCmd(name)
     *
     * @this {FDC}
     * @param {string|undefined} [name]
     * @returns {number}
     */
    popCmd(name)
    {

        let bCmd = this.regDataArray[this.regDataIndex];
        if (DEBUG) {
            let bCmdMasked = bCmd & FDC.REG_DATA.CMD.MASK;
            if (!name && !this.regDataIndex && FDC.aCmdInfo[bCmdMasked]) name = FDC.aCmdInfo[bCmdMasked].name;
            this.printf(MESSAGE.PORT + MESSAGE.FDC, "%s.popCmd(%s): %#04x\n", this.idComponent, (name || this.regDataIndex), bCmd);
        }
        this.regDataIndex++;
        return bCmd;
    }

    /**
     * popHLT()
     *
     * NOTE: This byte is actually a combination of HLT (Head Load Time) and ND (Non-DMA Mode)
     *
     * @this {FDC}
     */
    popHLT()
    {
        this.popCmd(FDC.TERMS.HLT);
     // this.nHLT = this.popCmd(FDC.TERMS.HLT);
    }

    /**
     * popSRT()
     *
     * NOTE: This byte is actually a combination of SRT (Step Rate Time) and HUT (Head Unload Time)
     *
     * @this {FDC}
     */
    popSRT()
    {
        this.popCmd(FDC.TERMS.SRT);
     // this.nSRT = this.popCmd(FDC.TERMS.SRT);
    }

    /**
     * requestInterrupt(nDelay)
     *
     * Request an FDC interrupt, as long as INT_ENABLE is set (and the optional supplied condition, if any, is true).
     *
     * @this {FDC}
     * @param {number} [nDelay]
     */
    requestInterrupt(nDelay)
    {
        if (this.regOutput & FDC.REG_OUTPUT.INT_ENABLE) {
            if (this.chipset) this.chipset.setIRR(ChipSet.IRQ.FDC, nDelay);
        }
    }

    /**
     * beginResult()
     *
     * @this {FDC}
     */
    beginResult()
    {
        this.setLED();
        this.regDataIndex = this.regDataTotal = 0;
    }

    /**
     * pushResult(bResult, name)
     *
     * @this {FDC}
     * @param {number} bResult
     * @param {string|undefined} [name]
     */
    pushResult(bResult, name)
    {
        if (DEBUG) this.printf(MESSAGE.PORT + MESSAGE.FDC, "%s.pushResult(%s): %#04x\n", this.idComponent, (name || this.regDataTotal), bResult);

        this.regDataArray[this.regDataTotal++] = bResult;
    }

    /**
     * pushST0(drive)
     *
     * @this {FDC}
     * @param {Object} drive
     */
    pushST0(drive)
    {
        this.pushResult(drive.iDrive | (drive.bHead << 2) | (drive.resCode & FDC.REG_DATA.RES.ST0), FDC.TERMS.ST0);
    }

    /**
     * pushST1(drive)
     *
     * @this {FDC}
     * @param {Object} drive
     */
    pushST1(drive)
    {
        this.pushResult((drive.resCode & FDC.REG_DATA.RES.ST1) >>> 8, FDC.TERMS.ST1);
    }

    /**
     * pushST2(drive)
     *
     * @this {FDC}
     * @param {Object} drive
     */
    pushST2(drive)
    {
        this.pushResult((drive.resCode & FDC.REG_DATA.RES.ST2) >>> 16, FDC.TERMS.ST2);
    }

    /**
     * pushST3(drive)
     *
     * @this {FDC}
     * @param {Object} drive
     */
    pushST3(drive)
    {
        this.pushResult((drive.resCode & FDC.REG_DATA.RES.ST3) >>> 24, FDC.TERMS.ST3);
    }

    /**
     * doDMARead(drive, b, done)
     *
     * @this {FDC}
     * @param {Object} drive
     * @param {number} b
     * @param {function(number,boolean)} done
     */
    doDMARead(drive, b, done)
    {
        if (b === undefined || b < 0) {
            this.readData(drive, done);
            return;
        }
        /**
         * The DMA controller should be ASKING for data, not GIVING us data; this suggests an internal DMA miscommunication
         */
        if (DEBUG) this.printf("%s.doDMARead(): invalid DMA acknowledgement\n", this.idComponent);
        done(-1, false);
    }

    /**
     * doDMAWrite(drive, b)
     *
     * @this {FDC}
     * @param {Object} drive
     * @param {number} b
     * @returns {number}
     */
    doDMAWrite(drive, b)
    {
        if (b !== undefined && b >= 0) {
            return this.writeData(drive, b);
        }
        /**
         * The DMA controller should be GIVING us data, not ASKING for data; this suggests an internal DMA miscommunication
         */
        if (DEBUG) this.printf("%s.doDMAWrite(): invalid DMA acknowledgement\n", this.idComponent);
        return -1;
    }

    /**
     * doDMAFormat(drive, b)
     *
     * @this {FDC}
     * @param {Object} drive
     * @param {number} b
     * @returns {number}
     */
    doDMAFormat(drive, b)
    {
        if (b !== undefined && b >= 0) {
            return this.writeFormat(drive, b);
        }
        /**
         * The DMA controller should be GIVING us data, not ASKING for data; this suggests an internal DMA miscommunication
         */
        if (DEBUG) this.printf("%s.doDMAFormat(): invalid DMA acknowledgement\n", this.idComponent);
        return -1;
    }

    /**
     * doRead(drive)
     *
     * @this {FDC}
     * @param {Object} drive
     * @returns {boolean}
     */
    doRead(drive)
    {
        /**
         * With only NOT_READY and INCOMPLETE set, an empty drive causes DOS to report "General Failure";
         * with the addition of NO_DATA, DOS reports "Sector not found".  The traditional "Drive not ready"
         * error message is not triggered by anything we return here, but simply by BIOS commands timing out.
         */
        drive.resCode = FDC.REG_DATA.RES.NOT_READY | FDC.REG_DATA.RES.INCOMPLETE;
        if (drive.disk) {
            if (this.messageEnabled()) {
                let a = this.chipset.getDMAState(ChipSet.DMA_FDC);
                this.printf("%s.doRead(drive=%d,CHS=%d:%d:%d,LBA=%d,addr=%#X,len=%#X)\n",
                            this.idComponent, drive.iDrive, drive.bCylinder, drive.bHead, drive.bSector,
                            (drive.bCylinder * (drive.disk.nHeads * drive.disk.nSectors) + drive.bHead * drive.disk.nSectors + drive.bSector-1),
                            a[0], a[1]+1);
            }
            if (drive.bHead > drive.nHeads - 1) {
                drive.resCode = FDC.REG_DATA.RES.NO_DATA | FDC.REG_DATA.RES.INCOMPLETE;
                return true;
            }
            drive.sector = null;
            drive.resCode = FDC.REG_DATA.RES.NONE;
            if (this.chipset) {
                if (!drive.bCylinder && !drive.bHead && drive.bSector == 1) {
                    if (!drive.fBootable && this.chipset.getDMAState(ChipSet.DMA_FDC)[0] == 0x7C00) {
                        return false;
                    }
                }
                this.chipset.connectDMA(ChipSet.DMA_FDC, this, 'dmaRead', drive);
                this.chipset.requestDMA(ChipSet.DMA_FDC);
            }
        }
        return true;
    }

    /**
     * doWrite(drive)
     *
     * @this {FDC}
     * @param {Object} drive
     * @returns {boolean}
     */
    doWrite(drive)
    {
        drive.resCode = FDC.REG_DATA.RES.NOT_READY | FDC.REG_DATA.RES.INCOMPLETE;
        if (drive.disk) {
            if (this.messageEnabled()) {
                let a = this.chipset.getDMAState(ChipSet.DMA_FDC);
                this.printf("%s.doWrite(drive=%d,CHS=%d:%d:%d,LBA=%d,addr=%#X,len=%#X)\n",
                            this.idComponent, drive.iDrive, drive.bCylinder, drive.bHead, drive.bSector,
                            (drive.bCylinder * (drive.disk.nHeads * drive.disk.nSectors) + drive.bHead * drive.disk.nSectors + drive.bSector-1),
                            a[0], a[1]+1);
            }
            if (drive.bHead > drive.nHeads - 1) {
                drive.resCode = FDC.REG_DATA.RES.NO_DATA | FDC.REG_DATA.RES.INCOMPLETE;
                return true;
            }
            if (!drive.fWritable || drive.disk.fWriteProtected) {
                drive.resCode = FDC.REG_DATA.RES.NOT_WRITABLE | FDC.REG_DATA.RES.INCOMPLETE;
                return true;
            }
            drive.sector = null;
            drive.resCode = FDC.REG_DATA.RES.NONE;
            if (this.chipset) {
                this.chipset.connectDMA(ChipSet.DMA_FDC, this, 'dmaWrite', drive);
                this.chipset.requestDMA(ChipSet.DMA_FDC);
            }
        }
        return true;
    }

    /**
     * doFormat(drive)
     *
     * drive is initialized by doCmd() to the following extent:
     *
     *      drive.bHead (ignored)
     *      drive.nBytes (bytes/sector)
     *      drive.bSectorEnd (sectors/track)
     *      drive.bFiller (fill byte)
     *
     * and we expect the DMA controller to provide C, H, R and N (ie, 4 bytes) for each sector to be formatted.
     *
     * @this {FDC}
     * @param {Object} drive
     */
    doFormat(drive)
    {
        drive.resCode = FDC.REG_DATA.RES.NOT_READY | FDC.REG_DATA.RES.INCOMPLETE;
        /**
         * NOTE: Strangely, we must ignore the number of drive heads both here and in seek(); otherwise,
         * PC DOS 1.10 "FORMAT /1" will fail, even though "/1" means format it as a single-sided diskette.
         *
         *      if (drive.bHead > drive.nHeads - 1) {
         *          drive.resCode = FDC.REG_DATA.RES.NO_DATA | FDC.REG_DATA.RES.INCOMPLETE;
         *          return;
         *      }
         */
        if (drive.disk) {
            drive.sector = null;
            drive.resCode = FDC.REG_DATA.RES.NONE;
            if (this.chipset) {
                drive.cbFormat = 0;
                drive.abFormat = new Array(4);
                drive.bFormatting = true;
                drive.cSectorsFormatted = 0;
                this.chipset.connectDMA(ChipSet.DMA_FDC, this, 'dmaFormat', drive);
                this.chipset.requestDMA(ChipSet.DMA_FDC);
                drive.bFormatting = false;
            }
        }
    }

    /**
     * readData(drive, done)
     *
     * The following drive properties must have been setup prior to our first call:
     *
     *      drive.bHead
     *      drive.bCylinder
     *      drive.bSector
     *      drive.sector (initialized to null)
     *
     * On the first readData() request, since drive.sector will be null, we ask the Disk object to look
     * up the first sector of the request.  We then ask the Disk for bytes from that sector until the sector
     * is exhausted, and then we look up the next sector and continue the process.
     *
     * NOTE: Since the FDC isn't aware of the extent of the transfer, all readData() can do is return bytes
     * until the current track (or, in the case of a multi-track request, the current cylinder) has been exhausted.
     *
     * TODO: Research the requirements, if any, for multi-track I/O and determine what else needs to be done.
     *
     * @this {FDC}
     * @param {Object} drive
     * @param {function(number,boolean,Object,number)} done (number is next available byte from drive, or -1 if no more bytes available)
     */
    readData(drive, done)
    {
        let b = -1;
        let obj = null, off = 0;    // these variables are purely for BACKTRACK purposes

        /**
         * Our JSON-encoded disk images now support certain copy-protection-related features, such as sectors
         * with non-standard sizes (ie, other than 512), non-sequential sector IDs (see IBM Multiplan 1.00), and
         * sectors with forced CRC errors (see Microsoft Word 1.15).
         *
         * The latter requires that we check our sectors for the optional *dataError* property and set resCode
         * accordingly; logically, that probably shouldn't happen until just after the last byte of the sector
         * has been transferred, but we don't really know when that happens, since we're just calling disk.read()
         * as many times as the DMA controller count indicates.
         *
         * So we simply set resCode to CRC_ERROR as soon as we notice a sector with *dataError* set, and we no
         * longer bypass the entire operation simply because resCode has been set to that value.
         *
         * TODO: Someday all possible FDC error conditions need to be tested on a real controller, because this
         * code is becoming a bit too crufty.
         */
        if ((!drive.resCode || drive.resCode == (FDC.REG_DATA.RES.CRC_ERROR | FDC.REG_DATA.RES.INCOMPLETE)) && drive.disk) {
            do {
                if (drive.sector) {
                    off = drive.iByte;
                    if ((b = drive.disk.read(drive.sector, drive.iByte++)) >= 0) {
                        obj = drive.sector;
                        break;
                    }
                }
                /**
                 * Locate the next sector, and then try reading again.
                 */
                drive.sector = drive.disk.seek(drive.bCylinder, drive.bHead, drive.bSector, drive.sectorPrev);
                if (!drive.sector) {
                    drive.resCode = FDC.REG_DATA.RES.NO_DATA | FDC.REG_DATA.RES.INCOMPLETE;
                    break;
                }
                drive.sectorPrev = drive.sector;
                if (drive.sector['dataError']) {
                    drive.resCode = FDC.REG_DATA.RES.CRC_ERROR | FDC.REG_DATA.RES.INCOMPLETE;
                }
                drive.iByte = 0;
                /**
                 * We "pre-advance" bSector et al now, instead of waiting to advance it right before the seek().
                 * This allows the initial call to readData() to perform a seek without triggering an unwanted advance.
                 */
                this.advanceSector(drive);
            } while (true);
        }
        done(b, false, obj, off);
    }

    /**
     * writeData(drive, b)
     *
     * The following drive properties must have been setup prior to our first call:
     *
     *      drive.bHead
     *      drive.bCylinder
     *      drive.bSector
     *      drive.sector (initialized to null)
     *
     * On the first writeData() request, since drive.sector will be null, we ask the Disk object to look
     * up the first sector of the request.  We then send the Disk bytes for that sector until the sector
     * is full, and then we look up the next sector and continue the process.
     *
     * NOTE: Since the FDC isn't aware of the extent of the transfer, all writeData() can do is accept bytes
     * until the current track (or, in the case of a multi-track request, the current cylinder) has been exhausted.
     *
     * TODO: Research the requirements, if any, for multi-track I/O and determine what else needs to be done.
     *
     * @this {FDC}
     * @param {Object} drive
     * @param {number} b containing next byte to write
     * @returns {number} (b unchanged; return -1 if command should be terminated)
     */
    writeData(drive, b)
    {
        if (drive.resCode || !drive.disk) return -1;
        do {
            if (drive.sector) {
                if (drive.sector['dataError'] && drive.iByte >= drive.sector['dataError']) {
                    break;
                }
                if (drive.disk.write(drive.sector, drive.iByte++, b)) break;
            }
            /**
             * Locate the next sector, and then try writing again.
             */
            drive.sector = drive.disk.seek(drive.bCylinder, drive.bHead, drive.bSector, drive.sectorPrev);
            if (!drive.sector) {
                /**
                 * TODO: Determine whether this should be FDC.REG_DATA.RES.CRC_ERROR or FDC.REG_DATA.RES.DATA_FIELD
                 */
                drive.resCode = FDC.REG_DATA.RES.CRC_ERROR | FDC.REG_DATA.RES.INCOMPLETE;
                b = -1;
                break;
            }
            drive.sectorPrev = drive.sector;
            drive.iByte = 0;
            /**
             * We "pre-advance" bSector et al now, instead of waiting to advance it right before the seek().
             * This allows the initial call to writeData() to perform a seek without triggering an unwanted advance.
             */
            this.advanceSector(drive);
        } while (true);
        return b;
    }

    /**
     * advanceSector(drive)
     *
     * This increments the sector number; when the sector number reaches drive.nDiskSectors on the current track, we
     * increment drive.bHead and reset drive.bSector, and when drive.bHead reaches drive.nDiskHeads, we reset drive.bHead
     * and increment drive.bCylinder.
     *
     * @this {FDC}
     * @param {Object} drive
     */
    advanceSector(drive)
    {

        drive.bSector++;
        let bSectorStart = 1;
        if (drive.bSector >= drive.nDiskSectors + bSectorStart) {
            drive.bSector = bSectorStart;
            drive.bHead++;
            if (drive.bHead >= drive.nDiskHeads) {
                drive.bHead = 0;
                drive.bCylinder++;
            }
        }
    }

    /**
     * writeFormat(drive, b)
     *
     * @this {FDC}
     * @param {Object} drive
     * @param {number} b containing a format command byte
     * @returns {number} (b if successful, -1 if command should be terminated)
     */
    writeFormat(drive, b)
    {
        if (drive.resCode) return -1;
        drive.abFormat[drive.cbFormat++] = b;
        if (drive.cbFormat == drive.abFormat.length) {
            drive.bCylinder = drive.abFormat[0];    // C
            drive.bHead = drive.abFormat[1];        // H
            drive.bSector = drive.abFormat[2];      // R
            drive.nBytes = 128 << drive.abFormat[3];// N (0 => 128, 1 => 256, 2 => 512, 3 => 1024)
            drive.cbFormat = 0;
            if (this.messageEnabled()) {
                this.printf("%s.writeFormat(drive=%d,CHS=%d:%d:%d,len=%d)\n",
                            this.idComponent, drive.iDrive, drive.bCylinder, drive.bHead, drive.bSector, drive.nBytes);
            }
            for (let i = 0; i < drive.nBytes; i++) {
                if (this.writeData(drive, drive.bFiller) < 0) {
                    return -1;
                }
            }
            drive.cSectorsFormatted++;
        }
        if (drive.cSectorsFormatted >= drive.bSectorEnd) b = -1;
        return b;
    }

    /**
     * FDC.init()
     *
     * This function operates on every HTML element of class "fdc", extracting the
     * JSON-encoded parameters for the FDC constructor from the element's "data-value"
     * attribute, invoking the constructor to create a FDC component, and then binding
     * any associated HTML controls to the new component.
     */
    static init()
    {
        let aeFDC = Component.getElementsByClass(APPCLASS, "fdc");
        for (let iFDC = 0; iFDC < aeFDC.length; iFDC++) {
            let eFDC = aeFDC[iFDC];
            let parmsFDC = Component.getComponentParms(eFDC);
            let fdc = new FDC(parmsFDC);
            Component.bindComponentControls(fdc, eFDC, APPCLASS);
        }
    }
}

/**
 * Initialize every Floppy Drive Controller (FDC) module on the page.
 */
WebLib.onInit(FDC.init);

/**
 * @copyright https://www.pcjs.org/machines/pcx86/modules/v2/hdc.js (C) 2012-2024 Jeff Parsons
 */

/** @typedef {{ name: string, path: string, type: number, size: number, mode: string }} */
let DriveConfig;

/** @typedef {{ iDrive: number, errorCode: number, senseCode: number, fRemovable: boolean, abDriveParms: Array.<number>, buffer: Array.<number>, bHead: number, nHeads: number, wCylinder: number, nCylinders: number, bSector: number, bSectorEnd: number, nBytes: number, bSectorBias: number, name: string, path: string, mode: string, type: number, sDiskPath: string, nSectors: number, cbSector: number, cbTransfer: number, disk: (Disk|null), sector: (Sector|null), iByte: number, useBuffer: boolean, chunksCached: Array, chunksMRU: Array }} */
let Drive;

/**
 * @class HDC
 * @property {Array.<DriveConfig>} aDriveConfigs
 * @unrestricted (allows the class to define properties, both dot and named, outside of the constructor)
 */
class HDC extends Component {

    /**
     * HDC defaults, in case drive parameters weren't specified
     */
    static DEFAULT_DRIVE_NAME = "Hard Drive";

    /**
     * ATC (AT Controller) Registers
     *
     * The "IBM Personal Computer AT Fixed Disk and Diskette Drive Adapter", aka the HFCOMBO card, contains what we refer
     * to here as the ATC (AT Controller).  Even though that card contains both Fixed Disk and Diskette Drive controllers,
     * this component (HDC) still deals only with the "Fixed Disk" portion.  Fortunately, the "Diskette Drive Adapter"
     * portion of the card is compatible with the existing FDC component, so that component continues to be responsible
     * for all diskette operations.
     *
     * ATC ports default to their primary addresses; secondary port addresses are 0x80 lower (e.g., 0x170 instead of 0x1F0).
     *
     * It's important to know that the MODEL_5170 BIOS has a special relationship with the "Combo Hard File/Diskette
     * (HFCOMBO) Card" (see @F000:144C).  Initially, the ChipSet component intercepted reads for HFCOMBO's STATUS port
     * and returned the BUSY bit clear to reduce boot time; however, it turned out that was also a prerequisite for the
     * BIOS to write test patterns to the CYLLO port (0x1F4) and set the "DUAL" bit (bit 0) of the "HFCNTRL" byte at 40:8Fh
     * if those CYLLO operations succeeded (now that the HDC is "ATC-aware", the ChipSet port intercepts have been removed).
     *
     * Without the "DUAL" bit set, when it came time later to report the diskette drive type, the "DISK_TYPE" function
     * (@F000:273D) would branch to one of two almost-identical blocks of code -- specifically, a block that disallowed
     * diskette drive types >= 2 (ChipSet.CMOS.FDRIVE.FD360) instead of >= 3 (ChipSet.CMOS.FDRIVE.FD1200).
     *
     * In other words, the "Fixed Disk" portion of the HFCOMBO controller has to be present and operational if the user
     * wants to use high-capacity (80-track) diskettes with "Diskette Drive" portion of the controller.  This may not be
     * immediately obvious to anyone creating a 5170 machine configuration with the FDC component but no HDC component.
     *
     * TODO: Investigate what a MODEL_5170 can do, if anything, with diskettes if an "HFCOMBO card" was NOT installed;
     * e.g., was there Diskette-only Controller that could be installed, and if so, did it support high-capacity diskette
     * drives?  Also, consider making the FDC component able to detect when the HDC is missing and provide the same minimal
     * HFCOMBO port intercepts that ChipSet once provided (this is not a requirement, just a usability improvement).
     *
     * UPDATE: I later discovered that newer (ie, REV2 and REV3) 5170 ROMs are even less happy when no HDC is installed,
     * *unless* an undocumented FDC "DIAGNOSTIC" register (port 0x3F1) provides a "MULTIPLE DATA RATE" response, bypassing
     * the HDC port tests described above.  This may also imply that those newer 5170 revisions are incompatible with FD360
     * diskette drives, because if none of the "MULTIPLE DATA RATE" tests succeed, a "601-Diskette Error" always occurs.
     */
    static ATC = {
        DATA:   {                   // no register (read-write)
            PORT1:      0x1F0,      // data port address for primary interface
            PORT2:      0x170       // data port address for secondary interface
        },
        DIAG:   {                   // this.regError (read-only)
            PORT1:      0x1F1,
            PORT2:      0x171,
            NO_ERROR:    0x01,
            CTRL_ERROR:  0x02,
            SEC_ERROR:   0x03,
            ECC_ERROR:   0x04,
            PROC_ERROR:  0x05
        },
        ERROR: {                    // this.regError (read-only)
            PORT1:      0x1F1,
            PORT2:      0x171,
            NONE:        0x00,
            NO_DAM:      0x01,      // Data Address Mark (DAM) not found
            NO_TRK0:     0x02,      // Track 0 not detected
            CMD_ABORT:   0x04,      // Aborted Command
            NO_CHS:      0x10,      // ID field with the specified C:H:S not found
            ECC_ERR:     0x40,      // Data ECC Error
            BAD_BLOCK:   0x80       // Bad Block Detect
        },
        WPREC:  {                   // this.regWPreC (write-only)
            PORT1:      0x1F1,
            PORT2:      0x171
        },
        SECCNT: {                   // this.regSecCnt (read-write; 0 implies a 256-sector request)
            PORT1:      0x1F2,
            PORT2:      0x172,
            PACKET_CD:   0x01,      // for PACKET command, bit 0 set upon transfer of packet command
            PACKET_IO:   0x02       // for PACKET command, bit 1 set upon transfer of packet response
        },
        SECNUM: {                   // this.regSecNum (read-write)
            PORT1:      0x1F3,
            PORT2:      0x173
        },
        CYLLO:  {                   // this.regCylLo (read-write; all 8 bits are used)
            PORT1:      0x1F4,
            PORT2:      0x174
        },
        CYLHI:  {                   // this.regCylHi (read-write; only bits 0-1 are used, for a total of 10 bits, or 1024 max cylinders)
            PORT1:      0x1F5,
            PORT2:      0x175,
            MASK:        0x03
        },
        DRVHD:  {                   // this.regDrvHd (read-write)
            PORT1:      0x1F6,
            PORT2:      0x176,
            HEAD_MASK:   0x0F,      // set this to the max number of heads before issuing a SET PARAMETERS command
            DRIVE_MASK:  0x10,
            SET_MASK:    0xE0,
            SET_BITS:    0xA0       // for whatever reason, these bits must always be set
        },
        STATUS: {                   // this.regStatus (read-only; reading clears IRQ.ATC1 or IRQ.ATC2 as appropriate)
            PORT1:      0x1F7,
            PORT2:      0x177,
            ERROR:       0x01,      // set when the previous command ended in an error; one or more bits are set in the ERROR register (the next command to the controller resets the ERROR bit)
            INDEX:       0x02,      // set once for every revolution of the disk
            CORRECTED:   0x04,
            DATA_REQ:    0x08,      // indicates that "the sector buffer requires servicing during a Read or Write command. If either bit 7 (BUSY) or this bit is active, a command is being executed. Upon receipt of any command, this bit is reset."
            SEEK_OK:     0x10,      // seek operation complete
            WFAULT:      0x20,      // write fault
            READY:       0x40,      // if this is set (along with the SEEK_OK bit), the drive is ready to read/write/seek again
            BUSY:        0x80       // if this is set, no other STATUS bits are valid
        },
        COMMAND: {                  // this.regCommand (write-only)
            PORT1:      0x1F7,
            PORT2:      0x177,
            NO_RETRY:    0x01,      // optional bit for READ_DATA, WRITE_DATA, and READ_VERF commands
            WITH_ECC:    0x02,      // optional bit for READ_DATA and WRITE_DATA commands
            STEP_RATE:   0x0F,      // optional bits for stepping rate used with RESTORE and SEEK commands
                                    // (low nibble x 500us equals stepping rate, except for 0, which corresponds to 35us)
            /**
             * The following 8 commands comprised the original PC AT (ATA) command set.  You may see other later command
             * set definitions that show "mandatory" commands, such as READ_MULT (0xC4) or WRITE_MULT (0xC5), but those didn't
             * exist until the introduction of later interface enhancements (e.g., ATA-1, ATA-2, IDE, EIDE, ATAPI, etc).
             */
            RESTORE:     0x10,      // aka RECALIBRATE
            READ_DATA:   0x20,      // also supports NO_RETRY and/or WITH_ECC
            WRITE_DATA:  0x30,      // also supports NO_RETRY and/or WITH_ECC
            READ_VERF:   0x40,      // also supports NO_RETRY
            FORMAT_TRK:  0x50,      // TODO
            SEEK:        0x70,      //
            DIAGNOSE:    0x90,      //
            SETPARMS:    0x91,      //
            /**
             * Additional commands go here.  As for when these commands were introduced, I may try to include
             * that information parenthetically, but I'm not going to pretend this is in any way authoritative.
             */
            RESET:       0x08,      // Device Reset (ATAPI)
            PACKET:      0xA0,      // Packet Request (ATAPI)
            IDPACKET:    0xA1,      // Identify Packet Device (ATAPI)
            IDDEVICE:    0xEC       // Identify Device (ATA-1)
        },
        FDR: {                      // this.regFDR
            PORT1:      0x3F6,
            PORT2:      0x376,
            INT_DISABLE: 0x02,      // a logical 0 enables fixed disk interrupts
            RESET:       0x04,      // a logical 1 enables reset fixed disk function
            HS3:         0x08,      // a logical 1 enables head select 3 (a logical 0 enables reduced write current)
            RESERVED:    0xF1
        },
        /**
         * Much of the following IDENTIFY structure information came from a Seagate ATA Reference Manual,
         * 36111-001, Rev. C, dated 21 May 1993 (111-1c.pdf), a specification which I believe later became known
         * as ATA-1.
         *
         * All words are stored little-endian; also note some definitions of CUR_CAPACITY define it as two
         * 16-bit words, since as a 32-bit dword, it would be misaligned if the structure began on a dword boundary
         * (and, of course, if it did NOT begin on a dword boundary, then LBA_CAPACITY would be misaligned).
         * Alignment considerations are of no great concern on Intel platforms, however.
         */
        IDENTIFY: {
            CONFIG: {                   // WORD: GENERAL_CONFIG
                OFFSET:         0x00,
                ATA_RESERVED:   0x0001, // always clear (ATA reserved)
                HARD_SECTORED:  0x0002, // set if hard sectored
                SOFT_SECTORED:  0x0004, // set if soft sectored
                NOT_MFM:        0x0008, // set if not MFM encoded
                HDSW_15MS:      0x0010, // set if head switch time > 15usec
                SPINDLE_OPT:    0x0020, // set if spindle motor control option implemented
                FIXED:          0x0040, // set if fixed drive
                REMOVABLE:      0x0080, // set if removable cartridge drive
                RATE_5MBIT:     0x0100, // set if disk transfer rate <= 5Mbit/sec
                RATE_10MBIT:    0x0200, // set if disk transfer rate <= 10Mbit/sec and > 5Mbit/sec
                RATE_FASTER:    0x0400, // set if disk transfer rate > 10Mbit/sec
                ROT_TOLERANCE:  0x0800, // set if rotational speed tolerance is > 0.5%
                STROBE_OPT:     0x1000, // set if data strobe offset option available
                TRACK_OPT:      0x2000, // set if track offset option available
                FMT_TOLERANCE:  0x4000, // set if format speed tolerance gap required
                NM_RESERVED:    0x8000  // always clear (reserved for non-magnetic drives)
            },
            CYLS:               0x02,   // WORD: number of physical cylinders
            CONFIG2:            0x04,   // WORD: SPECIFIC_CONFIG
            HEADS:              0x06,   // WORD: number of physical heads
            TRACK_BYTES:        0x08,   // WORD: bytes per track
            SECBYTES:           0x0A,   // WORD: bytes per sector
            SECTORS:            0x0C,   // WORD: sectors per track
                                        // (reserved words at 0x0E, 0x10, and 0x12)
            SERIAL_NUMBER:      0x14,   // CHAR: 20 ASCII characters
            BUFFER_TYPE:        0x28,   // WORD: 0=unspecified, 1=single, 2=dual, 3=caching
            BUFFER_SIZE:        0x2A,   // WORD: 512-byte increments
            ECC_BYTES:          0x2C,   // WORD: number of ECC bytes on read/write long commands
            FIRMWARE_REV:       0x2E,   // CHAR: 8 ASCII characters
            MODEL_NUMBER:       0x36,   // CHAR: 40 ASCII characters
            MAX_MULTISEC:       0x5E,   // BYTE: if non-zero, number of transferable sectors per interrupt
                                        // (reserved byte at 0x5F)
            DWORD_IO:           0x60,   // WORD: 0x0001 if double-word I/O supported, 0x0000 if not
                                        // (reserved byte at 0x62)
            CAPABILITY:         0x63,   // BYTE: bit0=DMA, bit1=LBA, bit2=IORDYsw, bit3=IORDYsup
                                        // (reserved word at 0x64; reserved byte at 0x66)
            PIO_TIMING:         0x67,   // BYTE: 0=slow, 1=medium, 2=fast
                                        // (reserved byte at 0x68)
            DMA_TIMING:         0x69,   // BYTE: 0=slow, 1=medium, 2=fast
            NEXT5_VALID:        0x6A,   // WORD: bit0=1 if next 5 words are valid, 0 if not
            CUR_CYLS:           0x6C,   // WORD: number of logical cylinders
            CUR_HEADS:          0x6E,   // WORD: number of logical heads
            CUR_SECTORS:        0x70,   // WORD: number of logical sectors per track
            CUR_CAPACITY:       0x72,   // LONG: logical capacity in sectors
            MULTISECT:          0x76,   // BYTE: current multiple sector count
            MULTISECT_VALID:    0x77,   // BYTE: bit0=1 if MULTSECT is valid, 0 if not
            LBA_CAPACITY:       0x78,   // LONG: total number of sectors
            DMA_SINGLE:         0x7C,   // BYTE
            DMA_SINGLE_ACTIVE:  0x7D,   // BYTE
            DMA_MULTI:          0x7E,   // BYTE
            DMA_MULTI_ACTIVE:   0x7F,   // BYTE
            /**
             * The rest of this 512-byte structure (words 64 through 255) was reserved at the time of the ATA-1 spec,
             * so I will not delve any deeper into this structure now.
             *
             * Further details can be found at:
             *
             *      https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/content/ata/ns-ata-_identify_device_data
             *      https://chromium.googlesource.com/chromiumos/third_party/u-boot-next/+/master/include/ata.h
             *
             * Regrettably, those more modern documents don't bother mentioning at what point any fields were added
             * to the specification, and they treat some of the early obsolete fields as too old to warrant any explanation,
             * calling them simply "Retired" or "Obsolete".  Not particularly helpful to anyone who cares about history.
             */
        },
        PACKET: {
            COMMAND: {
                TEST_UNIT:      0x00,   // Test Unit Ready
                REQ_SENSE:      0x03,   // Request Sense
                INQUIRY:        0x12,   // Inquiry
                READ:           0x28,   // Read
                SEEK:           0x2B,   // Seek
                READ_TOC:       0x43,   // Read TOC (Table of Contents), PMA (Program Memory Area), and ATIP (Absolute Time in Pre-Groove)
                PLAY_AUDIO:     0x45,   // Play Audio
                MODE_SENSE:     0x5A    // Mode Sense
            },
            /**
             * Finding a succinct list of all the (SCSI) Page Codes in old ATAPI/SCSI specs is surprisingly hard,
             * but there is a nice summary on Wikipedia (https://en.wikipedia.org/wiki/SCSI_mode_page).  For details
             * on Page Code contents, check out the ANSI X3.304-1997 spec (e.g., page 72 for Page Code 0x2A).
             */
            PAGECODE: {
                RW_ERRREC:      0x01,   // Read-Write Error Recovery Page
                CD_STATUS:      0x2A    // CD Capabilities and Mechanical Status Page
            },
            ADR: {                      // ADR Q sub-channel values (0x4-0xF reserved)
                NONE:           0x0,
                CUR_POS:        0x1,
                MEDIA_CAT_NO:   0x2,
                ISRC:           0x3
            },
            CONTROL: {                  // CONTROL Q sub-channel values
                DATA_TRACK:     0x4
            }
        }
    };

    /**
     * XTC (XT Controller) Registers
     */
    static XTC = {
        /**
         * XTC Data Register (0x320, read-write)
         *
         * Writes to this register are discussed below; see HDC Commands.
         *
         * Reads from this register after a command has been executed retrieve a "status byte",
         * which must NOT be confused with the Status Register (see below).  This data "status byte"
         * contains only two bits of interest: XTC.DATA.STATUS.ERROR and XTC.DATA.STATUS.UNIT.
         */
        DATA: {
            PORT:          0x320,   // port address
            STATUS: {
                OK:         0x00,   // no error
                ERROR:      0x02,   // error occurred during command execution
                UNIT:       0x20    // logical unit number of the drive
            },
            /**
             * XTC Commands, as issued to XTC_DATA
             *
             * Commands are multi-byte sequences sent to XTC_DATA, starting with a XTC_DATA.CMD byte,
             * and followed by 5 more bytes, for a total of 6 bytes, which collectively are called a
             * Device Control Block (DCB).  Not all commands use all 6 bytes, but all 6 bytes must be present;
             * unused bytes are simply ignored.
             *
             *      XTC_DATA.CMD    (3-bit class code, 5-bit operation code)
             *      XTC_DATA.HEAD   (1-bit drive number, 5-bit head number)
             *      XTC_DATA.CLSEC  (upper bits of 10-bit cylinder number, 6-bit sector number)
             *      XTC_DATA.CH     (lower bits of 10-bit cylinder number)
             *      XTC_DATA.COUNT  (8-bit interleave or block count)
             *      XTC_DATA.CTRL   (8-bit control field)
             *
             * One command, HDC.XTC.DATA.CMD.INIT_DRIVE, must include 8 additional bytes following the DCB:
             *
             *      maximum number of cylinders (high)
             *      maximum number of cylinders (low)
             *      maximum number of heads
             *      start reduced write current cylinder (high)
             *      start reduced write current cylinder (low)
             *      start write precompensation cylinder (high)
             *      start write precompensation cylinder (low)
             *      maximum ECC data burst length
             *
             * Note that the 3 word values above are stored in "big-endian" format (high byte followed by low byte),
             * rather than the "little-endian" format (low byte followed by high byte) you typically find on Intel machines.
             */
            CMD: {
                TEST_READY:     0x00,       // Test Drive Ready
                RECALIBRATE:    0x01,       // Recalibrate
                REQ_SENSE:      0x03,       // Request Sense Status
                FORMAT_DRIVE:   0x04,       // Format Drive
                READ_VERF:      0x05,       // Read Verify
                FORMAT_TRK:     0x06,       // Format Track
                FORMAT_BAD:     0x07,       // Format Bad Track
                READ_DATA:      0x08,       // Read
                WRITE_DATA:     0x0A,       // Write
                SEEK:           0x0B,       // Seek
                INIT_DRIVE:     0x0C,       // Initialize Drive Characteristics
                READ_ECC_BURST: 0x0D,       // Read ECC Burst Error Length
                READ_BUFFER:    0x0E,       // Read Data from Sector Buffer
                WRITE_BUFFER:   0x0F,       // Write Data to Sector Buffer
                RAM_DIAGNOSTIC: 0xE0,       // RAM Diagnostic
                DRV_DIAGNOSTIC: 0xE3,       // HDC BIOS: CHK_DRV_CMD
                CTL_DIAGNOSTIC: 0xE4,       // HDC BIOS: CNTLR_DIAG_CMD
                READ_LONG:      0xE5,       // HDC BIOS: RD_LONG_CMD
                WRITE_LONG:     0xE6        // HDC BIOS: WR_LONG_CMD
            },
            ERR: {
                /**
                 * HDC error conditions, as returned in byte 0 of the (4) bytes returned by the Request Sense Status command
                 */
                NONE:           0x00,
                NO_INDEX:       0x01,       // no index signal detected
                SEEK_INCOMPLETE:0x02,       // no seek-complete signal
                WRITE_FAULT:    0x03,
                NOT_READY:      0x04,       // after the controller selected the drive, the drive did not respond with a ready signal
                NO_TRACK:       0x06,       // after stepping the max number of cylinders, the controller did not receive the track 00 signal from the drive
                STILL_SEEKING:  0x08,
                ECC_ID_ERROR:   0x10,
                ECC_DATA_ERROR: 0x11,
                NO_ADDR_MARK:   0x12,
                NO_SECTOR:      0x14,
                BAD_SEEK:       0x15,       // seek error: the cylinder and/or head address did not compare with the expected target address
                ECC_CORRECTABLE:0x18,       // correctable data error
                BAD_TRACK:      0x19,
                BAD_CMD:        0x20,
                BAD_DISK_ADDR:  0x21,
                RAM:            0x30,
                CHECKSUM:       0x31,
                POLYNOMIAL:     0x32,
                MASK:           0x3F
            },
            SENSE: {
                ADDR_VALID:     0x80
            }
        },
        /**
         * XTC Status Register (0x321, read-only)
         *
         * WARNING: The IBM Technical Reference Manual *badly* confuses the XTC_DATA "status byte" (above)
         * that the controller sends following an HDC.XTC.DATA.CMD operation with the Status Register (below).
         * In fact, it's so badly confused that it completely fails to document any of the Status Register
         * bits below; I'm forced to guess at their meanings from the HDC BIOS listing.
         */
        STATUS: {
            PORT:          0x321,   // port address
            NONE:           0x00,
            REQ:            0x01,   // HDC BIOS: request bit
            IOMODE:         0x02,   // HDC BIOS: mode bit (GUESS: set whenever XTC_DATA contains a response?)
            BUS:            0x04,   // HDC BIOS: command/data bit (GUESS: set whenever XTC_DATA ready for request?)
            BUSY:           0x08,   // HDC BIOS: busy bit
            INTERRUPT:      0x20    // HDC BIOS: interrupt bit
        }
    };

    /**
     * XTC Config Register (0x322, read-only)
     *
     * This register is used to read HDC card switch settings that defined the "Drive Type" for
     * drives 0 and 1.  SW[1],SW[2] (for drive 0) and SW[3],SW[4] (for drive 1) are set as follows:
     *
     *      ON,  ON     Drive Type 0   (306 cylinders, 2 heads)
     *      ON,  OFF    Drive Type 1   (375 cylinders, 8 heads)
     *      OFF, ON     Drive Type 2   (306 cylinders, 6 heads)
     *      OFF, OFF    Drive Type 3   (306 cylinders, 4 heads)
     */

    /**
     * HDC Command Sequences
     *
     * Unlike the FDC, all the HDC commands have fixed-length command request sequences (well, OK, except for
     * HDC.XTC.DATA.CMD.INIT_DRIVE) and fixed-length response sequences (well, OK, except for HDC.XTC.DATA.CMD.REQ_SENSE),
     * so a table of byte-lengths isn't much use, but having names for all the commands is still handy for debugging.
     */
    static aATACommands = {
        0x08: "Device Reset",           // ATAPI
        0x10: "Restore (Recalibrate)",  // ATA
        0x20: "Read",                   // ATA
        0x30: "Write",                  // ATA
        0x40: "Read Verify",            // ATA
        0x50: "Format Track",           // ATA
        0x70: "Seek",                   // ATA
        0x90: "Diagnose",               // ATA
        0x91: "Set Parameters",         // ATA
        0xA0: "Packet Request",         // ATAPI
        0xA1: "Identify Packet Device", // ATAPI
        0xEC: "Identify Device"         // ATA-1
    };

    static aATAPICommands = {
        [HDC.ATC.PACKET.COMMAND.TEST_UNIT]:     "Test Unit Ready",
        [HDC.ATC.PACKET.COMMAND.REQ_SENSE]:     "Request Sense",
        [HDC.ATC.PACKET.COMMAND.INQUIRY]:       "Inquiry",
        [HDC.ATC.PACKET.COMMAND.READ]:          "Read",
        [HDC.ATC.PACKET.COMMAND.SEEK]:          "Seek",
        [HDC.ATC.PACKET.COMMAND.READ_TOC]:      "Read TOC",
        [HDC.ATC.PACKET.COMMAND.PLAY_AUDIO]:    "Play Audio",
        [HDC.ATC.PACKET.COMMAND.MODE_SENSE]:    "Mode Sense",
    };

    static aXTACommands = {
        0x00: "Test Drive Ready",
        0x01: "Recalibrate",
        0x03: "Request Sense Status",
        0x04: "Format Drive",
        0x05: "Read Verify",
        0x06: "Format Track",
        0x07: "Format Bad Track",
        0x08: "Read",
        0x0A: "Write",
        0x0B: "Seek",
        0x0C: "Initialize Drive Characteristics",
        0x0D: "Read ECC Burst Error Length",
        0x0E: "Read Data from Sector Buffer",
        0x0F: "Write Data to Sector Buffer",
        0xE0: "RAM Diagnostic",
        0xE3: "Drive Diagnostic",
        0xE4: "Controller Diagnostic",
        0xE5: "Read Long",
        0xE6: "Write Long"
    };

    static {
        /**
         * Port input notification tables
         */
        HDC.aXTCPortInput = {
            0x320:  HDC.prototype.inXTCData,
            0x321:  HDC.prototype.inXTCStatus,
            0x322:  HDC.prototype.inXTCConfig
        };

        /**
         * For future reference, the REV2 and REV3 PC AT ROM BIOS also refer to a "FIXED DISK DIAGNOSTIC REGISTER" at
         * port 0x5F7, but I have no documentation on it, and failure to respond is non-fatal.  See the discussion of the
         * FDC diagnostic register in inFDCDiagnostic() for more details.
         */
        HDC.aATCPortInputPrimary = {
            0x1F0:  HDC.prototype.inATCData,
            0x1F1:  HDC.prototype.inATCError,
            0x1F2:  HDC.prototype.inATCSecCnt,
            0x1F3:  HDC.prototype.inATCSecNum,
            0x1F4:  HDC.prototype.inATCCylLo,
            0x1F5:  HDC.prototype.inATCCylHi,
            0x1F6:  HDC.prototype.inATCDrvHd,
            0x1F7:  HDC.prototype.inATCStatus
        };

        HDC.aATCPortInputSecondary = {
            0x170:  HDC.prototype.inATCData,
            0x171:  HDC.prototype.inATCError,
            0x172:  HDC.prototype.inATCSecCnt,
            0x173:  HDC.prototype.inATCSecNum,
            0x174:  HDC.prototype.inATCCylLo,
            0x175:  HDC.prototype.inATCCylHi,
            0x176:  HDC.prototype.inATCDrvHd,
            0x177:  HDC.prototype.inATCStatus
        };

        /**
         * Port output notification tables
         */
        HDC.aXTCPortOutput = {
            0x320:  HDC.prototype.outXTCData,
            0x321:  HDC.prototype.outXTCReset,
            0x322:  HDC.prototype.outXTCPulse,
            0x323:  HDC.prototype.outXTCPattern,
            /**
             * The PC XT Fixed Disk BIOS includes some additional "housekeeping" that it performs
             * not only on port 0x323 but also on three additional ports, at increments of 4 (see all
             * references to "RESET INT/DMA MASK" in the Fixed Disk BIOS).  It's not clear to me if
             * those ports refer to additional HDC controllers, and I haven't seen other references to
             * them, but in any case, they represent a lot of "I/O noise" that we simply squelch here.
             */
            0x327:  HDC.prototype.outXTCNoise,
            0x32B:  HDC.prototype.outXTCNoise,
            0x32F:  HDC.prototype.outXTCNoise
        };

        HDC.aATCPortOutputPrimary = {
            0x1F0:  HDC.prototype.outATCData,
            0x1F1:  HDC.prototype.outATCWPreC,
            0x1F2:  HDC.prototype.outATCSecCnt,
            0x1F3:  HDC.prototype.outATCSecNum,
            0x1F4:  HDC.prototype.outATCCylLo,
            0x1F5:  HDC.prototype.outATCCylHi,
            0x1F6:  HDC.prototype.outATCDrvHd,
            0x1F7:  HDC.prototype.outATCCommand,
            0x3F6:  HDC.prototype.outATCFDR
        };

        HDC.aATCPortOutputSecondary = {
            0x170:  HDC.prototype.outATCData,
            0x171:  HDC.prototype.outATCWPreC,
            0x172:  HDC.prototype.outATCSecCnt,
            0x173:  HDC.prototype.outATCSecNum,
            0x174:  HDC.prototype.outATCCylLo,
            0x175:  HDC.prototype.outATCCylHi,
            0x176:  HDC.prototype.outATCDrvHd,
            0x177:  HDC.prototype.outATCCommand,
            0x376:  HDC.prototype.outATCFDR
        };
    }

    /**
     * HDC(parmsHDC)
     *
     * The HDC component simulates an STC-506/412 interface to an IBM-compatible fixed disk drive. The first
     * such drive was a 10Mb 5.25-inch drive containing two platters and 4 heads. Data spanned 306 cylinders
     * for a total of 1224 tracks, with 17 sectors/track and 512 bytes/sector.  Support has since been expanded
     * to include the original PC AT Western Digital controller.
     *
     * HDC supports the following component-specific properties:
     *
     *      drives: an array of DriveConfig objects, each containing 'name', 'path', 'type' and 'size' properties
     *      type: either "XT" (for the PC XT Xebec controller), or "AT" (for the PC AT Western Digital controller)
     *
     * The 'type' parameter defaults to "XT", enabling support for the PC XT controller.  All ports for the
     * PC XT controller are referred to as XTC ports.  We may also say that the XTC implements the XTA interface,
     * to differentiate it from ATA controllers, which came later.
     *
     * Choosing "AT" as the controller type enables ATA compatibility, and by default, the primary ATA interface is
     * enabled (ie, "AT" is equivalent to "AT1"); if you want to enable the secondary ATA interface, specify "AT2".
     * PC AT controller ports are referred to as ATC ports, and the ATC implements the ATA interface (along with
     * ATAPI, if requested).
     *
     * If you want to connect an ATAPI (CD-ROM) drive to the controller, specify "ATAPI" instead of "AT"; unlike
     * "AT", "ATAPI" defaults to secondary interface (ie, "ATAPI" is equivalent to "ATAPI2"), but you can override
     * the default (e.g., "ATAPI1").
     *
     * If 'path' is empty, a scratch disk image is created; otherwise, we make a note of the path, but we will NOT
     * pre-load it like we do for floppy disk images.
     *
     * My current plan is to read all disk data on-demand, keeping a cache of what we've read, and possibly adding
     * some read-ahead as well. Any portions of the disk image that are written before being read will never be read.
     *
     * TRIVIA: On p.1-179 of the PC XT Technical Reference Manual (revised APR83), it reads:
     *
     *      "WARNING: The last cylinder on the fixed disk drive is reserved for diagnostic use.
     *      Diagnostic write tests will destroy any data on this cylinder."
     *
     * Does FDISK insure that the last cylinder is reserved?  I'm sure we'll eventually find out.
     *
     * @this {HDC}
     * @param {Object} parmsHDC
     */
    constructor(parmsHDC)
    {
        super("HDC", parmsHDC, MESSAGE.HDC);

        this['dmaRead'] = HDC.prototype.doDMARead;
        this['dmaWrite'] = HDC.prototype.doDMAWrite;
        this['dmaWriteBuffer'] = HDC.prototype.doDMAWriteBuffer;
        this['dmaWriteFormat'] = HDC.prototype.doDMAWriteFormat;

        this.aDriveConfigs = [];

        /**
         * We used to eval() driveConfigs immediately, but now we wait until initBus() is called, so that
         * we can check for any machine overrides.
         */
        this.driveConfigs = parmsHDC['drives'];

        /**
         * Set fATC (AT Controller flag) according to the 'type' parameter.  This in turn determines other
         * defaults.  For example, the default XT drive type is 3 (for a 10Mb disk drive), whereas the default
         * AT drive type is 2 (for a 20Mb disk drive).
         */
        this.fATC = this.fATAPI = false;
        this.sType = (parmsHDC['type'] || "XT").toUpperCase();
        if (this.sType.indexOf("XT") < 0) {
            this.fATC = true;
            this.fATAPI = this.sType.indexOf("ATAPI") >= 0;
        }
        this.nInterface = (this.fATAPI? 1 : 0);     // default to the secondary interface if type is "ATAPI"
        let nInterface = this.sType.slice(-1);      // but if an interface is specified (e.g., "AT2", "ATAPI1"), honor it
        if (nInterface == '1') {
            this.nInterface = 0;
        } else if (nInterface == '2') {
            this.nInterface = 1;
        }

        /**
         * Support for local disk images is currently limited to desktop browsers with FileReader support;
         * when this flag is set, setBinding() allows local disk bindings and informs initBus() to update the
         * "listDisks" binding accordingly.
         */
        this.fLocalDisks = (!WebLib.isMobile() && 'FileReader' in globals.window);

        /**
         * The remainder of HDC initialization now takes place in our initBus() handler.
         */
    }

    /**
     * setBinding(sHTMLType, sBinding, control, sValue)
     *
     * @this {HDC}
     * @param {string} sHTMLType is the type of the HTML control (e.g., "button", "list", "text", "submit", "textarea", "canvas")
     * @param {string} sBinding is the value of the 'binding' parameter stored in the HTML control's "data-value" attribute (e.g., "listDisks")
     * @param {HTMLElement} control is the HTML control DOM object (e.g., HTMLButtonElement)
     * @param {string} [sValue] optional data value
     * @returns {boolean} true if binding was successful, false if unrecognized binding request
     */
    setBinding(sHTMLType, sBinding, control, sValue)
    {
        let hdc = this;

        switch (sBinding) {

        case "listDisks":
            this.bindings[sBinding] = control;
            break;

        case "saveHD0":
        case "saveHD1":
            /**
             * Yes, technically, this feature does not require "Local disk support" (which is really a reference
             * to FileReader support), but since fLocalDisks is also false for all mobile devices, and since there
             * is an "orthogonality" to disabling both features in tandem, let's just let it slide, OK?
             */
            if (!this.fLocalDisks) {
                if (DEBUG) this.printf(MESSAGE.LOG, "Local disk support not available\n");
                /**
                 * We could also simply remove the control; eg:
                 *
                 *      control.parentNode.removeChild(@type {Node} (control));
                 *
                 * but as long as the parentNode remains, with its accompanying style, the visual layout of the machine
                 * could look odd.  So let's change the parent's style instead.
                 */
                control.parentNode.style.display = "none";
                return false;
            }
            this.bindings[sBinding] = control;
            control.onclick = function(iDrive) {
                return function onClickSaveDrive(event) {
                    let drive = hdc.aDrives && hdc.aDrives[iDrive];
                    if (drive && drive.disk) {
                        /**
                         * Note the similarity (and hence factoring opportunity) between this code and the FDC's
                         * "saveDisk" binding.
                         *
                         * One important difference between the FDC and the HDC is that an FDC may or may not contain
                         * a disk, whereas an HDC always contains a disk.  However, the contents of an HDC's disk may
                         * never have been initialized with the contents of an external disk image, and therefore the
                         * disk's sDiskFile/sDiskPath properties may be undefined.  sDiskName should always be defined
                         * though, defaulting to the name of the drive (e.g., "10Mb Hard Disk").
                         */
                        let disk = drive.disk;
                        let sDiskName = disk.sDiskFile || disk.sDiskName;
                        let i = sDiskName.lastIndexOf('.');
                        if (i >= 0) sDiskName = sDiskName.substr(0, i);
                        sDiskName += ".img";
                        if (DEBUG) hdc.printf("saving disk %s...\n", sDiskName);
                        let sAlert = WebLib.downloadFile(disk.encodeAsBinary(), "octet-stream", true, sDiskName);
                        Component.alertUser(sAlert);
                    } else {
                        hdc.printf(MESSAGE.NOTICE, "Hard drive %d is not available.\n", iDrive);
                    }
                };
            }(+sBinding.slice(-1));
            return true;
        }
        return false;
    }

    /**
     * initBus(cmp, bus, cpu, dbg)
     *
     * @this {HDC}
     * @param {Computer} cmp
     * @param {Busx86} bus
     * @param {CPUx86} cpu
     * @param {Debuggerx86} dbg
     */
    initBus(cmp, bus, cpu, dbg)
    {
        this.bus = bus;
        this.cpu = cpu;
        this.dbg = dbg;
        this.cmp = cmp;

        /**
         * Any machine-specific 'drives' settings apply only the first HDC interface.
         */
        let driveConfigs = cmp.getMachineParm(this.nInterface? 'cdromDrives' : 'drives') || this.driveConfigs;

        if (Array.isArray(driveConfigs)) {
            this.aDriveConfigs = driveConfigs;
        }
        else if (typeof driveConfigs == "string") {
            try {
                /**
                 * We must take care when parsing user-supplied JSON-encoded drive data.
                 */
                this.aDriveConfigs = eval("(" + driveConfigs + ")");
            } catch (e) {
                Component.error("HDC drive configuration error: " + e.message + " (" + driveConfigs + ")");
            }
        }

        /**
         * We need access to the ChipSet component, because we need to communicate with
         * the PIC and DMA controller.
         */
        this.chipset = cmp.getMachineComponent("ChipSet");

        this.iDriveCtrl = 0;
        this.iDriveTypeDefault = 3;

        if (!this.fATC) {
            bus.addPortInputTable(this, HDC.aXTCPortInput);
            bus.addPortOutputTable(this, HDC.aXTCPortOutput);
        } else {
            if (!this.nInterface) {
                bus.addPortInputTable(this, HDC.aATCPortInputPrimary);
                bus.addPortOutputTable(this, HDC.aATCPortOutputPrimary);
                bus.addPortInputWidth(HDC.ATC.DATA.PORT1, 2);
                bus.addPortOutputWidth(HDC.ATC.DATA.PORT1, 2);
            } else {
                bus.addPortInputTable(this, HDC.aATCPortInputSecondary);
                bus.addPortOutputTable(this, HDC.aATCPortOutputSecondary);
                bus.addPortInputWidth(HDC.ATC.DATA.PORT2, 2);
                bus.addPortOutputWidth(HDC.ATC.DATA.PORT2, 2);
            }
            this.iDriveCtrl++;
            if (this.chipset && this.chipset.model == ChipSet.MODEL_COMPAQ_DESKPRO386) this.iDriveCtrl++;
            this.iDriveTypeDefault = 2;
        }

        cpu.addIntNotify(Interrupts.DISK, this.intBIOSDisk.bind(this));
        cpu.addIntNotify(Interrupts.ALT_DISK, this.intBIOSDiskette.bind(this));

        /**
         * The following code used to be performed in the HDC constructor, but now we need to wait for information
         * about the Computer to be available (e.g., getMachineID() and getUserID()) before we start loading and/or
         * connecting to disk images.
         *
         * If we didn't need auto-mount support, we could defer controller initialization until we received a powerUp()
         * notification, at which point reset() would call initController(), or restore() would restore the controller;
         * in that case, all we'd need to do here is call setReady().
         */
        this.reset();

        this.fdc = cmp.getMachineComponent("FDC");
        if (this.fdc && this.fATAPI && this.bindings["listDisks"]) {
            for (let iDrive = 0; iDrive < this.aDrives.length; iDrive++) {
                let drive = this.aDrives[iDrive];
                if (!drive.type) this.fdc.addDrive(drive, this, this.bindings["listDisks"]);
            }
        }

        if (!this.autoMount()) this.setReady();
    }

    /**
     * powerUp(data, fRepower)
     *
     * @this {HDC}
     * @param {Object|null} data
     * @param {boolean} [fRepower]
     * @returns {boolean} true if successful, false if failure
     */
    powerUp(data, fRepower)
    {
        if (!fRepower) {
            if (!data) {
                this.initController();
                if (this.cmp.fReload) {
                    /**
                     * If the computer's fReload flag is set, we're required to toss all currently
                     * loaded disks and remount all disks specified in the auto-mount configuration.
                     */
                    this.autoMount(true);
                }
            } else {
                if (!this.restore(data)) return false;
            }
        }
        return true;
    }

    /**
     * powerDown(fSave, fShutdown)
     *
     * @this {HDC}
     * @param {boolean} [fSave]
     * @param {boolean} [fShutdown]
     * @returns {Object|boolean}
     */
    powerDown(fSave, fShutdown)
    {
        return fSave? this.save() : true;
    }

    /**
     * getMachineID()
     *
     * @returns {string}
     */
    getMachineID()
    {
        return this.cmp? this.cmp.getMachineID() : "";
    }

    /**
     * getUserID()
     *
     * @returns {string}
     */
    getUserID()
    {
        return this.cmp? this.cmp.getUserID() : "";
    }

    /**
     * reset()
     *
     * @this {HDC}
     */
    reset()
    {
        /**
         * TODO: The controller is also initialized by the constructor, to assist with auto-mount support,
         * so think about whether we can skip powerUp initialization.
         */
        this.initController(null, true);
    }

    /**
     * save()
     *
     * This implements save support for the HDC component.
     *
     * @this {HDC}
     * @returns {Object}
     */
    save()
    {
        let state = new State(this);
        state.set(0, this.saveController());
        return state.data();
    }

    /**
     * restore(data)
     *
     * This implements restore support for the HDC component.
     *
     * @this {HDC}
     * @param {Object} data
     * @returns {boolean} true if successful, false if failure
     */
    restore(data)
    {
        return this.initController(data[0]);
    }

    /**
     * initController(data, fHard)
     *
     * @this {HDC}
     * @param {Array} [data]
     * @param {boolean} [fHard] true if a machine reset (not just a controller reset)
     * @returns {boolean} true if successful, false if failure
     */
    initController(data, fHard)
    {
        let i = 0;
        let fSuccess = true;

        /**
         * TODO: This is used to re-select the controller's active drive whenever the machine is restored, but alas,
         * we currently only update it and save it for the ATC, not the XTC.
         */
        this.iDrive = -1;

        /**
         * At this point, it's worth calling into question my decision to NOT split the HDC component into separate XTC
         * and ATC components, given all the differences, and given that I'm about to write some "if (ATC) else (XTC) ..."
         * code.  And all I can say in my defense is, yes, it's definitely worth calling that into question.
         *
         * However, there's also some common code, mostly in the area of disk management rather than controller management,
         * and if the components were split, then I'd have to create a third component for that common code (although again,
         * disk management probably belongs in its own component anyway).
         *
         * However, let's not forget that since my overall plan is to have only one PCx86 "binary", everything's going to end
         * up in the same bucket anyway, so let's not be too obsessive about organizational details.  As long as the number
         * of these conditionals is small and they're not performance-critical, this seems much ado about nothing.
         */
        if (this.fATC) {
            /**
             * Since there's no way (and never will be a way) for an HDC to change its "personality" (from 'xt' to 'at'
             * or vice versa), we're under no obligation to use the same number of registers, or save/restore format, etc,
             * as the original XT controller.
             */
            if (data == null) data = [0, 0, 0, 0, 0, 0, 0, HDC.ATC.STATUS.READY, 0, [0, -1]];
            this.regError   = data[i++];
            this.regWPreC   = data[i++];
            this.regSecCnt  = data[i++];
            this.regSecNum  = data[i++];
            this.regCylLo   = data[i++];
            this.regCylHi   = data[i++];
            this.regDrvHd   = data[i++];
            this.regStatus  = data[i++];
            this.regCommand = data[i++];
            this.regFDR     = data[i++];
            if (typeof this.regFDR == "object") {
                let a = this.regFDR;
                this.regFDR = a[0];
                this.iDrive = a[1];
            }
            /**
             * Additional state is maintained by the Drive object (e.g., buffer, iByte)
             */
        } else {
            if (data == null) data = [0, HDC.XTC.STATUS.NONE, new Array(14), 0, 0];
            this.regConfig    = data[i++];
            this.regStatus    = data[i++];
            this.regDataArray = data[i++];  // there can be up to 14 command bytes (6 for normal commands, plus 8 more for HDC.XTC.DATA.CMD.INIT_DRIVE)
            this.regDataIndex = data[i++];  // used to control the next data byte to be received
            this.regDataTotal = data[i++];  // used to control the next data byte to be sent (internally, we use regDataIndex to read data bytes, up to this total)
            this.regReset     = data[i++];
            this.regPulse     = data[i++];
            this.regPattern   = data[i++];
            /**
             * Initialize iDriveAllowFail only if it's never been initialized, otherwise its entire purpose will be defeated.
             * See the related HACK in intBIOSDisk() for more details.
             */
            let iDriveAllowFail = data[i++];
            if (iDriveAllowFail !== undefined) {
                this.iDriveAllowFail = iDriveAllowFail;
            } else {
                if (this.iDriveAllowFail === undefined) this.iDriveAllowFail = -1;
            }
        }

        if (this.aDrives === undefined) {
            this.aDrives = new Array(this.aDriveConfigs.length);
        }

        let dataDrives = data[i];
        if (dataDrives === undefined) dataDrives = [];

        for (let iDrive = 0; iDrive < this.aDrives.length; iDrive++) {
            if (this.aDrives[iDrive] === undefined) {
                this.aDrives[iDrive] = {};
            }
            let drive = this.aDrives[iDrive];
            let driveConfig = this.aDriveConfigs[iDrive];
            if (!this.initDrive(iDrive, drive, driveConfig, dataDrives[iDrive], fHard)) {
                fSuccess = false;
            }
            /**
             * XTC only: the original STC-506/412 controller had two pairs of DIP switches to indicate a drive
             * type (0, 1, 2 or 3) for drives 0 and 1.  Those switch settings are recorded in regConfig, now that
             * drive.type has been validated by initDrive().
             */
            if (this.regConfig != null && iDrive <= 1) {
                this.regConfig |= (drive.type & 0x3) << ((1 - iDrive) << 1);
            }
        }

        if (this.iDrive >= 0) {
            this.drive = this.aDrives[this.iDrive];
        }

        if (fHard) this.printf("HDC initialized for %d drive(s)\n", this.aDrives.length);
        return fSuccess;
    }

    /**
     * saveController()
     *
     * @this {HDC}
     * @returns {Array}
     */
    saveController()
    {
        let i = 0;
        let data = [];
        if (this.fATC) {
            data[i++] = this.regError;
            data[i++] = this.regWPreC;
            data[i++] = this.regSecCnt;
            data[i++] = this.regSecNum;
            data[i++] = this.regCylLo;
            data[i++] = this.regCylHi;
            data[i++] = this.regDrvHd;
            data[i++] = this.regStatus;
            data[i++] = this.regCommand;
            data[i++] = [this.regFDR, this.iDrive];
        } else {
            data[i++] = this.regConfig;
            data[i++] = this.regStatus;
            data[i++] = this.regDataArray;
            data[i++] = this.regDataIndex;
            data[i++] = this.regDataTotal;
            data[i++] = this.regReset;
            data[i++] = this.regPulse;
            data[i++] = this.regPattern;
            data[i++] = this.iDriveAllowFail;
        }
        data[i] = this.saveDrives();
        return data;
    }

    /**
     * initBuffer(drive, length)
     *
     * @this {HDC}
     * @param {Drive} drive
     * @param {number} [length]
     */
    initBuffer(drive, length=drive.nBytes)
    {
        if (!drive.buffer || drive.buffer.length < length) {
            drive.buffer = new Array(length);
        }
        drive.buffer.fill(0, 0, length);
        drive.iByte = 0;
    }

    /**
     * initDrive(iDrive, drive, driveConfig, data, fHard)
     *
     * TODO: Consider a separate Drive class that both FDC and HDC can use, since there's a lot of commonality
     * between the drive objects created by both controllers.  This will clean up overall drive management and allow
     * us to factor out some common Drive methods (e.g., advanceSector()).
     *
     * @this {HDC}
     * @param {number} iDrive
     * @param {Drive} drive
     * @param {DriveConfig} driveConfig
     * @param {Array} [data]
     * @param {boolean} [fHard] true if a machine reset (not just a controller reset)
     * @returns {boolean} true if successful, false if failure
     */
    initDrive(iDrive, drive, driveConfig, data, fHard)
    {
        let i = 0;
        let fSuccess = true;
        if (data === undefined) data = [HDC.XTC.DATA.ERR.NONE, 0, false, new Array(8)];

        drive.iDrive = iDrive;

        /**
         * errorCode could be an HDC global, but in order to insulate HDC state from the operation of various functions
         * that operate on drive objects (e.g., readData and writeData), I've made it a per-drive variable.  This choice
         * may be contrary to how the actual hardware works, but I prefer this approach, as long as it doesn't expose any
         * incompatibilities that any software actually cares about.
         */
        drive.errorCode = data[i++];
        drive.senseCode = data[i++];
        drive.fRemovable = data[i++];
        drive.abDriveParms = data[i++];         // captures drive parameters programmed via HDC.XTC.DATA.CMD.INIT_DRIVE

        /**
         * TODO: Make buffer a DWORD array rather than a BYTE array (we could even allocate a Memory block for it);
         * alternatively, eliminate the buffer entirely and re-establish a reference to the appropriate Disk sector object.
         */
        drive.buffer = data[i++];

        /**
         * The next group of properties are set by various HDC command sequences.
         */
        drive.bHead = data[i++];
        drive.nHeads = data[i++];
        drive.wCylinder = data[i++];
        drive.bSector = data[i++];
        drive.bSectorEnd = data[i++];           // aka EOT
        drive.nBytes = data[i++];
        drive.bSectorBias = (this.fATC? 0: 1);

        drive.name = driveConfig['name'];
        if (drive.name === undefined) drive.name = HDC.DEFAULT_DRIVE_NAME;
        drive.path = drive.sDiskPath = driveConfig['path'];

        /**
         * If no 'mode' is specified, we fall back to the original behavior, which is to completely preload
         * any specific disk image, or create an empty (purely local) disk image.
         */
        drive.mode = driveConfig['mode'] || (drive.path? DiskAPI.MODE.PRELOAD : DiskAPI.MODE.LOCAL);

        /**
         * On-demand I/O of raw disk images is supported only if there's a valid user ID; fall back to an empty
         * local disk image if there's not.
         */
        if (drive.mode == DiskAPI.MODE.DEMANDRO || drive.mode == DiskAPI.MODE.DEMANDRW) {
            if (!this.getUserID()) drive.mode = DiskAPI.MODE.LOCAL;
        }

        drive.type = driveConfig['type'];
        if (drive.type === undefined || DRIVE_TYPES[this.iDriveCtrl][drive.type] === undefined) drive.type = this.iDriveTypeDefault;

        let driveType = DRIVE_TYPES[this.iDriveCtrl][drive.type];
        drive.nSectors = driveType[2] || 17;                        // sectors/track
        drive.cbSector = drive.cbTransfer = driveType[3] || 512;    // bytes/sector (default is 512 if unspecified in the table)

        /**
         * On a full machine reset, pass the current drive type to setCMOSDriveType() (a no-op on pre-CMOS machines).
         */
        if (fHard && this.chipset) {
            this.chipset.setCMOSDriveType(this.nInterface*2+iDrive, drive.type);
        }

        /**
         * The next group of properties are set by user requests to load/unload disk images.
         *
         * We no longer reinitialize drive.disk, in order to retain previously mounted disk across resets.
         */
        if (drive.disk === undefined) {
            drive.disk = null;
            this.printf(MESSAGE.STATUS, "Type %d \"%s\" is fixed disk %d\n", drive.type, drive.name, iDrive);
        }

        /**
         * With the advent of save/restore, we need to verify every drive at initialization, not just whenever
         * drive characteristics are initialized.  Thus, if we've restored a sensible set of drive characteristics,
         * then verifyDrive will create an empty disk if none has been provided, insuring we are ready for
         * disk.restore().
         */
        this.verifyDrive(drive);

        /**
         * The next group of properties are managed by worker functions (e.g., doRead()) to maintain state across DMA requests.
         */
        drive.iByte = data[i++];                // location of the next byte to be accessed in the above sector
        drive.sector = null;                    // initialized to null by worker, and then set to the next sector satisfying the request
        drive.useBuffer = false;
        drive.chunksCached = [];
        drive.chunksMRU = [];

        if (drive.disk) {
            let deltas = data[i];
            if (deltas !== undefined && drive.disk.restore(deltas) < 0) {
                fSuccess = false;
            }
            if (fSuccess && drive.iByte !== undefined) {
                drive.sector = drive.disk.seek(drive.wCylinder, drive.bHead, drive.bSector + drive.bSectorBias);
            }
        }
        return fSuccess;
    }

    /**
     * saveDrives()
     *
     * @this {HDC}
     * @returns {Array}
     */
    saveDrives()
    {
        let i = 0;
        let data = [];
        for (let iDrive = 0; iDrive < this.aDrives.length; iDrive++) {
            data[i++] = this.saveDrive(this.aDrives[iDrive]);
        }
        return data;
    }

    /**
     * saveDrive(drive)
     *
     * @this {HDC}
     * @returns {Array}
     */
    saveDrive(drive)
    {
        let i = 0;
        let data = [];
        data[i++] = drive.errorCode;
        data[i++] = drive.senseCode;
        data[i++] = drive.fRemovable;
        data[i++] = drive.abDriveParms;
        data[i++] = drive.buffer;
        data[i++] = drive.bHead;
        data[i++] = drive.nHeads;
        data[i++] = drive.wCylinder;
        data[i++] = drive.bSector;
        data[i++] = drive.bSectorEnd;
        data[i++] = drive.nBytes;
        data[i++] = drive.iByte;
        data[i] = drive.disk? drive.disk.save() : null;
        return data;
    }

    /**
     * copyDrive(iDrive)
     *
     * @this {HDC}
     * @param {number} iDrive
     * @returns {Object|undefined} (undefined if the requested drive does not exist)
     */
    copyDrive(iDrive)
    {
        let driveNew;
        let driveOld = this.aDrives[iDrive];
        if (driveOld !== undefined) {
            driveNew = {};
            for (let p in driveOld) {
                driveNew[p] = driveOld[p];
            }
        }
        return driveNew;
    }

    /**
     * verifyDrive(drive, type)
     *
     * If no disk image is attached, create an empty disk with the specified drive characteristics.
     * Normally, we'd rely on the drive characteristics programmed via the HDC.XTC.DATA.CMD.INIT_DRIVE
     * command, but if an explicit drive type is specified, then we use the characteristics (geometry)
     * associated with that type.
     *
     * @this {HDC}
     * @param {Drive} drive
     * @param {number} [type] to create a disk of the specified type, if no disk exists yet
     */
    verifyDrive(drive, type)
    {
        if (drive) {
            let nHeads = 0, nCylinders = 0;
            if (type == null) {
                /**
                 * If the caller wants us to use the programmed drive parameters, we use those,
                 * but if there aren't any drive parameters (yet), then use default parameters based
                 * on drive.type.
                 *
                 * We used to do the last step ONLY if there was no drive.path -- otherwise, we'd waste
                 * time creating an empty disk if autoMount() was going to load an image from drive.path;
                 * but hopefully the Disk component is smarter now.
                 */
                nHeads = drive.abDriveParms[2];
                if (nHeads) {
                    nCylinders = (drive.abDriveParms[0] << 8) | drive.abDriveParms[1];
                } else {
                    type = drive.type;
                }
            }
            if (type != null && !nHeads) {
                nHeads = DRIVE_TYPES[this.iDriveCtrl][type][1];
                nCylinders = DRIVE_TYPES[this.iDriveCtrl][type][0];
            }
            if (nHeads) {
                /**
                 * The assumption here is that if the 3rd drive parameter byte (abDriveParms[2]) has been set
                 * (ie, if nHeads is valid) then the first two bytes (ie, the low and high cylinder byte values)
                 * must have been set as well.
                 *
                 * Do these values agree with those for the given drive type?  Even if they don't, all we do is warn.
                 */
                let driveType = DRIVE_TYPES[this.iDriveCtrl][drive.type];
                if (driveType) {
                    if (nCylinders != driveType[0] && nHeads != driveType[1]) {
                        this.printf(MESSAGE.NOTICE, "Warning: drive parameters (%d,%d) do not match drive type %d (%d,%d)\n", nCylinders, nHeads, drive.type, driveType[0], driveType[1]);
                    }
                }
                if (!drive.nCylinders || this.sType.indexOf("PCJS") < 0) {
                    drive.nCylinders = nCylinders;
                    drive.nHeads = nHeads;
                }
                if (drive.disk == null) {
                    drive.disk = new Disk(this, drive, drive.mode);
                }
            }
        }
    }

    /**
     * seekDrive(drive, iSector, nSectors)
     *
     * The HDC doesn't need this function, since all HDC requests from the CPU are handled by doXTCmd().  This function
     * is used by other components (e.g., Debugger) to mimic an HDC request, using a drive object obtained from copyDrive(),
     * to avoid disturbing the internal state of the HDC's drive objects.
     *
     * Also note that in an actual HDC request, drive.nBytes is initialized to the size of a single sector; the extent
     * of the entire transfer is actually determined by a count that has been pre-loaded into the DMA controller.  The HDC
     * isn't aware of the extent of the transfer, so in the case of a read request, all readData() can do is return bytes
     * until the current track (or, in the case of a multi-track request, the current cylinder) has been exhausted.
     *
     * Since seekDrive() is for use with non-DMA requests, we use nBytes to specify the length of the entire transfer.
     *
     * @this {HDC}
     * @param {Drive} drive
     * @param {number} iSector (a "logical" sector number, relative to the entire disk, NOT a physical sector number)
     * @param {number} nSectors
     * @returns {boolean} true if successful, false if invalid position request
     */
    seekDrive(drive, iSector, nSectors)
    {
        if (drive.disk) {
            let aDiskInfo = drive.disk.info();
            let nCylinders = aDiskInfo[0];
            /**
             * If nCylinders is zero, we probably have an empty disk image, awaiting initialization (see verifyDrive())
             */
            if (nCylinders) {
                let nHeads = aDiskInfo[1];
                let nSectorsPerTrack = aDiskInfo[2];
                let nSectorsPerCylinder = nHeads * nSectorsPerTrack;
                let nSectorsPerDisk = nCylinders * nSectorsPerCylinder;
                if (iSector + nSectors <= nSectorsPerDisk) {
                    drive.wCylinder = Math.floor(iSector / nSectorsPerCylinder);
                    iSector %= nSectorsPerCylinder;
                    drive.bHead = Math.floor(iSector / nSectorsPerTrack);
                    /**
                     * Important difference between the FDC and the XTC: the XTC uses 0-based sector numbers, so unlike
                     * FDC.seekDrive(), we must NOT add 1 to bSector below.  I could change how sector numbers are stored in
                     * hard drive images, but it seems preferable to keep the image format consistent and controller-independent.
                     */
                    drive.bSector = (iSector % nSectorsPerTrack);
                    drive.nBytes = nSectors * aDiskInfo[3];
                    /**
                     * NOTE: We don't set nSectorEnd, as an HDC command would, but it's irrelevant, because we don't actually
                     * do anything with nSectorEnd at this point.  Perhaps someday, when we faithfully honor/restrict requests
                     * to a single track (or a single cylinder, in the case of multi-track requests).
                     */
                    drive.errorCode = HDC.XTC.DATA.ERR.NONE;
                    /**
                     * At this point, we've finished simulating what an HDC.XTC.DATA.CMD.READ_DATA command would have performed,
                     * up through doRead().  Now it's the caller responsibility to call readData(), like the DMA Controller would.
                     */
                    return true;
                }
            }
        }
        return false;
    }

    /**
     * autoMount(fRemount)
     *
     * @this {HDC}
     * @param {boolean} [fRemount] is true if we're remounting all auto-mounted disks
     * @returns {boolean} true if one or more disk images are being auto-mounted, false if none
     */
    autoMount(fRemount)
    {
        if (!fRemount) this.cAutoMount = 0;
        for (let iDrive = 0; iDrive < this.aDrives.length; iDrive++) {
            let drive = this.aDrives[iDrive];
            if (drive.name && drive.sDiskPath) {
                if (fRemount && drive.disk && drive.disk.isRemote() || this.fATAPI) {
                    /**
                     * The Disk component has its own logic for remounting remote disks, so skip this disk.
                     *
                     * TODO: Consider rewriting how ALL disks are automounted/remounted, now that the Disk component
                     * is receiving its own powerDown() and powerUp() notifications (originally, it didn't receive them).
                     */
                    continue;
                }
                if (!this.loadDisk(iDrive, drive.name, drive.sDiskPath, true) && fRemount) {
                    this.setReady(false);
                }
                continue;
            }
            if (fRemount && drive.type !== undefined) {
                drive.disk = null;
                this.verifyDrive(drive, drive.type);
            }
        }
        return !!this.cAutoMount;
    }

    /**
     * loadDisk(iDrive, sDiskName, sDiskPath, fAutoMount)
     *
     * @this {HDC}
     * @param {number} iDrive
     * @param {string} sDiskName
     * @param {string} sDiskPath
     * @param {boolean} fAutoMount
     * @returns {boolean} true if disk (already) loaded, false if queued up (or busy)
     */
    loadDisk(iDrive, sDiskName, sDiskPath, fAutoMount)
    {
        let drive = this.aDrives[iDrive];
        if (drive.fBusy) {
            this.printf(MESSAGE.NOTICE, "Drive %d busy\n", iDrive);
            return true;
        }
        drive.fBusy = true;
        if (fAutoMount) {
            drive.fAutoMount = true;
            this.cAutoMount++;
            this.printf("loading \"%s\"\n", sDiskName);
        }
        let disk = drive.disk || new Disk(this, drive, drive.mode);
        sDiskPath = WebLib.redirectResource(sDiskPath);
        disk.load(sDiskName, sDiskPath, null, this.doneLoadDisk);
        return false;
    }

    /**
     * loadSelectedDisk(iDrive, controlDisks)
     *
     * @this {HDC}
     * @param {number} iDrive
     * @param {HTMLSelectElement} controlDisks
     */
    loadSelectedDisk(iDrive, controlDisks)
    {
        let drive = this.aDrives[iDrive];
        drive.sDiskPath = controlDisks.options[controlDisks.selectedIndex].value;
        drive.chunksCached = [];
        drive.chunksMRU = [];
    }

    /**
     * doneLoadDisk(drive, disk, sDiskName, sDiskPath)
     *
     * This is a callback issued by the Disk component once the load() operation has finished.
     *
     * @this {HDC}
     * @param {Drive} drive
     * @param {Disk} disk is set if the disk was successfully mounted, null if not
     * @param {string} sDiskName
     * @param {string} sDiskPath
     */
    doneLoadDisk(drive, disk, sDiskName, sDiskPath)
    {
        drive.fBusy = false;
        if ((drive.disk = disk)) {
            /**
             * With the addition of notice(), users are now "alerted" whenever a diskette has finished loading;
             * notice() is selective about its output, using print() if a print window is open, otherwise alert().
             *
             * WARNING: This conversion of drive number to drive letter, starting with "C:" (0x43), is very simplistic
             * and is not guaranteed to match the drive mapping that DOS ultimately uses.
             */
            this.printf(drive.fAutoMount? MESSAGE.STATUS : MESSAGE.NOTICE, "Mounted disk \"%s\" in drive %s\n", sDiskName, String.fromCharCode(0x43 + drive.iDrive));

            let aDiskInfo = disk.info();
            if (aDiskInfo[0] != drive.nCylinders || aDiskInfo[1] != drive.nHeads || aDiskInfo[2] != drive.nSectors || aDiskInfo[3] != drive.cbSector) {
                /**
                 * TODO: Decide how to deal with this problem; ie, either disallow disk access altogether, or automatically
                 * map the controller's I/O requests to the disk's geometry.  Also, we should provide a way to reformat such a
                 * disk so that its geometry matches the controller requirements.
                 */
                if (this.sType.indexOf("PCJS") == 0) {          // if pc.js custom-built this disk...
                    drive.nCylinders = aDiskInfo[0];
                    drive.nHeads = aDiskInfo[1];
                    drive.nSectors = aDiskInfo[2];
                    drive.cbSector = aDiskInfo[3];
                } else {
                    this.printf(MESSAGE.NOTICE, "Warning: disk geometry (%d:%d:%d) does not match %s drive type %d (%d:%d:%d)\n", aDiskInfo[0], aDiskInfo[1], aDiskInfo[2], DRIVE_CTRLS[this.iDriveCtrl], drive.type, drive.nCylinders, drive.nHeads, drive.nSectors);
                }
            }
        }
        if (drive.fAutoMount) {
            drive.fAutoMount = false;
            if (!--this.cAutoMount) this.setReady();
        }
    }

    /**
     * intXTCData(port, addrFrom)
     *
     * @this {HDC}
     * @param {number} port (0x320)
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     * @returns {number} simulated port value
     */
    inXTCData(port, addrFrom)
    {
        let bIn = 0;
        if (this.regDataIndex < this.regDataTotal) {
            bIn = this.regDataArray[this.regDataIndex];
        }
        if (this.chipset) this.chipset.clearIRR(ChipSet.IRQ.XTC);
        this.regStatus &= ~HDC.XTC.STATUS.INTERRUPT;

        this.printIO(port, undefined, addrFrom, "DATA[" + this.regDataIndex + "]", bIn);
        if (++this.regDataIndex >= this.regDataTotal) {
            this.regDataIndex = this.regDataTotal = 0;
            this.regStatus &= ~(HDC.XTC.STATUS.IOMODE | HDC.XTC.STATUS.BUS | HDC.XTC.STATUS.BUSY);
        }
        return bIn;
    }

    /**
     * outXTCData(port, bOut, addrFrom)
     *
     * @this {HDC}
     * @param {number} port (0x320)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to write the specified port)
     */
    outXTCData(port, bOut, addrFrom)
    {
        this.printIO(port, bOut, addrFrom, "DATA[" + this.regDataTotal + "]");
        if (this.regDataTotal < this.regDataArray.length) {
            this.regDataArray[this.regDataTotal++] = bOut;
        }
        let bCmd = this.regDataArray[0];
        let cbCmd = (bCmd != HDC.XTC.DATA.CMD.INIT_DRIVE? 6 : this.regDataArray.length);
        if (this.regDataTotal == 6) {
            /**
             * XTC.STATUS.REQ must be CLEAR following any 6-byte command sequence that the HDC BIOS "COMMAND" function outputs,
             * yet it must also be SET before the HDC BIOS will proceed with the remaining the 8-byte sequence that's part of
             * HDC.XTC.DATA.CMD.INIT_DRIVE command. See inXTCStatus() for HACK details.
             */
            this.regStatus &= ~HDC.XTC.STATUS.REQ;
        }
        if (this.regDataTotal >= cbCmd) {
            /**
             * It's essential that XTC.STATUS.IOMODE be set here, at least after the final 8-byte HDC.XTC.DATA.CMD.INIT_DRIVE sequence.
             */
            this.regStatus |= HDC.XTC.STATUS.IOMODE;
            this.regStatus &= ~HDC.XTC.STATUS.REQ;
            this.doXTC();
        }
    }

    /**
     * inXTCStatus(port, addrFrom)
     *
     * @this {HDC}
     * @param {number} port (0x321)
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     * @returns {number} simulated port value
     */
    inXTCStatus(port, addrFrom)
    {
        let b = this.regStatus;
        this.printIO(port, undefined, addrFrom, "STATUS", b);
        /**
         * HACK: The HDC BIOS will not finish the HDC.XTC.DATA.CMD.INIT_DRIVE sequence unless it sees XTC.STATUS.REQ set again, nor will
         * it read any of the XTC.DATA bytes returned from a HDC.XTC.DATA.CMD.REQ_SENSE command unless XTC.STATUS.REQ is set again, so
         * we turn it back on if there are unprocessed data bytes.
         */
        if (this.regDataIndex < this.regDataTotal) {
            this.regStatus |= HDC.XTC.STATUS.REQ;
        }
        return b;
    }

    /**
     * outXTCReset(port, bOut, addrFrom)
     *
     * @this {HDC}
     * @param {number} port (0x321)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to write the specified port)
     */
    outXTCReset(port, bOut, addrFrom)
    {
        this.printIO(port, bOut, addrFrom, "RESET");
        /**
         * Not sure what to do with this value, and the value itself may be "don't care", but we'll save it anyway.
         */
        this.regReset = bOut;
        if (this.chipset) this.chipset.clearIRR(ChipSet.IRQ.XTC);
        this.initController();
    }

    /**
     * inXTCConfig(port, addrFrom)
     *
     * @this {HDC}
     * @param {number} port (0x322)
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     * @returns {number} simulated port value
     */
    inXTCConfig(port, addrFrom)
    {
        this.printIO(port, undefined, addrFrom, "CONFIG", this.regConfig);
        return this.regConfig;
    }

    /**
     * outXTCPulse(port, bOut, addrFrom)
     *
     * @this {HDC}
     * @param {number} port (0x322)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to write the specified port)
     */
    outXTCPulse(port, bOut, addrFrom)
    {
        this.printIO(port, bOut, addrFrom, "PULSE");
        /**
         * Not sure what to do with this value, and the value itself may be "don't care", but we'll save it anyway.
         */
        this.regPulse = bOut;
        /**
         * The HDC BIOS "COMMAND" function (@C800:0562) waits for these ALL status bits after writing to both regPulse
         * and regPattern, so we must oblige it.
         *
         * TODO: Figure out exactly when either XTC.STATUS.BUS or XTC.STATUS.BUSY are supposed to be cleared.
         * The HDC BIOS doesn't care much about them, except for the one location mentioned above. However, MS-DOS 4.0
         * (aka the unreleased "multitasking" version of MS-DOS) cares, so I'm going to start by clearing them at the
         * same point I clear XTC.STATUS.IOMODE.
         */
        this.regStatus = HDC.XTC.STATUS.REQ | HDC.XTC.STATUS.BUS | HDC.XTC.STATUS.BUSY;
    }

    /**
     * outXTCPattern(port, bOut, addrFrom)
     *
     * @this {HDC}
     * @param {number} port (0x323)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to write the specified port)
     */
    outXTCPattern(port, bOut, addrFrom)
    {
        this.printIO(port, bOut, addrFrom, "PATTERN");
        this.regPattern = bOut;
    }

    /**
     * outXTCNoise(port, bOut, addrFrom)
     *
     * @this {HDC}
     * @param {number} port (0x327, 0x32B or 0x32F)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to write the specified port)
     */
    outXTCNoise(port, bOut, addrFrom)
    {
        this.printIO(port, bOut, addrFrom, "NOISE");
    }

    /**
     * inATCByte(port, addrFrom)
     *
     * @this {HDC}
     * @param {number} port (0x1F0)
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     * @returns {number} simulated port value
     */
    inATCByte(port, addrFrom)
    {
        let bIn = -1;
        let drive = this.drive;

        if (drive) {
            /**
             * We use the synchronous form of readData() at this point because we have no choice; an I/O instruction
             * has just occurred and cannot be delayed.  The good news is that doATC() should have already primed
             * the pump; all we can do is assert that the pump has something in it.  If bIn is inexplicably negative,
             * well, then the caller will get 0xff.
             */
            let hdc = this;
            bIn = this.readData(drive, function onATCReadData(b, fAsync, obj, off) {

                if (BACKTRACK && obj) {
                    if (!off && obj.file) {
                        hdc.printf(MESSAGE.DISK + MESSAGE.PORT + MESSAGE.ADDR, "loading %s[%d] via port %#06x\n", obj.file.path, obj.offFile, port);
                    }
                    /**
                     * TODO: We could define a cached BTO that's reset prior to a new ATC command, and then pass that
                     * to addBackTrackObject() here instead of null; but for now, we're going to rely on that function's
                     * simplistic MRU logic.  If that fails, the worst that will (or should) happen is we'll burn through
                     * more BackTrack wrapper objects than necessary, and risk running out.
                     */
                    let bto = hdc.bus.addBackTrackObject(obj, /** @type BackTrack */ (null), off);
                    hdc.cpu.backTrack.btiIO = hdc.bus.getBackTrackIndex(bto, off);
                }
            });


            if (drive.iByte == 1 || drive.iByte == drive.cbTransfer) {
                /**
                 * printIO() calls, if enabled, can be overwhelming for this port, so limit them to the first
                 * and last bytes of each sector.
                 */
                if (this.messageEnabled(MESSAGE.PORT + MESSAGE.HDC)) {
                    this.printIO(port, undefined, addrFrom, "DATA[" + drive.iByte + "]", bIn);
                }
                if (drive.iByte > 1) {          // in other words, if drive.iByte == drive.cbTransfer...
                    if (this.messageEnabled(MESSAGE.DATA + MESSAGE.HDC)) {
                        let sDump = drive.disk.dumpSector(drive.sector);
                        if (sDump) this.print(sDump);
                    }
                    /**
                     * Now that we've supplied a full sector of data, see if the caller's expecting additional sectors;
                     * if so, prime the pump again.  The caller should not poll us again until another interrupt's delivered.
                     */
                    drive.nBytes -= drive.cbTransfer;
                    this.regSecCnt = (this.regSecCnt - 1) & 0xff;
                    /**
                     * TODO: If the WITH_ECC bit is set in the READ_DATA command, then we need to support "stuffing" 4
                     * additional bytes into the inATCByte() stream.  And we must first set DATA_REQ in the STATUS register.
                     */
                    if (drive.nBytes >= drive.cbTransfer) {
                        /**
                         * FYI, with regard to regStatus, I'm simply aping what the ATC.COMMAND.READ_DATA setup code does
                         * for the first sector, which may not strictly be necessary for subsequent sectors....
                         */
                        hdc.regStatus = HDC.ATC.STATUS.BUSY;
                        this.readData(drive, function onATCReadDataNext(b, fAsync) {
                            if (b >= 0) {
                                hdc.setATCIRR();
                                /**
                                 * Due to the way I'm immediately triggering an interrupt whenever more data is available,
                                 * I must take a "shotgun approach' to regStatus bits in order to make the MODEL_5170_REV1,
                                 * MODEL_5170_REV3, and MODEL_COMPAQ_DESKPRO386 all happy.
                                 *
                                 * In general, it's fine for all of STATUS.READY, STATUS.SEEK_OK and STATUS.DATA_REQ to be
                                 * set now; the MODEL_5170_REV3 requires at least the first two, and the MODEL_COMPAQ_DESKPRO386
                                 * requires the third.  Unfortunately, the outlier is the MODEL_5170_REV1, which also needs
                                 * the STATUS.BUSY to be set on the first regStatus read after it finishes reading a sector;
                                 * otherwise, the MODEL_5170_REV1 BIOS will never read any remaining sectors.
                                 *
                                 * Technically, it doesn't make sense for both BUSY and READY to be set at the same time,
                                 * so we fix that in inATCStatus() by clearing BUSY whenever READY is detected *after* that
                                 * first read.  In addition, since this hack is really only needed for the MODEL_5170_REV1,
                                 * we clear BUSY immediately on the MODEL_COMPAQ_DESKPRO386 (which makes the Windows 95
                                 * protected-mode disk driver much happier).
                                 */
                                if (hdc.chipset && hdc.chipset.model == ChipSet.MODEL_COMPAQ_DESKPRO386) hdc.regStatus = 0;
                                hdc.regStatus |= HDC.ATC.STATUS.READY | HDC.ATC.STATUS.SEEK_OK | HDC.ATC.STATUS.DATA_REQ;
                            } else {
                                /**
                                 * TODO: It would be nice to be a bit more specific about the error (if any) that just occurred.
                                 * Consult drive.errorCode (it uses older XTC error codes, but mapping those codes should be trivial).
                                 */
                                hdc.regStatus = HDC.ATC.STATUS.ERROR;
                                hdc.regError = HDC.ATC.ERROR.NO_CHS;
                                if (DEBUG) hdc.printf("%s.inATCByte(): read failed\n", this.idComponent);
                            }
                        }, false);
                    } else {

                        this.regStatus = HDC.ATC.STATUS.READY;
                        if (!drive.useBuffer) {
                            this.regStatus |= HDC.ATC.STATUS.SEEK_OK;   // TODO: Necessary?
                        } else {
                            this.regSecCnt = HDC.ATC.SECCNT.PACKET_IO | HDC.ATC.SECCNT.PACKET_CD;
                            this.setATCIRR();
                        }
                    }
                }
            }
        }
        return bIn;
    }

    /**
     * inATCData(port, addrFrom)
     *
     * Wrapper around inATCByte() to treat this as a 16-bit port; see addPortInputWidth(HDC.ATC.DATA.PORT1, 2).
     *
     * @this {HDC}
     * @param {number} port (0x1F0,0x170)
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     * @returns {number} simulated port data
     */
    inATCData(port, addrFrom)
    {
        return this.inATCByte(port, addrFrom) | (this.inATCByte(port, addrFrom) << 8);
    }

    /**
     * outATCByte(port, bOut, addrFrom)
     *
     * @this {HDC}
     * @param {number} port (0x1F0,0x170)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to write the specified port)
     */
    outATCByte(port, bOut, addrFrom)
    {
        let drive = this.drive;
        if (drive) {
            if (drive.nBytes >= drive.cbTransfer) {
                if (this.writeData(drive, bOut) < 0) {
                    /**
                     * TODO: It would be nice to be a bit more specific about the error (if any) that just occurred.
                     * Consult drive.errorCode (it uses older XTC error codes, but mapping those codes should be trivial).
                     */
                    this.regStatus = HDC.ATC.STATUS.ERROR;
                    this.regError = HDC.ATC.ERROR.NO_CHS;
                    if (DEBUG) {
                        this.printf("%s.outATCByte(%#04x): write failed\n", this.idComponent, bOut);
                    }
                }
                else if (drive.iByte == 1 || drive.iByte == drive.cbTransfer) {
                    /**
                     * printIO() calls, if enabled, can be overwhelming for this port, so limit them to the first
                     * and last bytes of each sector.
                     */
                    if (this.messageEnabled(MESSAGE.PORT + MESSAGE.HDC)) {
                        this.printIO(port, bOut, addrFrom, "DATA[" + drive.iByte + "]");
                    }
                    if (drive.iByte > 1) {          // in other words, if drive.iByte == drive.cbTransfer...
                        if (this.messageEnabled(MESSAGE.DATA + MESSAGE.HDC)) {
                            let sDump = drive.disk.dumpSector(drive.sector);
                            if (sDump) this.print(sDump);
                        }
                        drive.nBytes -= drive.cbTransfer;
                        this.regSecCnt = (this.regSecCnt - 1) & 0xff;
                        this.regStatus = HDC.ATC.STATUS.READY | HDC.ATC.STATUS.SEEK_OK;
                        if (drive.nBytes >= drive.cbTransfer) {
                            this.regStatus |= HDC.ATC.STATUS.DATA_REQ;
                        } else {

                            if (drive.useBuffer) {
                                this.processPacket(drive);
                                return;
                            }
                        }
                        this.setATCIRR(true);
                    }
                }
            } else {
                /**
                 * TODO: What to do about unexpected writes? The number of bytes has exceeded what the command specified.
                 */
                if (DEBUG) {
                    this.printf("%s.outATCByte(%#04x): write exceeds count (%d)\n", this.idComponent, bOut, this.drive.nBytes);
                }
            }
        } else {
            /**
             * TODO: What to do about unexpected writes? No command was specified.
             */
            if (DEBUG) {
                this.printf("%s.outATCByte(%#04x): write without command\n", this.idComponent, bOut);
            }
        }
    }

    /**
     * outATCData(port, data, addrFrom)
     *
     * Wrapper around outATCByte() to treat this as a 16-bit port; see addPortOutputWidth(HDC.ATC.DATA.PORT1, 2)
     *
     * @this {HDC}
     * @param {number} port (0x1F0,0x170)
     * @param {number} data
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to write the specified port)
     */
    outATCData(port, data, addrFrom)
    {
        this.outATCByte(port, data & 0xff, addrFrom);
        this.outATCByte(port, (data >> 8) & 0xff, addrFrom);
    }

    /**
     * inATCError(port, addrFrom)
     *
     * @this {HDC}
     * @param {number} port (0x1F1,0x171)
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     * @returns {number} simulated port value
     */
    inATCError(port, addrFrom)
    {
        let bIn = this.regError;
        this.printIO(port, undefined, addrFrom, "ERROR", bIn);
        return bIn;
    }

    /**
     * outATCWPreC(port, bOut, addrFrom)
     *
     * @this {HDC}
     * @param {number} port (0x1F1,0x171)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to write the specified port)
     */
    outATCWPreC(port, bOut, addrFrom)
    {
        this.printIO(port, bOut, addrFrom, "WPREC");
        this.regWPreC = bOut;
    }

    /**
     * inATCSecCnt(port, addrFrom)
     *
     * @this {HDC}
     * @param {number} port (0x1F2,0x172)
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     * @returns {number} simulated port value
     */
    inATCSecCnt(port, addrFrom)
    {
        let bIn = this.regSecCnt;
        this.printIO(port, undefined, addrFrom, "SECCNT", bIn);
        return bIn;
    }

    /**
     * outATCSecCnt(port, bOut, addrFrom)
     *
     * @this {HDC}
     * @param {number} port (0x1F2,0x172)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to write the specified port)
     */
    outATCSecCnt(port, bOut, addrFrom)
    {
        this.printIO(port, bOut, addrFrom, "SECCNT");
        this.regSecCnt = bOut;
    }

    /**
     * inATCSecNum(port, addrFrom)
     *
     * @this {HDC}
     * @param {number} port (0x1F3,0x173)
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     * @returns {number} simulated port value
     */
    inATCSecNum(port, addrFrom)
    {
        let bIn = this.regSecNum;
        this.printIO(port, undefined, addrFrom, "SECNUM", bIn);
        return bIn;
    }

    /**
     * outATCSecNum(port, bOut, addrFrom)
     *
     * @this {HDC}
     * @param {number} port (0x1F3,0x173)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to write the specified port)
     */
    outATCSecNum(port, bOut, addrFrom)
    {
        this.printIO(port, bOut, addrFrom, "SECNUM");
        this.regSecNum = bOut;
    }

    /**
     * inATCCylLo(port, addrFrom)
     *
     * @this {HDC}
     * @param {number} port (0x1F4,0x174)
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     * @returns {number} simulated port value
     */
    inATCCylLo(port, addrFrom)
    {
        let bIn = this.regCylLo;
        this.printIO(port, undefined, addrFrom, "CYLLO", bIn);
        return bIn;
    }

    /**
     * outATCCylLo(port, bOut, addrFrom)
     *
     * @this {HDC}
     * @param {number} port (0x1F4,0x174)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to write the specified port)
     */
    outATCCylLo(port, bOut, addrFrom)
    {
        this.printIO(port, bOut, addrFrom, "CYLLO");
        this.regCylLo = bOut;
    }

    /**
     * inATCCylHi(port, addrFrom)
     *
     * @this {HDC}
     * @param {number} port (0x1F5,0x175)
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     * @returns {number} simulated port value
     */
    inATCCylHi(port, addrFrom)
    {
        let bIn = this.regCylHi;
        this.printIO(port, undefined, addrFrom, "CYLHI", bIn);
        return bIn;
    }

    /**
     * outATCCylHi(port, bOut, addrFrom)
     *
     * @this {HDC}
     * @param {number} port (0x1F5,0x175)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to write the specified port)
     */
    outATCCylHi(port, bOut, addrFrom)
    {
        this.printIO(port, bOut, addrFrom, "CYLHI");
        this.regCylHi = bOut;
    }

    /**
     * inATCDrvHd(port, addrFrom)
     *
     * @this {HDC}
     * @param {number} port (0x1F6,0x176)
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     * @returns {number} simulated port value
     */
    inATCDrvHd(port, addrFrom)
    {
        let bIn = this.regDrvHd;
        this.printIO(port, undefined, addrFrom, "DRVHD", bIn);
        return bIn;
    }

    /**
     * outATCDrvHd(port, bOut, addrFrom)
     *
     * @this {HDC}
     * @param {number} port (0x1F6,0x176)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to write the specified port)
     */
    outATCDrvHd(port, bOut, addrFrom)
    {
        this.printIO(port, bOut, addrFrom, "DRVHD");
        this.regDrvHd = bOut;
        /**
         * The MODEL_5170_REV3 BIOS (see "POST2_CHK_HF2" @F000:14FC) probes for a 2nd hard drive when the number
         * of configured hard drives is something other than 2, using INT 0x13/AH=0x10.  This in turn calls the
         * BIOS "TST_RDY" function, which selects the drive in this register (see DRIVE_MASK), and then immediately
         * expects regStatus to reflect success or failure.
         *
         * We were always returning success, because no ATC command was actually issued, and so the user would
         * always get a spurious CMOS configuration error: "System Options Not Set-(Run SETUP)".
         *
         * So now we update regStatus here.  I'm not sure which status bits are normally set to indicate failure,
         * but it should be sufficient to set or clear the READY bit according to whether the drive exists or not.
         *
         * TODO: Dig into the ATC documentation some more, and determine what other situations, if any, regStatus
         * needs to be updated.
         *
         * UPDATE: The COMPAQ DeskPro 386 ROM BIOS requires setting STATUS.SEEK_OK in addition to STATUS.READY;
         * a quick retest of the MODEL_5170_REV3 BIOS suggests that it's happy with that change, so it's quite likely
         * that was the appropriate change all along.
         */
        let iDrive = (this.regDrvHd & HDC.ATC.DRVHD.DRIVE_MASK? 1 : 0);
        if (this.aDrives[iDrive]) {
            this.regStatus |= HDC.ATC.STATUS.READY | HDC.ATC.STATUS.SEEK_OK;
        } else {
            this.regStatus &= ~HDC.ATC.STATUS.READY;
        }
    }

    /**
     * inATCStatus(port, addrFrom)
     *
     * @this {HDC}
     * @param {number} port (0x1F7,0x177)
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to read the specified port)
     * @returns {number} simulated port value
     */
    inATCStatus(port, addrFrom)
    {
        let bIn = this.regStatus;
        this.printIO(port, undefined, addrFrom, "STATUS", bIn);
        /**
         * Despite what IBM's documentation for the "Personal Computer AT Fixed Disk and Diskette Drive Adapter"
         * (August 31, 1984) says (ie, "A read of the status register clears interrupt request 14"), we cannot
         * unilaterally clear the IRQ on any read of STATUS.  For starters, that would completely break the PC AT
         * ROM BIOS; here's what it does for multi-sector reads:
         *
         *      (1) read sector (REP INSW)
         *      (2) check STATUS
         *      (3) check sector count, exit if done
         *      (4) wait for interrupt
         *      (5) repeat
         *
         * Since we set the IRR immediately after (1), we cannot immediately clear the IRR at (2), otherwise the
         * interrupt at (4) never happens.  So, maybe there are SOME situations where IRR should be cleared on
         * a read, but I don't know what they are.
         *
         *      if (this.chipset) this.chipset.clearIRR(ChipSet.IRQ.ATC1 + this.nInterface);
         */
        if (this.regStatus & HDC.ATC.STATUS.READY) this.regStatus &= ~HDC.ATC.STATUS.BUSY;
        return bIn;
    }

    /**
     * outATCCommand(port, bOut, addrFrom)
     *
     * @this {HDC}
     * @param {number} port (0x1F7,0x177)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to write the specified port)
     */
    outATCCommand(port, bOut, addrFrom)
    {
        this.printIO(port, bOut, addrFrom, "COMMAND");
        this.regCommand = bOut;
        if (this.chipset) this.chipset.clearIRR(ChipSet.IRQ.ATC1 + this.nInterface);
        this.doATC();
    }

    /**
     * outATCFDR(port, bOut, addrFrom)
     *
     * This is referred to in IBM's docs as the "Fixed Disk Register" (write-only); aka "Device Control Register".
     *
     * @this {HDC}
     * @param {number} port (0x3F6,0x376)
     * @param {number} bOut
     * @param {number} [addrFrom] (not defined whenever the Debugger tries to write the specified port)
     */
    outATCFDR(port, bOut, addrFrom)
    {
        this.printIO(port, bOut, addrFrom, "FDR");
        /**
         * I'm not really sure if I should set HDC.ATC.DIAG.NO_ERROR in regError after *every* write where
         * HDC.ATC.FDR.RESET is clear, or only after it has transitioned from set to clear; since the BIOS only
         * requires the latter, I'm going to be conservative and restrict regError updates to the latter.
         */
        if ((this.regFDR & HDC.ATC.FDR.RESET) && !(bOut & HDC.ATC.FDR.RESET)) this.regError = HDC.ATC.DIAG.NO_ERROR;
        this.regFDR = bOut;
    }

    /**
     * doATC()
     *
     * Handles ATC (AT Controller) commands.  Initially, just PC AT (ATA) commands were supported,
     * but in order to work with CD-ROM devices, selected (ATA-1 and ATAPI) commands have been added.
     * However, the configuration must request that support; eg:
     *
     *      	<hdc id="cdrom" type="ATAPI" drives='[{name:"CD-ROM Drive"}]'/>
     *
     * in order to set the fATAPI property and enable that support.
     *
     * @this {HDC}
     */
    doATC()
    {
        let hdc = this;
        let fInterrupt = false, fProcessed = false;

        let bCmd = this.regCommand;
        let bCmdMasked = bCmd & ~HDC.ATC.COMMAND.STEP_RATE;
        if (bCmdMasked == HDC.ATC.COMMAND.RESTORE || bCmdMasked == HDC.ATC.COMMAND.SEEK) {
            bCmd = bCmdMasked;
        } else if (bCmdMasked == HDC.ATC.COMMAND.READ_DATA || bCmdMasked == HDC.ATC.COMMAND.WRITE_DATA) {
            bCmd &= ~(HDC.ATC.COMMAND.NO_RETRY | HDC.ATC.COMMAND.WITH_ECC);
        } else if (bCmdMasked == HDC.ATC.COMMAND.READ_VERF) {
            bCmd &= ~(HDC.ATC.COMMAND.NO_RETRY);
        }

        let iDrive = (this.regDrvHd & HDC.ATC.DRVHD.DRIVE_MASK? 1 : 0);
        let nHead = this.regDrvHd & HDC.ATC.DRVHD.HEAD_MASK;
        let nCylinder = this.regCylLo | ((this.regCylHi & HDC.ATC.CYLHI.MASK) << 8);
        let nSector = this.regSecNum;
        let nSectors = this.regSecCnt || 256;

        this.iDrive = -1;
        this.drive = null;
        this.regError = HDC.ATC.ERROR.NONE;
        this.regStatus = HDC.ATC.STATUS.READY | HDC.ATC.STATUS.SEEK_OK;
        let drive = this.aDrives[iDrive];

        this.printf(MESSAGE.HDC + MESSAGE.PORT + MESSAGE.ADDR, "%s.doATC(%d,%#04x): %s%s\n", this.idComponent, (this.nInterface*2+iDrive), bCmd, HDC.aATACommands[bCmd], (drive? "" : " (drive " + iDrive + " not present)"));

        if (!drive) return;
        this.iDrive = iDrive;
        this.drive = drive;

        /**
         * Update the Drive object with the new positional information associated with this command.
         */
        drive.wCylinder = nCylinder;
        drive.bHead = nHead;
        drive.bSector = nSector;
        drive.nBytes = nSectors * (drive.cbTransfer = drive.cbSector);

        /**
         * Since the (original) ATC doesn't use DMA, we must now set some additional Drive state for the benefit
         * of any follow-up I/O instructions.  For example, any subsequent inATCByte() and outATCByte() calls need
         * to know which drive to talk to ("this.drive"), to issue their own readData() and writeData() calls.
         *
         * The XTC didn't need this, because it used doRead(), doWrite(), doFormat() helper functions, which reset
         * the current drive's sector and errorCode properties themselves and then used DMA functions that delivered
         * drive data with direct calls to readData() and writeData().
         */
        drive.sector = null;
        drive.iByte = 0;
        drive.errorCode = 0;
        drive.useBuffer = false;

        switch (bCmd) {

        case HDC.ATC.COMMAND.RESET:                 // 0x08 (ATAPI)
            if (this.processReset(drive)) {
                fProcessed = true;
            }
            break;

        case HDC.ATC.COMMAND.RESTORE:               // 0x10 (ATA)
            /**
             * Physically, this retracts the heads to cylinder 0, but logically, there isn't anything to do.
             */
            fInterrupt = fProcessed = true;
            break;

        case HDC.ATC.COMMAND.IDPACKET:              // 0xA1 (ATAPI)
        case HDC.ATC.COMMAND.IDDEVICE:              // 0xEC (ATA-1)
            if (!this.processIdentify(drive, bCmd)) break;
            /* falls through */

        case HDC.ATC.COMMAND.READ_DATA:             // 0x20 (ATA)
            if (!drive.useBuffer) {
                this.printf(MESSAGE.HDC + MESSAGE.PORT, "%s.doATCRead(%d,%d:%d:%d,%d)\n", this.idComponent, iDrive, drive.wCylinder, drive.bHead, drive.bSector, nSectors);
            }
            /**
             * We're using a call to readData() that disables auto-increment, so that once we've got the first
             * byte of the next sector, we can signal an interrupt without also consuming the first byte, allowing
             * inATCByte() to begin with that byte.
             */
            this.regStatus = HDC.ATC.STATUS.BUSY;
            this.readData(drive, function onATCReadDataFirst(b, fAsync) {
                if (b >= 0 && hdc.chipset) {
                    hdc.setATCIRR();
                    /**
                     * Bytes from the requested sector(s) will now be delivered via inATCByte().
                     *
                     * FYI, I'm taking a shotgun approach to these status bits: I need to clear STATUS.BUSY and
                     * set STATUS.DATA_REQ, because otherwise COMPAQ DeskPro 386 reads will fail, and I need to set
                     * the STATUS.READY and STATUS.SEEK_OK bits, because otherwise MODEL_5170_REV3 reads will fail.
                     */
                    hdc.regStatus = HDC.ATC.STATUS.READY | HDC.ATC.STATUS.SEEK_OK | HDC.ATC.STATUS.DATA_REQ;
                } else {
                    /**
                     * TODO: It would be nice to be a bit more specific about the error (if any) that just occurred.
                     * Consult drive.errorCode (it uses older XTC error codes, but mapping those codes should be trivial).
                     */
                    hdc.regStatus = HDC.ATC.STATUS.ERROR;
                    hdc.regError = HDC.ATC.ERROR.NO_CHS;
                }
            }, false);
            fProcessed = true;
            break;

        case HDC.ATC.COMMAND.PACKET:                // 0xA0 (ATAPI)
            this.initBuffer(drive);
            drive.useBuffer = true;
            drive.nBytes = drive.cbTransfer = 12;
            this.regSecCnt = HDC.ATC.SECCNT.PACKET_CD;
            /* falls through */

        case HDC.ATC.COMMAND.WRITE_DATA:            // 0x30 (ATA)
            if (!drive.useBuffer) {
                this.printf(MESSAGE.HDC + MESSAGE.PORT, "%s.doATCWrite(%d,%d:%d:%d,%d)\n", this.idComponent, iDrive, drive.wCylinder, drive.bHead, drive.bSector, nSectors);
            }
            this.regStatus = HDC.ATC.STATUS.DATA_REQ;
            fProcessed = true;
            break;

        case HDC.ATC.COMMAND.READ_VERF:             // 0x40 (ATA)
            /**
             * Since the READ VERIFY command returns no data, once again, logically, there isn't much we HAVE to
             * to do, but... TODO: Verify that all the disk parameters are valid, and return an error if they're not.
             */
            fInterrupt = fProcessed = true;
            break;

        case HDC.ATC.COMMAND.SEEK:                  // 0x70 (ATA)
            /**
             * Physically, this moves the head(s) to the requested cylinder, but logically, there isn't anything to do;
             * in fact, we didn't even need this command for the MODEL_5170 ROM BIOS (the COMPAQ DeskPro 386 ROM BIOS was
             * another story).
             */
            fInterrupt = fProcessed = true;
            break;

        case HDC.ATC.COMMAND.DIAGNOSE:              // 0x90 (ATA)
            this.regError = HDC.ATC.DIAG.NO_ERROR;
            fInterrupt = fProcessed = true;
            break;

        case HDC.ATC.COMMAND.SETPARMS:              // 0x91 (ATA)
            /**
             * The documentation implies that the only parameters this command really affects are the number
             * of heads (from regDrvHd) and sectors/track (from regSecCnt) -- this despite the fact that the BIOS
             * programs all the other registers.  For a type 2 drive, that includes:
             *
             *      WPREC:   0x4B
             *      SECCNT:  0x11 (for 17 sectors per track)
             *      CYL:    0x100 (256 -- huh?)
             *      SECNUM:  0x0C (12 -- huh?)
             *      DRVHD:   0xA3 (max head of 0x03, for 4 total heads)
             *
             * The importance of SECCNT (nSectors) and DRVHD (nHeads) is controlling how multi-sector operations
             * advance to the next sector; see advanceSector().
             */
            drive.nHeads = nHead + 1;
            drive.nSectors = nSectors;
            fInterrupt = fProcessed = true;
            break;

        /**
         * We don't need a 'default' case because any command that declined to set fProcessed will be dealt with below.
         */
        }

        if (fProcessed) {
            if (fInterrupt) this.setATCIRR();
        } else {
            this.regStatus = HDC.ATC.STATUS.ERROR;
            this.regError = HDC.ATC.ERROR.CMD_ABORT;
            if (this.messageEnabled()) {
                this.printf("%s.doATC(%#04x): unsupported operation\n", this.idComponent, this.regCommand);
                if (MAXDEBUG) this.dbg.stopCPU();
            }
        }
    }

    /**
     * setATCIRR(fWrite)
     *
     * Raise the ATC's IRQ, provided ATC interrupts are enabled.
     *
     * @this {HDC}
     * @param {boolean} [fWrite] is true on completion of a write to the sector buffer
     */
    setATCIRR(fWrite)
    {
        if (this.chipset) {
            if (!(this.regFDR & HDC.ATC.FDR.INT_DISABLE)) {
                /**
                 * TODO: Determine what the "correct" instruction delay should be here.  When the OS/2 1.0 Install Disk
                 * begins copying files to the hard drive, at one point it performs the following 125-sector write (use the
                 * Debugger's "m hdc on" and "m pic on" commands to enable HDC and PIC messages, along with "m data on"
                 * if you also want to see the actual sector data being written):
                 *
                 *      HDC.doATC(0x30): Write
                 *      HDC.doATCWrite(0,2:0:5,125)
                 *
                 * As the write progresses, you'll notice that the HDC interrupt after each sector occurs at decreasingly
                 * lower points in the stack, until we eventually start overwriting non-stack data:
                 *
                 *      getIRRVector(): IRQ 14 interrupting @0090:52A6 stack=0050:1906
                 *      getIRRVector(): IRQ 14 interrupting @0318:196B stack=0050:18D6
                 *      getIRRVector(): IRQ 14 interrupting @0318:196B stack=0050:18A6
                 *      ...
                 *      getIRRVector(): IRQ 14 interrupting @0318:196B stack=0050:1156
                 *
                 * At roughly this point, very bad things start happening.  I decided to try an arbitrarily large delay
                 * on the setIRR() call here (120), and the problem vanished, so it seems likely that the OS/2 disk driver
                 * has a low tolerance for fast controller interrupts during multi-sector operations.
                 */
                this.chipset.setIRR(ChipSet.IRQ.ATC1 + this.nInterface, 120);
                if (DEBUG) this.printf(MESSAGE.PIC + MESSAGE.HDC, "%s.setATCIRR(): enabled\n", this.idComponent);
            } else {
                if (DEBUG) this.printf(MESSAGE.PIC + MESSAGE.HDC, "%s.setATCIRR(): disabled\n", this.idComponent);
            }
        }
    }

    /**
     * doXTC()
     *
     * Handles XTC (XT Controller) commands
     *
     * @this {HDC}
     */
    doXTC()
    {
        let hdc = this;
        this.regDataIndex = 0;

        let bCmd = this.popCmd();
        let bCmdOrig = bCmd;
        let b1 = this.popCmd();
        let bDrive = b1 & 0x20;
        let iDrive = (bDrive >> 5);

        let bHead = b1 & 0x1f;
        let b2 = this.popCmd();
        let b3 = this.popCmd();
        let wCylinder = ((b2 << 2) & 0x300) | b3;
        let bSector = b2 & 0x3f;
        let bCount = this.popCmd();                 // block count or interleave count, depending on the command
        let bControl = this.popCmd();
        let bParm, bDataStatus;

        let drive = this.aDrives[iDrive];
        if (drive) {
            drive.wCylinder = wCylinder;
            drive.bHead = bHead;
            drive.bSector = bSector;
            drive.nBytes = bCount * drive.cbSector;
        }

        /**
         * I tried to save normal command processing from having to deal with invalid drives,
         * but the HDC BIOS initializes both drive 0 AND drive 1 on a HDC.XTC.DATA.CMD.INIT_DRIVE command,
         * and apparently that particular command has no problem with non-existent drives.
         *
         * So I've separated the commands into two groups: drive-ambivalent commands should be
         * processed in the first group, and all the rest should be processed in the second group.
         */
        let i;
        switch (bCmd) {

        case HDC.XTC.DATA.CMD.REQ_SENSE:            // 0x03
            this.beginResult(drive? drive.errorCode : HDC.XTC.DATA.ERR.NOT_READY);
            this.pushResult(b1);
            this.pushResult(b2);
            this.pushResult(b3);
            /**
             * Although not terribly clear from IBM's "Fixed Disk Adapter" documentation, a data "status byte"
             * also follows the 4 "sense bytes".  Interestingly, The HDC BIOS checks that data status byte for
             * XTC.DATA.STATUS.ERROR, but I have to wonder if it would have ever been set for this command....
             *
             * The whole point of the HDC.XTC.DATA.CMD.REQ_SENSE command is to obtain details about a
             * previous error, so if HDC.XTC.DATA.CMD.REQ_SENSE itself reports an error, what would that mean?
             */
            this.pushResult(HDC.XTC.DATA.STATUS.OK | bDrive);
            bCmd = -1;                              // mark the command as complete
            break;

        case HDC.XTC.DATA.CMD.INIT_DRIVE:           // 0x0C
            /**
             * Pop off all the extra "Initialize Drive Characteristics" bytes and store them, for the benefit of
             * other functions, like verifyDrive().
             */
            i = 0;
            while ((bParm = this.popCmd()) >= 0) {
                if (drive && i < drive.abDriveParms.length) {
                    drive.abDriveParms[i++] = bParm;
                }
            }
            if (drive) this.verifyDrive(drive);
            bDataStatus = HDC.XTC.DATA.STATUS.OK;
            if (!drive && this.iDriveAllowFail == iDrive) {
                this.iDriveAllowFail = -1;
                if (DEBUG) this.printf(MESSAGE.HDC + MESSAGE.PORT, "%s.doXTC(): fake failure triggered\n", this.idComponent);
                bDataStatus = HDC.XTC.DATA.STATUS.ERROR;
            }
            this.beginResult(bDataStatus | bDrive);
            bCmd = -1;                              // mark the command as complete
            break;

        case HDC.XTC.DATA.CMD.RAM_DIAGNOSTIC:       // 0xE0
        case HDC.XTC.DATA.CMD.CTL_DIAGNOSTIC:       // 0xE4
            this.beginResult(HDC.XTC.DATA.STATUS.OK | bDrive);
            bCmd = -1;                              // mark the command as complete
            break;

        default:
            break;
        }

        if (bCmd >= 0) {
            if (drive === undefined) {
                bCmd = -1;
            } else {
                /**
                 * In preparation for this command, zero out the drive's errorCode and senseCode.
                 * Commands that require a disk address should update senseCode with HDC.XTC.DATA.SENSE_ADDR_VALID.
                 * And of course, any command that encounters an error should set the appropriate error code.
                 */
                drive.errorCode = HDC.XTC.DATA.ERR.NONE;
                drive.senseCode = 0;
            }
            switch (bCmd) {
            case HDC.XTC.DATA.CMD.TEST_READY:       // 0x00
                this.beginResult(HDC.XTC.DATA.STATUS.OK | bDrive);
                break;

            case HDC.XTC.DATA.CMD.RECALIBRATE:      // 0x01
                drive.bControl = bControl;
                if (DEBUG) {
                    this.printf(MESSAGE.HDC + MESSAGE.PORT, "%s.doXTC(): drive %d control byte: %#04x\n", this.idComponent, iDrive, bControl);
                }
                this.beginResult(HDC.XTC.DATA.STATUS.OK | bDrive);
                break;

            case HDC.XTC.DATA.CMD.READ_VERF:        // 0x05
                /**
                 * This is a non-DMA operation, so we simply pretend everything is OK for now.  TODO: Revisit.
                 */
                this.beginResult(HDC.XTC.DATA.STATUS.OK | bDrive);
                break;

            case HDC.XTC.DATA.CMD.READ_DATA:        // 0x08
                this.doRead(drive, function onXTCReadDataCommand(bStatus) {
                    hdc.beginResult(bStatus | bDrive);
                });
                break;

            case HDC.XTC.DATA.CMD.WRITE_DATA:       // 0x0A
                /**
                 * QUESTION: The IBM TechRef (p.1-188) implies that bCount is used as part of HDC.XTC.DATA.CMD.WRITE_DATA command,
                 * but it is omitted from the HDC.XTC.DATA.CMD.READ_DATA command.  Is that correct?  Note that, as far as the length
                 * of the transfer is concerned, we rely exclusively on the DMA controller being programmed with the appropriate byte count.
                 */
                this.doWrite(drive, function onXTCWriteDataCommand(bStatus) {
                    hdc.beginResult(bStatus | bDrive);
                });
                break;

            case HDC.XTC.DATA.CMD.WRITE_BUFFER:     // 0x0F
                this.doWriteBuffer(drive, function onXTCWriteBufferCommand(bStatus) {
                    hdc.beginResult(bStatus | bDrive);
                });
                break;

            default:
                this.beginResult(HDC.XTC.DATA.STATUS.ERROR | bDrive);
                if (this.messageEnabled()) {
                    this.printf("%s.doXTC(%#04x): %d\n", this.idComponent, bCmdOrig, (bCmd < 0? ("invalid drive (" + iDrive + ")") : "unsupported operation"));
                    if (MAXDEBUG && bCmd >= 0) this.dbg.stopCPU();
                }
                break;
            }
        }
    }

    /**
     * popCmd()
     *
     * @this {HDC}
     * @returns {number}
     */
    popCmd()
    {
        let bCmd = -1;
        let bCmdIndex = this.regDataIndex;
        if (bCmdIndex < this.regDataTotal) {
            bCmd = this.regDataArray[this.regDataIndex++];
            this.printf((bCmdIndex > 0? MESSAGE.PORT : 0) + MESSAGE.HDC, "%s.popCmd(%d): %#04x%s\n", this.idComponent, bCmdIndex, bCmd, (!bCmdIndex && HDC.aXTACommands[bCmd]? (" (" + HDC.aXTACommands[bCmd] + ")") : ""));
        }
        return bCmd;
    }

    /**
     * beginResult(bResult)
     *
     * @this {HDC}
     * @param {number} [bResult]
     */
    beginResult(bResult)
    {
        this.regDataIndex = this.regDataTotal = 0;
        if (bResult !== undefined) this.pushResult(bResult);
        /**
         * After the Execution phase (e.g., DMA Terminal Count has occurred, or the EOT sector has been read/written),
         * an interrupt is supposed to occur, signaling the beginning of the Result Phase.  Once the data "status byte"
         * has been read from XTC.DATA, the interrupt is cleared (see inXTCData).
         */
        if (this.chipset) this.chipset.setIRR(ChipSet.IRQ.XTC);
        this.regStatus |= HDC.XTC.STATUS.INTERRUPT;
    }

    /**
     * pushResult(bResult)
     *
     * @this {HDC}
     * @param {number} bResult
     */
    pushResult(bResult)
    {
        if (DEBUG) {
            this.printf((this.regDataTotal > 0? MESSAGE.PORT : 0) + MESSAGE.HDC, "%s.pushResult(%d): %#04x\n", this.idComponent, this.regDataTotal, bResult);
        }
        this.regDataArray[this.regDataTotal++] = bResult;
    }

    /**
     * doDMARead(drive, b, done)
     *
     * @this {HDC}
     * @param {Drive} drive
     * @param {number} b
     * @param {function(number,boolean)} done
     */
    doDMARead(drive, b, done)
    {
        if (b === undefined || b < 0) {
            this.readData(drive, done);
            return;
        }
        /**
         * The DMA controller should be ASKING for data, not GIVING us data; this suggests an internal DMA miscommunication
         */
        if (DEBUG) this.printf(MESSAGE.HDC + MESSAGE.PORT, "%s.doDMARead(): invalid DMA acknowledgement\n", this.idComponent);
        done(-1, false);
    }

    /**
     * doDMAWrite(drive, b)
     *
     * @this {HDC}
     * @param {Drive} drive
     * @param {number} b
     * @returns {number}
     */
    doDMAWrite(drive, b)
    {
        if (b !== undefined && b >= 0) {
            return this.writeData(drive, b);
        }
        /**
         * The DMA controller should be GIVING us data, not ASKING for data; this suggests an internal DMA miscommunication
         */
        if (DEBUG) this.printf(MESSAGE.HDC + MESSAGE.PORT, "%s.doDMAWrite(): invalid DMA acknowledgement\n", this.idComponent);
        return -1;
    }

    /**
     * doDMAWriteBuffer(drive, b)
     *
     * @this {HDC}
     * @param {Drive} drive
     * @param {number} b
     * @returns {number}
     */
    doDMAWriteBuffer(drive, b)
    {
        if (b !== undefined && b >= 0) {
            return this.writeBuffer(drive, b);
        }
        /**
         * The DMA controller should be GIVING us data, not ASKING for data; this suggests an internal DMA miscommunication
         */
        if (DEBUG) this.printf(MESSAGE.HDC + MESSAGE.PORT, "%s.doDMAWriteBuffer(): invalid DMA acknowledgement\n", this.idComponent);
        return -1;
    }

    /**
     * doDMAWriteFormat(drive, b)
     *
     * @this {HDC}
     * @param {Drive} drive
     * @param {number} b
     * @returns {number}
     */
    doDMAWriteFormat(drive, b)
    {
        if (b !== undefined && b >= 0) {
            return this.writeFormat(drive, b);
        }
        /**
         * The DMA controller should be GIVING us data, not ASKING for data; this suggests an internal DMA miscommunication
         */
        if (DEBUG) this.printf(MESSAGE.HDC + MESSAGE.PORT, "%s.doDMAWriteFormat(): invalid DMA acknowledgement\n", this.idComponent);
        return -1;
    }

    /**
     * doRead(drive, done)
     *
     * @this {HDC}
     * @param {Drive} drive
     * @param {function(number)} done (dataStatus is XTC.DATA.STATUS.OK or XTC.DATA.STATUS.ERROR; if error, then drive.errorCode should be set as well)
     */
    doRead(drive, done)
    {
        drive.errorCode = HDC.XTC.DATA.ERR.NOT_READY;

        this.printf(MESSAGE.HDC + MESSAGE.PORT, "%s.doRead(%d,%d:%d:%d,%d)\n", this.idComponent, drive.iDrive, drive.wCylinder, drive.bHead, drive.bSector, ((drive.nBytes / drive.cbSector)|0));

        if (drive.disk) {
            drive.sector = null;
            if (this.chipset) {
                /**
                 * We need to reverse the original logic, and default to success unless/until an actual error occurs;
                 * otherwise doDMARead()/readData() will bail on us.  The original approach used to work because requestDMA()
                 * would immediately call us back with fComplete set to true EVEN if the DMA channel was not yet unmasked;
                 * now the callback is deferred until the DMA channel has been unmasked and the DMA request has finished.
                 */
                drive.errorCode = HDC.XTC.DATA.ERR.NONE;
                this.chipset.connectDMA(ChipSet.DMA_HDC, this, 'dmaRead', drive);
                this.chipset.requestDMA(ChipSet.DMA_HDC, function onDMAReadRequest(fComplete) {
                    if (!fComplete) {
                        /**
                         * If an incomplete request wasn't triggered by an explicit error, then let's make explicit
                         * (ie, revert to the default failure code that we originally set above).
                         */
                        if (drive.errorCode == HDC.XTC.DATA.ERR.NONE) {
                            drive.errorCode = HDC.XTC.DATA.ERR.NOT_READY;
                        }
                    }
                    done(drive.errorCode? HDC.XTC.DATA.STATUS.ERROR : HDC.XTC.DATA.STATUS.OK);
                });
                return;
            }
        }
        done(drive.errorCode? HDC.XTC.DATA.STATUS.ERROR : HDC.XTC.DATA.STATUS.OK);
    }

    /**
     * doWrite(drive, done)
     *
     * @this {HDC}
     * @param {Drive} drive
     * @param {function(number)} done (dataStatus is XTC.DATA.STATUS.OK or XTC.DATA.STATUS.ERROR; if error, then drive.errorCode should be set as well)
     */
    doWrite(drive, done)
    {
        drive.errorCode = HDC.XTC.DATA.ERR.NOT_READY;

        this.printf(MESSAGE.HDC + MESSAGE.PORT, "%s.doWrite(%d,%d:%d:%d,%d)\n", this.idComponent, drive.iDrive, drive.wCylinder, drive.bHead, drive.bSector, ((drive.nBytes / drive.cbSector)|0));

        if (drive.disk) {
            drive.sector = null;
            if (this.chipset) {
                /**
                 * We need to reverse the original logic, and default to success unless/until an actual error occurs;
                 * otherwise doDMAWrite()/writeData() will bail on us.  The original approach would work because requestDMA()
                 * would immediately call us back with fComplete set to true EVEN if the DMA channel was not yet unmasked;
                 * now the callback is deferred until the DMA channel has been unmasked and the DMA request has finished.
                 */
                drive.errorCode = HDC.XTC.DATA.ERR.NONE;
                this.chipset.connectDMA(ChipSet.DMA_HDC, this, 'dmaWrite', drive);
                this.chipset.requestDMA(ChipSet.DMA_HDC, function onDMAWriteRequest(fComplete) {
                    if (!fComplete) {
                        /**
                         * If an incomplete request wasn't triggered by an explicit error, then let's make explicit
                         * (ie, revert to the default failure code that we originally set above).
                         */
                        if (drive.errorCode == HDC.XTC.DATA.ERR.NONE) {
                            drive.errorCode = HDC.XTC.DATA.ERR.NOT_READY;
                        }
                        /**
                         * Mask any error that's the result of an attempt to write beyond the end of the track (which is
                         * something the MS-DOS 4.0M's FORMAT utility seems to like to do).
                         */
                        if (drive.errorCode == HDC.XTC.DATA.ERR.NO_SECTOR) {
                            drive.errorCode = HDC.XTC.DATA.ERR.NONE;
                        }
                    }
                    done(drive.errorCode? HDC.XTC.DATA.STATUS.ERROR : HDC.XTC.DATA.STATUS.OK);
                });
                return;
            }
        }
        done(drive.errorCode? HDC.XTC.DATA.STATUS.ERROR : HDC.XTC.DATA.STATUS.OK);
    }

    /**
     * doWriteBuffer(drive, done)
     *
     * @this {HDC}
     * @param {Drive} drive
     * @param {function(number)} done (dataStatus is XTC.DATA.STATUS.OK or XTC.DATA.STATUS.ERROR; if error, then drive.errorCode should be set as well)
     */
    doWriteBuffer(drive, done)
    {
        drive.errorCode = HDC.XTC.DATA.ERR.NOT_READY;

        if (DEBUG) this.printf(MESSAGE.HDC + MESSAGE.PORT, "%s.doWriteBuffer()\n", this.idComponent);

        this.initBuffer(drive);

        if (this.chipset) {
            /**
             * We need to reverse the original logic, and default to success unless/until an actual error occurs;
             * otherwise doDMAWriteBuffer() will bail on us.  The original approach would work because requestDMA()
             * would immediately call us back with fComplete set to true EVEN if the DMA channel was not yet unmasked;
             * now the callback is deferred until the DMA channel has been unmasked and the DMA request has finished.
             */
            drive.errorCode = HDC.XTC.DATA.ERR.NONE;
            this.chipset.connectDMA(ChipSet.DMA_HDC, this, 'dmaWriteBuffer', drive);
            this.chipset.requestDMA(ChipSet.DMA_HDC, function onDMAWriteBufferRequest(fComplete) {
                if (!fComplete) {
                    /**
                     * If an incomplete request wasn't triggered by an explicit error, then let's make explicit
                     * (ie, revert to the default failure code that we originally set above).
                     */
                    if (drive.errorCode == HDC.XTC.DATA.ERR.NONE) {
                        drive.errorCode = HDC.XTC.DATA.ERR.NOT_READY;
                    }
                }
                done(drive.errorCode? HDC.XTC.DATA.STATUS.ERROR : HDC.XTC.DATA.STATUS.OK);
            });
            return;
        }
        done(drive.errorCode? HDC.XTC.DATA.STATUS.ERROR : HDC.XTC.DATA.STATUS.OK);
    }

    /**
     * readData(drive, done)
     *
     * The following drive variable properties must have been setup prior to our first call:
     *
     *      drive.wCylinder
     *      drive.bHead
     *      drive.bSector
     *      drive.sector (initialized to null)
     *
     * On the first readData() request, since drive.sector will be null, we ask the Disk object to look
     * up the first sector of the request.  We then ask the Disk for bytes from that sector until the sector
     * is exhausted, and then we look up the next sector and continue the process.
     *
     * NOTE: Since the HDC isn't aware of the extent of the transfer, all readData() can do is return bytes
     * until the current track (or, in the case of a multi-track request, the current cylinder) has been exhausted.
     *
     * @this {HDC}
     * @param {Drive} drive
     * @param {function(number,boolean,Object,number)} [done] (number is next available byte from drive, or -1 if no more bytes available)
     * @param {boolean} [fAutoInc] (default is true to auto-increment)
     * @returns {number} the requested byte, or -1 if unavailable
     */
    readData(drive, done, fAutoInc)
    {
        let b = -1;
        let obj = null, off = 0;    // these variables are purely for BACKTRACK purposes

        if (drive.errorCode) {
            if (done) done(b, false, obj, off);
            return b;
        }

        let inc = (fAutoInc !== false? 1 : 0);

        if (drive.useBuffer) {
            if (drive.iByte < drive.buffer.length) {
                b = drive.buffer[drive.iByte];
                drive.iByte += inc;
                if (done) done(b, false, obj, off);
            }
            return b;
        }

        if (drive.sector) {
            off = drive.iByte;
            b = drive.disk.read(drive.sector, drive.iByte);
            drive.iByte += inc;
            if (b >= 0) {
                obj = drive.sector;
                if (done) done(b, false, obj, off);
                return b;
            }
        }

        /**
         * Locate the next sector, and then try reading again.
         *
         * Important difference between the FDC and the XTC: the XTC uses 0-based sector numbers,
         * hence the bSectorBias below.  I could change how sector numbers are stored in the image,
         * but it seems preferable to keep the image format consistent and controller-independent.
         */
        if (done) {
            let hdc = this;
            if (drive.disk) {
                drive.disk.seek(drive.wCylinder, drive.bHead, drive.bSector + drive.bSectorBias, null, false, function onReadDataSeek(sector, fAsync) {
                    if ((drive.sector = sector)) {
                        obj = sector;
                        off = drive.iByte = 0;
                        /**
                         * We "pre-advance" bSector et al now, instead of waiting to advance it right before the seek().
                         * This allows the initial call to readData() to perform a seek without triggering an unwanted advance.
                         */
                        hdc.advanceSector(drive);
                        b = drive.disk.read(drive.sector, drive.iByte);
                        drive.iByte += inc;
                    } else {
                        drive.errorCode = HDC.XTC.DATA.ERR.NO_SECTOR;
                    }
                    done(b, fAsync, obj, off);
                });
                return b;
            }
            drive.errorCode = HDC.XTC.DATA.ERR.NO_SECTOR;
            done(b, false, obj, off);
        }
        return b;
    }

    /**
     * writeData(drive, b)
     *
     * The following drive variable properties must have been setup prior to our first call:
     *
     *      drive.wCylinder
     *      drive.bHead
     *      drive.bSector
     *      drive.sector (initialized to null)
     *
     * On the first writeData() request, since drive.sector will be null, we ask the Disk object to look
     * up the first sector of the request.  We then send the Disk bytes for that sector until the sector
     * is full, and then we look up the next sector and continue the process.
     *
     * NOTE: Since the HDC isn't aware of the extent of the transfer, all writeData() can do is accept bytes
     * until the current track (or, in the case of a multi-track request, the current cylinder) has been exhausted.
     *
     * @this {HDC}
     * @param {Drive} drive
     * @param {number} b containing next byte to write
     * @returns {number} (b unchanged; return -1 if command should be terminated)
     */
    writeData(drive, b)
    {
        if (drive.errorCode) return -1;
        do {
            if (drive.useBuffer) {
                if (drive.iByte < drive.buffer.length) {
                    drive.buffer[drive.iByte++] = b;
                    return b;
                }
                return -1;
            }
            if (drive.sector) {
                if (drive.disk.write(drive.sector, drive.iByte++, b)) break;
            }
            /**
             * Locate the next sector, and then try writing again.
             *
             * Important difference between the FDC and the XTC: the XTC uses 0-based sector numbers,
             * hence the bSectorBias below.  I could change how sector numbers are stored in the image,
             * but it seems preferable to keep the image format consistent and controller-independent.
             */
            if (drive.disk) {
                drive.disk.seek(drive.wCylinder, drive.bHead, drive.bSector + drive.bSectorBias, null, true, function onWriteDataSeek(sector, fAsync) {
                    drive.sector = sector;
                });
            }
            if (!drive.sector) {
                drive.errorCode = HDC.XTC.DATA.ERR.NO_SECTOR;
                b = -1;
                break;
            }
            drive.iByte = 0;
            /**
             * We "pre-advance" bSector et al now, instead of waiting to advance it right before the seek().
             * This allows the initial call to writeData() to perform a seek without triggering an unwanted advance.
             */
            this.advanceSector(drive);
        } while (true);
        return b;
    }

    /**
     * advanceSector(drive)
     *
     * This increments the sector number; when the sector number reaches drive.nSectors on the current track, we
     * increment drive.bHead and reset drive.bSector, and when drive.bHead reaches drive.nHeads, we reset drive.bHead
     * and increment drive.wCylinder.
     *
     * One wrinkle is that the ATC uses 1-based sector numbers (bSectorBias is 0), whereas the XTC uses 0-based sector
     * numbers (bSectorBias is 1).  Thus, the correct "reset" value for bSector is (1 - bSectorBias), and the correct
     * limit for bSector is (nSectors + bSectorStart).
     *
     * @this {HDC}
     * @param {Drive} drive
     */
    advanceSector(drive)
    {

        drive.bSector++;
        let bSectorStart = (1 - drive.bSectorBias);
        if (drive.bSector >= drive.nSectors + bSectorStart) {
            drive.bSector = bSectorStart;
            drive.bHead++;
            if (drive.bHead >= drive.nHeads) {
                drive.bHead = 0;
                drive.wCylinder++;
            }
            /**
             * ATA Note: It's unclear just from reading specs whether the original PC AT adapter updated
             * the Drive/Head register to reflect the current head at the end of a command.  Since later adapters
             * apparently did, and since the risk of always updating it seems minimal, that's what we'll do.
             */
            this.regDrvHd = (this.regDrvHd & ~HDC.ATC.DRVHD.HEAD_MASK) | (drive.bHead & HDC.ATC.DRVHD.HEAD_MASK);
        }
    }

    /**
     * writeBuffer(drive, b)
     *
     * NOTE: Since the HDC isn't aware of the extent of the transfer, all writeBuffer() can do is accept bytes
     * until the buffer is full.
     *
     * TODO: Support for HDC.XTC.DATA.CMD.READ_BUFFER is missing, and support for HDC.XTC.DATA.CMD.WRITE_BUFFER may not be complete;
     * tests required.
     *
     * @this {HDC}
     * @param {Drive} drive
     * @param {number} b containing next byte to write
     * @returns {number} (b unchanged; return -1 if command should be terminated)
     */
    writeBuffer(drive, b)
    {
        if (drive.iByte < drive.buffer.length) {
            drive.buffer[drive.iByte++] = b;
        } else {
            /**
             * TODO: Determine the proper error code to return here.
             */
            drive.errorCode = HDC.XTC.DATA.ERR.NO_SECTOR;
            b = -1;
        }
        return b;
    }

    /**
     * writeFormat(drive, b)
     *
     * @this {HDC}
     * @param {Drive} drive
     * @param {number} b containing a format command byte
     * @returns {number} (b if successful, -1 if command should be terminated)
     */
    writeFormat(drive, b)
    {
        if (drive.errorCode) return -1;
        drive.abFormat[drive.cbFormat++] = b;
        if (drive.cbFormat == drive.abFormat.length) {
            drive.wCylinder = drive.abFormat[0];    // C
            drive.bHead = drive.abFormat[1];        // H
            drive.bSector = drive.abFormat[2];      // R
            drive.nBytes = 128 << drive.abFormat[3];// N (0 => 128, 1 => 256, 2 => 512, 3 => 1024)
            drive.cbFormat = 0;

            this.printf(MESSAGE.HDC + MESSAGE.PORT, "%s.writeFormat(%d:%d:%d:%d)\n", this.idComponent, drive.wCylinder, drive.bHead, drive.bSector, drive.nBytes);

            for (let i = 0; i < drive.nBytes; i++) {
                if (this.writeData(drive, drive.bFiller) < 0) {
                    return -1;
                }
            }
            drive.cSectorsFormatted++;
        }
        if (drive.cSectorsFormatted >= drive.bSectorEnd) b = -1;
        return b;
    }

    /**
     * processIdentify(drive, bCmd)
     *
     * Worker for the IDDEVICE (ATA-1) and IDPACKET (ATAPI) commands.
     *
     * @this {HDC}
     * @param {Drive} drive
     * @param {number} bCmd
     * @returns {boolean} (true if processed, false otherwise)
     */
    processIdentify(drive, bCmd)
    {
        if (this.fATAPI) {

            if (drive.type && bCmd == HDC.ATC.COMMAND.IDPACKET) {
                return false;
            }

            if (!drive.type && bCmd == HDC.ATC.COMMAND.IDDEVICE) {
                this.processReset(drive);
                return false;
            }

            this.initBuffer(drive);

            /**
             * NOTE: The data for both IDENTIFY commands is stored little-endian, with one unusual exception: string data
             * is returned with every even/odd byte pair swapped.  setString() takes this into account, by XOR'ing bit 0 of
             * each character offset with 0x1.
             */
            let setByte = function(offset, value) {
                drive.buffer[offset] = value & 0xff;
            };
            let setWord = function(offset, value) {
                setByte(offset, value);
                setByte(offset + 1, value >> 8);
            };
            let setLong = function(offset, value) {
                setWord(offset, value);
                setWord(offset + 2, value >> 16);
            };
            let setString = function(offset, value, length) {
                if (!value) value = "";
                for (let i = 0; i < length; i++) {
                    setByte(offset + (i ^ 0x1), i < value.length? value.charCodeAt(i) : 0x20);
                }
            };
            /**
             * TODO: Filling out a complete IDENTIFY response packet requires more work; hopefully this is good enough for now.
             */
            setWord(HDC.ATC.IDENTIFY.CONFIG.OFFSET, drive.type? HDC.ATC.IDENTIFY.CONFIG.FIXED : 0x8580);
            if (drive.type) {
                setWord(HDC.ATC.IDENTIFY.CYLS, drive.nCylinders);
                setWord(HDC.ATC.IDENTIFY.HEADS, drive.nHeads);
                setWord(HDC.ATC.IDENTIFY.SECBYTES, drive.cbSector);
                setWord(HDC.ATC.IDENTIFY.SECTORS, drive.nSectors);
            }
            setString(HDC.ATC.IDENTIFY.SERIAL_NUMBER, "PCJS-20190528", 20);
            setWord(HDC.ATC.IDENTIFY.BUFFER_TYPE, 3);
            setWord(HDC.ATC.IDENTIFY.BUFFER_SIZE, 512);
            setString(HDC.ATC.IDENTIFY.FIRMWARE_REV, "0.1", 8);
            setString(HDC.ATC.IDENTIFY.MODEL_NUMBER, "PCJS CD-ROM", 40);
            if (!drive.type) setByte(HDC.ATC.IDENTIFY.CAPABILITY, 0x0B);
            drive.useBuffer = true;
            if (MAXDEBUG) this.dbg.stopCPU();
            return true;
        }
        return false;
    }

    /**
     * processPacket(drive)
     *
     * @this {HDC}
     * @param {Drive} drive
     */
    processPacket(drive)
    {
        let hdc = this;
        let limit = drive.buffer.length, error = 0;
        let format, lba, num, page = 0, pageCode, pageControl;
        let bPacketCmd, off, iChunk, offChunk, lenChunk, lenTotal, offBuffer, nChunks, nChunkErrors;
        /**
         * NOTE: Packet data is typically stored big-endian, and since BE is not normally assumed,
         * we include BE in the appropriate function signatures.
         */
        let getBits = function(offset, bit, length) {
            return (drive.buffer[offset] >> bit) & ((1 << length) - 1);
        };
        let getByte = function(offset) {
            return drive.buffer[offset] & 0xff;
        };
        let getWordBE = function(offset) {
            return (getByte(offset) << 8) | getByte(offset + 1);
        };
        let getLongBE = function(offset) {
            return (getWordBE(offset) << 16) | getWordBE(offset + 2);
        };
        let getLength = function(offset) {
            let length = getWordBE(offset);
            if (length > limit) length = limit;
            return length;
        };
        let setByte = function(offset, value) {
            if (offset < limit) {
                drive.buffer[offset] = value & 0xff;
            }
        };
        let setBytes = function(offset, value, length) {
            while (length--) setByte(offset++, value);
        };
        let setString = function(offset, value, length) {
            if (!value) value = "";
            for (let i = 0; i < length; i++) {
                setByte(offset + i, i < value.length? value.charCodeAt(i) : 0x20);
            }
        };
        let setWordBE = function(offset, value) {
            setByte(offset, value >> 8);
            setByte(offset + 1, value);
        };
        let setLongBE = function(offset, value) {
            setWordBE(offset, value >> 16);
            setWordBE(offset + 2, value);
        };
        let done = function(fData, error=0) {
            /**
             * TODO: Deal with errors.  In addition, if nChunkErrors is non-zero, then at least one of the
             * requested chunks returned an error (or simply failed to return any data), so deal with that, too.
             */
            if (error) {
                hdc.regStatus = HDC.ATC.STATUS.ERROR;
            }
            else if (!fData) {
                hdc.regStatus = HDC.ATC.STATUS.READY;
                hdc.regSecCnt = HDC.ATC.SECCNT.PACKET_IO | HDC.ATC.SECCNT.PACKET_CD;
            } else {
                drive.iByte = 0;
                drive.nBytes = drive.cbTransfer = limit;
                hdc.regCylLo = limit & 0xff;
                hdc.regCylHi = (limit >> 8) & 0xff;
                hdc.regStatus = (hdc.regStatus & ~HDC.ATC.STATUS.BUSY) | HDC.ATC.STATUS.DATA_REQ;
                hdc.regSecCnt = HDC.ATC.SECCNT.PACKET_IO;
            }
            hdc.setATCIRR(true);
        };
        let copyChunk = function(data, iChunk, offChunk, lenChunk, offBuffer) {
            let dataCached = drive.chunksCached[iChunk];
            if (data) {

            } else {
                if (!dataCached) return false;
                data = dataCached;
            }
            let i = -1;
            if (dataCached) {
                i = drive.chunksMRU.indexOf(iChunk);

                if (i > 0) drive.chunksMRU.splice(i, 1);
            } else {
                drive.chunksCached[iChunk] = data;
            }
            if (drive.chunksMRU.length >= 128) drive.chunksMRU.pop();
            if (i) drive.chunksMRU.unshift(iChunk);
            let bytes = new Uint8Array(data);
            while (offChunk < bytes.byteLength && lenChunk--) {
                setByte(offBuffer++, bytes[offChunk++]);
            }
            if (!--nChunks) done(true);
            return true;
        };
        let readChunk = function(iChunk, offChunk, lenChunk, offBuffer) {
            nChunks++;
            if (copyChunk(null, iChunk, offChunk, lenChunk, offBuffer)) return;
            WebLib.getResource(StrLib.sprintf("%s/x%05d", drive.sDiskPath, iChunk), "arraybuffer", true, function(url, data, error) {
                if (data && !error) {
                    copyChunk(data, iChunk, offChunk, lenChunk, offBuffer);
                    return;
                }
                nChunkErrors++;
                if (!--nChunks) done(false, error);
            });
        };

        bPacketCmd = getByte(0);

        this.printf(MESSAGE.HDC, "%s.packet(%#04x): %s (drive %d)\n", this.idComponent, bPacketCmd, HDC.aATAPICommands[bPacketCmd], drive.iDrive);

        switch(bPacketCmd) {
        case HDC.ATC.PACKET.COMMAND.TEST_UNIT:  // 0x00
            /**
             * If the TEST UNIT READY command status is GOOD, then there is no further response;
             * otherwise, we have a CHECK CONDITION, which will require adding the REQUEST SENSE command.
             * TODO: Worry about that later.
             *
             * NOTE: This was a 12-byte packet (circa 2001) with nothing but a Logical Unit Number (LUN)
             * in bits 5-7 of byte 1, but it was later spec'ed (circa 2010) as a 6-byte packet with no LUN
             * and a CONTROL value in byte 5.
             */
            bPacketCmd = 0;                     // nothing to return, so we can wrap up this command now
            break;

        case HDC.ATC.PACKET.COMMAND.REQ_SENSE:  // 0x03
            limit = 0;                          // TODO
            break;

        case HDC.ATC.PACKET.COMMAND.INQUIRY:    // 0x12
            limit = getLength(3);               // in ATAPI (circa 2001), length was simply drive.buffer[4]; e.g., 36 (0x24) bytes
            setByte(0, 0x05);                   // 0x05 (bits 0-4, the Peripheral Device Type, is 0x05 for CD-ROM devices)
            setByte(1, 0x80);                   // 0x80 (bit 7, the RMB or Removable Media Bit, must be set for CD-ROM devices)
            setByte(2, 0x00);                   // 0x00 (bits 0-2 == ANSI version, bits 3-5 == ECMA version, bits 6-7 == ISO version)
            setByte(3, 0x21);                   // 0x21 (bits 0-3 == Response Data Format (1), bits 4-7 == ATAPI version (2))
            setByte(4, 31);                     // number of additional bytes following this one
            setBytes(5, 0, 3);                  // these bytes were defined in later specs, but we're sticking with earlier (circa 2001) specs for now
            setString(8, "PCJS.ORG", 8);
            setString(16, drive.name, 16);
            setString(32, "1.0", 4);
            break;

        case HDC.ATC.PACKET.COMMAND.READ:       // 0x28
            lba = getLongBE(2);                 // LBA
            num = getWordBE(7);                 // number of blocks
            off = lba << 11;                    // shift left 11 bits to multiply by 2Kb
            limit = num << 11;
            this.initBuffer(drive, limit);
            nChunks = 1;                        // preset chunk request count to 1
            nChunkErrors = 0;
            iChunk = off >>> 15;                // iChunk is the starting 32Kb chunk
            offChunk = off & 0x7fff;            // offChunk is the starting offset within that chunk
            lenTotal = limit;                   // lenTotal is number of bytes left to read
            offBuffer = 0;
            while (lenTotal > 0) {
                lenChunk = 32768 - offChunk;
                if (lenChunk > lenTotal) lenChunk = lenTotal;
                readChunk(iChunk, offChunk, lenChunk, offBuffer);
                offBuffer += lenChunk;
                lenTotal -= lenChunk;
                offChunk = 0;
                iChunk++;
            }
            if (!--nChunks) done(true);         // if chunk request count drops to zero immediately, all chunks must have been cached
            bPacketCmd = -1;
            break;

        case HDC.ATC.PACKET.COMMAND.SEEK:       // 0x2B
            lba = getLongBE(2);                 // TODO: Do something with the Logical Block Address
            bPacketCmd = 0;                     // nothing to return, so we can wrap up this command now
            break;

        case HDC.ATC.PACKET.COMMAND.READ_TOC:   // 0x43
            /**
                Sample requests:

                    1) 0030:c13d65b0 43 02 00 00 00 00 00 03-24 40 00 00 00 00 00 00
                    2) 0030:c13d65b0 43 02 00 00 00 00 00 03-24 00 00 00 00 00 00 00

                Sample responses:

                    1) 0030:c1a05f6c 00 0a 01 01 00 14 01 00-00 00 02 00 (6 words)
                    2) 0030:c1a05f6c 00 12 01 01 00 14 01 00-00 00 02 00 00 14 aa 00 00 3f 2c 42 (10 words)
             */
            limit = getLength(7);
            format = getBits(2, 0, 4);
            switch(format) {
            case 0x0:                           // track/session number (starting track number for which the data will be returned)
                setWordBE(0, 10);               // 0-1: TOC data length
                setByte(2, 1);                  // 2: first track number
                setByte(3, 1);                  // 3: last track number
                                                // beginning of TOC track descriptor(s)
                setByte(4, 0);                  // 4: reserved
                setByte(5, 0x14);               // 5: bits 7-4 = ADR.CUR_POS; bits 3-0 = CONTROL.DATA_TRACK
                setByte(6, 1);                  // 6: track number
                setByte(7, 0);                  // 7: reserved
                setLongBE(8, 0);                // 8-11: LBA
                break;

            default:
                this.printf(MESSAGE.HDC, "%s.packet(%#04x): unsupported format %d\n", this.idComponent, bPacketCmd, format);
                if (MAXDEBUG) this.dbg.stopCPU();
                bPacketCmd = -1;                // TODO: Add support for other READ_TOC formats
                break;
            }
            break;

        case HDC.ATC.PACKET.COMMAND.PLAY_AUDIO: // 0x45
            /**
                Sample request:

                0030:c13d65b0 45 00 00 00 00 96 00 00-00 00 00 00 00 00 00 00 E...............
             */
            bPacketCmd = 0;                     // nothing to return, so we can wrap up this command now
            // error = -1;
            break;

        case HDC.ATC.PACKET.COMMAND.MODE_SENSE: // 0x5A
            limit = getLength(7);
            pageCode = getBits(2, 0, 6);
            pageControl = getBits(2, 6, 2);
            switch(pageCode) {
            case HDC.ATC.PACKET.PAGECODE.RW_ERRREC:     // 0x01
            /**
                Sample requests:

                    1) 0030:c13d65b0 5a 00 01 00 00 00 00 00-10 00 00 00 00 00 00 00 Z...............
                    2) 0030:c13d65b0 5a 00 41 00 00 00 00 00-10 00 00 00 00 00 00 00 Z.A.............

                The word at offset 7 specifies a Parameter List Length (aka limit) of 0x0010, so we'll
                restrict our response to that many bytes.

                Sample responses (0x10 bytes):

                    1) 0030:c1a06294 00 0e 01 00 00 00 00 00-01 06 00 01 00 00 00 00 ................
                    2) 0030:c1a06294 00 0e 01 00 00 00 00 00-01 06 00 00 00 00 00 00 ................
             */
                setBytes(0, 0, limit);
                setWordBE(0, limit-2);
                setByte(2, 1);          // Medium Type Code (vendor-specific. so I'm not sure what this means)
                page = 8;
                setByte(page, pageCode);
                setByte(page+1, limit-8-2);
                break;

            case HDC.ATC.PACKET.PAGECODE.CD_STATUS:     // 0x2A
            /**
                Sample request:

                    0030:c13d7ba8 5a 00 2a 00 00 00 00 00-1c 00 00 00 00 00 00 00 Z.*.............

                The word at offset 7 specifies a Parameter List Length (aka limit) of 0x001C, so we should
                restrict our response to that many bytes; however, the sample VirtualBox response below didn't
                appear to honor that limit (unless I'm misunderstanding how it's interpreted).

                Sample response:

                    0b8c:000000f8: 00 26 00 00 00 00 00 00-2a 1e 08 00 71 00 29 00  .&......*...q.).
                    0b8c:00000108: 16 00 00 02 00 80 16 00-00 00 00 00 00 00 00 00  ................
                    0b8c:00000118: 00 00 00 01 00 00 00 00

                The first 8 bytes are a Mode Parameter Header.  The first word (0x0026) is the number of bytes
                in the entire response (excluding the first word).  There are some other bits that can be set in
                the MPH that we'll worry about later.

                The first (and in this case only) "page" begins at offset 8 with a Page Code (0x2A) followed by
                a length byte (0x1E) indicating the number of bytes in the rest of the "page".  Deciphering the above
                sample, here are the first 16 bytes (I'm not sure what the rest of the bytes beyond that point are).

                Byte    Value   Bit 7   Bit 6   Bit 5   Bit 4   Bit 3   Bit 2   Bit 1   Bit 0
                ----    -----   -----   -----   -----   -----   -----   -----   -----   -----
                   0     2Ah    (Page Code)
                   1     1Eh    (Number of following bytes)
                   2     08h                                            Method2 CDRW-R  CDR-R
                   3     00h                                            TestW   CDRW-W  CDR-W
                   4     71h            MultiS  Mode2-2 Mode2-1 DP-2    DP-1    Comp.   Audio
                   5     00h    BarCode UPC     ISRC    C2      R-W     R-W     CD-DA   CD-DA
                   6     29h    -----Loading Type----   Res.    Eject   PJ      LockS   Lock
                   7     00h    ----------Reserved-----------   SS      DPR     SCM     SVL
                   8     16h    ----------Maximum Read Speed Supported (KBps) MSB------------
                   9     00h
                  10     00h    ----------Number of Volume Levels Supported MSB--------------
                  11     02h
                  12     00h    ----------Buffer Size Supported by Drive (KB) MSB------------
                  13     80h
                  14     16h    ----------Current Read Speed Selected (KBps) MSB-------------
                  15     00h
             */
                setBytes(0, 0, limit);          // previously hard-coded to 30
                setWordBE(0, limit-2);          // previously hard-coded to 30-2
                page = 8;
                setByte(page, pageCode);
                setByte(page+1, limit-8-2);     // previously hard-coded to 22-2
                setByte(page+2, 0x08);
                setByte(page+4, 0x71);
                setByte(page+6, 0x29);
                setWordBE(page+8,  0x1600);
                setWordBE(page+10, 0x0002);
                setWordBE(page+12, 0x0080);
                setWordBE(page+14, 0x1600);
                break;

            default:
                this.printf(MESSAGE.HDC, "%s.packet(%#04x): unsupported page code %d\n", this.idComponent, bPacketCmd, pageCode);
                if (MAXDEBUG) this.dbg.stopCPU();
                bPacketCmd = -1;        // TODO: Add support for other Page Codes
                break;
            }
            break;

        default:
            if (MAXDEBUG) this.dbg.stopCPU();
            bPacketCmd = -1;            // TODO: Not sure what to do, so currently we choose to do nothing
            break;
        }
        if (bPacketCmd >= 0) done(bPacketCmd > 0, error);
    }

    /**
     * processReset(drive)
     *
     * Worker for the DEVICE RESET (ATAPI) command, as well as other operations that are supposed to
     * store "signature" bytes in the device registers, based on the level of packet (ATAPI) command support.
     *
     * @this {HDC}
     * @param {Drive} drive
     * @returns {boolean}
     */
    processReset(drive)
    {
        if (this.fATAPI) {
            this.regSecCnt = 0x01;
            this.regSecNum = 0x01;
            if (!drive.type) {
                this.regCylLo = 0x14;
                this.regCylHi = 0xEB;
            } else {
                this.regCylLo = this.regCylHi = 0;
            }
            this.regDrvHd = 0;
            if (MAXDEBUG) this.dbg.stopCPU();
            return true;
        }
        return false;
    }

    /**
     * intBIOSDisk(addr)
     *
     * NOTE: This function differentiates HDC requests from FDC requests, based on whether the INT 0x13 drive number
     * in DL is >= 0x80.
     *
     * HACK: The HDC BIOS code for both INT 0x13/AH=0x00 and INT 0x13/AH=0x09 calls "INIT_DRV" @C800:0427, which is
     * hard-coded to issue the HDC.XTC.DATA.CMD.INIT_DRIVE command for BOTH drives 0 and 1 (aka drive numbers 0x80 and
     * 0x81), regardless of the drive number specified in DL; this means that the HDC.XTC.DATA.CMD.INIT_DRIVE command
     * must always succeed for drive 1 if it also succeeds for drive 0 -- even if there is no drive 1.  Bizarre, but OK,
     * whatever.
     *
     * So assuming we a have drive 0, when the power-on diagnostics in "DISK_SETUP" @C800:0003 call INT 0x13/AH=0x09
     * (@C800:00DB) for drive 0, it must succeed.  No problem.  But when "DISK_SETUP" starts probing for additional drives,
     * it first issues INT 0x13/AH=0x00, followed by INT 0x13/AH=0x11, and finally INT 0x13/AH=0x09.  If the first
     * (AH=0x00) or third (AH=0x09) INT 0x13 fails, it quickly moves on (ie, it jumps to "POD_DONE").  But as we just
     * discussed, both those operations call "INIT_DRV", which can't return an error.  This means the only function that
     * can return an error in this context is the recalibrate function (AH=0x11).  That sucks, because the way the HDC
     * BIOS is written, it will loop for anywhere from 1.5 seconds to 25 seconds (depending on whether the controller
     * is part of the "System Unit" or not; see port 0x213), attempting to recalibrate drive 1 until it finally times out.
     *
     * Normally, you'll only experience the 1.5 second delay, but even so, it's a ridiculous waste of time and a lot of
     * useless INT 0x13 calls.  So I monitor INT 0x13/AH=0x00 for DL >= 0x80 and set a special HDC.XTC.DATA.CMD.INIT_DRIVE
     * override flag (iDriveAllowFail) that will allow that command to fail, and in theory, make the the HDC BIOS
     * "DISK_SETUP" code much more efficient.
     *
     * @this {HDC}
     * @param {number} addr
     * @returns {boolean} true to proceed with the INT 0x13 software interrupt, false to skip
     */
    intBIOSDisk(addr)
    {
        let AH = this.cpu.regEAX >> 8;
        let DL = this.cpu.regEDX & 0xff;
        if (!AH && DL > 0x80) this.iDriveAllowFail = DL - 0x80;
        return true;
    }

    /**
     * intBIOSDiskette(addr)
     *
     * When the HDC BIOS overwrites the ROM BIOS INT 0x13 address, it saves the original INT 0x13 address
     * in the INT 0x40 vector.  This function intercepts calls to that vector to work around a minor nuisance.
     *
     * The HDC BIOS's plan was simple, albeit slightly flawed: assign fixed disks drive numbers >= 0x80,
     * and whenever someone calls INT 0x13 with a drive number < 0x80, invoke the original INT 0x13 diskette
     * code via INT 0x40 and return via RET 2.
     *
     * Unfortunately, not all original INT 0x13 functions required a drive number in DL (e.g., the "reset"
     * function, where AH=0).  And the HDC BIOS knew this, which is why, in the case of the "reset" function,
     * the HDC BIOS performs BOTH an INT 0x40 diskette reset AND an HDC reset -- it can't be sure which
     * controller the caller really wants to reset.
     *
     * An unfortunate side-effect of this behavior: when the HDC BIOS is initialized for the first time, it may
     * issue several resets internally, depending on whether there are 0, 1 or 2 hard drives installed, and each
     * of those resets also triggers completely useless diskette resets, each wasting up to two seconds waiting
     * for the FDC to interrupt.  The FDC tries to interrupt, but it can't, because at this early stage of
     * ROM BIOS initialization, IRQ.FDC hasn't been unmasked yet.
     *
     * My work-around: have the HDC component hook INT 0x40, and every time an INT 0x40 is issued with AH=0 and
     * IRQ.FDC masked, bypass the INT 0x40 interrupt.  This is as close as PCx86 has come to patching any BIOS code
     * (something I've refused to do), and even here, I'm not doing it out of necessity, just annoyance.
     *
     * @this {HDC}
     * @param {number} addr
     * @returns {boolean} true to proceed with the INT 0x40 software interrupt, false to skip
     */
    intBIOSDiskette(addr)
    {
        let AH = this.cpu.regEAX >> 8;
        if ((!AH && this.chipset && this.chipset.checkIMR(ChipSet.IRQ.FDC))) {
            if (DEBUG) this.printf("%s.intBIOSDiskette(): skipping useless INT 0x40 diskette reset\n", this.idComponent);
            return false;
        }
        return true;
    }

    /**
     * unloadDrive(iDrive)
     *
     * NOTE: At the moment, we support only auto-mounts; there is no user interface for selecting hard drive
     * images, let alone unloading them, so there is currently no need for the following function.
     *
     * @this {HDC}
     * @param {number} iDrive
     */
    // unloadDrive(iDrive)
    // {
    //     this.aDrives[iDrive].disk = null;
    //     //
    //     // WARNING: This conversion of drive number to drive letter, starting with "C:" (0x43), is very simplistic
    //     // and is not guaranteed to match the drive mapping that DOS ultimately uses.
    //     //
    //     this.printf(MESSAGE.NOTICE, "Drive %s unloaded\n", String.fromCharCode(0x43 + iDrive));
    // }

    /**
     * doFormat(drive, done)
     *
     * The drive variable is initialized by doXTC() to the following extent:
     *
     *      drive.bHead (ignored)
     *      drive.nBytes (bytes/sector)
     *      drive.bSectorEnd (sectors/track)
     *      drive.bFiller (fill byte)
     *
     * and we expect the DMA controller to provide C, H, R and N (ie, 4 bytes) for each sector to be formatted.
     *
     * NOTE: This function is not currently used.
     *
     * @this {HDC}
     * @param {Drive} drive
     * @param {function(number)} done (dataStatus is XTC.DATA.STATUS.OK or XTC.DATA.STATUS.ERROR; if error, then drive.errorCode should be set as well)
     */
    // doFormat(drive, done)
    // {
    //     drive.errorCode = HDC.XTC.DATA.ERR.NOT_READY;
    //
    //     if (drive.disk) {
    //         drive.sector = null;
    //         if (this.chipset) {
    //             drive.cbFormat = 0;
    //             drive.abFormat = new Array(4);
    //             drive.bFormatting = true;
    //             drive.cSectorsFormatted = 0;
    //             //
    //             // We need to reverse the original logic, and default to success unless/until an actual error occurs;
    //             // otherwise doDMAWriteFormat() will bail on us.  The original approach would work because requestDMA()
    //             // would immediately call us back with fComplete set to true EVEN if the DMA channel was not yet unmasked;
    //             // now the callback is deferred until the DMA channel has been unmasked and the DMA request has finished.
    //             //
    //             drive.errorCode = HDC.XTC.DATA.ERR.NONE;
    //             this.chipset.connectDMA(ChipSet.DMA_HDC, this, 'dmaWriteFormat', drive);
    //             this.chipset.requestDMA(ChipSet.DMA_HDC, function onDMAFormat(fComplete) {
    //                 if (!fComplete) {
    //                     //
    //                     // If an incomplete request wasn't triggered by an explicit error, then let's make explicit
    //                     // (ie, revert to the default failure code that we originally set above).
    //                     //
    //                     if (drive.errorCode == HDC.XTC.DATA.ERR.NONE) {
    //                         drive.errorCode = HDC.XTC.DATA.ERR.NOT_READY;
    //                     }
    //                 }
    //                 drive.bFormatting = false;
    //                 done(drive.errorCode? HDC.XTC.DATA.STATUS.ERROR : HDC.XTC.DATA.STATUS.OK);
    //             });
    //             return;
    //         }
    //     }
    //     done(drive.errorCode? HDC.XTC.DATA.STATUS.ERROR : HDC.XTC.DATA.STATUS.OK);
    // }

    /**
     * HDC.init()
     *
     * This function operates on every HTML element of class "hdc", extracting the
     * JSON-encoded parameters for the HDC constructor from the element's "data-value"
     * attribute, invoking the constructor to create a HDC component, and then binding
     * any associated HTML controls to the new component.
     */
    static init()
    {
        let aeHDC = Component.getElementsByClass(APPCLASS, "hdc");
        for (let iHDC = 0; iHDC < aeHDC.length; iHDC++) {
            let eHDC = aeHDC[iHDC];
            let parmsHDC = Component.getComponentParms(eHDC);
            let hdc = new HDC(parmsHDC);
            Component.bindComponentControls(hdc, eHDC, APPCLASS);
        }
    }
}

/**
 * Initialize every Hard Drive Controller (HDC) module on the page.
 */
WebLib.onInit(HDC.init);

/**
 * @copyright https://www.pcjs.org/machines/modules/v2/dbglib.js (C) 2012-2024 Jeff Parsons
 */

/** @typedef {{ addr: (number|undefined), fTemporary: (boolean|undefined), sCmd: (string|undefined), aCmds: (Array.<string>|undefined) }} */
let DbgAddr;

/**
 * Since the Closure Compiler treats ES6 classes as @struct rather than @dict by default,
 * it deters us from defining named properties on our components; eg:
 *
 *      this['exports'] = {...}
 *
 * results in an error:
 *
 *      Cannot do '[]' access on a struct
 *
 * So, in order to define 'exports', we must override the @struct assumption by annotating
 * the class as @unrestricted (or @dict).  Note that this must be done both here and in the
 * subclass (eg, SerialPort), because otherwise the Compiler won't allow us to *reference*
 * the named property either.
 *
 * TODO: Consider marking ALL our classes unrestricted, because otherwise it forces us to
 * define every single property the class uses in its constructor, which results in a fair
 * bit of redundant initialization, since many properties aren't (and don't need to be) fully
 * initialized until the appropriate init(), reset(), restore(), etc. function is called.
 *
 * The upside, however, may be that since the structure of the class is completely defined by
 * the constructor, JavaScript engines may be able to optimize and run more efficiently.
 *
 * @class DbgLib
 * @unrestricted
 */
class DbgLib extends Component {
    /**
     * DbgLib(parmsDbg)
     *
     * The DbgLib component supports the following optional (parmsDbg) properties:
     *
     *      base: the base to use for most numeric input/output (default is 16)
     *
     * The DbgLib component is a shared component containing a subset of functionality used by
     * the other CPU-specific Debuggers (eg, Debuggerx86).  Over time, the goal is to factor out as
     * much common debugging support as possible from those components into this one.
     *
     * @this {DbgLib}
     * @param {string} type
     * @param {Object} [parmsDbg]
     * @param {number} [bitsMessage] selects message(s) that the component wants to enable (default is 0)
     */
    constructor(type, parmsDbg, bitsMessage)
    {
        super(type, parmsDbg, bitsMessage);

        if (DEBUGGER) {

            /*
             * Default base used to display all values; modified with the "s base" command.
             */
            this.nBase = +parmsDbg['base'] || 16;

            /*
             * Default number of bits of integer precision; it can be overridden by the Debugger
             * but there is no command to adjust it.
             */
            this.nBits = 32;

            this.achGroup = ['{','}'];
            this.achAddress = ['[',']'];

            /*
             * These keep track of instruction activity, but only when tracing or when Debugger checks
             * have been enabled (eg, one or more breakpoints have been set).
             *
             * They are zeroed by the reset() notification handler.  cInstructions is advanced by
             * stepCPU() and checkInstruction() calls.  nCycles is updated by every stepCPU() or stop()
             * call and simply represents the number of cycles performed by the last run of instructions.
             */
            this.nCycles = 0;
            this.cOpcodes = this.cOpcodesStart = 0;

            /*
             * fAssemble is true when "assemble mode" is active, false when not.
             */
            this.fAssemble = false;

            /*
             * This maintains command history.  New commands are inserted at index 0 of the array.
             * When Enter is pressed on an empty input buffer, we default to the command at aPrevCmds[0].
             */
            this.iPrevCmd = -1;
            this.aPrevCmds = [];

            /*
             * aVariables is an object with properties that grow as setVariable() assigns more variables;
             * each property corresponds to one variable, where the property name is the variable name (ie,
             * a string beginning with a non-digit, followed by zero or more symbol characters and/or digits)
             * and the property value is the variable's numeric value.  See doVar() and setVariable() for
             * details.
             *
             * Note that parseValue() parses variables before numbers, so any variable that looks like a
             * unprefixed hex value (eg, "a5" as opposed to "0xa5") will trump the numeric value.  Unprefixed
             * hex values are a convenience of parseValue(), which always calls StrLib.parseInt() with a default
             * base of 16; however, that default be overridden with a variety of explicit prefixes or suffixes
             * (eg, a leading "0o" to indicate octal, a trailing period to indicate decimal, etc.)
             *
             * See StrLib.parseInt() for more details about supported numbers.
             */
            this.aVariables = {};

            /*
             * Array of functions to call when notifyEvent() is called.  Functions are added with onEvent().
             */
            this.afnNotify = [];

        }   // endif DEBUGGER
    }

    /**
     * getRegIndex(sReg, off)
     *
     * NOTE: This must be implemented by the individual debuggers.
     *
     * @this {DbgLib}
     * @param {string} sReg
     * @param {number} [off] optional offset into sReg
     * @returns {number} register index, or -1 if not found
     */
    getRegIndex(sReg, off)
    {
        return -1;
    }

    /**
     * getRegValue(iReg)
     *
     * NOTE: This must be implemented by the individual debuggers.
     *
     * @this {DbgLib}
     * @param {number} iReg
     * @returns {number|undefined}
     */
    getRegValue(iReg)
    {
        return undefined;
    }

    /**
     * parseAddrReference(s, sAddr)
     *
     * Returns the given string with the given address reference replaced with the contents of that address.
     *
     * NOTE: This must be implemented by the individual debuggers.
     *
     * @this {DbgLib}
     * @param {string} s
     * @param {string} sAddr
     * @returns {string}
     */
    parseAddrReference(s, sAddr)
    {
        return s.replace('[' + sAddr + ']', "unimplemented");
    }

    /**
     * getNextCommand()
     *
     * @this {DbgLib}
     * @returns {string}
     */
    getNextCommand()
    {
        let sCmd;
        if (this.iPrevCmd > 0) {
            sCmd = this.aPrevCmds[--this.iPrevCmd];
        } else {
            sCmd = "";
            this.iPrevCmd = -1;
        }
        return sCmd;
    }

    /**
     * getPrevCommand()
     *
     * @this {DbgLib}
     * @returns {string|null}
     */
    getPrevCommand()
    {
        let sCmd = null;
        if (this.iPrevCmd < this.aPrevCmds.length - 1) {
            sCmd = this.aPrevCmds[++this.iPrevCmd];
        }
        return sCmd;
    }

    /**
     * parseCommand(sCmd, fSave, chSep)
     *
     * @this {DbgLib}
     * @param {string|undefined} sCmd
     * @param {boolean} [fSave] is true to save the command, false if not
     * @param {string} [chSep] is the command separator character (default is ';')
     * @returns {Array.<string>}
     */
    parseCommand(sCmd, fSave, chSep)
    {
        if (fSave) {
            if (!sCmd) {
                if (this.fAssemble) {
                    sCmd = "end";
                } else {
                    sCmd = this.aPrevCmds[this.iPrevCmd+1];
                }
            } else {
                if (this.iPrevCmd < 0 && this.aPrevCmds.length) {
                    this.iPrevCmd = 0;
                }
                if (this.iPrevCmd < 0 || sCmd != this.aPrevCmds[this.iPrevCmd]) {
                    this.aPrevCmds.splice(0, 0, sCmd);
                    this.iPrevCmd = 0;
                }
                this.iPrevCmd--;
            }
        }
        let a = [];
        if (sCmd) {
            /*
             * With the introduction of breakpoint commands (ie, quoted command sequences
             * associated with a breakpoint), we can no longer perform simplistic splitting.
             *
             *      a = sCmd.split(chSep || ';');
             *      for (let i = 0; i < a.length; i++) a[i] = StrLib.trim(a[i]);
             *
             * We may now split on semi-colons ONLY if they are outside a quoted sequence.
             *
             * Also, to allow quoted strings *inside* breakpoint commands, we first replace all
             * DOUBLE double-quotes with single quotes.
             */
            sCmd = sCmd.replace(/""/g, "'");

            let iPrev = 0;
            let chQuote = null;
            chSep = chSep || ';';
            /*
             * NOTE: Processing charAt() up to and INCLUDING length is not a typo; we're taking
             * advantage of the fact that charAt() with an invalid index returns an empty string,
             * allowing us to use the same substring() call to capture the final portion of sCmd.
             *
             * In a sense, it allows us to pretend that the string ends with a zero terminator.
             */
            for (let i = 0; i <= sCmd.length; i++) {
                let ch = sCmd.charAt(i);
                if (ch == '"' || ch == "'") {
                    if (!chQuote) {
                        chQuote = ch;
                    } else if (ch == chQuote) {
                        chQuote = null;
                    }
                }
                else if (ch == chSep && !chQuote || !ch) {
                    /*
                     * Recall that substring() accepts starting (inclusive) and ending (exclusive)
                     * indexes, whereas substr() accepts a starting index and a length.  We need the former.
                     */
                    a.push(StrLib.trim(sCmd.substring(iPrev, i)));
                    iPrev = i + 1;
                }
            }
        }
        return a;
    }

    /**
     * evalAND(dst, src)
     *
     * Adapted from /machines/dec/pdp10/modules/v2/cpuops.js:PDP10.AND().
     *
     * Performs the bitwise "and" (AND) of two operands > 32 bits.
     *
     * @this {DbgLib}
     * @param {number} dst
     * @param {number} src
     * @returns {number} (dst & src)
     */
    evalAND(dst, src)
    {
        /*
         * We AND the low 32 bits separately from the higher bits, and then combine them with addition.
         * Since all bits above 32 will be zero, and since 0 AND 0 is 0, no special masking for the higher
         * bits is required.
         *
         * WARNING: When using JavaScript's 32-bit operators with values that could set bit 31 and produce a
         * negative value, it's critical to perform a final right-shift of 0, ensuring that the final result is
         * positive.
         */
        if (this.nBits <= 32) {
            return dst & src;
        }
        /*
         * Negative values don't yield correct results when dividing, so pass them through an unsigned truncate().
         */
        dst = this.truncate(dst, 0, true);
        src = this.truncate(src, 0, true);
        return ((((dst / DbgLib.TWO_POW32)|0) & ((src / DbgLib.TWO_POW32)|0)) * DbgLib.TWO_POW32) + ((dst & src) >>> 0);
    }

    /**
     * evalIOR(dst, src)
     *
     * Adapted from /machines/dec/pdp10/modules/v2/cpuops.js:PDP10.IOR().
     *
     * Performs the logical "inclusive-or" (OR) of two operands > 32 bits.
     *
     * @this {DbgLib}
     * @param {number} dst
     * @param {number} src
     * @returns {number} (dst | src)
     */
    evalIOR(dst, src)
    {
        /*
         * We OR the low 32 bits separately from the higher bits, and then combine them with addition.
         * Since all bits above 32 will be zero, and since 0 OR 0 is 0, no special masking for the higher
         * bits is required.
         *
         * WARNING: When using JavaScript's 32-bit operators with values that could set bit 31 and produce a
         * negative value, it's critical to perform a final right-shift of 0, ensuring that the final result is
         * positive.
         */
        if (this.nBits <= 32) {
            return dst | src;
        }
        /*
         * Negative values don't yield correct results when dividing, so pass them through an unsigned truncate().
         */
        dst = this.truncate(dst, 0, true);
        src = this.truncate(src, 0, true);
        return ((((dst / DbgLib.TWO_POW32)|0) | ((src / DbgLib.TWO_POW32)|0)) * DbgLib.TWO_POW32) + ((dst | src) >>> 0);
    }

    /**
     * evalXOR(dst, src)
     *
     * Adapted from /machines/dec/pdp10/modules/v2/cpuops.js:PDP10.XOR().
     *
     * Performs the logical "exclusive-or" (XOR) of two operands > 32 bits.
     *
     * @this {DbgLib}
     * @param {number} dst
     * @param {number} src
     * @returns {number} (dst ^ src)
     */
    evalXOR(dst, src)
    {
        /*
         * We XOR the low 32 bits separately from the higher bits, and then combine them with addition.
         * Since all bits above 32 will be zero, and since 0 XOR 0 is 0, no special masking for the higher
         * bits is required.
         *
         * WARNING: When using JavaScript's 32-bit operators with values that could set bit 31 and produce a
         * negative value, it's critical to perform a final right-shift of 0, ensuring that the final result is
         * positive.
         */
        if (this.nBits <= 32) {
            return dst ^ src;
        }
        /*
         * Negative values don't yield correct results when dividing, so pass them through an unsigned truncate().
         */
        dst = this.truncate(dst, 0, true);
        src = this.truncate(src, 0, true);
        return ((((dst / DbgLib.TWO_POW32)|0) ^ ((src / DbgLib.TWO_POW32)|0)) * DbgLib.TWO_POW32) + ((dst ^ src) >>> 0);
    }

    /**
     * evalMUL(dst, src)
     *
     * I could have adapted the code from /machines/dec/pdp10/modules/v2/cpuops.js:PDP10.doMUL(), but it was simpler to
     * write this base method and let the PDP-10 Debugger override it with a call to the *actual* doMUL() method.
     *
     * @this {DbgLib}
     * @param {number} dst
     * @param {number} src
     * @returns {number} (dst * src)
     */
    evalMUL(dst, src)
    {
        return dst * src;
    }

    /**
     * truncate(v, nBits, fUnsigned)
     *
     * @this {DbgLib}
     * @param {number} v
     * @param {number} [nBits]
     * @param {boolean} [fUnsigned]
     * @returns {number}
     */
    truncate(v, nBits, fUnsigned)
    {
        let limit, vNew = v;
        nBits = nBits || this.nBits;

        if (fUnsigned) {
            if (nBits == 32) {
                vNew = v >>> 0;
            }
            else if (nBits < 32) {
                vNew = v & ((1 << nBits) - 1);
            }
            else {
                limit = Math.pow(2, nBits);
                if (v < 0 || v >= limit) {
                    vNew = v % limit;
                    if (vNew < 0) vNew += limit;
                }
            }
        }
        else {
            if (nBits <= 32) {
                vNew = (v << (32 - nBits)) >> (32 - nBits);
            }
            else {
                limit = Math.pow(2, nBits - 1);
                if (v >= limit) {
                    vNew = (v % limit);
                    if (((v / limit)|0) & 1) vNew -= limit;
                } else if (v < -limit) {
                    vNew = (v % limit);
                    if ((((-v - 1) / limit) | 0) & 1) {
                        if (vNew) vNew += limit;
                    }
                    else {
                        if (!vNew) vNew -= limit;
                    }
                }
            }
        }
        if (v != vNew) {
            if (MAXDEBUG) this.printf("warning: value %d truncated to %d\n", v, vNew);
            v = vNew;
        }
        return v;
    }

    /**
     * evalOps(aVals, aOps, cOps)
     *
     * Some of our clients want a specific number of bits of integer precision.  If that precision is
     * greater than 32, some of the operations below will fail; for example, JavaScript bitwise operators
     * always truncate the result to 32 bits, so beware when using shift operations.  Similarly, it would
     * be wrong to always "|0" the final result, which is why we rely on truncate() now.
     *
     * Note that JavaScript integer precision is limited to 52 bits.  For example, in Node, if you set a
     * variable to 0x80000001:
     *
     *      foo=0x80000001|0
     *
     * then calculate foo*foo and display the result in binary using "(foo*foo).toString(2)":
     *
     *      '11111111111111111111111111111100000000000000000000000000000000'
     *
     * which is slightly incorrect because it has overflowed JavaScript's floating-point precision.
     *
     * 0x80000001 in decimal is -2147483647, so the product is 4611686014132420609, which is 0x3FFFFFFF00000001.
     *
     * @this {DbgLib}
     * @param {Array.<number>} aVals
     * @param {Array.<string>} aOps
     * @param {number} [cOps] (default is -1 for all)
     * @returns {boolean} true if successful, false if error
     */
    evalOps(aVals, aOps, cOps = -1)
    {
        while (cOps-- && aOps.length) {
            let chOp = aOps.pop();
            if (aVals.length < 2) return false;
            let valNew;
            let val2 = aVals.pop();
            let val1 = aVals.pop();
            switch(chOp) {
            case '*':
                valNew = this.evalMUL(val1, val2);
                break;
            case '/':
                if (!val2) return false;
                valNew = Math.trunc(val1 / val2);
                break;
            case '^/':
                if (!val2) return false;
                valNew = val1 % val2;
                break;
            case '+':
                valNew = val1 + val2;
                break;
            case '-':
                valNew = val1 - val2;
                break;
            case '<<':
                valNew = val1 << val2;
                break;
            case '>>':
                valNew = val1 >> val2;
                break;
            case '>>>':
                valNew = val1 >>> val2;
                break;
            case '<':
                valNew = (val1 < val2? 1 : 0);
                break;
            case '<=':
                valNew = (val1 <= val2? 1 : 0);
                break;
            case '>':
                valNew = (val1 > val2? 1 : 0);
                break;
            case '>=':
                valNew = (val1 >= val2? 1 : 0);
                break;
            case '==':
                valNew = (val1 == val2? 1 : 0);
                break;
            case '!=':
                valNew = (val1 != val2? 1 : 0);
                break;
            case '&':
                valNew = this.evalAND(val1, val2);
                break;
            case '!':           // alias for MACRO-10 to perform a bitwise inclusive-or (OR)
            case '|':
                valNew = this.evalIOR(val1, val2);
                break;
            case '^!':          // since MACRO-10 uses '^' for base overrides, '^!' is used for bitwise exclusive-or (XOR)
                valNew = this.evalXOR(val1, val2);
                break;
            case '&&':
                valNew = (val1 && val2? 1 : 0);
                break;
            case '||':
                valNew = (val1 || val2? 1 : 0);
                break;
            case ',,':
                valNew = this.truncate(val1, 18, true) * Math.pow(2, 18) + this.truncate(val2, 18, true);
                break;
         // case '_':
            case '^_':
                valNew = val1;
                /*
                 * While we always try to avoid assuming any particular number of bits of precision, the 'B' shift
                 * operator (which we've converted to '^_') is unique to the MACRO-10 environment, which imposes the
                 * following restrictions on the shift count.
                 */
                if (chOp == '^_') val2 = 35 - (val2 & 0xff);
                if (val2) {
                    /*
                     * Since binary shifting is a logical (not arithmetic) operation, and since shifting by division only
                     * works properly with positive numbers, we call truncate() to produce an unsigned value.
                     */
                    valNew = this.truncate(valNew, 0, true);
                    if (val2 > 0) {
                        valNew *= Math.pow(2, val2);
                    } else {
                        valNew = Math.trunc(valNew / Math.pow(2, -val2));
                    }
                }
                break;
            default:
                return false;
            }
            aVals.push(this.truncate(valNew));
        }
        return true;
    }

    /**
     * parseArray(asValues, iValue, iLimit, nBase, aUndefined)
     *
     * parseExpression() takes a complete expression and divides it into array elements, where even elements
     * are values (which may be empty if two or more operators appear consecutively) and odd elements are operators.
     *
     * For example, if the original expression was "2*{3+{4/2}}", parseExpression() would call parseArray() with:
     *
     *      0   1   2   3   4   5   6   7   8   9  10  11  12  13  14
     *      -   -   -   -   -   -   -   -   -   -  --  --  --  --  --
     *      2   *       {   3   +       {   4   /   2   }       }
     *
     * This function takes care of recursively processing grouped expressions, by processing subsets of the array,
     * as well as handling certain base overrides (eg, temporarily switching to base-10 for binary shift suffixes).
     *
     * @param {Array.<string>} asValues
     * @param {number} iValue
     * @param {number} iLimit
     * @param {number} nBase
     * @param {Array|undefined} [aUndefined]
     * @returns {number|undefined}
     */
    parseArray(asValues, iValue, iLimit, nBase, aUndefined)
    {
        let value;
        let sValue, sOp;
        let fError = false;
        let nUnary = 0;
        let aVals = [], aOps = [];

        let nBasePrev = this.nBase;
        this.nBase = nBase;

        while (iValue < iLimit) {
            let v;
            sValue = asValues[iValue++].trim();
            sOp = (iValue < iLimit? asValues[iValue++] : "");

            if (sValue) {
                v = this.parseValue(sValue, undefined, aUndefined, nUnary);
            } else {
                if (sOp == '{') {
                    let cOpen = 1;
                    let iStart = iValue;
                    while (iValue < iLimit) {
                        sValue = asValues[iValue++].trim();
                        sOp = (iValue < asValues.length? asValues[iValue++] : "");
                        if (sOp == '{') {
                            cOpen++;
                        } else if (sOp == '}') {
                            if (!--cOpen) break;
                        }
                    }
                    v = this.parseArray(asValues, iStart, iValue-1, this.nBase, aUndefined);
                    if (v != null && nUnary) {
                        v = this.parseUnary(v, nUnary);
                    }
                    sValue = (iValue < iLimit? asValues[iValue++].trim() : "");
                    sOp = (iValue < iLimit? asValues[iValue++] : "");
                }
                else {
                    /*
                     * When parseExpression() calls us, it has collapsed all runs of whitespace into single spaces,
                     * and although it allows single spaces to divide the elements of the expression, a space is neither
                     * a unary nor binary operator.  It's essentially a no-op.  If we encounter it here, then it followed
                     * another operator and is easily ignored (although perhaps it should still trigger a reset of nBase
                     * and nUnary -- TBD).
                     */
                    if (sOp == ' ') {
                        continue;
                    }
                    if (sOp == '^B') {
                        this.nBase = 2;
                        continue;
                    }
                    if (sOp == '^O') {
                        this.nBase = 8;
                        continue;
                    }
                    if (sOp == '^D') {
                        this.nBase = 10;
                        continue;
                    }
                    if (!(nUnary & (0xC0000000|0))) {
                        if (sOp == '+') {
                            continue;
                        }
                        if (sOp == '-') {
                            nUnary = (nUnary << 2) | 1;
                            continue;
                        }
                        if (sOp == '~' || sOp == '^-') {
                            nUnary = (nUnary << 2) | 2;
                            continue;
                        }
                        if (sOp == '^L') {
                            nUnary = (nUnary << 2) | 3;
                            continue;
                        }
                    }
                    fError = true;
                    break;
                }
            }

            if (v === undefined) {
                if (aUndefined) {
                    aUndefined.push(sValue);
                    v = 0;
                } else {
                    fError = true;
                    aUndefined = [];
                    break;
                }
            }

            aVals.push(this.truncate(v));

            /*
             * When parseExpression() calls us, it has collapsed all runs of whitespace into single spaces,
             * and although it allows single spaces to divide the elements of the expression, a space is neither
             * a unary nor binary operator.  It's essentially a no-op.  If we encounter it here, then it followed
             * a value, and since we don't want to misinterpret the next operator as a unary operator, we look
             * ahead and grab the next operator if it's not preceded by a value.
             */
            if (sOp == ' ') {
                if (iValue < asValues.length - 1 && !asValues[iValue]) {
                    iValue++;
                    sOp = asValues[iValue++];
                } else {
                    fError = true;
                    break;
                }
            }

            if (!sOp) break;

            let aBinOp = (this.achGroup[0] == '<'? DbgLib.aDECOpPrecedence : DbgLib.aBinOpPrecedence);
            if (!aBinOp[sOp]) {
                fError = true;
                break;
            }
            if (aOps.length && aBinOp[sOp] <= aBinOp[aOps[aOps.length - 1]]) {
                this.evalOps(aVals, aOps, 1);
            }
            aOps.push(sOp);

            /*
             * The MACRO-10 binary shifting operator assumes a base-10 shift count, regardless of the current
             * base, so we must override the current base to ensure the count is parsed correctly.
             */
            this.nBase = (sOp == '^_')? 10 : nBase;
            nUnary = 0;
        }

        if (fError || !this.evalOps(aVals, aOps) || aVals.length != 1) {
            fError = true;
        }

        if (!fError) {
            value = aVals.pop();

        } else if (!aUndefined) {
            this.printf("parse error (%s)\n", (sValue || sOp));
        }

        this.nBase = nBasePrev;
        return value;
    }

    /**
     * parseASCII(sExp, chDelim, nBits, cchMax)
     *
     * @this {DbgLib}
     * @param {string} sExp
     * @param {string} chDelim
     * @param {number} nBits
     * @param {number} cchMax
     * @returns {string|undefined}
     */
    parseASCII(sExp, chDelim, nBits, cchMax)
    {
        let i;
        while ((i = sExp.indexOf(chDelim)) >= 0) {
            let v = 0;
            let j = i + 1;
            let cch = cchMax;
            while (j < sExp.length) {
                let ch = sExp[j++];
                if (ch == chDelim) {
                    cch = -1;
                    break;
                }
                if (!cch) break;
                cch--;
                let c = ch.charCodeAt(0);
                if (nBits == 7) {
                    c &= 0x7F;
                } else {
                    c = (c - 0x20) & 0x3F;
                }
                v = this.truncate(v * Math.pow(2, nBits) + c, nBits * cchMax, true);
            }
            if (cch >= 0) {
                this.printf("parse error (%s%s%s)\n", chDelim, sExp, chDelim);
                return undefined;
            } else {
                sExp = sExp.substr(0, i) + this.toStrBase(v, -1) + sExp.substr(j);
            }
        }
        return sExp;
    }

    /**
     * parseExpression(sExp, fQuiet)
     *
     * A quick-and-dirty expression parser.  It takes an expression like:
     *
     *      EDX+EDX*4+12345678
     *
     * and builds a value stack in aVals and a "binop" (binary operator) stack in aOps:
     *
     *      aVals       aOps
     *      -----       ----
     *      EDX         +
     *      EDX         *
     *      4           +
     *      ...
     *
     * We pop 1 "binop" from aOps and 2 values from aVals whenever a "binop" of lower priority than its
     * predecessor is encountered, evaluate, and push the result back onto aVals.  Only selected unary
     * operators are supported (eg, negate and complement); no ternary operators like '?:' are supported.
     *
     * fQuiet can be used to pass an array that collects any undefined variables that parseExpression()
     * encounters; the value of an undefined variable is zero.  This mode was added for components that need
     * to support expressions containing "fixups" (ie, values that must be determined later).
     *
     * @this {DbgLib}
     * @param {string|undefined} sExp
     * @param {Array|undefined|boolean} [fQuiet]
     * @returns {number|undefined} numeric value, or undefined if sExp contains any undefined or invalid values
     */
    parseExpression(sExp, fQuiet)
    {
        let value = undefined;
        let fPrint = (fQuiet === false);
        let aUndefined = Array.isArray(fQuiet)? fQuiet : undefined;

        if (sExp) {

            /*
             * The default delimiting characters for grouped expressions are braces; they can be changed by altering
             * achGroup, but when that happens, instead of changing our regular expressions and operator tables,
             * we simply replace all achGroup characters with braces in the given expression.
             *
             * Why not use parentheses for grouped expressions?  Because some debuggers use parseReference() to perform
             * parenthetical value replacements in message strings, and they don't want parentheses taking on a different
             * meaning.  And for some machines, like the PDP-10, the convention is to use parentheses for other things,
             * like indexed addressing, and to use angle brackets for grouped expressions.
             */
            if (this.achGroup[0] != '{') {
                sExp = sExp.split(this.achGroup[0]).join('{').split(this.achGroup[1]).join('}');
            }

            /*
             * Quoted ASCII characters can have a numeric value, too, which must be converted now, to avoid any
             * conflicts with the operators below.
             */
            sExp = this.parseASCII(sExp, '"', 7, 5);    // MACRO-10 packs up to 5 7-bit ASCII codes into a value
            if (!sExp) return value;
            sExp = this.parseASCII(sExp, "'", 6, 6);    // MACRO-10 packs up to 6 6-bit ASCII (SIXBIT) codes into a value
            if (!sExp) return value;

            /*
             * All browsers (including, I believe, IE9 and up) support the following idiosyncrasy of a RegExp split():
             * when the RegExp uses a capturing pattern, the resulting array will include entries for all the pattern
             * matches along with the non-matches.  This effectively means that, in the set of expressions that we
             * support, all even entries in asValues will contain "values" and all odd entries will contain "operators".
             *
             * Although I started listing the operators in the RegExp in "precedential" order, that's not important;
             * what IS important is listing operators that contain shorter operators first.  For example, bitwise
             * shift operators must be listed BEFORE the logical less-than or greater-than operators.  The aBinOp tables
             * (aBinOpPrecedence and aDECOpPrecedence) are what determine precedence, not the RegExp.
             *
             * Also, to better accommodate MACRO-10 syntax, I've replaced the single '^' for XOR with '^!', and I've
             * added '!' as an alias for '|' (bitwise inclusive-or), '^-' as an alias for '~' (one's complement operator),
             * and '_' as a shift operator (+/- values specify a left/right shift, and the count is not limited to 32).
             *
             * 2023 Update: I've removed '_' as a shift operator, because it interferes with symbols that use underscores.
             *
             * And to avoid conflicts with MACRO-10 syntax, I've replaced the original mod operator ('%') with '^/'.
             *
             * The MACRO-10 binary shifting suffix ('B') is a bit more problematic, since a capital B can also appear
             * inside symbols, or inside hex values.  So if the default base is NOT 16, then I pre-scan for that suffix
             * and replace all non-symbolic occurrences with an internal shift operator ('^_').
             *
             * Note that StrLib.parseInt(), which parseValue() relies on, supports both the MACRO-10 base prefix overrides
             * and the binary shifting suffix ('B'), but since that suffix can also be a bracketed expression, we have to
             * support it here as well.
             *
             * MACRO-10 supports only a subset of all the PCjs operators; for example, MACRO-10 doesn't support any of
             * the boolean logical/compare operators.  But unless we run into conflicts, I prefer sticking with this
             * common set of operators.
             *
             * All whitespace in the expression is collapsed to single spaces, and space has been added to the list
             * of "operators", but its sole function is as a separator, not as an operator.  parseArray() will ignore
             * single spaces as long as they are preceded and/or followed by a "real" operator.  It would be dangerous
             * to remove spaces entirely, because if an operator-less expression like "A B" was passed in, we would want
             * that to generate an error; if we converted it to "AB", evaluation might inadvertently succeed.
             */
            let regExp = /({|}|\|\||&&|\||\^!|\^B|\^O|\^D|\^L|\^-|~|\^_|&|!=|!|==|>=|>>>|>>|>|<=|<<|<|-|\+|\^\/|\/|\*|,,| )/;
            if (this.nBase != 16) {
                sExp = sExp.replace(/(^|[^A-Z0-9$%.])([0-9]+)B/, "$1$2^_").replace(/\s+/g, ' ');
            }
            let asValues = sExp.split(regExp);
            value = this.parseArray(asValues, 0, asValues.length, this.nBase, aUndefined);
            if (value !== undefined && fPrint) {
                this.printValue(null, value);
            }
        }
        return value;
    }

    /**
     * parseReference(s)
     *
     * Returns the given string with any "{expression}" sequences replaced with the value of the expression,
     * and any "[address]" references replaced with the contents of the address.  Expressions are parsed BEFORE
     * addresses.
     *
     * @this {DbgLib}
     * @param {string} s
     * @returns {string|undefined}
     */
    parseReference(s)
    {
        let a;
        let chOpen = this.achGroup[0];
        let chClose = this.achGroup[1];
        let chEscape = (chOpen == '(' || chOpen == '{' || chOpen == '[')? '\\' : '';
        let chInnerEscape = (chOpen == '['? '\\' : '');
        let reSubExp = new RegExp(chEscape + chOpen + "([^" + chInnerEscape + chOpen + chInnerEscape + chClose + "]+)" + chEscape + chClose);
        while ((a = s.match(reSubExp))) {
            let value = this.parseExpression(a[1]);
            if (value === undefined) return undefined;
            let sSearch = chOpen + a[1] + chClose;
            let sReplace = value != null? this.toStrBase(value) : "undefined";
            /*
             * Note that by default, the String replace() method only replaces the FIRST occurrence,
             * and there MIGHT be more than one occurrence of the expression we just parsed, so we could
             * do this instead:
             *
             *      s = s.split(sSearch).join(sReplace);
             *
             * However, that's knd of an expensive (slow) solution, and it's not strictly necessary, since
             * any additional identical expressions will be picked up on a subsequent iteration through this loop.
             */
            s = s.replace(sSearch, sReplace);
        }
        if (this.achAddress.length) {
            chOpen = this.achAddress[0];
            chClose = this.achAddress[1];
            chEscape = (chOpen == '(' || chOpen == '{' || chOpen == '[')? '\\' : '';
            chInnerEscape = (chOpen == '['? '\\' : '');
            reSubExp = new RegExp(chEscape + chOpen + "([^" + chInnerEscape + chOpen + chInnerEscape + chClose + "]+)" + chEscape + chClose);
            while ((a = s.match(reSubExp))) {
                s = this.parseAddrReference(s, a[1]);
            }
        }
        return this.parseSysVars(s);
    }

    /**
     * parseSysVars(s)
     *
     * Returns the given string with any recognized "$var" replaced with its value; eg:
     *
     *      $ops: the number of opcodes executed since the last time it was displayed (or reset)
     *
     * @this {DbgLib}
     * @param {string} s
     * @returns {string}
     */
    parseSysVars(s)
    {
        let a;
        while ((a = s.match(/\$([a-z]+)/i))) {
            let v = null;
            switch(a[1].toLowerCase()) {
            case "ops":
                v = this.cOpcodes - this.cOpcodesStart;
                break;
            }
            if (v == null) break;
            s = s.replace(a[0], v.toString());
        }
        return s;
    }

    /**
     * parseUnary(value, nUnary)
     *
     * nUnary is actually a small "stack" of unary operations encoded in successive pairs of bits.
     * As parseExpression() encounters each unary operator, nUnary is shifted left 2 bits, and the
     * new unary operator is encoded in bits 0 and 1 (0b00 is none, 0b01 is negate, 0b10 is complement,
     * and 0b11 is reserved).  Here, we process the bits in reverse order (hence the stack-like nature),
     * ensuring that we process the unary operators associated with this value right-to-left.
     *
     * Since bitwise operators see only 32 bits, more than 16 unary operators cannot be supported
     * using this method.  We'll let parseExpression() worry about that; if it ever happens in practice,
     * then we'll have to switch to a more "expensive" approach (eg, an actual array of unary operators).
     *
     * @this {DbgLib}
     * @param {number} value
     * @param {number} nUnary
     * @returns {number}
     */
    parseUnary(value, nUnary)
    {
        while (nUnary) {
            let bit;
            switch(nUnary & 0o3) {
            case 1:
                value = -this.truncate(value);
                break;
            case 2:
                value = this.evalXOR(value, -1);        // this is easier than adding an evalNOT()...
                break;
            case 3:
                bit = 35;                               // simple left-to-right zero-bit-counting loop...
                while (bit >= 0 && !this.evalAND(value, Math.pow(2, bit))) bit--;
                value = 35 - bit;
                break;
            }
            nUnary >>>= 2;
        }
        return value;
    }

    /**
     * parseValue(sValue, sName, fQuiet, nUnary)
     *
     * @this {DbgLib}
     * @param {string} [sValue]
     * @param {string} [sName] is the name of the value, if any
     * @param {Array|boolean} [fQuiet]
     * @param {number} [nUnary] (0 for none, 1 for negate, 2 for complement, 3 for leading zeros)
     * @returns {number|undefined} numeric value, or undefined if sValue is either undefined or invalid
     */
    parseValue(sValue, sName, fQuiet, nUnary = 0)
    {
        let value;
        let aUndefined = Array.isArray(fQuiet)? fQuiet : undefined;

        if (sValue != undefined) {
            let iReg = this.getRegIndex(sValue);
            if (iReg >= 0) {
                value = this.getRegValue(iReg);
            } else {
                value = this.getVariable(sValue);
                if (value != undefined) {
                    let sUndefined = this.getVariableFixup(sValue);
                    if (sUndefined) {
                        if (aUndefined) {
                            aUndefined.push(sUndefined);
                        } else {
                            let valueUndefined = this.parseExpression(sUndefined, fQuiet);
                            if (valueUndefined !== undefined) {
                                value += valueUndefined;
                            } else {
                                if (!fQuiet) {
                                    this.printf("undefined %s: %s (%s)\n", (sName || "value"), sValue, sUndefined);
                                }
                                value = undefined;
                            }
                        }
                    }
                } else {
                    /*
                     * A feature of MACRO-10 is that any single-digit number is automatically interpreted as base-10.
                     */
                    value = StrLib.parseInt(sValue, sValue.length > 1 || this.nBase > 10? this.nBase : 10);
                }
            }
            if (value != undefined) {
                value = this.truncate(this.parseUnary(value, nUnary));
            } else {
                if (!fQuiet) {
                    this.printf("invalid %s: %s\n", (sName || "value"), sValue);
                }
            }
        } else {
            if (!fQuiet) {
                this.printf("missing %s\n", (sName || "value"));
            }
        }
        return value;
    }

    /**
     * printValue(sVar, value)
     *
     * @this {DbgLib}
     * @param {string|null|*} sVar
     * @param {number|undefined} value
     * @returns {boolean} true if value defined, false if not
     */
    printValue(sVar, value)
    {
        let sValue;
        let fDefined = false;
        if (value !== undefined) {
            fDefined = true;
            if (this.nBase == 8) {
                sValue = this.toStrBase(value, this.nBits, 8, 1) + "  " + value + '.';
            } else {
                sValue = this.toStrBase(value, this.nBits, 16, 1) + "  " + this.toStrBase(value, this.nBits, 8, 1) + "  " + this.toStrBase(value, this.nBits, 2, this.nBits <= 32? 8 : 6) + "  " + value + '.';
            }
            if (value >= 0x20 && value < 0x7F) {
                sValue += " '" + String.fromCharCode(value) + "'";
            }
        }
        sVar = (sVar != null? (sVar + ": ") : "");
        this.printf("%s%s\n", sVar, sValue);
        return fDefined;
    }

    /**
     * resetVariables()
     *
     * @this {DbgLib}
     * @returns {Object}
     */
    resetVariables()
    {
        let a = this.aVariables;
        this.aVariables = {};
        return a;
    }

    /**
     * restoreVariables(a)
     *
     * @this {DbgLib}
     * @param {Object} a (from previous resetVariables() call)
     */
    restoreVariables(a)
    {
        this.aVariables = a;
    }

    /**
     * printVariable(sVar)
     *
     * @this {DbgLib}
     * @param {string} [sVar]
     * @returns {boolean} true if all value(s) defined, false if not
     */
    printVariable(sVar)
    {
        let cVariables = 0;
        if (this.aVariables) {
            if (sVar) {
                return this.printValue(sVar, this.aVariables[sVar] && this.aVariables[sVar].value);
            }
            let aVars = Object.keys(this.aVariables);
            aVars.sort();
            for (let i = 0; i < aVars.length; i++) {
                this.printValue(aVars[i], this.aVariables[aVars[i]].value);
                cVariables++;
            }
        }
        return cVariables > 0;
    }

    /**
     * delVariable(sVar)
     *
     * @this {DbgLib}
     * @param {string} sVar
     */
    delVariable(sVar)
    {
        delete this.aVariables[sVar];
    }

    /**
     * getVariable(sVar)
     *
     * @this {DbgLib}
     * @param {string} sVar
     * @returns {number|undefined}
     */
    getVariable(sVar)
    {
        if (this.aVariables[sVar]) {
            return this.aVariables[sVar].value;
        }
        sVar = sVar.substr(0, 6);
        return this.aVariables[sVar] && this.aVariables[sVar].value;
    }

    /**
     * getVariableFixup(sVar)
     *
     * @this {DbgLib}
     * @param {string} sVar
     * @returns {string|undefined}
     */
    getVariableFixup(sVar)
    {
        return this.aVariables[sVar] && this.aVariables[sVar].sUndefined;
    }

    /**
     * isVariable(sVar)
     *
     * @this {DbgLib}
     * @param {string} sVar
     * @returns {boolean}
     */
    isVariable(sVar)
    {
        return this.aVariables[sVar] !== undefined;
    }

    /**
     * setVariable(sVar, value, sUndefined)
     *
     * @this {DbgLib}
     * @param {string} sVar
     * @param {number} value
     * @param {string|undefined} [sUndefined]
     */
    setVariable(sVar, value, sUndefined)
    {
        this.aVariables[sVar] = {value, sUndefined};
    }

    /**
     * toStrBase(n, nBits, nBase, nGrouping)
     *
     * Use this instead of Str's toOct()/toDec()/toHex() to convert numbers to the Debugger's default base.
     *
     * @this {DbgLib}
     * @param {number|null|undefined} n
     * @param {number} [nBits] (-1 to strip leading zeros, 0 to allow a variable number of digits)
     * @param {number} [nBase]
     * @param {number} [nGrouping] (if nBase is 2, this is a grouping; otherwise, it's a prefix condition)
     * @returns {string}
     */
    toStrBase(n, nBits = 0, nBase = 0, nGrouping = 0)
    {
        let s;
        switch(nBase || this.nBase) {
        case 2:
            s = StrLib.toBin(n, nBits > 0? nBits : 0, nGrouping);
            break;
        case 8:
            s = StrLib.toOct(n, nBits > 0? ((nBits + 2)/3)|0 : 0, !!nGrouping);
            break;
        case 10:
            /*
             * The multiplier is actually Math.log(2)/Math.log(10), but an approximation is more than adequate.
             */
            s = StrLib.toDec(n, nBits > 0? Math.ceil(nBits * 0.3) : 0);
            break;
        case 16:
        default:
            s = StrLib.toHex(n, nBits > 0? ((nBits + 3) >> 2) : 0, !!nGrouping);
            break;
        }
        return (nBits < 0? StrLib.stripLeadingZeros(s) : s);
    }

    /**
     * onEvent(fnNotify)
     *
     * @param {function()} fnNotify
     */
    onEvent(fnNotify)
    {
        this.afnNotify.push(fnNotify);
    }

    /**
     * notifyEvent(nEvent, dataEvent)
     *
     * @param {number} nEvent (see DbgLib.EVENTS)
     * @param {number} [dataEvent] (optional data for event)
     */
    notifyEvent(nEvent, dataEvent)
    {
        for (let i = 0; i < this.afnNotify.length; i++) {
            this.afnNotify[i](nEvent, dataEvent);
        }
    }
}

if (DEBUGGER) {

    /*
     * These are our operator precedence tables.  Operators toward the bottom (with higher values) have
     * higher precedence.  aBinOpPrecedence was our original table; we had to add aDECOpPrecedence because
     * the precedence of operators in DEC's MACRO-10 expressions differ.  Having separate tables also allows
     * us to remove operators that shouldn't be supported, but unless some operator creates a problem,
     * I prefer to keep as much commonality between the tables as possible.
     *
     * Missing from these tables are the (limited) set of unary operators we support (negate and complement),
     * since this is only a BINARY operator precedence, not a general-purpose precedence table.  Assume that
     * all unary operators take precedence over all binary operators.
     */
    DbgLib.aBinOpPrecedence = {
        '||':   5,      // logical OR
        '&&':   6,      // logical AND
        '!':    7,      // bitwise OR (conflicts with logical NOT, but we never supported that)
        '|':    7,      // bitwise OR
        '^!':   8,      // bitwise XOR (added by MACRO-10 sometime between the 1972 and 1978 versions)
        '&':    9,      // bitwise AND
        '!=':   10,     // inequality
        '==':   10,     // equality
        '>=':   11,     // greater than or equal to
        '>':    11,     // greater than
        '<=':   11,     // less than or equal to
        '<':    11,     // less than
        '>>>':  12,     // unsigned bitwise right shift
        '>>':   12,     // bitwise right shift
        '<<':   12,     // bitwise left shift
        '-':    13,     // subtraction
        '+':    13,     // addition
        '^/':   14,     // remainder
        '/':    14,     // division
        '*':    14,     // multiplication
    //  '_':    19,     // MACRO-10 shift operator
        '^_':   19,     // MACRO-10 internal shift operator (converted from 'B' suffix form that MACRO-10 uses)
        '{':    20,     // open grouped expression (converted from achGroup[0])
        '}':    20      // close grouped expression (converted from achGroup[1])
    };
    DbgLib.aDECOpPrecedence = {
        ',,':   1,      // high-word,,low-word
        '||':   5,      // logical OR
        '&&':   6,      // logical AND
        '!=':   10,     // inequality
        '==':   10,     // equality
        '>=':   11,     // greater than or equal to
        '>':    11,     // greater than
        '<=':   11,     // less than or equal to
        '<':    11,     // less than
        '>>>':  12,     // unsigned bitwise right shift
        '>>':   12,     // bitwise right shift
        '<<':   12,     // bitwise left shift
        '-':    13,     // subtraction
        '+':    13,     // addition
        '^/':   14,     // remainder
        '/':    14,     // division
        '*':    14,     // multiplication
        '!':    15,     // bitwise OR (conflicts with logical NOT, but we never supported that)
        '|':    15,     // bitwise OR
        '^!':   15,     // bitwise XOR (added by MACRO-10 sometime between the 1972 and 1978 versions)
        '&':    15,     // bitwise AND
    //  '_':    19,     // MACRO-10 shift operator
        '^_':   19,     // MACRO-10 internal shift operator (converted from 'B' suffix form that MACRO-10 uses)
        '{':    20,     // open grouped expression (converted from achGroup[0])
        '}':    20      // close grouped expression (converted from achGroup[1])
    };

    /*
     * Assorted constants
     */
    DbgLib.TWO_POW32 = Math.pow(2, 32);

}   // endif DEBUGGER

DbgLib.EVENTS = {
    EXIT:       0,
    ENTER:      1,
    READY:      2,
};

/**
 * @copyright https://www.pcjs.org/machines/pcx86/modules/v2/debugger.js (C) 2012-2024 Jeff Parsons
 */

/** @typedef {{ off: (number|undefined), sel: (number|undefined), addr: (number|undefined), type: (number|undefined), fData32: (boolean|undefined), fAddr32: (boolean|undefined), fData32Orig: (boolean|undefined), fAddr32Orig: (boolean|undefined), fTempBreak: (boolean|undefined), sCmd: (string|undefined), aCmds: (Array.<string>|undefined), nCPUCycles: (number|undefined), nDebugCycles: (number|undefined), nDebugState: (number|undefined) }} */
let DbgAddrx86;

/** @typedef {{ vector: (number|undefined), type: (number|undefined), dbgAddr: (DbgAddrx86|undefined) }} */
let VectorBP;

/**
 * Debugger Breakpoint Tips
 *
 * Here's an example of our powerful new breakpoint command capabilities:
 *
 *      bp 0397:022B "?'GlobalAlloc(wFlags:[ss:sp+8],dwBytes:[ss:sp+6][ss:sp+4])';g [ss:sp+2]:[ss:sp] '?ax;if ax'"
 *
 * The above breakpoint will display a pleasing "GlobalAlloc()" string containing the current
 * stack parameters, and will briefly stop execution on the return to print the result in AX,
 * halting the CPU whenever AX is zero (the default behavior of "if" whenever the expression is
 * false is to look for an "else" and automatically halt when there is no "else").
 *
 * How do you figure out where the code for GlobalAlloc is in the first place?  You need to have
 * BACKTRACK support enabled (which currently means running the non-COMPILED version), so that as
 * the Disk component loads disk images, it will automatically extract symbolic information from all
 * "NE" (New Executable) binaries on those disks, which the Debugger's "dt" command can then search
 * for you; eg:
 *
 *      ## dt globalalloc
 *      GLOBALALLOC: KRNL386.EXE 0001:022B len 0xC570
 *
 * And then you just need to do a bit more sleuthing to find the right CODE segment.  And that just
 * got easier, now that the PCx86 Debugger mimics portions of the Windows Debugger INT 0x41 interface;
 * see intWindowsDebugger() for details.  So even if you neglect to run WDEB386.EXE /E inside the
 * machine before running Windows, you should still see notifications like:
 *
 *      KERNEL!undefined code(0001)=#0397 len 0000C580
 *
 * in the PCx86 Debugger output window, as segments are being loaded by the Windows kernel.
 */

/**
 * @class Debuggerx86
 * @unrestricted (allows the class to define properties, both dot and named, outside of the constructor)
 */
class Debuggerx86 extends DbgLib {
    /**
     * Debuggerx86(parmsDbg)
     *
     * The Debuggerx86 component is an optional component that implements a variety of user commands
     * for controlling the CPU, dumping and editing memory, etc.
     *
     * Debuggerx86 extends the shared Debugger component and supports the following optional (parmsDbg)
     * properties:
     *
     *      commands: string containing zero or more commands, separated by ';'
     *
     *      messages: string containing zero or more message categories to enable;
     *      multiple categories must be separated by ',' or ';'.  Parsed by messageInit().
     *
     * @this {Debuggerx86}
     * @param {Object} parmsDbg
     */
    constructor(parmsDbg)
    {
        super("Debugger", parmsDbg, -1);

        if (DEBUGGER) {

            /**
             * Default number of hex chars in a register and a linear address (ie, for real-mode);
             * updated by initBus().
             */
            this.cchReg = 4;
            this.cchAddr = 5;
            this.maskAddr = 0xfffff;

            /**
             * Most commands that require an address call parseAddr(), which defaults to dbgAddrNextCode
             * or dbgAddrNextData when no address has been given.  doDump() and doUnassemble(), in turn,
             * update dbgAddrNextData and dbgAddrNextCode, respectively, when they're done.
             *
             * All dbgAddr variables contain properties off, sel, and addr, where sel:off represents the
             * segmented address and addr is the corresponding linear address (if known).  For certain
             * segmented addresses (eg, breakpoint addresses), we pre-compute the linear address and save
             * that in addr, so that the breakpoint will still operate as intended even if the mode changes
             * later (eg, from real-mode to protected-mode).
             *
             * Finally, for TEMPORARY breakpoint addresses, we set fTempBreak to true, so that they can be
             * automatically cleared when they're hit.
             */
            this.dbgAddrNextCode = this.newAddr(0, 0);
            this.dbgAddrNextData = this.newAddr(0, 0);
            this.dbgAddrAssemble = this.newAddr(0, 0);

            /**
             * aSymbolTable is an array of SymbolTable objects, one per ROM or other chunk of address space,
             * where each object contains the following properties:
             *
             *      sModule
             *      nSegment
             *      sel
             *      off
             *      addr (physical address, if any; eg, symbols for a ROM)
             *      len
             *      aSymbols
             *      aOffsets
             *
             * See addSymbols() for more details, since that's how callers add sets of symbols to the table.
             */
            this.aSymbolTable = [];

            /**
             * clearBreakpoints() initializes the breakpoints lists: aBreakExec is a list of addresses
             * to halt on whenever attempting to execute an instruction at the corresponding address,
             * and aBreakRead and aBreakWrite are lists of addresses to halt on whenever a read or write,
             * respectively, occurs at the corresponding address.
             *
             * NOTE: Curiously, after upgrading the Google Closure Compiler from v20141215 to v20150609,
             * the resulting compiled code would crash in clearBreakpoints(), because the (renamed) aBreakRead
             * property was already defined.  To eliminate whatever was confusing the Closure Compiler, I've
             * explicitly initialized all the properties that clearBreakpoints() (re)initializes.
             */
            this.aBreakExec = this.aBreakRead = this.aBreakWrite = [];
            this.clearBreakpoints();

            /**
             * The new "bn" command allows you to specify a number of instructions to execute and then stop;
             * "bn 0" disables any outstanding count.
             */
            this.nBreakIns = 0;

            /**
             * A new breakpoint command, "bv", allows you to monitor an interrupt vector.  Vector breakpoints
             * don't simply monitor "INT" instructions; they also snapshot the vector address when the "bv"
             * command is issued and monitor execution of that address.  The array is filled with VectorBP objects,
             * which contain vector and dbgAddr properties.
             */
            this.aVectorBP = [];
            this.vectorHalt = true;             // true to halt on vector breakpoints
            this.vectorSkip = -1;
            this.vectorTrace = -1;              // >= 0 whenever a vector has been traced

            /**
             * Execution history is allocated by historyInit() whenever checksEnabled() conditions change.
             * Execution history is updated whenever the CPU calls checkInstruction(), which will happen
             * only when checksEnabled() returns true (eg, whenever one or more breakpoints have been set).
             * This ensures that, by default, the CPU runs as fast as possible.
             */
            this.historyInit();

            /**
             * Initialize Debugger message and command support
             */
            this.afnDumpers = {};
            this.messageInit(parmsDbg['messages']);
            this.sCommandsInit = parmsDbg['commands'];

            /**
             * Make it easier to access Debugger commands from an external REPL, like the WebStorm "live" console
             * window; eg:
             *
             *      pcx86('r')
             *      pcx86('dw 0:0')
             *      pcx86('h')
             *      ...
             */
            let dbg = this;
            if (globals.window[APPCLASS] === undefined) {
                globals.window[APPCLASS] = function(s) { return dbg.doCommands(s); };
            }

        }   // endif DEBUGGER
    }

    /**
     * initBus(bus, cpu, dbg)
     *
     * @this {Debuggerx86}
     * @param {Computer} cmp
     * @param {Busx86} bus
     * @param {CPUx86} cpu
     * @param {Debuggerx86} dbg
     */
    initBus(cmp, bus, cpu, dbg)
    {
        this.bus = bus;
        this.cpu = cpu;
        this.cmp = cmp;
        this.fdc = cmp.getMachineComponent("FDC", false);
        this.hdc = cmp.getMachineComponent("HDC", false);
        this.mouse = cmp.getMachineComponent("Mouse", false);

        /**
         * Re-initialize Debugger message and command support as needed
         */
        let sMessages = cmp.getMachineParm('messages');
        if (sMessages) this.messageInit(sMessages);
        this.sCommandsInit = cmp.getMachineParm('commands') || this.sCommandsInit;

        /**
         * If CHIPSET or VIDEO messages are enabled at startup, we enable ChipSet or Video diagnostic info in
         * the instruction history buffer as appropriate.
         */
        if (this.messageEnabled(MESSAGE.CHIPSET)) {
            this.chipset = cmp.getMachineComponent("ChipSet");
        }
        else if (this.messageEnabled(MESSAGE.VIDEO)) {
            this.video = cmp.getMachineComponent("Video");
        }

        this.cchAddr = bus.getWidth() >> 2;
        this.maskAddr = bus.nBusLimit;

        /**
         * Allocate a special segment "register", for use whenever a requested selector is not currently loaded
         */
        this.segDebugger = new Segx86(this.cpu, Segx86.ID.DBG, "DBG");

        this.aaOpDescs = Debuggerx86.aaOpDescs;
        if (this.cpu.model >= X86.MODEL_80186) {
            this.aaOpDescs = Debuggerx86.aaOpDescs.slice();
            this.aaOpDescs[0x0F] = Debuggerx86.aOpDescUndefined;
            if (this.cpu.model >= X86.MODEL_80286) {
                /**
                 * TODO: Consider whether the aOpDesc0F table should be split in two: one for 80286-only instructions,
                 * and one for both 80286 and 80386.  For now, the Debugger is not as strict as the CPUx86 is about
                 * the instructions it supports for each type of CPU, in part because an 80286 machine could still be
                 * presented with 80386-only code that is simply "skipped over" when then CPU doesn't support it.
                 *
                 * Obviously I'm not being entirely consistent, since I don't disassemble *any* 0x0F opcodes for any
                 * pre-80286 CPUs.  But at least I'm being up front about it.
                 */
                this.aaOpDescs[0x0F] = Debuggerx86.aOpDesc0F;
                if (I386 && this.cpu.model >= X86.MODEL_80386) this.cchReg = 8;
            }
        }

        this.messageDump(MESSAGE.BUS,  function onDumpBus(asArgs) { dbg.dumpBus(asArgs); });
        this.messageDump(MESSAGE.DESC, function onDumpSel(asArgs) { dbg.dumpSel(asArgs); });
        this.messageDump(MESSAGE.DOS,  function onDumpDOS(asArgs) { dbg.dumpDOS(asArgs); });
        this.messageDump(MESSAGE.MEM,  function onDumpMem(asArgs) { dbg.dumpMem(asArgs); });
        this.messageDump(MESSAGE.TSS,  function onDumpTSS(asArgs) { dbg.dumpTSS(asArgs); });

        let fSymbols = cmp.getMachineBoolean('symbols');
        if (DEBUG && fSymbols !== false || fSymbols) {
            if (Interrupts.WINDBG.ENABLED || Interrupts.WINDBGRM.ENABLED) {
                this.fWinDbg = null;
                this.cTrapFaults = 0;
                this.fIgnoreNextCheckFault = false;
                this.cpu.addIntNotify(Interrupts.WINCB.VECTOR, this.intWindowsCallBack.bind(this));
                this.cpu.addIntNotify(Interrupts.WINDBG.VECTOR, this.intWindowsDebugger.bind(this));
            }
            if (Interrupts.WINDBGRM.ENABLED) {
                this.fWinDbgRM = null;
                this.cpu.addIntNotify(Interrupts.WINDBGRM.VECTOR, this.intWindowsDebuggerRM.bind(this));
            }
        }
        this.setReady();
    }

    /**
     * addSegmentInfo(dbgAddr, nSegment, sel, fCode, fPrint)
     *
     * @this {Debuggerx86}
     * @param {DbgAddrx86} dbgAddr (address of module name)
     * @param {number} nSegment (logical segment number)
     * @param {number} sel (current selector)
     * @param {boolean} fCode (true if code segment, false if data segment)
     * @param {boolean|null} [fPrint] (false means we're merely monitoring, so let WDEB386 print its own notifications)
     */
    addSegmentInfo(dbgAddr, nSegment, sel, fCode, fPrint)
    {
        let sModule = this.getSZ(dbgAddr);
        let seg = this.getSegment(sel);
        let len = seg? seg.limit + 1 : 0;
        let sSection = (fCode? "_CODE" : "_DATA") + StrLib.toHex(nSegment, 2);
        if (fPrint) {
            this.printf(MESSAGE.DEBUG, "%s %s(%04X)=#%04X len %0X\n", sModule, (fCode? "code" : "data"), nSegment, sel, len);
        }
        let off = 0;
        let aSymbols = this.findModuleInfo(sModule, nSegment);
        aSymbols[sModule + sSection] = off;
        this.addSymbols(sModule, nSegment, sel, off, null, len, aSymbols);
    }

    /**
     * removeSegmentInfo(sel, fPrint)
     *
     * @this {Debuggerx86}
     * @param {number} sel
     * @param {boolean|null} [fPrint] (false means we're merely monitoring OR we don't really care about these notifications)
     */
    removeSegmentInfo(sel, fPrint)
    {
        let sModuleRemoved = this.removeSymbols(null, sel);
        if (fPrint) {
            if (sModuleRemoved) {
                this.printf(MESSAGE.DEBUG, "%s #%04X removed\n", sModuleRemoved, sel);
            } else {
                this.printf(MESSAGE.DEBUG, "unable to remove module for segment #%04X\n", sel);
            }
        }
    }

    /**
     * addSectionInfo(dbgAddr, fCode, fPrint)
     *
     * @this {Debuggerx86}
     * @param {DbgAddrx86} dbgAddr (address of D386_Device_Params)
     * @param {boolean} fCode (true if code section, false if data section)
     * @param {boolean|null} [fPrint] (false means we're merely monitoring, so let WDEB386 print its own notifications)
     */
    addSectionInfo(dbgAddr, fCode, fPrint)
    {
        let nSegment = this.getShort(dbgAddr, 2);
        let sel = this.getShort(dbgAddr, 2);
        let off = this.getLong(dbgAddr, 4);
        let len = this.getLong(dbgAddr, 4);
        let dbgAddrModule = this.newAddr(this.getLong(dbgAddr, 4), this.getShort(dbgAddr, 2));
        let dbgAddrParent = this.newAddr(this.getLong(dbgAddr, 4), this.getShort(dbgAddr, 2));
        // sel = this.getShort(dbgAddr, 2) || sel;
        let sParent = this.getSZ(dbgAddrParent).toUpperCase();
        let sModule = this.getSZ(dbgAddrModule).toUpperCase();
        if (sParent == sModule) {
            sParent = "";
        } else {
            sParent += '!';
        }
        let sSection = (fCode? "_CODE" : "_DATA") + StrLib.toHex(nSegment, 2);
        /**
         * Mimics WDEB386 output, except that WDEB386 only displays a linear address, omitting the selector.
         */
        if (fPrint) {
            this.printf(MESSAGE.DEBUG, "%s%s %s(%04X)=%04X:%0X len %0X\n", sParent, sModule, (fCode? "code" : "data"), nSegment, sel, off, len);
        }
        /**
         * TODO: Add support for 32-bit symbols; findModuleInfo() relies on Disk.getModuleInfo(),
         * and the Disk component doesn't yet know how to parse 32-bit executables.
         */
        let aSymbols = this.findModuleInfo(sModule, nSegment);
        aSymbols[sModule + sSection] = off;
        this.addSymbols(sModule, nSegment, sel, off, null, len, aSymbols);
    }

    /**
     * removeSectionInfo(nSegment, dbgAddr, fPrint)
     *
     * @this {Debuggerx86}
     * @param {number} nSegment (logical segment number)
     * @param {DbgAddrx86} dbgAddr (address of module)
     * @param {boolean|null} [fPrint] (false means we're merely monitoring OR we don't really care about these notifications)
     */
    removeSectionInfo(nSegment, dbgAddr, fPrint)
    {
        let sModule = this.getSZ(dbgAddr).toUpperCase();
        let sModuleRemoved = this.removeSymbols(sModule, nSegment);
        if (fPrint) {
            if (sModuleRemoved) {
                this.printf(MESSAGE.DEBUG, "%s %04X removed\n", sModule, nSegment);
            } else {
                this.printf(MESSAGE.DEBUG, "unable to remove %s for section %04X\n", sModule, nSegment);
            }
        }
    }

    /**
     * intWindowsCallBack()
     *
     * This intercepts calls to Windows callback addresses, which use INT 0x30 (aka Transfer Space Faults).
     *
     * We're only interested in one particular callback: the VW32_Int41Dispatch (0x002A002A) that KERNEL32
     * issues as 32-bit executable sections are loaded.
     *
     * At the time that INT 0x30 occurs, a far 32-bit call has been made, preceded by a near 32-bit call,
     * preceded by a 32-bit push of the Windows Debugger function # that would normally be in EAX if this had
     * been an actual INT 0x41.
     *
     * NOTE: Regardless whether we're "handling" INT 0x41 or merely "monitoring" INT 0x41, as far as THIS
     * interrupt is concerned, we always let the system process it, because execution never continues at the
     * instruction following an INT 0x30; in fact, execution doesn't even continue after the far 32-bit call
     * (even though the kernel places a "RET 4" after that call).  So, rather than recreate all that automatic
     * address popping, we let the system do it for us, since it's designed to work whether a debugger (eg,
     * WDEB386's DEBUG VxD) is installed or not.
     *
     * TODO: Consider "consuming" all VW32_Int41Dispatch callbacks, because the Windows 95 kernel goes to
     * great effort to pass those requests on to the DEBUG VxD, which end up going nowhere when the VxD isn't
     * loaded (to load it, you must either run WDEB386.EXE or install the VxD via SYSTEM.INI).  Regrettably,
     * Windows 95 assumes that if WDEB386 support is present, then a DEBUG VxD must be present as well.
     *
     * @this {Debuggerx86}
     * @param {number} addr
     * @returns {boolean} (true to proceed with the INT 0x30 software interrupt)
     */
    intWindowsCallBack(addr)
    {
        let cpu = this.cpu;

        if (this.fWinDbg != null && cpu.regEAX == 0x002A002A) {

            let DX = cpu.regEDX & 0xffff;
            let SI = cpu.regESI & 0xffff;
            let dbgAddr = this.newAddr(cpu.getSP() + 0x0C, cpu.getSS());
            let EAX = this.getLong(dbgAddr);

            switch(EAX) {
            case Interrupts.WINDBG.LOADSEG32:
                /**
                 *  SI == segment type:
                 *      0x0     code selector
                 *      0x1     data selector
                 *  DX:EBX -> D386_Device_Params structure (see addSectionInfo() for details)
                 */
                this.addSectionInfo(this.newAddr(cpu.regEBX, DX), !SI, this.fWinDbg);
                break;
            }
        }
        return true;
    }

    /**
     * intWindowsDebugger()
     *
     * This intercepts calls to the Windows Debugger protected-mode interface (INT 0x41).
     *
     * It's enabled if Interrupts.WINDBG.ENABLED is true, but it must ALSO be enabled if
     * Interrupts.WINDBGRM.ENABLED is true, because if the latter decides to respond to requests,
     * then we must start responding, too.  Windows assumes that if INT 0x68 support is present,
     * then INT 0x41 support must be present as well.
     *
     * That is why intWindowsDebuggerRM() will also set this.fWinDbg to true: we MUST return false
     * for all INT 0x41 requests, so that all requests are consumed, since there's no guarantee
     * that a valid INT 0x41 handler will exist inside the machine.
     *
     * @this {Debuggerx86}
     * @param {number} addr
     * @returns {boolean} (true to proceed with the INT 0x41 software interrupt, false to skip)
     */
    intWindowsDebugger(addr)
    {
        let dbgAddr;
        let cpu = this.cpu;
        let AX = cpu.regEAX & 0xffff;
        let BX = cpu.regEBX & 0xffff;
        let CX = cpu.regECX & 0xffff;
        let DX = cpu.regEDX & 0xffff;
        let SI = cpu.regESI & 0xffff;
        let DI = cpu.regEDI & 0xffff;
        let ES = cpu.segES.sel;

        if (this.fWinDbg == null) {
            if (AX == Interrupts.WINDBG.IS_LOADED) {
                /**
                 * We're only going to respond to this function if no one else did, in which case,
                 * we'll set fWinDbg to true and handle additional notifications.
                 */
                cpu.addIntReturn(addr, function(dbg) {
                    return function onInt41Return(nLevel) {
                        if ((cpu.regEAX & 0xffff) != Interrupts.WINDBG.LOADED) {
                            cpu.regEAX = (cpu.regEAX & ~0xffff) | Interrupts.WINDBG.LOADED;
                            /**
                             * TODO: We need a DEBUGGER message category; using the MEM category for now.
                             */
                            dbg.printf(MESSAGE.DEBUG, "INT 41 handling enabled\n");
                            dbg.fWinDbg = true;
                        } else {
                            dbg.printf(MESSAGE.DEBUG, "INT 41 monitoring enabled\n");
                            dbg.fWinDbg = false;
                        }
                    };
                }(this));
            }
            return true;
        }

        /**
         * NOTE: If this.fWinDbg is true, then all cases should return false, because we're taking full
         * responsibility for all requests (don't assume there's valid interrupt handler inside the machine).
         */
        switch(AX) {
        case Interrupts.WINDBG.ISCHAR:              // 0x0003 (called regularly by Win31)
            break;

        case Interrupts.WINDBG.FORCEDGO16:          // 0x0040 (called regularly by Win31)
            /**
             * 2023 Update: It's been a while since I've tried doing a clean install of Windows 95, and this was
             * firing incessantly.  TODO: Investigate who/what is triggering this later.
             */
            break;

        case Interrupts.WINDBG.IS_LOADED:           // 0x004F
            if (this.fWinDbg) {
                cpu.regEAX = (cpu.regEAX & ~0xffff) | Interrupts.WINDBG.LOADED;
                this.printf(MESSAGE.DEBUG, "INT 41 handling enabled\n");
            }
            break;

        case Interrupts.WINDBG.LOADSEG:             // 0x0050
            this.addSegmentInfo(this.newAddr(DI, ES), BX+1, CX, !(SI & 0x1), this.fWinDbg);
            break;

        case Interrupts.WINDBG.FREESEG:             // 0x0052
            this.removeSegmentInfo(BX, this.fWinDbg);
            break;

        case Interrupts.WINDBG.KRNLVARS:            // 0x005A
            /**
             *  BX = version number of this data (0x3A0)
             *  DX:CX points to:
             *      WORD    hGlobalHeap     ****
             *      WORD    pGlobalHeap     ****
             *      WORD    hExeHead        ****
             *      WORD    hExeSweep
             *      WORD    topPDB
             *      WORD    headPDB
             *      WORD    topsizePDB
             *      WORD    headTDB         ****
             *      WORD    curTDB          ****
             *      WORD    loadTDB
             *      WORD    LockTDB
             *      WORD    SelTableLen     ****
             *      DWORD   SelTableStart   ****
             */
            break;

        case Interrupts.WINDBG.RELSEG:              // 0x005C
        case Interrupts.WINDBG.EXITCALL:            // 0x0062
        case Interrupts.WINDBG.LOADDLL:             // 0x0064
        case Interrupts.WINDBG.DELMODULE:           // 0x0065
        case Interrupts.WINDBG.UNKNOWN66:           // 0x0066
        case Interrupts.WINDBG.UNKNOWN67:           // 0x0067
            /**
             * TODO: Figure out what to do with these notifications, if anything
             */
            break;

        case Interrupts.WINDBG.LOADHIGH:            // 0x005D
        case Interrupts.WINDBG.REGDOTCMD:           // 0x0070
        case Interrupts.WINDBG.CONDBP:              // 0xF001
            break;

        case Interrupts.WINDBG.CHECKFAULT:          // 0x007F
            if (this.fWinDbg) {
                /**
                 * AX == 0 means handle fault normally, 1 means issue TRAPFAULT
                 */
                cpu.regEAX = (cpu.regEAX & ~0xffff) | (this.fIgnoreNextCheckFault? 0 : 1);
                this.printf(MESSAGE.DEBUG, "INT 41 CHECKFAULT: fault=%04X type=%04X trap=%b\n", BX, CX, !this.fIgnoreNextCheckFault);
            }
            break;

        case Interrupts.WINDBG.TRAPFAULT:           // 0x0083
            /**
             * If we responded with AX == 1 to a preceding CHECKFAULT notification, then we should receive the
             * following TRAPFAULT notification; additionally, a TRAPFAULT notification may be issued without
             * any CHECKFAULT warning if the user was presented with a fault dialog containing a "Debug" button,
             * and the user clicked it.
             *
             * Regardless, whenever we receive this notification, we allocate a temporary breakpoint at the
             * reported fault address.
             */
            if (this.fWinDbg) {
                dbgAddr = this.newAddr(cpu.regEDX, CX);
                if (!this.cTrapFaults++) {
                    this.printf("INT 41 TRAPFAULT: fault=%04X error=%08X addr=%s\n", BX, cpu.regESI, this.toHexAddr(dbgAddr));
                    this.addBreakpoint(this.aBreakExec, dbgAddr, true);
                    this.historyInit(true);         // temporary breakpoints don't normally trigger history, but in this case, we want it to
                } else {
                    this.printf("TRAPFAULT failed\n");
                    this.findBreakpoint(this.aBreakExec, dbgAddr, true, true, true);
                    this.cTrapFaults = 0;
                    this.stopCPU();
                }
            }
            break;

        case Interrupts.WINDBG.GETSYMBOL:           // 0x008D
            if (this.fWinDbg) cpu.regEAX = (cpu.regEAX & ~0xffff)|1;        // AX == 1 means not found
            break;

        case Interrupts.WINDBG.LOADSEG32:           // 0x0150
            /**
             *  SI == segment type:
             *      0x0     code selector
             *      0x1     data selector
             *  DX:EBX -> D386_Device_Params structure (see addSectionInfo() for details)
             */
            this.addSectionInfo(this.newAddr(cpu.regEBX, DX), !SI, this.fWinDbg);
            break;

        case Interrupts.WINDBG.FREESEG32:           // 0x0152
            /**
             *  BX == segment number
             *  DX:EDI -> module name
             */
            this.removeSectionInfo(BX, this.newAddr(cpu.regEDI, DX), this.fWinDbg);
            break;

        case Interrupts.WINDBG.FORCEDBP:            // 0xF002
            break;

        default:
            if (this.fWinDbg) {
                this.printf(MESSAGE.DEBUG, "INT 41: AX=%04X (unhandled)\n", AX);
            }
            break;
        }

        /**
         * Let's try to limit the scope of any "gt" command by resetting this flag after any INT 0x41
         */
        this.fIgnoreNextCheckFault = false;

        return !this.fWinDbg;
    }

    /**
     * intWindowsDebuggerRM()
     *
     * This intercepts calls to the Windows Debugger real-mode interface (INT 0x68).
     *
     * @this {Debuggerx86}
     * @param {number} addr
     * @returns {boolean} (true to proceed with the INT 0x68 software interrupt, false to skip)
     */
    intWindowsDebuggerRM(addr)
    {
        let cpu = this.cpu;
        let AL = cpu.regEAX & 0xff;
        let AH = (cpu.regEAX >> 8) & 0xff;
        let BX = cpu.regEBX & 0xffff;
        let CX = cpu.regECX & 0xffff;
        let DX = cpu.regEDX & 0xffff;
        let DI = cpu.regEDI & 0xffff;
        let ES = cpu.segES.sel;

        if (this.fWinDbgRM == null) {
            if (AH == Interrupts.WINDBGRM.IS_LOADED) {
                /**
                 * It looks like IFSHLP.SYS issues a preliminary INT 0x68 before Windows 95 gets rolling,
                 * and the Windows Debugger will not have had a chance to load yet, so we need to ignore
                 * that call.  We detect IFSHLP.SYS by looking for "IFS$" in the caller's code segment,
                 * where the IFSHLP device driver header is located.
                 */
                if (cpu.getLong((cpu.segCS.sel << 4) + 0x0A) == 0x24534649) {
                    this.printf(MESSAGE.DEBUG, "ignoring INT 68 from IFSHLP.SYS\n");
                    return true;
                }
                /**
                 * Ditto for WDEB386 itself, which presumably wants to avoid loading on top of itself.
                 * The offset of the "WDEB" signature is at 0x82 in the Windows 3.1 version (3.10.46 1/16/92),
                 * and at 0x5F in the Windows 95 version.
                 */
                if (cpu.getLong((cpu.segCS.sel << 4) + 0x82) == 0x42454457 ||
                    cpu.getLong((cpu.segCS.sel << 4) + 0x5F) == 0x42454457) {
                    this.printf(MESSAGE.DEBUG, "ignoring INT 68 from WDEB386.EXE\n");
                    return true;
                }
                /**
                 * We're only going to respond to this function if no one else did, in which case, we'll set
                 * fWinDbgRM to true and handle additional notifications.
                 */
                cpu.addIntReturn(addr, function(dbg) {
                    return function onInt68Return(nLevel) {
                        if ((cpu.regEAX & 0xffff) != Interrupts.WINDBGRM.LOADED) {
                            cpu.regEAX = (cpu.regEAX & ~0xffff) | Interrupts.WINDBGRM.LOADED;
                            dbg.printf(MESSAGE.DEBUG, "INT 68 handling enabled\n");
                            /**
                             * If we turn on INT 0x68 handling, we must also turn on INT 0x41 handling,
                             * because Windows assumes that the latter handler exists whenever the former does.
                             */
                            dbg.fWinDbg = dbg.fWinDbgRM = true;
                        } else {
                            dbg.printf(MESSAGE.DEBUG, "INT 68 monitoring enabled\n");
                            dbg.fWinDbgRM = false;
                        }
                    };
                }(this));
            }
            return true;
        }

        /**
         * NOTE: If this.fWinDbgRM is true, then all cases should return false, because we're taking full
         * responsibility for all requests (don't assume there's valid interrupt handler inside the machine).
         */
        switch(AH) {
        case Interrupts.WINDBGRM.IS_LOADED:         // 0x43
            if (this.fWinDbgRM) {
                cpu.regEAX = (cpu.regEAX & ~0xffff) | Interrupts.WINDBGRM.LOADED;
            }
            break;

        case Interrupts.WINDBGRM.PREP_PMODE:        // 0x44
            if (this.fWinDbgRM) {
                /**
                 * Use our fancy new "call break" mechanism to obtain a special address that will
                 * trap all calls, routing control to the specified function (callWindowsDebuggerPMInit).
                 */
                let a = cpu.segCS.addCallBreak(this.callWindowsDebuggerPMInit.bind(this));
                if (a) {
                    cpu.regEDI = a[0];              // ES:EDI receives the "call break" address
                    cpu.setES(a[1]);
                }
            }
            break;

        case Interrupts.WINDBGRM.FREESEG:           // 0x48
            this.removeSegmentInfo(BX, this.fWinDbg);
            break;

        case Interrupts.WINDBGRM.REMOVESEGS:        // 0x4F
            /**
             * TODO: This probably just signals the end of module loading; nothing is required, but we should
             * clean up whatever we can....
             */
            break;

        case Interrupts.WINDBGRM.LOADSEG:           // 0x50
            if (AL == 0x20) {
                /**
                 *  Real-mode EXE
                 *  CX == paragraph
                 *  ES:DI -> module name
                 */
                this.addSegmentInfo(this.newAddr(DI, ES), 0, CX, true, this.fWinDbgRM);
            }
            else if (AL < 0x80) {
                /**
                 *  AL == segment type:
                 *      0x00    code selector
                 *      0x01    data selector
                 *      0x10    code segment
                 *      0x11    data segment
                 *      0x40    code segment & sel
                 *      0x41    data segment & sel
                 *  BX == segment #
                 *  CX == actual segment/selector
                 *  DX == actual selector (if 0x40 or 0x41)
                 *  ES:DI -> module name
                 */
                this.addSegmentInfo(this.newAddr(DI, ES), BX+1, (AL & 0x40)? DX : CX, !(AL & 0x1), this.fWinDbgRM);
            }
            else {
                /**
                 *  AL == segment type:
                 *      0x80    device driver code seg
                 *      0x81    device driver data seg
                 *  ES:DI -> D386_Device_Params structure (see addSectionInfo() for details)
                 */
                this.addSectionInfo(this.newAddr(DI, ES), !(AL & 0x1), this.fWinDbgRM);
            }
            if (this.fWinDbgRM) {
                cpu.regEAX = (cpu.regEAX & ~0xff) | 0x01;
            }
            break;

        default:
            if (this.fWinDbgRM) {
                this.printf(MESSAGE.DEBUG, "INT 68: AH=%02X (unhandled)\n", AH);
            }
            break;
        }

        return !this.fWinDbgRM;
    }

    /**
     * callWindowsDebuggerPMInit()
     *
     * This intercepts calls to the Windows Debugger "PMInit" interface; eg:
     *
     *      AL = function code
     *
     *          0 - initialize IDT
     *              ES:EDI points to protected mode IDT
     *
     *          1 - initialize page checking
     *              BX = physical selector
     *              ECX = linear bias
     *
     *          2 - specify that debug queries are supported
     *
     *          3 - initialize spare PTE
     *              EBX = linear address of spare PTE
     *              EDX = linear address the PTE represents
     *
     *          4 - set Enter/Exit VMM routine address
     *              EBX = Enter VMM routine address
     *              ECX = Exit VMM routine address
     *              EDX = $_Debug_Out_Service address
     *              ESI = $_Trace_Out_Service address
     *              The VMM enter/exit routines must return with a retfd
     *
     *          5 - get debugger size/physical address
     *              returns: AL = 0 (don't call AL = 1)
     *              ECX = size in bytes
     *              ESI = starting physical code/data address
     *
     *          6 - set debugger base/initialize spare PTE
     *              EBX = linear address of spare PTE
     *              EDX = linear address the PTE represents
     *              ESI = starting linear address of debug code/data
     *
     *          7 - enable memory context functions
     *
     * @this {Debuggerx86}
     * @returns {boolean} (must always return false to skip the call, because the call is using a CALLBREAK address)
     */
    callWindowsDebuggerPMInit()
    {
        let cpu = this.cpu;
        let AL = cpu.regEAX & 0xff;
        if (MAXDEBUG) this.printf("INT 68 callback: AL=%02X\n", AL);
        if (AL == 5) {
            cpu.regECX = cpu.regESI = 0;                // our in-machine debugger footprint is zero
            cpu.regEAX = (cpu.regEAX & ~0xff) | 0x01;   // TODO: Returning a "don't call" response sounds good, but what does it REALLY mean?
        }
        return false;
    }

    /**
     * setBinding(sHTMLType, sBinding, control, sValue)
     *
     * @this {Debuggerx86}
     * @param {string} sHTMLType is the type of the HTML control (eg, "button", "list", "text", "submit", "textarea", "canvas")
     * @param {string} sBinding is the value of the 'binding' parameter stored in the HTML control's "data-value" attribute (eg, "debugInput")
     * @param {HTMLElement} control is the HTML control DOM object (eg, HTMLButtonElement)
     * @param {string} [sValue] optional data value
     * @returns {boolean} (true if binding was successful, false if unrecognized binding request)
     */
    setBinding(sHTMLType, sBinding, control, sValue)
    {
        let dbg = this;
        switch (sBinding) {

        case "debugInput":
            this.bindings[sBinding] = control;
            this.controlDebug = /** @type {HTMLInputElement} */ (control);
            /**
             * For halted machines, this is fine, but for auto-start machines, it can be annoying.
             *
             *      controlInput.focus();
             */
            control.onkeydown = function onKeyDownDebugInput(event) {
                let sLine;
                if (event.keyCode == Keys.KEYCODE.CR) {
                    sLine = dbg.controlDebug.value;
                    dbg.controlDebug.value = "";
                    dbg.doCommands(sLine, true);
                }
                else if (event.keyCode == Keys.KEYCODE.ESC) {
                    dbg.controlDebug.value = sLine = "";
                }
                else {
                    if (event.keyCode == Keys.KEYCODE.UP) {
                        sLine = dbg.getPrevCommand();
                    }
                    else if (event.keyCode == Keys.KEYCODE.DOWN) {
                        sLine = dbg.getNextCommand();
                    }
                    if (sLine != null) {
                        let cch = sLine.length;
                        dbg.controlDebug.value = sLine;
                        dbg.controlDebug.setSelectionRange(cch, cch);
                    }
                }
                if (sLine != null && event.preventDefault) event.preventDefault();
            };
            return true;

        case "debugEnter":
            this.bindings[sBinding] = control;
            WebLib.onClickRepeat(
                control,
                500, 100,
                function onClickDebugEnter(fRepeat) {
                    if (dbg.controlDebug) {
                        let sCommands = dbg.controlDebug.value;
                        dbg.controlDebug.value = "";
                        dbg.doCommands(sCommands, true);
                        return true;
                    }
                    if (DEBUG) dbg.printf(MESSAGE.LOG, "no debugger input buffer\n");
                    return false;
                }
            );
            return true;

        case "step":
            this.bindings[sBinding] = control;
            WebLib.onClickRepeat(
                control,
                500, 100,
                function onClickStep(fRepeat) {
                    let fCompleted = false;
                    if (!dbg.isBusy(true)) {
                        dbg.setBusy(true);
                        fCompleted = dbg.stepCPU(fRepeat? 1 : 0);
                        dbg.setBusy(false);
                    }
                    return fCompleted;
                }
            );
            return true;

        default:
            break;
        }
        return false;
    }

    /**
     * updateFocus()
     *
     * @this {Debuggerx86}
     */
    updateFocus()
    {
        if (this.controlDebug) this.controlDebug.focus();
    }

    /**
     * getCPUMode()
     *
     * @this {Debuggerx86}
     * @returns {boolean} (true if protected mode, false if not)
     */
    getCPUMode()
    {
        return !!(this.cpu && (this.cpu.regCR0 & X86.CR0.MSW.PE) && !(this.cpu.regPS & X86.PS.VM));
    }

    /**
     * getAddressType()
     *
     * @this {Debuggerx86}
     * @returns {number}
     */
    getAddressType()
    {
        return this.getCPUMode()? Debuggerx86.ADDRTYPE.PROT : Debuggerx86.ADDRTYPE.REAL;
    }

    /**
     * getSegment(sel, type)
     *
     * If the selector matches that of any of the CPU segment registers, then return the CPU's segment
     * register, instead of using our own segDebugger segment register.  This makes it possible for us to
     * see what the CPU is seeing at certain critical junctures, such as after an LMSW instruction has
     * switched the processor from real to protected mode.  Actually loading the selector from the GDT/LDT
     * should be done only as a last resort.
     *
     * @this {Debuggerx86}
     * @param {number|undefined} sel
     * @param {number} [type] (defaults to getAddressType())
     * @returns {Segx86|null} (seg)
     */
    getSegment(sel, type)
    {
        let typeDefault = this.getAddressType();

        if (!type) type = typeDefault;

        if (type == typeDefault) {
            if (sel === this.cpu.getCS()) return this.cpu.segCS;
            if (sel === this.cpu.getDS()) return this.cpu.segDS;
            if (sel === this.cpu.getES()) return this.cpu.segES;
            if (sel === this.cpu.getSS()) return this.cpu.segSS;
            if (I386 && this.cpu.model >= X86.MODEL_80386) {
                if (sel === this.cpu.getFS()) return this.cpu.segFS;
                if (sel === this.cpu.getGS()) return this.cpu.segGS;
            }
            /**
             * Even if nSuppressBreaks is set, we'll allow the call in real-mode,
             * because a loadReal() request using segDebugger should generally be safe.
             */
            if (this.nSuppressBreaks && type == Debuggerx86.ADDRTYPE.PROT || !this.segDebugger) return null;
        }
        let seg = this.segDebugger;
        if (type != Debuggerx86.ADDRTYPE.PROT) {
            seg.loadReal(sel);
            seg.limit = 0xffff;         // although an ACTUAL real-mode segment load would not modify the limit,
            seg.offMax = 0x10000;       // proper segDebugger operation requires that we update the limit ourselves
        } else {
            seg.probeDesc(sel);
        }
        return seg;
    }

    /**
     * getAddr(dbgAddr, fWrite, nb)
     *
     * @this {Debuggerx86}
     * @param {DbgAddrx86|undefined} dbgAddr
     * @param {boolean} [fWrite]
     * @param {number} [nb] number of bytes to check (1, 2 or 4); default is 1
     * @returns {number} (is the corresponding linear address, or X86.ADDR_INVALID)
     */
    getAddr(dbgAddr, fWrite, nb)
    {
        /**
         * Some addresses (eg, breakpoint addresses) save their original linear address in dbgAddr.addr,
         * so we want to use that if it's there, but otherwise, dbgAddr is assumed to be a segmented address
         * whose linear address must always be (re)calculated based on current machine state (mode, active
         * descriptor tables, etc).
         */
        let addr = dbgAddr && dbgAddr.addr;
        if (addr == undefined) {
            addr = X86.ADDR_INVALID;
            if (dbgAddr) {
                /**
                 * TODO: We should try to cache the seg inside dbgAddr, to avoid unnecessary calls to getSegment().
                 */
                let seg = this.getSegment(dbgAddr.sel, dbgAddr.type);
                if (seg) {
                    if (!fWrite) {
                        addr = seg.checkReadDebugger(dbgAddr.off || 0, nb || 1);
                    } else {
                        addr = seg.checkWriteDebugger(dbgAddr.off || 0, nb || 1);
                    }
                    dbgAddr.addr = addr;
                }
            }
        }
        return addr;
    }

    /**
     * getByte(dbgAddr, inc)
     *
     * We must route all our memory requests through the CPU now, in case paging is enabled.
     *
     * @this {Debuggerx86}
     * @param {DbgAddrx86} dbgAddr
     * @param {number} [inc]
     * @returns {number}
     */
    getByte(dbgAddr, inc)
    {
        let b = 0xff;
        let addr = this.getAddr(dbgAddr, false, 1);
        if (addr !== X86.ADDR_INVALID) {
            /**
             * TODO: Determine what we should do about the fact that we're masking any error from probeAddr()
             */
            b = this.cpu.probeAddr(addr, 1, dbgAddr.type == Debuggerx86.ADDRTYPE.PHYSICAL) | 0;
            if (inc) this.incAddr(dbgAddr, inc);
        }
        return b;
    }

    /**
     * getWord(dbgAddr, fAdvance)
     *
     * @this {Debuggerx86}
     * @param {DbgAddrx86} dbgAddr
     * @param {boolean} [fAdvance]
     * @returns {number}
     */
    getWord(dbgAddr, fAdvance)
    {
        return dbgAddr.fData32? this.getLong(dbgAddr, fAdvance? 4 : 0) : this.getShort(dbgAddr, fAdvance? 2 : 0);
    }

    /**
     * getShort(dbgAddr, inc)
     *
     * @this {Debuggerx86}
     * @param {DbgAddrx86} dbgAddr
     * @param {number} [inc]
     * @returns {number}
     */
    getShort(dbgAddr, inc)
    {
        let w = 0xffff;
        let addr = this.getAddr(dbgAddr, false, 2);
        if (addr !== X86.ADDR_INVALID) {
            /**
             * TODO: Determine what we should do about the fact that we're masking any error from probeAddr()
             */
            w = this.cpu.probeAddr(addr, 2, dbgAddr.type == Debuggerx86.ADDRTYPE.PHYSICAL) | 0;
            if (inc) this.incAddr(dbgAddr, inc);
        }
        return w;
    }

    /**
     * getLong(dbgAddr, inc)
     *
     * @this {Debuggerx86}
     * @param {DbgAddrx86} dbgAddr
     * @param {number} [inc]
     * @returns {number}
     */
    getLong(dbgAddr, inc)
    {
        let l = -1;
        let addr = this.getAddr(dbgAddr, false, 4);
        if (addr !== X86.ADDR_INVALID) {
            /**
             * TODO: Determine what we should do about the fact that we're masking any error from probeAddr()
             */
            l = this.cpu.probeAddr(addr, 4, dbgAddr.type == Debuggerx86.ADDRTYPE.PHYSICAL) | 0;
            if (inc) this.incAddr(dbgAddr, inc);
        }
        return l;
    }

    /**
     * setByte(dbgAddr, b, inc, fNoUpdate)
     *
     * NOTE: If you need to patch a ROM, you MUST use the ROM location's physical address.
     *
     * WARNING: Be careful with the editing commands that use function, because we don't have a safe
     * counterpart to cpu.probeAddr().
     *
     * @this {Debuggerx86}
     * @param {DbgAddrx86} dbgAddr
     * @param {number} b
     * @param {number} [inc]
     * @param {boolean} [fNoUpdate] (when doing a large number of setByte() calls, set this to true and call cpu.updateCPU() when you're done)
     */
    setByte(dbgAddr, b, inc, fNoUpdate)
    {
        let addr = this.getAddr(dbgAddr, true, 1);
        if (addr !== X86.ADDR_INVALID) {
            if (dbgAddr.type != Debuggerx86.ADDRTYPE.PHYSICAL) {
                this.cpu.setByte(addr, b);
            } else {
                this.bus.setByteDirect(addr, b);
            }
            if (inc) this.incAddr(dbgAddr, inc);
            if (!fNoUpdate) this.cpu.updateCPU(true);   // we set fForce to true in case video memory was the target
        }
    }

    /**
     * setShort(dbgAddr, w, inc, fFast)
     *
     * NOTE: If you need to patch a ROM, you MUST use the ROM location's physical address.
     *
     * WARNING: Be careful with the editing commands that use function, because we don't have a safe
     * counterpart to cpu.probeAddr().
     *
     * @this {Debuggerx86}
     * @param {DbgAddrx86} dbgAddr
     * @param {number} w
     * @param {number} [inc]
     * @param {boolean} [fFast]
     */
    setShort(dbgAddr, w, inc, fFast)
    {
        let addr = this.getAddr(dbgAddr, true, 2);
        if (addr !== X86.ADDR_INVALID) {
            if (dbgAddr.type != Debuggerx86.ADDRTYPE.PHYSICAL) {
                this.cpu.setShort(addr, w);
            } else {
                this.bus.setShortDirect(addr, w);
            }
            if (inc) this.incAddr(dbgAddr, inc);
            if (!fFast) this.cpu.updateCPU(true);       // we set fForce to true in case video memory was the target
        }
    }

    /**
     * newAddr(off, sel, addr, type, fData32, fAddr32)
     *
     * Returns a NEW DbgAddrx86 object, initialized with specified values and/or defaults.
     *
     * @this {Debuggerx86}
     * @param {number} [off] (default is zero)
     * @param {number} [sel] (default is undefined)
     * @param {number} [addr] (default is undefined)
     * @param {number} [type] (default is based on current CPU mode)
     * @param {boolean} [fData32] (default is the current CPU operand size)
     * @param {boolean} [fAddr32] (default is the current CPU address size)
     * @returns {DbgAddrx86}
     */
    newAddr(off, sel, addr, type, fData32, fAddr32)
    {
        return this.setAddr({}, off, sel, addr, type, fData32, fAddr32);
    }

    /**
     * getAddrPrefix(dbgAddr)
     *
     * @this {Debuggerx86}
     * @param {DbgAddrx86} dbgAddr
     * @returns {string}
     */
    getAddrPrefix(dbgAddr)
    {
        let ch;

        switch (dbgAddr.type) {
        case Debuggerx86.ADDRTYPE.REAL:
        case Debuggerx86.ADDRTYPE.V86:
            ch = '&';
            break;
        case Debuggerx86.ADDRTYPE.PROT:
            ch = '#';
            break;
        case Debuggerx86.ADDRTYPE.LINEAR:
            ch = '%';
            break;
        case Debuggerx86.ADDRTYPE.PHYSICAL:
            ch = '%%';
            break;
        default:
            ch = dbgAddr.sel? '' : '%';
            break;
        }
        return ch;
    }

    /**
     * setAddr(dbgAddr, off, sel, addr, type, fData32, fAddr32)
     *
     * Updates an EXISTING DbgAddrx86 object, initialized with specified values and/or defaults.
     *
     * @this {Debuggerx86}
     * @param {DbgAddrx86} dbgAddr
     * @param {number} [off] (default is zero)
     * @param {number} [sel] (default is undefined)
     * @param {number} [addr] (default is undefined)
     * @param {number} [type] (default is based on current CPU mode)
     * @param {boolean} [fData32] (default is the current CPU operand size)
     * @param {boolean} [fAddr32] (default is the current CPU address size)
     * @returns {DbgAddrx86}
     */
    setAddr(dbgAddr, off, sel, addr, type, fData32, fAddr32)
    {
        dbgAddr.off = off || 0;
        dbgAddr.sel = sel;
        dbgAddr.addr = addr;
        dbgAddr.type = type || this.getAddressType();
        dbgAddr.fData32 = (fData32 != undefined)? fData32 : !!(this.cpu && this.cpu.segCS.sizeData == 4);
        dbgAddr.fAddr32 = (fAddr32 != undefined)? fAddr32 : !!(this.cpu && this.cpu.segCS.sizeAddr == 4);
        dbgAddr.fTempBreak = false;
        return dbgAddr;
    }

    /**
     * packAddr(dbgAddr)
     *
     * Packs a DbgAddrx86 object into an Array suitable for saving in a machine state object.
     *
     * NOTE: Element 6 was previously used to maintain an override count; that's no longer needed, hence the 0.
     *
     * @this {Debuggerx86}
     * @param {DbgAddrx86} dbgAddr
     * @returns {Array}
     */
    packAddr(dbgAddr)
    {
        return [dbgAddr.off, dbgAddr.sel, dbgAddr.addr, dbgAddr.fTempBreak, dbgAddr.fData32, dbgAddr.fAddr32, 0];
    }

    /**
     * unpackAddr(aAddr)
     *
     * Unpacks a DbgAddrx86 object from an Array created by packAddr() and restored from a saved machine state.
     *
     * @this {Debuggerx86}
     * @param {Array} aAddr
     * @returns {DbgAddrx86}
     */
    unpackAddr(aAddr)
    {
        return {off: aAddr[0], sel: aAddr[1], addr: aAddr[2], fTempBreak: aAddr[3], fData32: aAddr[4], fAddr32: aAddr[5]};
    }

    /**
     * checkLimit(dbgAddr, fUpdate)
     *
     * Used by incAddr() and parseAddr() to ensure that the (updated) dbgAddr offset is within segment bounds.
     *
     * @this {Debuggerx86}
     * @param {DbgAddrx86} dbgAddr
     * @param {boolean} [fUpdate] (true to update segment info)
     * @returns {boolean}
     */
    checkLimit(dbgAddr, fUpdate)
    {
        if (dbgAddr.sel != undefined) {
            let seg = this.getSegment(dbgAddr.sel, dbgAddr.type);
            if (seg) {
                let off = dbgAddr.off;
                if (!seg.fExpDown) {
                    if ((off >>> 0) >= seg.offMax) {
                        return false;
                    }
                }
                else {
                    if ((off >>> 0) < seg.offMax) {
                        return false;
                    }
                }
                if (fUpdate) {
                    dbgAddr.off = off & seg.maskAddr;
                    dbgAddr.fData32 = (seg.sizeData == 4);
                    dbgAddr.fAddr32 = (seg.sizeAddr == 4);
                }
            }
        }
        return true;
    }

    /**
     * parseAddr(sAddr, fCode, fNoChecks, fQuiet)
     *
     * As discussed above, dbgAddr variables contain one or more of: off, sel, and addr.  They represent
     * a segmented address (sel:off) when sel is defined or a linear address (addr) when sel is undefined.
     *
     * To create a segmented address, specify two values separated by ':'; for a linear address, use
     * a '%' prefix.  We check for ':' after '%', so if for some strange reason you specify both, the
     * address will be treated as segmented, not linear.
     *
     * The '%' syntax is similar to that used by the Windows 80386 kernel debugger (wdeb386) for linear
     * addresses.  If/when we add support for processors with page tables, we will likely adopt the same
     * convention for linear addresses and provide a different syntax (eg, "%%") physical memory references.
     *
     * Address evaluation and validation (eg, range checks) are no longer performed at this stage.  That's
     * done later, by getAddr(), which returns X86.ADDR_INVALID for invalid segments, out-of-range offsets,
     * etc.  The Debugger's low-level get/set memory functions verify all getAddr() results, but even if an
     * invalid address is passed through to the Bus memory interfaces, the address will simply be masked with
     * Bus.nBusLimit; in the case of X86.ADDR_INVALID, that will generally refer to the top of the physical
     * address space.
     *
     * @this {Debuggerx86}
     * @param {string|undefined} sAddr
     * @param {boolean} [fCode] (true if target is code, false if target is data)
     * @param {boolean} [fNoChecks] (true when setting breakpoints that may not be valid now, but will be later)
     * @param {boolean} [fQuiet]
     * @returns {DbgAddrx86|undefined}
     */
    parseAddr(sAddr, fCode, fNoChecks, fQuiet)
    {
        let dbgAddr;
        let dbgAddrNext = (fCode? this.dbgAddrNextCode : this.dbgAddrNextData);

        let type = fNoChecks? Debuggerx86.ADDRTYPE.NONE : dbgAddrNext.type;
        let off = dbgAddrNext.off, sel = dbgAddrNext.sel, addr = dbgAddrNext.addr;

        if (sAddr !== undefined) {

            sAddr = this.parseReference(sAddr);

            let ch = sAddr.charAt(0);
            let iColon = sAddr.indexOf(':');

            switch(ch) {
            case '&':
                type = Debuggerx86.ADDRTYPE.REAL;
                break;
            case '#':
                type = Debuggerx86.ADDRTYPE.PROT;
                break;
            case '%':
                type = Debuggerx86.ADDRTYPE.LINEAR;
                ch = sAddr.charAt(1);
                if (ch == '%') {
                    type = Debuggerx86.ADDRTYPE.PHYSICAL;
                    ch += ch;
                }
                off = addr = 0;
                sel = undefined;        // we still have code that relies on this crutch, instead of the type field
                break;
            default:
                if (iColon >= 0) type = Debuggerx86.ADDRTYPE.NONE;
                ch = '';
                break;
            }

            if (ch) {
                sAddr = sAddr.substr(ch.length);
                iColon -= ch.length;
            }

            dbgAddr = this.findSymbolAddr(sAddr);
            if (dbgAddr) return dbgAddr;

            if (iColon < 0) {
                if (sel != undefined) {
                    off = this.parseExpression(sAddr, fQuiet);
                    addr = undefined;
                } else {
                    addr = this.parseExpression(sAddr, fQuiet);
                    if (addr == undefined) off = undefined;
                }
            }
            else {
                sel = this.parseExpression(sAddr.substring(0, iColon), fQuiet);
                off = this.parseExpression(sAddr.substring(iColon + 1), fQuiet);
                addr = undefined;
            }
        }

        if (off != undefined) {
            dbgAddr = this.newAddr(off, sel, addr, type);
            if (!fNoChecks && !this.checkLimit(dbgAddr, true)) {
                this.printf("invalid offset: %s\n", this.toHexAddr(dbgAddr));
                dbgAddr = undefined;
            }
        }
        return dbgAddr;
    }

    /**
     * parseAddrOptions(dbgAddr, sLine)
     *
     * @this {Debuggerx86}
     * @param {DbgAddrx86} dbgAddr
     * @param {string} [sLine]
     */
    parseAddrOptions(dbgAddr, sLine)
    {
        if (sLine) {
            let a = sLine.match(/(['"])(.*?)\1/);
            if (a) {
                dbgAddr.aCmds = this.parseCommand(dbgAddr.sLine = a[2]);
            }
        }
    }

    /**
     * parseAddrReference(s, sAddr)
     *
     * Returns the given string with the given address references replaced with the contents of the address.
     *
     * @this {Debuggerx86}
     * @param {string} s
     * @param {string} sAddr
     * @returns {string}
     */
    parseAddrReference(s, sAddr)
    {
        let dbgAddr = this.parseAddr(sAddr);
        return s.replace('[' + sAddr + ']', dbgAddr? StrLib.toHex(this.getWord(dbgAddr), dbgAddr.fData32? 8 : 4) : "undefined");
    }

    /**
     * incAddr(dbgAddr, inc)
     *
     * @this {Debuggerx86}
     * @param {DbgAddrx86} dbgAddr
     * @param {number} [inc] contains value to increment dbgAddr by (default is 1)
     */
    incAddr(dbgAddr, inc)
    {
        inc = inc || 1;
        if (dbgAddr.addr != undefined) {
            dbgAddr.addr += inc;
        }
        if (dbgAddr.sel != undefined) {
            dbgAddr.off += inc;
            if (!this.checkLimit(dbgAddr)) {
                dbgAddr.off = 0;
                dbgAddr.addr = undefined;
            }
        }
    }

    /**
     * toHexOffset(off, sel, fAddr32)
     *
     * @this {Debuggerx86}
     * @param {number|undefined} [off]
     * @param {number|undefined} [sel]
     * @param {boolean} [fAddr32] is true for 32-bit ADDRESS size
     * @returns {string} (the hex representation of off (or sel:off))
     */
    toHexOffset(off, sel, fAddr32)
    {
        if (sel != undefined) {
            return StrLib.toHex(sel, 4) + ':' + StrLib.toHex(off, (off & ~0xffff) || fAddr32? 8 : 4);
        }
        return StrLib.toHex(off);
    }

    /**
     * toHexAddr(dbgAddr)
     *
     * @this {Debuggerx86}
     * @param {DbgAddrx86} dbgAddr
     * @returns {string} (the hex representation of the address)
     */
    toHexAddr(dbgAddr)
    {
        let ch = this.getAddrPrefix(dbgAddr);
        /**
         * TODO: Revisit the decision to check sel == undefined; I would rather see these decisions based on type.
         */
        return (dbgAddr.type >= Debuggerx86.ADDRTYPE.LINEAR || dbgAddr.sel == undefined)? (ch + StrLib.toHex(dbgAddr.addr)) : (ch + this.toHexOffset(dbgAddr.off, dbgAddr.sel, dbgAddr.fAddr32));
    }

    /**
     * getSZ(dbgAddr, cchMax)
     *
     * Gets zero-terminated (aka "ASCIIZ") string from dbgAddr.  It also stops at the first '$', in case this is
     * a '$'-terminated string -- mainly because I'm lazy and didn't feel like writing a separate get() function.
     * Yes, a zero-terminated string containing a '$' will be prematurely terminated -- not a big deal.
     *
     * @this {Debuggerx86}
     * @param {DbgAddrx86} dbgAddr
     * @param {number} [cchMax] (default is 256)
     * @returns {string} (and dbgAddr advanced past the terminating zero)
     */
    getSZ(dbgAddr, cchMax)
    {
        let s = "";
        cchMax = cchMax || 256;
        while (s.length < cchMax) {
            let b = this.getByte(dbgAddr, 1);
            if (!b || b == 0x24 || b >= 127) break;
            s += (b >= 32? String.fromCharCode(b) : '.');
        }
        return s;
    }

    /**
     * dumpBackTrack(asArgs)
     *
     * @this {Debuggerx86}
     * @param {Array.<string>} asArgs
     */
    dumpBackTrack(asArgs)
    {
        let sInfo = "no information";
        if (BACKTRACK) {
            let sAddr = asArgs[0];
            let dbgAddr = this.parseAddr(sAddr, true, true, true);
            if (dbgAddr) {
                let addr = this.getAddr(dbgAddr);
                if (dbgAddr.type != Debuggerx86.ADDRTYPE.PHYSICAL) {
                    let pageInfo = this.getPageInfo(addr);
                    if (pageInfo) {
                        dbgAddr.addr = pageInfo.addrPhys;
                        dbgAddr.type = Debuggerx86.ADDRTYPE.PHYSICAL;
                    }
                }
                sInfo = this.toHexAddr(dbgAddr) + ": " + (this.bus.getSymbol(addr, true) || sInfo);
            } else {
                let component, componentPrev = null;
                while ((component = this.cmp.getMachineComponent("Disk", componentPrev))) {
                    let aInfo = component.getSymbolInfo(sAddr);
                    if (aInfo.length) {
                        sInfo = "";
                        for (let i in aInfo) {
                            let a = aInfo[i];
                            if (sInfo) sInfo += '\n';
                            sInfo += a[0] + ": " + a[1] + ' ' + StrLib.toHex(a[2], 4) + ':' + StrLib.toHex(a[3], 4) + " len " + StrLib.toHexWord(a[4]);
                        }
                    }
                    componentPrev = component;
                }
            }
        }
        return sInfo;
    }

    /**
     * dumpBlocks(aBlocks, sAddr, fLinear)
     *
     * @this {Debuggerx86}
     * @param {Array} aBlocks
     * @param {string} [sAddr] (optional block address)
     * @param {boolean} [fLinear] (true if linear, physical otherwise)
     */
    dumpBlocks(aBlocks, sAddr, fLinear)
    {
        let addr = 0, i = 0, n = aBlocks.length;

        if (sAddr) {
            addr = this.getAddr(this.parseAddr(sAddr));
            if (addr === X86.ADDR_INVALID) {
                this.printf("invalid address: %s\n\n");
                return;
            }
            i = addr >>> this.cpu.nBlockShift;
            n = 1;
        }

        this.printf("blockid   %s   blockaddr   used    size    type\n", fLinear? "linear  " : "physical");
        this.printf("--------  ---------  ----------  ------  ------  ----\n");

        let typePrev = -1, cPrev = 0;
        while (n--) {
            let block = aBlocks[i];
            /**
             * We need to replicate a portion of what probeAddr() does, which is to "peek" at the
             * underlying physical block of any UNPAGED block.  An UNPAGED block doesn't imply
             * that the page is invalid, but merely that the CPU has not yet been asked to perform
             * the page directory/page table lookup.
             *
             * To do that, we use the same mapPageBlock() interface that the CPU uses, with fSuppress
             * set, so that it doesn't 1) generate a fault or 2) modify the block.  Blocks should only
             * "validated" when a CPU operation touches the corresponding page, and they should be only
             * be "invalidated" when the CPU wants to flush the TLB (ie, whenever CR3 is updated).
             */
            if (block && block.type == Memoryx86.TYPE.UNPAGED) {
                block = this.cpu.mapPageBlock(addr, false, true);
            }
            if (block.type == typePrev) {
                if (!cPrev++) this.printf("...\n");
            } else {
                typePrev = block.type;
                let sType = Memoryx86.TYPE.NAMES[typePrev];
                if (typePrev == Memoryx86.TYPE.PAGED) {
                    block = block.blockPhys;

                    sType += " -> " + Memoryx86.TYPE.NAMES[block.type];
                }
                if (block) {
                    this.printf("%08x  %%%08x  %%%%%08x  %#06x  %#06x  %s\n", block.id, i << this.cpu.nBlockShift, block.addr, block.used, block.size, sType);
                }
                if (typePrev != Memoryx86.TYPE.NONE && typePrev != Memoryx86.TYPE.UNPAGED) typePrev = -1;
                cPrev = 0;
            }
            addr += this.cpu.nBlockSize;
            i++;
        }
    }

    /**
     * dumpBus(asArgs)
     *
     * Dumps Bus allocations.
     *
     * @this {Debuggerx86}
     * @param {Array.<string>} asArgs (asArgs[0] is an optional block address)
     */
    dumpBus(asArgs)
    {
        this.dumpBlocks(this.cpu.aBusBlocks, asArgs[0]);
    }

    /**
     * dumpDOS(asArgs)
     *
     * Dumps DOS MCBs (Memory Control Blocks).
     *
     * TODO: Add some code to detect the current version of DOS (if any) and locate the first MCB automatically.
     *
     * @this {Debuggerx86}
     * @param {Array.<string>} asArgs
     */
    dumpDOS(asArgs)
    {
        let mcb;
        let sMCB = asArgs[0];
        if (sMCB) {
            mcb = this.parseValue(sMCB);
        }
        if (mcb === undefined) {
            this.printf("invalid MCB\n");
            return;
        }
        this.printf("dumpMCB(%#06x)\n", mcb);
        while (mcb) {
            let dbgAddr = this.newAddr(0, mcb);
            let bSig = this.getByte(dbgAddr, 1);
            let wPID = this.getShort(dbgAddr, 2);
            let wParas = this.getShort(dbgAddr, 5);
            if (bSig != 0x4D && bSig != 0x5A) break;
            this.printf("%s: '%s' PID=%#06x LEN=%#06x \"%s\"\n", this.toHexOffset(0, mcb), String.fromCharCode(bSig), wPID, wParas, this.getSZ(dbgAddr, 8));
            mcb += 1 + wParas;
        }
    }

    /**
     * dumpIDT(asArgs)
     *
     * Dumps an IDT vector entry.
     *
     * @this {Debuggerx86}
     * @param {Array.<string>} asArgs
     */
    dumpIDT(asArgs)
    {
        let sIDT = asArgs[0];

        if (!sIDT) {
            this.printf("no IDT vector\n");
            return;
        }

        let nIDT = this.parseValue(sIDT);
        if (nIDT === undefined || nIDT < 0 || nIDT > 255) {
            this.printf("invalid vector: %s\n", sIDT);
            return;
        }

        let ch = '&', fProt = this.cpu.isProtMode(), fAddr32 = false;
        let addrIDT = this.cpu.addrIDT + (nIDT << (fProt? 3 : 2));
        let off = this.cpu.getShort(addrIDT + X86.DESC.LIMIT.OFFSET);
        let sel = this.cpu.getShort(addrIDT + X86.DESC.BASE.OFFSET);
        if (fProt) {
            ch = '#';
            let acc = this.cpu.getShort(addrIDT + X86.DESC.ACC.OFFSET);
            if (acc & X86.DESC.ACC.TYPE.NONSEG_386) {
                fAddr32 = true;
                off |= this.cpu.getShort(addrIDT + X86.DESC.EXT.OFFSET) << 16;
            }
        }

        this.printf("dumpIDT(%#06x): %s%04x:%0*x\n", nIDT, ch, sel, fAddr32? 8 : 4, off);
    }

    /**
     * dumpMem(asArgs)
     *
     * Dumps page allocations.
     *
     * @this {Debuggerx86}
     * @param {Array.<string>} asArgs (asArgs[0] is an optional block address)
     */
    dumpMem(asArgs)
    {
        this.dumpBlocks(this.cpu.aMemBlocks, asArgs[0], this.cpu.aMemBlocks !== this.cpu.aBusBlocks);
    }

    /**
     * getPageEntry(addrPE, lPE, fPTE)
     *
     * @this {Debuggerx86}
     * @param {number} addrPE
     * @param {number} lPE
     * @param {boolean} [fPTE] (true if the entry is a PTE, false if it's a PDE)
     * @returns {string}
     */
    getPageEntry(addrPE, lPE, fPTE)
    {
        let s = StrLib.toHex(addrPE) + ' ' + StrLib.toHex(lPE) + ' ';
        s += (fPTE && (lPE & X86.PTE.DIRTY))? 'D' : '-';
        s += (lPE & X86.PTE.ACCESSED)? 'A' : '-';
        s += (lPE & X86.PTE.USER)? 'U' : 'S';
        s += (lPE & X86.PTE.READWRITE)? 'W' : 'R';
        s += (lPE & X86.PTE.PRESENT)? 'P' : 'N';
        return s;
    }

    /**
     * getPageInfo(addr)
     *
     * @this {Debuggerx86}
     * @param {number} addr
     * @returns {Object|null}
     */
    getPageInfo(addr)
    {
        let pageInfo = null;
        if (I386 && this.cpu.model >= X86.MODEL_80386) {
            let bus = this.bus;
            /**
             * Here begins code remarkably similar to mapPageBlock() (with fSuppress set).
             */
            pageInfo = {};
            pageInfo.offPDE = (addr & X86.LADDR.PDE.MASK) >>> X86.LADDR.PDE.SHIFT;
            pageInfo.addrPDE = this.cpu.regCR3 + pageInfo.offPDE;
            pageInfo.blockPDE = bus.aMemBlocks[(pageInfo.addrPDE & bus.nBusMask) >>> bus.nBlockShift];
            pageInfo.lPDE = pageInfo.blockPDE.readLong(pageInfo.offPDE);
            pageInfo.offPTE = (addr & X86.LADDR.PTE.MASK) >>> X86.LADDR.PTE.SHIFT;
            pageInfo.addrPTE = (pageInfo.lPDE & X86.PTE.FRAME) + pageInfo.offPTE;
            pageInfo.blockPTE = bus.aMemBlocks[(pageInfo.addrPTE & bus.nBusMask) >>> bus.nBlockShift];
            pageInfo.lPTE = pageInfo.blockPTE.readLong(pageInfo.offPTE);
            pageInfo.addrPhys = (pageInfo.lPTE & X86.PTE.FRAME) + (addr & X86.LADDR.OFFSET);
            //let blockPhys = bus.aMemBlocks[(addrPhys & bus.nBusMask) >>> bus.nBlockShift];
        }
        return pageInfo;
    }

    /**
     * dumpPage(asArgs)
     *
     * Dumps page table information about the given linear address.
     *
     * @this {Debuggerx86}
     * @param {Array.<string>} asArgs
     */
    dumpPage(asArgs)
    {
        let sAddr = asArgs[0];
        if (!sAddr) {
            this.printf("missing address\n");
            return;
        }

        let addr = this.getAddr(this.parseAddr(sAddr));
        if (addr === X86.ADDR_INVALID) {
            this.printf("invalid address: %s\n", sAddr);
            return;
        }

        let pageInfo = this.getPageInfo(addr);
        if (!pageInfo) {
            this.printf("unsupported operation\n");
            return;
        }

        this.printf("linear     PDE addr   PDE             PTE addr   PTE             physical\n");
        this.printf("---------  ---------- --------        ---------- --------        ----------\n");
        let s = '%' + StrLib.toHex(addr);
        s += "  %%" + this.getPageEntry(pageInfo.addrPDE, pageInfo.lPDE);
        s += "  %%" + this.getPageEntry(pageInfo.addrPTE, pageInfo.lPTE, true);
        s += "  %%" + StrLib.toHex(pageInfo.addrPhys);
        this.printf("%s\n", s);
    }

    /**
     * dumpSel(asArgs)
     *
     * Dumps a descriptor for the given selector.
     *
     * @this {Debuggerx86}
     * @param {Array.<string>} asArgs
     */
    dumpSel(asArgs)
    {
        let sSel = asArgs[0];

        if (!sSel) {
            this.printf("no selector\n");
            return;
        }

        let sel = this.parseValue(sSel);
        if (sel === undefined) {
            this.printf("invalid selector: %s\n", sSel);
            return;
        }

        let seg = this.getSegment(sel, Debuggerx86.ADDRTYPE.PROT);
        this.printf("dumpSel(%#06x): %%%0*x\n", seg? seg.sel : sel, this.cchAddr, seg? seg.addrDesc : null);
        if (!seg) return;

        let sType;
        let fGate = false;
        if (seg.type & X86.DESC.ACC.TYPE.SEG) {
            if (seg.type & X86.DESC.ACC.TYPE.CODE) {
                sType = "code";
                sType += (seg.type & X86.DESC.ACC.TYPE.READABLE)? ",readable" : ",execonly";
                if (seg.type & X86.DESC.ACC.TYPE.CONFORMING) sType += ",conforming";
            }
            else {
                sType = "data";
                sType += (seg.type & X86.DESC.ACC.TYPE.WRITABLE)? ",writable" : ",readonly";
                if (seg.type & X86.DESC.ACC.TYPE.EXPDOWN) sType += ",expdown";
            }
            if (seg.type & X86.DESC.ACC.TYPE.ACCESSED) sType += ",accessed";
        }
        else {
            let sysDesc = Debuggerx86.SYSDESCS[seg.type];
            if (sysDesc) {
                sType = sysDesc[0];
                fGate = sysDesc[1];
            }
        }

        if (sType && !(seg.acc & X86.DESC.ACC.PRESENT)) sType += ",not present";

        let sDump;
        if (fGate) {
            sDump = "seg=" + StrLib.toHexWord(seg.base & 0xffff) + " off=" + StrLib.toHexWord(seg.limit);
        } else {
            sDump = "base=" + StrLib.toHex(seg.base, this.cchAddr) + " limit=" + this.getLimitString(seg.limit);
        }
        /**
         * When we dump the EXT word, we mask off the LIMIT1619 and BASE2431 bits, because those have already
         * been incorporated into the limit and base properties of the segment register; all we care about here
         * are whether EXT contains any of the AVAIL (0x10), BIG (0x40) or LIMITPAGES (0x80) bits.
         */
        this.printf("%s type=%#04x (%s) ext=%#06x dpl=%#04x\n", sDump, seg.type >> 8, sType, seg.ext & ~(X86.DESC.EXT.LIMIT1619 | X86.DESC.EXT.BASE2431), seg.dpl);
    }

    /**
     * dumpHistory(sPrev, sLines, sComment)
     *
     * If sLines is not a number, it can be a instruction filter.  However, for the moment, the only
     * supported filter is "call", which filters the history buffer for all CALL and RET instructions
     * from the specified previous point forward.
     *
     * @this {Debuggerx86}
     * @param {string} [sPrev] is a (decimal) number of instructions to rewind to (default is 10)
     * @param {string} [sLines] is a (decimal) number of instructions to print (default is, again, 10)
     * @param {string} [sComment] (should be either "history" or "cycles"; default is "history")
     */
    dumpHistory(sPrev, sLines, sComment = "history")
    {
        let sMore = "";
        let cHistory = 0;
        let iHistory = this.iOpcodeHistory;
        let aHistory = this.aOpcodeHistory;

        if (aHistory.length) {

            let nPrev = +sPrev || this.nextHistory;
            let nLines = +sLines || 10;

            if (isNaN(nPrev)) {
                nPrev = nLines;
            } else {
                sMore = "more ";
            }

            if (nPrev > aHistory.length) {
                this.printf("note: only %d available\n", aHistory.length);
                nPrev = aHistory.length;
            }

            iHistory -= nPrev;
            if (iHistory < 0) {
                /**
                 * If the dbgAddr of the last aHistory element contains a valid selector, wrap around.
                 */
                if (aHistory[aHistory.length - 1].sel == null) {
                    nPrev = iHistory + nPrev;
                    iHistory = 0;
                } else {
                    iHistory += aHistory.length;
                }
            }

            let aFilters = [];
            if (sLines == "call") {
                nLines = 100000;
                aFilters = ["CALL"];
            }

            if (sPrev !== undefined) {
                this.printf("%d instructions earlier:\n", nPrev);
            }

            let sBuffer = "";
            let nCyclesPrev = 0;
            let fDumpCycles = (sComment == "cycles");

            /**
             * TODO: The following is necessary to prevent dumpHistory() from causing additional (or worse, recursive)
             * faults due to segmented addresses that are no longer valid, but the only alternative is to dramatically
             * increase the amount of memory used to store instruction history (eg, storing copies of all the instruction
             * bytes alongside the execution addresses).
             *
             * For now, we're living dangerously, so that our history dumps actually work.
             *
             *      this.nSuppressBreaks++;
             *
             * If you re-enable this protection, be sure to re-enable the decrement below, too.
             */
            while (nLines > 0 && iHistory != this.iOpcodeHistory) {

                let dbgAddr = aHistory[iHistory++];
                if (dbgAddr.sel == null) break;

                /**
                 * We must create a new dbgAddr from the address in aHistory, because dbgAddr was
                 * a reference, not a copy, and we don't want getInstruction() modifying the original.
                 */
                let dbgAddrNew = this.newAddr(dbgAddr.off, dbgAddr.sel, dbgAddr.addr, dbgAddr.type, dbgAddr.fData32, dbgAddr.fAddr32);

                let nSequence = nPrev--;
                if (fDumpCycles) {
                    nSequence = nCyclesPrev;
                    if (dbgAddr.nCPUCycles != null) {
                        nSequence = dbgAddr.nCPUCycles - nCyclesPrev;
                        nCyclesPrev = dbgAddr.nCPUCycles;
                    }
                }

                let sInstruction = this.getInstruction(dbgAddrNew, sComment, nSequence);

                if (dbgAddr.nDebugState != null) {
                    if (dbgAddr.nDebugCycles != null) {
                        sInstruction += " (" + dbgAddr.nDebugCycles + "," + StrLib.toHexByte(dbgAddr.nDebugState) + ")";
                    } else {
                        sInstruction += " (" + StrLib.toHexByte(dbgAddr.nDebugState >> 16) + ",AX=" + StrLib.toHexWord(dbgAddr.nDebugState & 0xffff) + ")";
                    }
                }

                if (!aFilters.length || sInstruction.indexOf(aFilters[0]) >= 0) {
                    sBuffer += (sBuffer? '\n' : '') + sInstruction;
                }

                if (iHistory >= aHistory.length) iHistory = 0;
                this.nextHistory = nPrev;
                cHistory++;
                nLines--;
            }

            if (sBuffer) this.printf("%s\n", sBuffer);

            /**
             * See comments above.
             *
             *      this.nSuppressBreaks--;
             */
        }

        if (!cHistory) {
            this.printf("no %shistory available\n", sMore);
            this.nextHistory = undefined;
        }
    }

    /**
     * dumpTSS(asArgs)
     *
     * This dumps a TSS using the given selector.  If none is specified, the current TR is used.
     *
     * @this {Debuggerx86}
     * @param {Array.<string>} asArgs
     */
    dumpTSS(asArgs)
    {
        let seg, sel;
        let sSel = asArgs[0];

        if (!sSel) {
            seg = this.cpu.segTSS;
        } else {
            sel = this.parseValue(sSel);
            if (sel === undefined) {
                this.printf("invalid task selector: %s\n", sSel);
                return;
            }
            seg = this.getSegment(sel, Debuggerx86.ADDRTYPE.PROT);
        }

        this.printf("dumpTSS(%#06x): %%0*x\n", seg? seg.sel : sel, this.cchAddr, seg? seg.base : null);
        if (!seg) return;

        let sDump = "";
        let type = seg.type & ~X86.DESC.ACC.TYPE.TSS_BUSY;
        let cch = (type == X86.DESC.ACC.TYPE.TSS286? 4 : 8);
        let aTSSFields = (type == X86.DESC.ACC.TYPE.TSS286? Debuggerx86.TSS286 : Debuggerx86.TSS386);
        let off, addr, v;
        for (let sField in aTSSFields) {
            off = aTSSFields[sField];
            addr = seg.base + off;
            v = this.cpu.probeAddr(addr, 2);
            if (type == X86.DESC.ACC.TYPE.TSS386) {
                v |= this.cpu.probeAddr(addr + 2, 2) << 16;
            }
            if (sDump) sDump += '\n';
            sDump += StrLib.toHexWord(off) + ' ' + StrLib.pad(sField + ':', -11) + StrLib.toHex(v, cch);
        }
        if (type == X86.DESC.ACC.TYPE.TSS386) {
            let iPort = 0;
            off = (v >>> 16);
            /**
             * We arbitrarily cut the IOPM dump off at port 0x3FF; we're not currently interested in anything above that.
             */
            while (off < seg.offMax && iPort < 0x3ff) {
                addr = seg.base + off;
                v = this.cpu.probeAddr(addr, 2);
                sDump += "\n" + StrLib.toHexWord(off) + " ports " + StrLib.toHexWord(iPort) + '-' + StrLib.toHexWord(iPort+15) + ": " + StrLib.toBinBytes(v, 2);
                iPort += 16;
                off += 2;
            }
        }
        this.print(sDump + "\n");
    }

    /**
     * findModuleInfo(sModule, nSegment)
     *
     * Since we're not sure what Disk the module was loaded from, we have to check all of them.
     *
     * @this {Debuggerx86}
     * @param {string} sModule
     * @param {number} nSegment
     * @returns {Object}
     */
    findModuleInfo(sModule, nSegment)
    {
        let aSymbols = {};
        if (SYMBOLS) {
            let component, componentPrev = null;
            while ((component = this.cmp.getMachineComponent("Disk", componentPrev))) {
                let a = component.getModuleInfo(sModule, nSegment);
                if (a) {
                    aSymbols = a;
                    break;
                }
                componentPrev = component;
            }
        }
        return aSymbols;
    }

    /**
     * messageInit(sEnable)
     *
     * @this {Debuggerx86}
     * @param {string|undefined} sEnable contains zero or more message categories to enable, separated by ','
     */
    messageInit(sEnable)
    {
        this.dbg = this;
        this.bitsMessage = MESSAGE.WARNING + (DEBUG? MESSAGE.DEBUG : 0);
        this.sMessagePrev = null;
        this.aMessageBuffer = [];
        let aEnable = this.parseCommand(sEnable, false, ',');
        if (aEnable.length) {
            this.bitsMessage -= MESSAGE.WARNING;    // when specific messages are being enabled, WARNING must be explicitly set
            for (let m in MESSAGE.NAMES) {
                if (UsrLib.indexOf(aEnable, m) >= 0) {
                    this.bitsMessage += MESSAGE.NAMES[m];
                    this.printf("%s messages enabled\n", m);
                }
            }
        }
        this.historyInit();                         // call this just in case MESSAGE.INT was turned on
    }

    /**
     * messageDump(bitMessage, fnDumper)
     *
     * @this {Debuggerx86}
     * @param {number} bitMessage is one Messages category flag
     * @param {function(Array.<string>)} fnDumper is a function the Debugger can use to dump data for that category
     * @returns {boolean} (true if successfully registered, false if not)
     */
    messageDump(bitMessage, fnDumper)
    {
        for (let m in MESSAGE.NAMES) {
            if (bitMessage == MESSAGE.NAMES[m]) {
                this.afnDumpers[m] = fnDumper;
                return true;
            }
        }
        return false;
    }

    /**
     * getRegIndex(sReg, off)
     *
     * @this {Debuggerx86}
     * @param {string} sReg
     * @param {number} [off] optional offset into sReg
     * @returns {number} (register index, or -1 if not found)
     */
    getRegIndex(sReg, off)
    {
        let i;
        sReg = sReg.toUpperCase();
        if (off == null) {
            i = UsrLib.indexOf(Debuggerx86.REGS, sReg);
        } else {
            i = UsrLib.indexOf(Debuggerx86.REGS, sReg.substr(off, 3));
            if (i < 0) i = UsrLib.indexOf(Debuggerx86.REGS, sReg.substr(off, 2));
        }
        return i;
    }

    /**
     * getRegString(iReg)
     *
     * @this {Debuggerx86}
     * @param {number} iReg
     * @returns {string}
     */
    getRegString(iReg)
    {
        let cch = 0;
        let n = this.getRegValue(iReg);
        if (n != null) {
            switch(iReg) {
            case Debuggerx86.REG_AL:
            case Debuggerx86.REG_CL:
            case Debuggerx86.REG_DL:
            case Debuggerx86.REG_BL:
            case Debuggerx86.REG_AH:
            case Debuggerx86.REG_CH:
            case Debuggerx86.REG_DH:
            case Debuggerx86.REG_BH:
                cch = 2;
                break;
            case Debuggerx86.REG_AX:
            case Debuggerx86.REG_CX:
            case Debuggerx86.REG_DX:
            case Debuggerx86.REG_BX:
            case Debuggerx86.REG_SP:
            case Debuggerx86.REG_BP:
            case Debuggerx86.REG_SI:
            case Debuggerx86.REG_DI:
            case Debuggerx86.REG_IP:
            case Debuggerx86.REG_SEG + Debuggerx86.REG_ES:
            case Debuggerx86.REG_SEG + Debuggerx86.REG_CS:
            case Debuggerx86.REG_SEG + Debuggerx86.REG_SS:
            case Debuggerx86.REG_SEG + Debuggerx86.REG_DS:
            case Debuggerx86.REG_SEG + Debuggerx86.REG_FS:
            case Debuggerx86.REG_SEG + Debuggerx86.REG_GS:
                cch = 4;
                break;
            case Debuggerx86.REG_EAX:
            case Debuggerx86.REG_ECX:
            case Debuggerx86.REG_EDX:
            case Debuggerx86.REG_EBX:
            case Debuggerx86.REG_ESP:
            case Debuggerx86.REG_EBP:
            case Debuggerx86.REG_ESI:
            case Debuggerx86.REG_EDI:
            case Debuggerx86.REG_CR0:
            case Debuggerx86.REG_CR1:
            case Debuggerx86.REG_CR2:
            case Debuggerx86.REG_CR3:
            case Debuggerx86.REG_EIP:
                cch = 8;
                break;
            case Debuggerx86.REG_PS:
                cch = this.cchReg;
                break;
            }
        }
        return cch? StrLib.toHex(n, cch) : "??";
    }

    /**
     * getRegValue(iReg)
     *
     * @this {Debuggerx86}
     * @param {number} iReg
     * @returns {number|undefined}
     */
    getRegValue(iReg)
    {
        let n;
        if (iReg >= 0) {
            let cpu = this.cpu;
            switch(iReg) {
            case Debuggerx86.REG_AL:
                n = cpu.regEAX & 0xff;
                break;
            case Debuggerx86.REG_CL:
                n = cpu.regECX & 0xff;
                break;
            case Debuggerx86.REG_DL:
                n = cpu.regEDX & 0xff;
                break;
            case Debuggerx86.REG_BL:
                n = cpu.regEBX & 0xff;
                break;
            case Debuggerx86.REG_AH:
                n = (cpu.regEAX >> 8) & 0xff;
                break;
            case Debuggerx86.REG_CH:
                n = (cpu.regECX >> 8) & 0xff;
                break;
            case Debuggerx86.REG_DH:
                n = (cpu.regEDX >> 8) & 0xff;
                break;
            case Debuggerx86.REG_BH:
                n = (cpu.regEBX >> 8) & 0xff;
                break;
            case Debuggerx86.REG_AX:
                n = cpu.regEAX & 0xffff;
                break;
            case Debuggerx86.REG_CX:
                n = cpu.regECX & 0xffff;
                break;
            case Debuggerx86.REG_DX:
                n = cpu.regEDX & 0xffff;
                break;
            case Debuggerx86.REG_BX:
                n = cpu.regEBX & 0xffff;
                break;
            case Debuggerx86.REG_SP:
                n = cpu.getSP() & 0xffff;
                break;
            case Debuggerx86.REG_BP:
                n = cpu.regEBP & 0xffff;
                break;
            case Debuggerx86.REG_SI:
                n = cpu.regESI & 0xffff;
                break;
            case Debuggerx86.REG_DI:
                n = cpu.regEDI & 0xffff;
                break;
            case Debuggerx86.REG_IP:
                n = cpu.getIP() & 0xffff;
                break;
            case Debuggerx86.REG_PS:
                n = cpu.getPS();
                break;
            case Debuggerx86.REG_SEG + Debuggerx86.REG_ES:
                n = cpu.getES();
                break;
            case Debuggerx86.REG_SEG + Debuggerx86.REG_CS:
                n = cpu.getCS();
                break;
            case Debuggerx86.REG_SEG + Debuggerx86.REG_SS:
                n = cpu.getSS();
                break;
            case Debuggerx86.REG_SEG + Debuggerx86.REG_DS:
                n = cpu.getDS();
                break;
            default:
                if (this.cpu.model == X86.MODEL_80286) {
                    if (iReg == Debuggerx86.REG_CR0) {
                        n = cpu.regCR0;
                    }
                }
                else if (I386 && this.cpu.model >= X86.MODEL_80386) {
                    switch(iReg) {
                    case Debuggerx86.REG_EAX:
                        n = cpu.regEAX;
                        break;
                    case Debuggerx86.REG_ECX:
                        n = cpu.regECX;
                        break;
                    case Debuggerx86.REG_EDX:
                        n = cpu.regEDX;
                        break;
                    case Debuggerx86.REG_EBX:
                        n = cpu.regEBX;
                        break;
                    case Debuggerx86.REG_ESP:
                        n = cpu.getSP();
                        break;
                    case Debuggerx86.REG_EBP:
                        n = cpu.regEBP;
                        break;
                    case Debuggerx86.REG_ESI:
                        n = cpu.regESI;
                        break;
                    case Debuggerx86.REG_EDI:
                        n = cpu.regEDI;
                        break;
                    case Debuggerx86.REG_CR0:
                        n = cpu.regCR0;
                        break;
                    case Debuggerx86.REG_CR1:
                        n = cpu.regCR1;
                        break;
                    case Debuggerx86.REG_CR2:
                        n = cpu.regCR2;
                        break;
                    case Debuggerx86.REG_CR3:
                        n = cpu.regCR3;
                        break;
                    case Debuggerx86.REG_SEG + Debuggerx86.REG_FS:
                        n = cpu.getFS();
                        break;
                    case Debuggerx86.REG_SEG + Debuggerx86.REG_GS:
                        n = cpu.getGS();
                        break;
                    case Debuggerx86.REG_EIP:
                        n = cpu.getIP();
                        break;
                    }
                }
                break;
            }
        }
        return n;
    }

    /**
     * replaceRegs(s)
     *
     * @this {Debuggerx86}
     * @param {string} s
     * @returns {string}
     */
    replaceRegs(s)
    {
        /**
         * Replace any references first; this means that register references inside the reference
         * do NOT need to be prefixed with '@'.
         */
        s = this.parseReference(s) || s;

        /**
         * Replace every @XX (or @XXX), where XX (or XXX) is a register, with the register's value.
         */
        let i = 0;
        let b, sChar, sAddr, dbgAddr, sReplace;
        while ((i = s.indexOf('@', i)) >= 0) {
            let iReg = this.getRegIndex(s, i + 1);
            if (iReg >= 0) {
                s = s.substr(0, i) + this.getRegString(iReg) + s.substr(i + 1 + Debuggerx86.REGS[iReg].length);
            }
            i++;
        }
        /**
         * Replace every #XX, where XX is a hex byte value, with the corresponding ASCII character (if printable).
         */
        i = 0;
        while ((i = s.indexOf('#', i)) >= 0) {
            sChar = s.substr(i+1, 2);
            b = StrLib.parseInt(sChar, 16);
            if (b != null && b >= 32 && b < 127) {
                sReplace = sChar + " '" + String.fromCharCode(b) + "'";
                s = s.replace('#' + sChar, sReplace);
                i += sReplace.length;
                continue;
            }
            i++;
        }
        /**
         * Replace every $XXXX:XXXX, where XXXX:XXXX is a segmented address, with the zero-terminated string at that address.
         */
        i = 0;
        while ((i = s.indexOf('$', i)) >= 0) {
            sAddr = s.substr(i+1, 9);
            dbgAddr = this.parseAddr(sAddr);
            if (dbgAddr) {
                sReplace = sAddr + ' "' + this.getSZ(dbgAddr) + '"';
                s = s.replace('$' + sAddr, sReplace);
                i += sReplace.length;
                continue;
            }
            i++;
        }
        /**
         * Replace every ^XXXX:XXXX, where XXXX:XXXX is a segmented address, with the FCB filename stored at that address.
         */
        i = 0;
        while ((i = s.indexOf('^', i)) >= 0) {
            sAddr = s.substr(i+1, 9);
            dbgAddr = this.parseAddr(sAddr);
            if (dbgAddr) {
                this.incAddr(dbgAddr);
                sReplace = sAddr + ' "' + this.getSZ(dbgAddr, 11) + '"';
                s = s.replace('^' + sAddr, sReplace);
                i += sReplace.length;
                continue;
            }
            i++;
        }
        return s;
    }

    /**
     * message(sMessage, bitsMessage)
     *
     * @this {Debuggerx86}
     * @param {string} sMessage
     * @param {number} [bitsMessage]
     */
    message(sMessage, bitsMessage = 0)
    {
        if ((bitsMessage & MESSAGE.ADDR) && this.cpu) {
            let sAddress = StrLib.sprintf(" at %s (%%%X)$1",  this.toHexAddr(this.newAddr(this.cpu.getIP(), this.cpu.getCS())), this.cpu.regLIP);
            sMessage = sMessage.replace(/(\n?)$/, sAddress);
        }

        if (Component.testBits(this.bitsMessage, MESSAGE.BUFFER)) {
            this.aMessageBuffer.push(sMessage);
            return;
        }

        if (this.sMessagePrev && sMessage == this.sMessagePrev) return;
        this.sMessagePrev = sMessage;

        if (bitsMessage && Component.testBits(this.bitsMessage, MESSAGE.HALT)) {
            sMessage = sMessage.replace(/(\n?)$/, " (cpu halted)$1");
            this.stopCPU();
        }

        this.print(sMessage, bitsMessage); // + " (" + this.cpu.getCycles() + " cycles)"

        /**
         * We have no idea what the frequency of print() calls might be; all we know is that they easily
         * screw up the CPU's careful assumptions about cycles per burst.  So we call yieldCPU() after every
         * message, to effectively end the current burst and start fresh.
         *
         * TODO: See CPU.calcStartTime() for a discussion of why we might want to call yieldCPU() *before*
         * we display the message.
         */
        if (this.cpu) this.cpu.yieldCPU();
    }

    /**
     * messageInt(nInt, addr, fForce)
     *
     * @this {Debuggerx86}
     * @param {number} nInt
     * @param {number} addr (LIP after the "INT n" instruction has been fetched but not dispatched)
     * @param {boolean} [fForce] (true if the message should be forced)
     * @returns {boolean} (true if message generated (which in turn triggers addIntReturn() inside checkIntNotify()), false if not)
     */
    messageInt(nInt, addr, fForce)
    {
        let AH, DL;
        let fMessage = fForce;
        let nCategory;

        /**
         * We currently arrive here only because the CPU has already determined that INT messages are enabled,
         * or because the ChipSet's RTC interrupt handler has already determined that INT messages are enabled.
         *
         * But software interrupts are very common, so we generally require additional categories to be enabled;
         * unless the caller has set fForce, we check those additional categories now.
         */
        if (!fMessage) {
            /**
             * Display all software interrupts if CPU messages are enabled (and it's not an "annoying" interrupt);
             * note that in some cases, even "annoying" interrupts can be turned with an extra message category.
             */
            fMessage = this.messageEnabled(MESSAGE.CPU) && Debuggerx86.INT_ANNOYING.indexOf(nInt) < 0;
            if (!fMessage) {
                /**
                 * Alternatively, display this software interrupt if its corresponding message category is enabled.
                 */
                nCategory = Debuggerx86.INT_MESSAGES[nInt];
                if (nCategory) {
                    if (this.messageEnabled(nCategory)) {
                        fMessage = true;
                    } else {
                        /**
                         * Alternatively, display this FDC interrupt if HDC messages are enabled (since they share
                         * a common software interrupt).  Normally, an HDC BIOS will copy the original DISK (0x13)
                         * vector to the ALT_DISK (0x40) vector, but it's a nuisance having to check different
                         * interrupts in different configurations for the same frickin' functionality, so we don't.
                         */
                        fMessage = (nCategory == MESSAGE.FDC && this.messageEnabled(nCategory = MESSAGE.HDC));
                    }
                }
            }
        }
        if (fMessage) {
            AH = (this.cpu.regEAX >> 8) & 0xff;
            DL = this.cpu.regEDX & 0xff;
            if (nInt == Interrupts.DOS /* 0x21 */ && AH == 0x0b ||
                nCategory == MESSAGE.FDC && DL >= 0x80 || nCategory == MESSAGE.HDC && DL < 0x80) {
                fMessage = false;
            }
        }
        if (fMessage) {
            let aFuncs = Interrupts.FUNCS[nInt];
            let sFunc = (aFuncs && aFuncs[AH]) || "";
            if (sFunc) sFunc = this.replaceRegs(sFunc);
            /**
             * For display purposes only, rewind addr to the address of the responsible "INT n" instruction;
             * we know it's the two-byte "INT n" instruction because that's the only opcode handler that calls
             * checkIntNotify() at the moment.
             */
            addr -= 2;
            this.printf("INT %#04X: AH=%#04X at %s %s\n",  nInt, AH, this.toHexOffset(addr - this.cpu.segCS.base, this.cpu.getCS()), sFunc);
        }
        return fMessage;
    }

    /**
     * messageIntReturn(nInt, nLevel, nCycles)
     *
     * @this {Debuggerx86}
     * @param {number} nInt
     * @param {number} nLevel
     * @param {number} nCycles
     * @param {string} [sResult]
     */
    messageIntReturn(nInt, nLevel, nCycles, sResult)
    {
        this.printf("INT %#04X: C=%d%s (cycles=%d%s)\n", nInt, (this.cpu.getCF()? 1 : 0), (sResult || ""), nCycles, (nLevel? ",level=" + (nLevel+1) : ""));
    }

    /**
     * messageIO(component, port, bOut, addrFrom, name, bIn, bitsMessage)
     *
     * @this {Debuggerx86}
     * @param {Component} component
     * @param {number} port
     * @param {number} [bOut] if an output operation
     * @param {number} [addrFrom]
     * @param {string} [name] of the port, if any
     * @param {number} [bIn] is the input value, if known, on an input operation
     * @param {number} [bitsMessage] is zero or more Messages flag(s)
     */
    messageIO(component, port, bOut, addrFrom, name, bIn, bitsMessage)
    {
        /**
         * Add MESSAGE.PORT to the set of required message flags.
         */
        bitsMessage = Component.setBits(bitsMessage || 0, MESSAGE.PORT);
        /**
         * We don't want to see "unknown" I/O messages unless WARNING is enabled.
         */
        if (!name) bitsMessage = Component.setBits(bitsMessage, MESSAGE.WARNING);

        if (addrFrom == undefined || Component.testBits(this.bitsMessage, bitsMessage)) {
            let sFrom = "";
            if (addrFrom != undefined) {
                let selFrom = this.cpu.getCS();
                addrFrom -= this.cpu.segCS.base;
                sFrom = "at " + this.toHexOffset(addrFrom, selFrom);
            }
            if (bOut == undefined) {
                this.printf("%s.inPort(%#06X,%s): %#04X %s\n", component.idComponent, port, name || "unknown", bIn, sFrom);
            } else {
                this.printf("%s.outPort(%#06X,%s,%#04X) %s\n", component.idComponent, port, name || "unknown", bOut, sFrom);
            }
        }
    }

    /**
     * init()
     *
     * @this {Debuggerx86}
     */
    init()
    {
        this.printf("Type ? for help with PCx86 Debugger commands\n");
        this.updateStatus();
        if (this.sCommandsInit) {
            let sCommands = this.sCommandsInit;
            this.sCommandsInit = null;
            this.doCommands(sCommands);
        }
    }

    /**
     * historyInit(fQuiet)
     *
     * This function is intended to be called by the constructor, reset(), addBreakpoint(), findBreakpoint()
     * and any other function that changes the checksEnabled() criteria used to decide whether checkInstruction()
     * should be called.
     *
     * That is, if the history arrays need to be allocated and haven't already been allocated, then allocate them,
     * and if the arrays are no longer needed, then deallocate them.
     *
     * @this {Debuggerx86}
     * @param {boolean} [fQuiet]
     */
    historyInit(fQuiet)
    {
        let i;
        if (!this.checksEnabled()) {
            if (this.aOpcodeHistory && this.aOpcodeHistory.length && !fQuiet) {
                this.printf("history buffer freed\n");
            }
            this.iOpcodeHistory = 0;
            this.aOpcodeHistory = [];
            this.aaOpcodeCounts = [];
            return;
        }
        if (!this.aOpcodeHistory || !this.aOpcodeHistory.length) {
            this.aOpcodeHistory = new Array(Debuggerx86.HISTORY_LIMIT);
            for (i = 0; i < this.aOpcodeHistory.length; i++) {
                /**
                 * Preallocate dummy Addr (Array) objects in every history slot, so that
                 * checkInstruction() doesn't need to call newAddr() on every slot update.
                 */
                this.aOpcodeHistory[i] = this.newAddr();
            }
            this.iOpcodeHistory = 0;
            if (!fQuiet) {
                this.printf("history buffer allocated\n");
            }
        }
        if (!this.aaOpcodeCounts || !this.aaOpcodeCounts.length) {
            this.aaOpcodeCounts = new Array(256);
            for (i = 0; i < this.aaOpcodeCounts.length; i++) {
                this.aaOpcodeCounts[i] = [i, 0];
            }
        }
    }

    /**
     * startCPU(fUpdateFocus, fQuiet)
     *
     * @this {Debuggerx86}
     * @param {boolean} [fUpdateFocus]
     * @param {boolean} [fQuiet]
     * @returns {boolean} (true if run request successful, false if not)
     */
    startCPU(fUpdateFocus, fQuiet)
    {
        if (this.checkCPU(fQuiet)) {
            return this.cpu.startCPU(fUpdateFocus, fQuiet);
        }
        return false;
    }

    /**
     * stepCPU(nCycles, fRegs, fUpdateCPU)
     *
     * @this {Debuggerx86}
     * @param {number} nCycles (0 for one instruction without checking breakpoints)
     * @param {boolean} [fRegs] is true to display registers after step (default is false)
     * @param {boolean} [fUpdateCPU] is false to disable calls to updateCPU() (default is true)
     * @returns {boolean}
     */
    stepCPU(nCycles, fRegs, fUpdateCPU)
    {
        if (!this.checkCPU()) return false;

        this.nCycles = 0;
        let fCheck = !nCycles;
        do {
            if (fCheck) {
                /**
                 * When single-stepping, the CPU won't call checkInstruction(), which is good for
                 * avoiding breakpoints, but bad for instruction data collection if checks are enabled.
                 * So we call checkInstruction() ourselves.
                 */
                if (this.checksEnabled()) this.checkInstruction(this.cpu.regLIP, 0);
                fCheck = false;     // only check once per instruction
            }
            /**
             * For our typically tiny bursts (usually single instructions), mimic what runCPU() does.
             */
            try {
                let nCyclesStep = this.cpu.stepCPU(nCycles);
                if (nCyclesStep > 0) {
                    this.nCycles += nCyclesStep;
                    this.cpu.addCycles(nCyclesStep, true);
                    this.cpu.updateTimers(nCyclesStep);
                    this.cpu.updateChecksum(nCyclesStep);
                    this.cOpcodes++;
                }
            }
            catch(exception) {
                if (typeof exception != "number") {
                    let e = exception;
                    this.nCycles = 0;
                    this.cpu.setError(e.stack || e.message);
                }
            }
        } while (this.cpu.opFlags & X86.OPFLAG_PREFIXES);

        /**
         * Because we called cpu.stepCPU() and not cpu.startCPU(), we must nudge the cpu's update code,
         * and then update our own state.  Normally, the only time fUpdateCPU will be false is when doTrace()
         * is calling us in a loop, in which case it will perform its own updateCPU() when it's done.
         */
        if (fUpdateCPU !== false) this.cpu.updateCPU(true);

        this.updateStatus(fRegs || false);
        return (this.nCycles > 0);
    }

    /**
     * stopCPU()
     *
     * @this {Debuggerx86}
     * @param {boolean} [fComplete]
     * @returns {boolean}
     */
    stopCPU(fComplete)
    {
        return this.cpu && this.cpu.stopCPU(fComplete) || false;
    }

    /**
     * updateStatus(fRegs)
     *
     * @this {Debuggerx86}
     * @param {boolean} [fRegs] (default is true)
     */
    updateStatus(fRegs)
    {
        if (fRegs === undefined) fRegs = true;

        this.dbgAddrNextCode = this.newAddr(this.cpu.getIP(), this.cpu.getCS());
        /**
         * this.nStep used to be a simple boolean, but now it's 0 (or undefined)
         * if inactive, 1 if stepping over an instruction without a register dump, or 2
         * if stepping over an instruction with a register dump.
         */
        if (!fRegs || this.nStep == 1) {
            this.doUnassemble();
        } else {
            this.doRegisters();
        }
    }

    /**
     * checkCPU(fQuiet)
     *
     * Make sure the CPU is ready (finished initializing), not busy (already running), and not in an error state.
     *
     * @this {Debuggerx86}
     * @param {boolean} [fQuiet]
     * @returns {boolean}
     */
    checkCPU(fQuiet)
    {
        if (!this.cpu || !this.cpu.isReady() || !this.cpu.isPowered() || this.cpu.isRunning()) {
            if (!fQuiet) this.printf("cpu busy or unavailable, command ignored\n");
            return false;
        }
        return !this.cpu.isError();
    }

    /**
     * powerUp(data, fRepower)
     *
     * @this {Debuggerx86}
     * @param {Object|null} data
     * @param {boolean} [fRepower]
     * @returns {boolean} (true if successful, false if failure)
     */
    powerUp(data, fRepower)
    {
        if (!fRepower) {
            /**
             * Because Debugger save/restore support is somewhat limited (and didn't always exist),
             * we deviate from the typical save/restore design pattern: instead of reset OR restore,
             * we always reset and then perform a (potentially limited) restore.
             */
            this.reset(true);

            // this.printf("%s\n", data? "resuming" : "powering up");

            if (data && this.restore) {
                if (!this.restore(data)) return false;
            }

            this.fpuActive = this.cpu.fpuActive;
        }
        return true;
    }

    /**
     * powerDown(fSave, fShutdown)
     *
     * @this {Debuggerx86}
     * @param {boolean} [fSave]
     * @param {boolean} [fShutdown]
     * @returns {Object|boolean}
     */
    powerDown(fSave, fShutdown)
    {
        if (fShutdown) this.printf("%s\n", fSave? "suspending" : "shutting down");
        return fSave? this.save() : true;
    }

    /**
     * reset(fQuiet)
     *
     * This is a notification handler, called by the Computer, to inform us of a reset.
     *
     * @this {Debuggerx86}
     * @param {boolean} fQuiet (true only when called from our own powerUp handler)
     */
    reset(fQuiet)
    {
        this.historyInit();
        this.cOpcodes = this.cOpcodesStart = 0;
        this.sMessagePrev = null;
        this.nCycles = 0;
        this.dbgAddrNextCode = this.newAddr(this.cpu.getIP(), this.cpu.getCS());
        this.clearTempBreakpoint();
        if (!fQuiet && !this.flags.running) this.updateStatus();
    }

    /**
     * save()
     *
     * This implements (very rudimentary) save support for the Debugger component.
     *
     * @this {Debuggerx86}
     * @returns {Object}
     */
    save()
    {
        let state = new State(this);
        state.set(0, this.packAddr(this.dbgAddrNextCode));
        state.set(1, this.packAddr(this.dbgAddrNextData));
        state.set(2, this.packAddr(this.dbgAddrAssemble));
        state.set(3, [this.aPrevCmds, this.fAssemble, Component.setBits(this.bitsMessage, MESSAGE.BUFFER)]);
        state.set(4, this.aSymbolTable);
        state.set(5, [this.aBreakExec, this.aBreakRead, this.aBreakWrite]);
        return state.data();
    }

    /**
     * restore(data)
     *
     * This implements (very rudimentary) restore support for the Debugger component.
     *
     * @this {Debuggerx86}
     * @param {Object} data
     * @returns {boolean} (true if successful, false if failure)
     */
    restore(data)
    {
        let i = 0;
        if (data[i]) this.dbgAddrNextCode = this.unpackAddr(data[i++]);
        /**
         * dbgAddrNextData wasn't saved until there were at least 6 elements, hence the check for data[5] instead of data[i]
         */
        if (data[5]) this.dbgAddrNextData = this.unpackAddr(data[i++]);
        if (data[i]) this.dbgAddrAssemble = this.unpackAddr(data[i++]);
        if (data[i]) {
            this.aPrevCmds = data[i][0];
            if (typeof this.aPrevCmds == "string") this.aPrevCmds = [this.aPrevCmds];
            this.fAssemble = data[i][1];
            let bitsMessage = data[i][2];
            /**
             * We ensure that we're restoring updated Messages flags, by verifying that MESSAGE.BUFFER was set by the save()
             * function; if so, we clear MESSAGE.BUFFER before restoring it (and yes, this means we'll never restore the BUFFER
             * setting, which is fine, and we'll also never restore any old Messages flags, which I doubt anyone will miss).
             */
            if (Component.testBits(bitsMessage, MESSAGE.BUFFER)) {
                bitsMessage = Component.clearBits(bitsMessage, MESSAGE.BUFFER);
                this.bitsMessage = Component.setBits(this.bitsMessage, bitsMessage);
            }
            i++;
        }
        if (data[i]) {
            this.aSymbolTable = data[i++];
        }
        if (data[i]) {
            this.restoreBreakpoints(this.aBreakExec, data[i][0]);
            this.restoreBreakpoints(this.aBreakRead, data[i][1]);
            this.restoreBreakpoints(this.aBreakWrite, data[i][2]);
        }
        return true;
    }

    /**
     * start(ms, nCycles)
     *
     * This is a notification handler, called by the Computer, to inform us the CPU has started.
     *
     * @this {Debuggerx86}
     * @param {number} ms
     * @param {number} nCycles
     */
    start(ms, nCycles)
    {
        this.flags.running = true;
        this.msStart = ms;
        this.nCyclesStart = nCycles;
        if (!this.nStep) {
            this.printf("running\n");
        }
        this.notifyEvent(DbgLib.EVENTS.EXIT, this.nStep);
    }

    /**
     * stop(ms, nCycles)
     *
     * This is a notification handler, called by the Computer, to inform us the CPU has now stopped.
     *
     * @this {Debuggerx86}
     * @param {number} ms
     * @param {number} nCycles
     */
    stop(ms, nCycles)
    {
        if (this.flags.running) {
            let nStep = this.nStep;
            this.flags.running = false;
            this.nCycles = nCycles - this.nCyclesStart;
            this.notifyEvent(DbgLib.EVENTS.ENTER, nStep);
            if (!nStep) {
                let sStopped = "stopped";
                if (this.nCycles) {
                    let msTotal = ms - this.msStart;
                    let nCyclesPerSecond = (msTotal > 0? Math.round(this.nCycles * 1000 / msTotal) : 0);
                    sStopped += " (";
                    if (this.checksEnabled()) {
                        sStopped += this.cOpcodes + " opcodes, ";
                        /**
                         * $ops displays progress by calculating cOpcodes - cOpcodesStart, so before
                         * zeroing cOpcodes, we should subtract cOpcodes from cOpcodesStart (since we're
                         * effectively subtracting cOpcodes from cOpcodes as well).
                         */
                        this.cOpcodesStart -= this.cOpcodes;
                        this.cOpcodes = 0;
                    }
                    sStopped += this.nCycles + " cycles, " + msTotal + " ms, " + nCyclesPerSecond + " hz)";
                    if (MAXDEBUG && this.chipset) {
                        let i, c, n;
                        for (i = 0; i < this.chipset.acInterrupts.length; i++) {
                            c = this.chipset.acInterrupts[i];
                            if (!c) continue;
                            n = c / Math.round(msTotal / 1000);
                            this.printf("IRQ%d: %d interrupts (%d per sec)\n", i, c, n);
                            this.chipset.acInterrupts[i] = 0;
                        }
                        for (i = 0; i < this.chipset.acTimersFired.length; i++) {
                            c = this.chipset.acTimersFired[i];
                            if (!c) continue;
                            n = c / Math.round(msTotal / 1000);
                            this.printf("TIMER%d: %d fires (%d per sec)\n", i, c, n);
                            this.chipset.acTimersFired[i] = 0;
                        }
                        n = 0;
                        for (i = 0; i < this.chipset.acTimer0Counts.length; i++) {
                            let a = this.chipset.acTimer0Counts[i];
                            n += a[0];
                            this.printf("TIMER0 update #%d: [%d,%d,%d]\n", i, a[0], a[1], a[2]);
                        }
                        this.chipset.acTimer0Counts = [];
                    }
                } else {
                    if (this.messageEnabled(MESSAGE.HALT)) {
                        /**
                         * It's possible the user is trying to 'g' past a fault that was blocked by helpCheckFault()
                         * for the Debugger's benefit; if so, it will continue to be blocked, so try displaying a helpful
                         * message (another helpful tip would be to simply turn off the "halt" message category).
                         */
                        sStopped += " (use the 't' command to execute blocked faults)";
                    }
                }
                this.printf("%s\n", sStopped);
            }
            this.updateStatus(true);
            this.updateFocus();
            this.clearTempBreakpoint(this.cpu.regLIP);
            this.notifyEvent(DbgLib.EVENTS.READY, nStep);
        }
    }

    /**
     * checksEnabled(fRelease)
     *
     * This "check" function is called by the CPU; we indicate whether or not every instruction needs to be checked.
     *
     * Originally, this returned true even when there were only read and/or write breakpoints, but those breakpoints
     * no longer require the intervention of checkInstruction(); the Bus component automatically swaps in/out appropriate
     * "checked" Memory access functions to deal with those breakpoints in the corresponding Memory blocks.  So I've
     * simplified the test below.
     *
     * @this {Debuggerx86}
     * @param {boolean} [fRelease] is true for release criteria only; default is false (any criteria)
     * @returns {boolean} (true if every instruction needs to pass through checkInstruction(), false if not)
     */
    checksEnabled(fRelease)
    {
        return ((MAXDEBUG && !fRelease)? true : (this.aBreakExec.length > 1 || this.aVectorBP.length > 0 || !!this.nBreakIns || this.messageEnabled(MESSAGE.INT) /* || this.aBreakRead.length > 1 || this.aBreakWrite.length > 1 */));
    }

    /**
     * checkInstruction(addr, nState)
     *
     * This "check" function is called by the CPU to inform us about the next instruction to be executed,
     * giving us an opportunity to look for "exec" breakpoints and update opcode frequencies and instruction history.
     *
     * @this {Debuggerx86}
     * @param {number} addr
     * @param {number} nState is < 0 if stepping, 0 if starting, or > 0 if running
     * @returns {boolean} (true if breakpoint hit, false if not)
     */
    checkInstruction(addr, nState)
    {
        let cpu = this.cpu;

        if (nState > 0) {
            if (this.nBreakIns && !--this.nBreakIns) {
                return true;
            }
            if (this.checkBreakpoint(addr, 1, this.aBreakExec)) {
                return true;
            }
            /**
             * Halt if running with interrupts disabled and IOPL < CPL, because that's likely an error.
             */
            if (MAXDEBUG && !(cpu.regPS & X86.PS.IF) && cpu.nIOPL < cpu.nCPL) {
                this.printf("interrupts disabled at IOPL %d and CPL %d\n", cpu.nIOPL, cpu.nCPL);
                return true;
            }
        }

        /**
         * The rest of the instruction tracking logic can only be performed if historyInit() has allocated the
         * necessary data structures.  Note that there is no explicit UI for enabling/disabling history, other than
         * adding/removing breakpoints, simply because it's breakpoints that trigger the call to checkInstruction();
         * well, OK, and a few other things now, like enabling MESSAGE.INT messages.
         */
        if (nState >= 0) {
            this.cOpcodes++;
            if (this.aaOpcodeCounts.length) {
                let bOpcode = cpu.probeAddr(addr);
                if (bOpcode != null) {
                    this.aaOpcodeCounts[bOpcode][1]++;
                    /**
                     * If any vector breakpoints are set AND we're not halting on vector breakpoints AND we
                     * did not just encounter an interrupt vector, then do NOT log the instruction.  Otherwise, log it.
                     */
                    let fLog = (!this.aVectorBP.length || this.vectorHalt || this.vectorTrace >= 0);

                    // if (cpu.getIP() == 0x3C0F && cpu.getCS() == 0x048F) fLog = true;

                    if (fLog) {

                        let dbgAddr = this.aOpcodeHistory[this.iOpcodeHistory];
                        this.setAddr(dbgAddr, cpu.getIP(), cpu.getCS());

                        /**
                         * This was added to collapse repeated instructions into a single entry in the history buffer.
                         */
                        let iPrevHistory = this.iOpcodeHistory? this.iOpcodeHistory - 1 : this.aOpcodeHistory.length - 1;
                        let dbgPrev = this.aOpcodeHistory[iPrevHistory];
                        if (dbgPrev.off == dbgAddr.off && dbgPrev.sel == dbgAddr.sel) {
                            this.iOpcodeHistory = iPrevHistory;
                            dbgAddr = dbgPrev;
                        }

                        dbgAddr.nCPUCycles = cpu.getCycles();

                        /**
                         * If vector tracing is enabled and we just encountered a vector, record some additional info.
                         */
                        if (this.aVectorBP.length && !this.vectorHalt && this.vectorTrace >= 0) {
                            dbgAddr.nDebugState = (cpu.regEAX & 0xffff) | (this.vectorTrace << 16);
                        }
                        /**
                         * For debugging timer issues, snap cycles remaining in the current burst and the state of TIMER0.
                         */
                        else if (this.chipset) {
                            let timer = this.chipset.aTimers[0];
                            dbgAddr.nDebugCycles = cpu.nStepCycles;
                            dbgAddr.nDebugState = timer.countCurrent[0] | (timer.countCurrent[1] << 8);
                        }
                        /**
                         * For debugging video timing (eg, retrace) issues, it's helpful to record the state of the Video
                         * component's countdown timer.  timerVideo will be set to null if there's no Video component or the
                         * timer doesn't exist, so findTimer() should be called at most once.
                         */
                        else if (this.video) {
                            if (this.timerVideo === undefined) {
                                this.timerVideo = cpu.findTimer(this.video.id);
                            }
                            if (this.timerVideo) {
                                dbgAddr.nDebugCycles = this.timerVideo[1];
                                dbgAddr.nDebugState = this.video.getRetraceBits(this.video.cardActive);
                            }
                        }
                        else {
                            delete dbgAddr.nDebugCycles;
                            delete dbgAddr.nDebugState;
                        }
                        if (++this.iOpcodeHistory == this.aOpcodeHistory.length) this.iOpcodeHistory = 0;
                    }
                }
            }
            this.vectorSkip = this.vectorTrace;
            this.vectorTrace = -1;
        }
        return false;
    }

    /**
     * checkMemoryRead(addr, nb)
     *
     * This "check" function is called by a Memory block to inform us that a memory read occurred, giving us an
     * opportunity to track the read if we want, and look for a matching "read" breakpoint, if any.
     *
     * In the "old days", it would be an error for this call to fail to find a matching Debugger breakpoint, but now
     * Memory blocks have no idea whether the Debugger or the machine's Debug register(s) triggered this "checked" read.
     *
     * If we return true, we "trump" the machine's Debug register(s); false allows normal Debug register processing.
     *
     * @this {Debuggerx86}
     * @param {number} addr
     * @param {number} [nb] (# of bytes; default is 1)
     * @returns {boolean} (true if breakpoint hit, false if not)
     */
    checkMemoryRead(addr, nb)
    {
        if (this.checkBreakpoint(addr, nb || 1, this.aBreakRead)) {
            this.stopCPU(true);
            return true;
        }
        return false;
    }

    /**
     * checkMemoryWrite(addr, nb)
     *
     * This "check" function is called by a Memory block to inform us that a memory write occurred, giving us an
     * opportunity to track the write if we want, and look for a matching "write" breakpoint, if any.
     *
     * In the "old days", it would be an error for this call to fail to find a matching Debugger breakpoint, but now
     * Memory blocks have no idea whether the Debugger or the machine's Debug register(s) triggered this "checked" write.
     *
     * If we return true, we "trump" the machine's Debug register(s); false allows normal Debug register processing.
     *
     * @this {Debuggerx86}
     * @param {number} addr
     * @param {number} [nb] (# of bytes; default is 1)
     * @returns {boolean} (true if breakpoint hit, false if not)
     */
    checkMemoryWrite(addr, nb)
    {
        if (this.checkBreakpoint(addr, nb || 1, this.aBreakWrite)) {
            this.stopCPU(true);
            return true;
        }
        return false;
    }

    /**
     * checkPortInput(port, size, data)
     *
     * This "check" function is called by the Bus component to inform us that port input occurred.
     *
     * @this {Debuggerx86}
     * @param {number} port
     * @param {number} size
     * @param {number} data
     * @returns {boolean} (true if breakpoint hit, false if not)
     */
    checkPortInput(port, size, data)
    {
        /**
         * We trust that the Bus component won't call us unless we told it to, so we halt unconditionally.
         */
        this.printf("break on input from port %#06x: %x\n", port, data);
        this.stopCPU(true);
        return true;
    }

    /**
     * checkPortOutput(port, size, data)
     *
     * This "check" function is called by the Bus component to inform us that port output occurred.
     *
     * @this {Debuggerx86}
     * @param {number} port
     * @param {number} size
     * @param {number} data
     * @returns {boolean} (true if breakpoint hit, false if not)
     */
    checkPortOutput(port, size, data)
    {
        /**
         * We trust that the Bus component won't call us unless we told it to, so we halt unconditionally.
         */
        this.printf("break on output to port %#06x: %x\n", port, data);
        this.stopCPU(true);
        return true;
    }

    /**
     * clearBreakpoints()
     *
     * @this {Debuggerx86}
     */
    clearBreakpoints()
    {
        let i, dbgAddr;
        this.aBreakExec = ["bp"];
        if (this.aBreakRead !== undefined) {
            for (i = 1; i < this.aBreakRead.length; i++) {
                dbgAddr = this.aBreakRead[i];
                this.cpu.removeMemBreak(this.getAddr(dbgAddr), false, dbgAddr.type == Debuggerx86.ADDRTYPE.PHYSICAL);
            }
        }
        this.aBreakRead = ["br"];
        if (this.aBreakWrite !== undefined) {
            for (i = 1; i < this.aBreakWrite.length; i++) {
                dbgAddr = this.aBreakWrite[i];
                this.cpu.removeMemBreak(this.getAddr(dbgAddr), true, dbgAddr.type == Debuggerx86.ADDRTYPE.PHYSICAL);
            }
        }
        this.aBreakWrite = ["bw"];
        /**
         * nSuppressBreaks ensures we can't get into an infinite loop where a breakpoint lookup requires
         * reading a segment descriptor via getSegment(), and that triggers more memory reads, which triggers
         * more breakpoint checks.
         */
        this.nSuppressBreaks = 0;
    }

    /**
     * addBreakpoint(aBreak, dbgAddr, fTempBreak, fQuiet)
     *
     * In case you haven't already figured this out, all our breakpoint commands use the address
     * to identify a breakpoint, not an incrementally assigned breakpoint index like other debuggers;
     * see doBreak() for details.
     *
     * This has a few implications, one being that you CANNOT set more than one kind of breakpoint
     * on a single address.  In practice, that's rarely a problem, because you can almost always set
     * a different breakpoint on a neighboring address.
     *
     * Also, there is one exception to the "one address, one breakpoint" rule, and that involves
     * temporary breakpoints (ie, one-time execution breakpoints that either a "p" or "g" command
     * may create to step over a chunk of code).  Those breakpoints automatically clear themselves,
     * so there usually isn't any need to refer to them using breakpoint commands.
     *
     * TODO: Consider supporting the more "traditional" breakpoint index syntax; the current
     * address-based syntax was implemented solely for expediency and consistency.  At the same time,
     * also consider a more WDEB386-like syntax, where "br" is used to set a variety of access-specific
     * breakpoints, using modifiers like "r1", "r2", "w1", "w2, etc.
     *
     * @this {Debuggerx86}
     * @param {Array} aBreak
     * @param {DbgAddrx86} dbgAddr
     * @param {boolean} [fTempBreak]
     * @param {boolean} [fQuiet]
     * @returns {boolean} (true if breakpoint added, false if already exists)
     */
    addBreakpoint(aBreak, dbgAddr, fTempBreak, fQuiet)
    {
        let fSuccess = true;

        // this.nSuppressBreaks++;

        /**
         * Instead of complaining that a breakpoint already exists (as we used to do), we now
         * allow breakpoints to be re-set; this makes it easier to update any commands that may
         * be associated with the breakpoint.
         *
         * The only exception: we DO allow a temporary breakpoint at an address where there may
         * already be a breakpoint, so that you can easily step ("p" or "g") over such addresses.
         */
        if (!fTempBreak) {
            this.findBreakpoint(aBreak, dbgAddr, true, false, true);
        }

        if (aBreak != this.aBreakExec) {
            let addr = this.getAddr(dbgAddr);
            if (addr === X86.ADDR_INVALID || !this.cpu.addMemBreak(addr, aBreak == this.aBreakWrite, dbgAddr.type == Debuggerx86.ADDRTYPE.PHYSICAL)) {
                this.printf("invalid address: %s\n", this.toHexAddr(dbgAddr));
                fSuccess = false;
            }
        }

        if (fSuccess) {
            aBreak.push(dbgAddr);
            if (fTempBreak) {
                /**
                 * Force temporary breakpoints to use their linear address, if one is available, by zapping
                 * the selector; this allows us to step over calls or interrupts that change the processor mode.
                 *
                 * TODO: Unfortunately, this will fail to "step" over a call in segment that moves during the call;
                 * consider alternatives.
                 */
                if (dbgAddr.addr != undefined) dbgAddr.sel = undefined;
                dbgAddr.fTempBreak = true;
            }
            else {
                if (!fQuiet) this.printBreakpoint(aBreak, aBreak.length-1, "set");
                this.historyInit();
            }
        }

        // this.nSuppressBreaks--;

        return fSuccess;
    }

    /**
     * findBreakpoint(aBreak, dbgAddr, fRemove, fTempBreak, fQuiet)
     *
     * @this {Debuggerx86}
     * @param {Array} aBreak
     * @param {DbgAddrx86} dbgAddr
     * @param {boolean} [fRemove]
     * @param {boolean} [fTempBreak]
     * @param {boolean} [fQuiet]
     * @returns {boolean} (true if found, false if not)
     */
    findBreakpoint(aBreak, dbgAddr, fRemove, fTempBreak, fQuiet)
    {
        let fFound = false;
        let addr = this.mapBreakpoint(this.getAddr(dbgAddr));
        for (let i = 1; i < aBreak.length; i++) {
            let dbgAddrBreak = aBreak[i];
            if (addr !== X86.ADDR_INVALID && addr == this.mapBreakpoint(this.getAddr(dbgAddrBreak)) ||
                addr === X86.ADDR_INVALID && dbgAddr.sel == dbgAddrBreak.sel && dbgAddr.off == dbgAddrBreak.off) {
                if (!fTempBreak || dbgAddrBreak.fTempBreak) {
                    fFound = true;
                    if (fRemove) {
                        if (!dbgAddrBreak.fTempBreak && !fQuiet) {
                            this.printBreakpoint(aBreak, i, "cleared");
                        }
                        aBreak.splice(i, 1);
                        if (aBreak != this.aBreakExec) {
                            this.cpu.removeMemBreak(addr, aBreak == this.aBreakWrite, dbgAddrBreak.type == Debuggerx86.ADDRTYPE.PHYSICAL);
                        }
                        /**
                         * We'll mirror the logic in addBreakpoint() and leave the history buffer alone if this
                         * was a temporary breakpoint.
                         */
                        if (!dbgAddrBreak.fTempBreak) {
                            this.historyInit();
                        }
                        break;
                    }
                    if (!fQuiet) this.printBreakpoint(aBreak, i, "exists");
                    break;
                }
            }
        }
        return fFound;
    }

    /**
     * listBreakpoints(aBreak)
     *
     * @this {Debuggerx86}
     * @param {Array} aBreak
     * @returns {number} (of breakpoints listed, 0 if none)
     */
    listBreakpoints(aBreak)
    {
        for (let i = 1; i < aBreak.length; i++) {
            this.printBreakpoint(aBreak, i);
        }
        return aBreak.length - 1;
    }

    /**
     * printBreakpoint(aBreak, i, sAction)
     *
     * TODO: We may need to start printing linear addresses also (if any), because segmented address can be ambiguous.
     *
     * @this {Debuggerx86}
     * @param {Array} aBreak
     * @param {number} i
     * @param {string} [sAction]
     */
    printBreakpoint(aBreak, i, sAction)
    {
        let dbgAddr = aBreak[i];
        this.printf("%s %s%s\n", aBreak[0], this.toHexAddr(dbgAddr), (sAction? (' ' + sAction) : (dbgAddr.sCmd? (' "' + dbgAddr.sCmd + '"') : '')));
    }

    /**
     * restoreBreakpoints(aBreak, aDbgAddr)
     *
     * @this {Debuggerx86}
     * @param {Array} aBreak
     * @param {Array} aDbgAddr
     */
    restoreBreakpoints(aBreak, aDbgAddr)
    {
        if (aDbgAddr[0] != aBreak[0]) return;
        for (let i = 1; i < aDbgAddr.length; i++) {
            let dbgAddr = aDbgAddr[i];
            this.addBreakpoint(aBreak, dbgAddr, dbgAddr.fTempBreak, true);
        }
    }

    /**
     * setTempBreakpoint(dbgAddr)
     *
     * @this {Debuggerx86}
     * @param {DbgAddrx86} dbgAddr of new temp breakpoint
     */
    setTempBreakpoint(dbgAddr)
    {
        this.addBreakpoint(this.aBreakExec, dbgAddr, true);
    }

    /**
     * clearTempBreakpoint(addr)
     *
     * @this {Debuggerx86}
     * @param {number|undefined} [addr] clear all temp breakpoints if no address specified
     */
    clearTempBreakpoint(addr)
    {
        if (addr !== undefined) {
            this.checkBreakpoint(addr, 1, this.aBreakExec, true);
            this.nStep = 0;
        } else {
            for (let i = 1; i < this.aBreakExec.length; i++) {
                let dbgAddrBreak = this.aBreakExec[i];
                if (dbgAddrBreak.fTempBreak) {
                    if (!this.findBreakpoint(this.aBreakExec, dbgAddrBreak, true, true)) break;
                    i = 0;
                }
            }
        }
    }

    /**
     * mapBreakpoint(addr)
     *
     * @this {Debuggerx86}
     * @param {number} addr
     * @returns {number}
     */
    mapBreakpoint(addr)
    {
        /**
         * Map addresses in the top 64Kb at the top of the address space (assuming either a 16Mb or 4Gb
         * address space) to the top of the 1Mb range.
         *
         * The fact that those two 64Kb regions are aliases of each other on an 80286 is a pain in the BUTT,
         * because any CS-based breakpoint you set immediately after a CPU reset will have a physical address
         * in the top 16Mb, yet after the first inter-segment JMP, you will be running in the first 1Mb.
         */
        if (addr !== X86.ADDR_INVALID) {
            let mask = (this.maskAddr & ~0xffff);
            if ((addr & mask) == mask) addr &= 0x000fffff;
        }
        return addr;
    }

    /**
     * checkBreakpoint(addr, nb, aBreak, fTempBreak)
     *
     * @this {Debuggerx86}
     * @param {number} addr
     * @param {number} nb (# of bytes)
     * @param {Array} aBreak
     * @param {boolean} [fTempBreak]
     * @returns {boolean} (true if breakpoint has been hit, false if not)
     */
    checkBreakpoint(addr, nb, aBreak, fTempBreak)
    {
        /**
         * Time to check for execution breakpoints; note that this should be done BEFORE updating frequency
         * or history data (see checkInstruction), since we might not actually execute the current instruction.
         */
        let fBreak = false;

        if (!this.nSuppressBreaks++) {

            addr = this.mapBreakpoint(addr);

            /**
             * As discussed in opINT3(), I decided to check for INT3 instructions here: we'll tell the CPU to
             * stop on INT3 whenever both the INT and HALT message bits are set; a simple "g" command allows you
             * to continue.
             */
            if (this.messageEnabled(MESSAGE.INT + MESSAGE.HALT)) {
                if (this.cpu.probeAddr(addr) == X86.OPCODE.INT3) {
                    fBreak = true;
                }
            }

            if (!fBreak && this.checkVectorAddr(addr)) {
                fBreak = true;
            }

            for (let i = 1; !fBreak && i < aBreak.length; i++) {

                let dbgAddrBreak = aBreak[i];

                if (fTempBreak && !dbgAddrBreak.fTempBreak) continue;

                /**
                 * We need to zap the linear address field of the breakpoint address before
                 * calling getAddr(), to force it to recalculate the linear address every time,
                 * unless this is a breakpoint on a linear address (as indicated by a null sel).
                 */
                if (dbgAddrBreak.sel != null) dbgAddrBreak.addr = undefined;

                /**
                 * We used to calculate the linear address of the breakpoint at the time the
                 * breakpoint was added, so that a breakpoint set in one mode (eg, in real-mode)
                 * would still work as intended if the mode changed later (eg, to protected-mode).
                 *
                 * However, that created difficulties setting protected-mode breakpoints in segments
                 * that might not be defined yet, or that could move in physical memory.
                 *
                 * If you want to create a real-mode breakpoint that will break regardless of mode,
                 * use the physical address of the real-mode memory location instead.
                 */
                let addrBreak = this.mapBreakpoint(this.getAddr(dbgAddrBreak));
                for (let n = 0; n < nb; n++) {
                    if (addr + n == addrBreak) {
                        let a;
                        fBreak = true;
                        if (dbgAddrBreak.fTempBreak) {
                            this.findBreakpoint(aBreak, dbgAddrBreak, true, true);
                            /**
                             * If nDebugState is set, then we're dealing with a VxD service breakpoint.
                             */
                            if (dbgAddrBreak.nDebugState) {
                                this.incAddr(dbgAddrBreak, 2);
                                this.addVxDSymbol(dbgAddrBreak.nDebugState, dbgAddrBreak, this.fWinDbg);
                                fBreak = false;
                            }
                            fTempBreak = true;
                        }
                        if ((a = dbgAddrBreak.aCmds)) {
                            /**
                             * When one or more commands are attached to a breakpoint, we don't halt by default.
                             * Instead, we set fBreak to true only if, at the completion of all the commands, the
                             * CPU is halted; in other words, you should include "h" as one of the breakpoint commands
                             * if you want the breakpoint to stop execution.
                             *
                             * Another useful command is "if", which will return false if the expression is false,
                             * at which point we'll jump ahead to the next "else" command, and if there isn't an "else",
                             * we abort.
                             */
                            fBreak = false;
                            for (let j = 0; j < a.length; j++) {
                                if (!this.doCommand(a[j], true)) {
                                    if (a[j].indexOf("if")) {
                                        fBreak = true;          // the failed command wasn't "if", so abort
                                        break;
                                    }
                                    let k = j + 1;
                                    for (; k < a.length; k++) {
                                        if (!a[k].indexOf("else")) break;
                                        j++;
                                    }
                                    if (k == a.length) {        // couldn't find an "else" after the "if", so abort
                                        fBreak = true;
                                        break;
                                    }
                                    /**
                                     * If we're still here, we'll execute the "else" command (which is just a no-op),
                                     * followed by any remaining commands.
                                     */
                                }
                            }
                            if (!this.cpu.isRunning()) fBreak = true;
                        }
                        if (fBreak) {
                            if (!fTempBreak) this.printBreakpoint(aBreak, i, "hit");
                            break;
                        }
                    }
                }
            }
        }
        this.nSuppressBreaks--;
        return fBreak;
    }

    /**
     * addVectorBP(vector, chType)
     *
     * @this {Debuggerx86}
     * @param {number} vector
     * @param {string} chType
     * @returns {boolean} (true if breakpoint added, false if error)
     */
    addVectorBP(vector, chType)
    {
        let i = this.findVectorBP(vector);
        if (i < 0) {
            let dbgAddr;
            let type = (chType == '#' || !chType && this.getCPUMode())? Debuggerx86.ADDRTYPE.PROT : Debuggerx86.ADDRTYPE.REAL;
            if (type != Debuggerx86.ADDRTYPE.PROT) {
                let addr = this.cpu.getLong(vector << 2);
                let off = addr & 0xffff;
                let sel = (addr >> 16) & 0xffff;
                addr = (sel << 4) + off;
                dbgAddr = this.newAddr(off, sel, addr, type);
            }
            this.aVectorBP.push({vector, type, dbgAddr});
            this.listVectorBP(vector, true);
            this.historyInit();
            return true;
        }
        return false;
    }

    /**
     * checkVectorBP(vector, nBytes, fProt)
     *
     * @this {Debuggerx86}
     * @param {number} vector
     * @param {number} nBytes
     * @param {boolean} fProt (true if protected-mode interrupt)
     * @returns {boolean}
     */
    checkVectorBP(vector, nBytes, fProt)
    {
        if (this.vectorSkip < 0) {
            this.vectorTrace = vector;
            if (vector == Interrupts.VxD.VECTOR && fProt && this.fWinDbg !== undefined) {
                let dbgAddr = this.newAddr(this.cpu.getIP(), this.cpu.getCS());
                /**
                 * Since nDebugState is normally only used by addresses stored in the history buffer
                 * (ie, not for breakpoint addresses), we are now going to make an exception to that rule
                 * and store the VxD service ID in nDebugState.  checkBreakpoint() will detect this and
                 * call addVxDSymbol() accordingly, since the service call should be "fixed up" when the
                 * the breakpoint is hit (ie, when the service call is re-executed).
                 */
                dbgAddr.nDebugState = this.getLong(dbgAddr);
                this.incAddr(dbgAddr, -2);
                this.setTempBreakpoint(dbgAddr);
                /**
                 * We also set the CPU's debugCheck flag, to guarantee that the CPU will start calling
                 * checkInstruction(); note that we don't bother with a corresponding setDebugCheck(false)
                 * when the last VxD breakpoint is removed, because debugCheck is automatically updated
                 * at the start of every burst.
                 */
                this.cpu.setDebugCheck(true);
            }
            if (this.vectorHalt) {
                let i = this.findVectorBP(vector);
                if (i >= 0) {
                    let vbp = this.aVectorBP[i];
                    if (fProt == (vbp.type == Debuggerx86.ADDRTYPE.PROT)) {
                        this.printf("break on vector %02X\n", vector);
                        this.stopCPU();
                        if (nBytes) {
                            this.cpu.setIP(this.cpu.getIP() - nBytes);
                            return true;
                        }
                    }
                }
            }
        }
        return false;
    }

    /**
     * checkVectorAddr(addr)
     *
     * @this {Debuggerx86}
     * @param {number} addr
     * @returns {boolean}
     */
    checkVectorAddr(addr)
    {
        if (this.vectorSkip < 0) {
            for (let i = 0; i < this.aVectorBP.length; i++) {
                let dbgAddr = this.aVectorBP[i].dbgAddr;
                if (dbgAddr && dbgAddr.addr == addr) {
                    this.vectorTrace = this.aVectorBP[i].vector;
                    if (this.vectorHalt) {
                        this.printf("break on vector %02X\n", this.vectorTrace);
                        return true;
                    }
                }
            }
        }
        return false;
    }

    /**
     * findVectorBP(vector)
     *
     * @this {Debuggerx86}
     * @param {number} vector
     * @returns {number}
     */
    findVectorBP(vector)
    {
        for (let i = 0; i < this.aVectorBP.length; i++) {
            if (this.aVectorBP[i].vector == vector) {
                return i;
            }
        }
        return -1;
    }

    /**
     * listVectorBP(vector, enabled)
     *
     * @this {Debuggerx86}
     * @param {number} [vector]
     * @param {boolean} [enabled]
     */
    listVectorBP(vector, enabled = true)
    {
        let i;
        for (i = 0; i < this.aVectorBP.length; i++) {
            let vbp = this.aVectorBP[i];
            if (vector == undefined || vbp.vector == vector) {
                let s = (enabled? "enabled" : "disabled");
                if (vbp.type == Debuggerx86.ADDRTYPE.PROT) {
                    this.printf("vector #%02X %s\n", vbp.vector, s);
                } else {
                    this.printf("vector &%02X %s (%04X:%04X)\n", vbp.vector, s, vbp.dbgAddr.sel, vbp.dbgAddr.off);
                }
            }
        }
        if (!i) {
            this.printf("no vector breakpoints\n");
        }
    }

    /**
     * removeVectorBP(vector)
     *
     * @this {Debuggerx86}
     * @param {number} vector
     * @returns {boolean} (true if breakpoint removed, false if error)
     */
    removeVectorBP(vector)
    {
        let i = this.findVectorBP(vector);
        if (i >= 0) {
            this.listVectorBP(vector, false);
            this.aVectorBP.splice(i, 1);
            this.historyInit();
            return true;
        }
        return false;
    }

    /**
     * getInstruction(dbgAddr, sComment, nSequence)
     *
     * @this {Debuggerx86}
     * @param {DbgAddrx86} dbgAddr
     * @param {string} [sComment] is an associated comment
     * @param {number} [nSequence] is an associated sequence number, -1 or undefined if none
     * @returns {string} (and dbgAddr is updated to the next instruction)
     */
    getInstruction(dbgAddr, sComment, nSequence)
    {
        let bModRM = -1;
        let asOpcodes = Debuggerx86.INS_NAMES;
        let dbgAddrIns = this.newAddr(dbgAddr.off, dbgAddr.sel, dbgAddr.addr, dbgAddr.type);

        /**
         * Incorporate segment, operand size, and address size overrides into the current instruction.
         *
         * Note that redundant prefixes must be ignored;  see opOS() and opAS() for details.  We limit the
         * total number of overrides to something reasonable (ie, 8).
         */
        let cMaxOverrides = 8;
        let fDataPrefix = false, fAddrPrefix = false;
        let bOpcode, aOpDesc, iIns, sPrefix = "", sSegment = "";

        do {
            bOpcode = this.getByte(dbgAddr, 1);
            aOpDesc = this.aaOpDescs[bOpcode];
            iIns = aOpDesc[0];
            let type = aOpDesc[1];
            if (type == Debuggerx86.TYPE_PREFIX) {
                if (bOpcode >= X86.OPCODE.LOCK) {
                    sPrefix = asOpcodes[iIns];
                } else {
                    sSegment = asOpcodes[iIns]; // eg, ES:, CS:, SS:, DS:
                }
            }
            else if (type == (Debuggerx86.TYPE_PREFIX | Debuggerx86.TYPE_80386)) {
                if (this.cpu.model < X86.MODEL_80386) break;
                if (bOpcode == X86.OPCODE.OS) {
                    if (!fDataPrefix) {
                        dbgAddr.fData32 = !dbgAddr.fData32;
                        fDataPrefix = true;
                    }
                } else if (bOpcode == X86.OPCODE.AS) {
                    if (!fAddrPrefix) {
                        dbgAddr.fAddr32 = !dbgAddr.fAddr32;
                        fAddrPrefix = true;
                    }
                } else {
                    sSegment = asOpcodes[iIns]; // eg, FS:, GS:
                }
            } else {
                break;
            }
        } while (cMaxOverrides--);

        if (iIns == Debuggerx86.INS.OP0F) {
            let b = this.getByte(dbgAddr, 1);
            aOpDesc = Debuggerx86.aaOp0FDescs[b] || Debuggerx86.aOpDescUndefined;
            bOpcode |= (b << 8);
            iIns = aOpDesc[0];
        }

        if (iIns == Debuggerx86.INS.ESC) {
            bModRM = this.getByte(dbgAddr, 1);
            let aOpFPUDesc = this.getFPUInstruction(bOpcode, bModRM);
            if (aOpFPUDesc) {
                asOpcodes = Debuggerx86.FINS_NAMES;
                aOpDesc = aOpFPUDesc;
                iIns = aOpDesc[0];
            }
        }

        if (iIns >= asOpcodes.length) {
            bModRM = this.getByte(dbgAddr, 1);
            aOpDesc = Debuggerx86.aaGrpDescs[iIns - asOpcodes.length][(bModRM >> 3) & 0x7];
            iIns = aOpDesc[0];
        }

        let sOpcode = asOpcodes[iIns];
        let cOperands = aOpDesc.length - 1;
        let sOperands = "";

        if (dbgAddr.fData32) {
            if (iIns == Debuggerx86.INS.CBW) {
                sOpcode = "CWDE";       // sign-extend AX into EAX, instead of AL into AX
            }
            else if (iIns == Debuggerx86.INS.CWD) {
                sOpcode = "CDQ";        // sign-extend EAX into EDX:EAX, instead of AX into DX:AX
            }
            else if (iIns >= Debuggerx86.INS.POPA && iIns <= Debuggerx86.INS.PUSHA) {
                sOpcode += 'D';         // transform POPA/POPF/PUSHF/PUSHA to POPAD/POPFD/PUSHFD/PUSHAD as appropriate
            }
        }

        if (this.isStringIns(bOpcode)) {
            cOperands = 0;              // suppress operands for string instructions, and add 'D' suffix as appropriate
            if (dbgAddr.fData32 && sOpcode.slice(-1) == 'W') sOpcode = sOpcode.slice(0, -1) + 'D';
        }

        let typeCPU = -1;
        for (let iOperand = 1; iOperand <= cOperands; iOperand++) {

            let disp, off, cch;
            let sOperand = "";
            let type = aOpDesc[iOperand];
            if (type === undefined) continue;

            if (typeCPU < 0) typeCPU = type >> Debuggerx86.TYPE_CPU_SHIFT;

            if (iIns == Debuggerx86.INS.LOADALL) {
                if (typeCPU == Debuggerx86.CPU_80286) {
                    sOperands = "[%800]";
                } else if (typeCPU == Debuggerx86.CPU_80386) {
                    /**
                     * NOTE: The 80386 LOADALL documentation, such as it is, doesn't suggest that segment
                     * overrides are allowed, but then again, it doesn't say they're not; we'll disassemble
                     * it as is, because chances are all legitimate uses of LOADALL in the known universe
                     * don't use an override, and if any do, then presumably that's because it works (or is
                     * ignored).
                     */
                    sOperands = (sSegment || "ES:") + "[" + (dbgAddr.fAddr32? 'E':'') + "DI]";
                }
            }

            let typeSize = type & Debuggerx86.TYPE_SIZE;
            if (typeSize == Debuggerx86.TYPE_NONE) {
                continue;
            }
            let typeMode = type & Debuggerx86.TYPE_MODE;
            if (typeMode >= Debuggerx86.TYPE_MODRM) {
                if (bModRM < 0) {
                    bModRM = this.getByte(dbgAddr, 1);
                }
                if (typeMode < Debuggerx86.TYPE_MODREG) {
                    /**
                     * This test also encompasses TYPE_MODMEM, which is basically the inverse of the case
                     * below (ie, only Mod values *other* than 11 are allowed); however, I believe that in
                     * some cases that's merely a convention, and that if you try to execute an instruction
                     * like "LEA AX,BX", it will actually do something (on some if not all processors), so
                     * there's probably some diagnostic value in allowing those cases to be disassembled.
                     */
                    sOperand = this.getModRMOperand(sOpcode, sSegment, bModRM, type, cOperands, dbgAddr);
                }
                else if (typeMode == Debuggerx86.TYPE_MODREG) {
                    /**
                     * TYPE_MODREG instructions assume that Mod is 11 (only certain early 80486 steppings
                     * actually *required* that Mod contain 11) and always treat RM as a register (which we
                     * could also simulate by setting Mod to 11 and letting getModRMOperand() do its thing).
                     */
                    sOperand = this.getRegOperand(bModRM & 0x7, type, dbgAddr);
                }
                else {
                    /**
                     * All remaining cases are register-based (eg, TYPE_REG); getRegOperand() will figure out which.
                     */
                    sOperand = this.getRegOperand((bModRM >> 3) & 0x7, type, dbgAddr);
                }
            }
            else if (typeMode == Debuggerx86.TYPE_ONE) {
                sOperand = '1';
            }
            else if (typeMode == Debuggerx86.TYPE_IMM) {
                sOperand = this.getImmOperand(type, dbgAddr);
            }
            else if (typeMode == Debuggerx86.TYPE_IMMOFF) {
                if (!dbgAddr.fAddr32) {
                    cch = 4;
                    off = this.getShort(dbgAddr, 2);
                } else {
                    cch = 8;
                    off = this.getLong(dbgAddr, 4);
                }
                sOperand = sSegment + '[' + StrLib.toHex(off, cch) + ']';
            }
            else if (typeMode == Debuggerx86.TYPE_IMMREL) {
                if (typeSize == Debuggerx86.TYPE_BYTE) {
                    disp = ((this.getByte(dbgAddr, 1) << 24) >> 24);
                }
                else {
                    disp = this.getWord(dbgAddr, true);
                }
                off = (dbgAddr.off + disp) & (dbgAddr.fData32? -1 : 0xffff);
                sOperand = StrLib.toHex(off, dbgAddr.fData32? 8: 4);
                let aSymbol = this.findSymbol(this.newAddr(off, dbgAddr.sel));
                if (aSymbol[0]) sOperand += " (" + aSymbol[0] + ")";
            }
            else if (typeMode == Debuggerx86.TYPE_IMPREG) {
                if (typeSize == Debuggerx86.TYPE_ST) {
                    sOperand = "ST";
                } else if (typeSize == Debuggerx86.TYPE_STREG) {
                    sOperand = "ST(" + (bModRM & 0x7) + ")";
                } else {
                    sOperand = this.getRegOperand((type & Debuggerx86.TYPE_IREG) >> 8, type, dbgAddr);
                }
            }
            else if (typeMode == Debuggerx86.TYPE_IMPSEG) {
                sOperand = this.getRegOperand((type & Debuggerx86.TYPE_IREG) >> 8, Debuggerx86.TYPE_SEGREG, dbgAddr);
            }
            else if (typeMode == Debuggerx86.TYPE_DSSI) {
                sOperand = (sSegment || "DS:") + "[SI]";
            }
            else if (typeMode == Debuggerx86.TYPE_ESDI) {
                sOperand = (sSegment || "ES:") + "[DI]";
            }
            if (!sOperand || !sOperand.length) {
                sOperands = "INVALID";
                break;
            }
            if (sOperands.length > 0) sOperands += ',';
            sOperands += (sOperand || "???");
        }

        let sBytes = "";
        let sLine = this.toHexAddr(dbgAddrIns) + ' ';
        if (dbgAddrIns.addr !== X86.ADDR_INVALID && dbgAddr.addr !== X86.ADDR_INVALID) {
            do {
                sBytes += StrLib.toHex(this.getByte(dbgAddrIns, 1), 2);
                if (dbgAddrIns.addr === X86.ADDR_INVALID || dbgAddrIns.addr == undefined) break;
            } while (dbgAddrIns.addr != dbgAddr.addr);
        }

        sLine += StrLib.pad(sBytes, dbgAddrIns.fAddr32? -20 : -16) + ' ';

        if (sPrefix.indexOf("REP") == 0) {
            /**
             * For MOVS, STOS, OUTS, INS (and perhaps also LODS, although that doesn't seem useful), REPZ (0xF3) becomes
             * REP, because the Z flag is ignored.  And apparently, the same is true for REPNZ (0xF2); ie, either prefix can
             * be used.  I considered leaving REPNZ alone, to highlight the uncommon use of that prefix with those instructions,
             * but it doesn't seem that interesting.
             *
             * So, unless the instruction is CMPS or SCAS, just display a simple REP prefix.
             */
            if (bOpcode != X86.OPCODE.CMPSB && bOpcode != X86.OPCODE.CMPSW && bOpcode != X86.OPCODE.SCASB && bOpcode != X86.OPCODE.SCASW) {
                sPrefix = "REP";
            }
        }
        if (sPrefix) {
            sOperands = sOpcode + ' ' + sOperands;
            sOpcode = sPrefix;
        }

        sLine += StrLib.pad(sOpcode, -8);
        if (sOperands) sLine += ' ' + sOperands;

        if (this.cpu.model < Debuggerx86.CPUS[typeCPU]) {
            sComment = Debuggerx86.CPUS[typeCPU] + " CPU only";
        }

        if (sComment) {
            sLine = StrLib.pad(sLine, dbgAddrIns.fAddr32? -74 : -62) + ';' + sComment;
            if (!this.cpu.flags.checksum) {
                sLine += (nSequence >= 0? '=' + nSequence.toString() : "");
            } else {
                let nCycles = this.cpu.getCycles();
                sLine += "cycles=" + nCycles.toString() + " cs=" + StrLib.toHex(this.cpu.nChecksum);
            }
        }

        this.initAddrSize(dbgAddr);
        return sLine;
    }

    /**
     * getFPUInstruction(bOpcode, bModRM)
     *
     * @this {Debuggerx86}
     * @param {number} bOpcode
     * @param {number} bModRM
     * @returns {Array|null} (FPU instruction group, or null if none)
     */
    getFPUInstruction(bOpcode, bModRM)
    {
        let aOpDesc = null;

        let mod = (bModRM >> 6) & 0x3;
        let reg = (bModRM >> 3) & 0x7;
        let r_m = (bModRM & 0x7);

        /**
         * Similar to how opFPU() decodes FPU instructions, we combine mod and reg into one
         * decodable value: put mod in the high nibble and reg in the low nibble, after first
         * collapsing all mod values < 3 to zero.
         */
        let modReg = (mod < 3? 0 : 0x30) + reg;

        /**
         * All values >= 0x34 imply mod == 3 and reg >= 4, so now we shift reg into the high
         * nibble and r_m into the low, yielding values >= 0x40.
         */
        if ((bOpcode == X86.OPCODE.ESC1 || bOpcode == X86.OPCODE.ESC3) && modReg >= 0x34) {
            modReg = (reg << 4) | r_m;
        }

        let aaOpDesc = Debuggerx86.aaaOpFPUDescs[bOpcode];
        if (aaOpDesc) aOpDesc = aaOpDesc[modReg];

        return aOpDesc;
    }

    /**
     * getImmOperand(type, dbgAddr)
     *
     * @this {Debuggerx86}
     * @param {number} type
     * @param {DbgAddrx86} dbgAddr
     * @returns {string} (operand)
     */
    getImmOperand(type, dbgAddr)
    {
        let aSymbol;
        let sOperand = ' ';
        let typeSize = type & Debuggerx86.TYPE_SIZE;

        switch (typeSize) {
        case Debuggerx86.TYPE_BYTE:
            /**
             * There's the occasional immediate byte we don't need to display (eg, the 0x0A
             * following an AAM or AAD instruction), so we suppress the byte if it lacks a TYPE_IN
             * or TYPE_OUT designation (and TYPE_BOTH, as the name implies, includes both).
             */
            if (type & Debuggerx86.TYPE_BOTH) {
                sOperand = StrLib.toHex(this.getByte(dbgAddr, 1), 2);
            }
            break;
        case Debuggerx86.TYPE_SBYTE:
            sOperand = StrLib.toHex((this.getByte(dbgAddr, 1) << 24) >> 24);
            break;
        case Debuggerx86.TYPE_WORD:
            if (dbgAddr.fData32) {
                sOperand = StrLib.toHex(this.getLong(dbgAddr, 4), 8);
                break;
            }
            /* falls through */
        case Debuggerx86.TYPE_SHORT:
            sOperand = StrLib.toHex(this.getShort(dbgAddr, 2), 4);
            break;
        case Debuggerx86.TYPE_FARP:
            dbgAddr = this.newAddr(this.getWord(dbgAddr, true), this.getShort(dbgAddr, 2), undefined, dbgAddr.type, dbgAddr.fData32, dbgAddr.fAddr32);
            sOperand = this.toHexAddr(dbgAddr);
            aSymbol = this.findSymbol(dbgAddr);
            if (aSymbol[0]) sOperand += " (" + aSymbol[0] + ")";
            break;
        default:
            sOperand = "imm(" + StrLib.toHexWord(type) + ')';
            break;
        }
        return sOperand;
    }

    /**
     * getRegOperand(bReg, type, dbgAddr)
     *
     * @this {Debuggerx86}
     * @param {number} bReg
     * @param {number} type
     * @param {DbgAddrx86} dbgAddr
     * @returns {string} (operand)
     */
    getRegOperand(bReg, type, dbgAddr)
    {
        let typeMode = type & Debuggerx86.TYPE_MODE;
        if (typeMode == Debuggerx86.TYPE_SEGREG) {
            if (bReg > Debuggerx86.REG_GS ||
                bReg >= Debuggerx86.REG_FS && this.cpu.model < X86.MODEL_80386) return "??";
            bReg += Debuggerx86.REG_SEG;
        }
        else if (typeMode == Debuggerx86.TYPE_CTLREG) {
            bReg += Debuggerx86.REG_CR0;
        }
        else if (typeMode == Debuggerx86.TYPE_DBGREG) {
            bReg += Debuggerx86.REG_DR0;
        }
        else if (typeMode == Debuggerx86.TYPE_TSTREG) {
            bReg += Debuggerx86.REG_TR0;
        }
        else {
            let typeSize = type & Debuggerx86.TYPE_SIZE;
            if (typeSize >= Debuggerx86.TYPE_SHORT) {
                if (bReg < Debuggerx86.REG_AX) {
                    bReg += Debuggerx86.REG_AX - Debuggerx86.REG_AL;
                }
                if (typeSize == Debuggerx86.TYPE_LONG || typeSize == Debuggerx86.TYPE_WORD && dbgAddr.fData32) {
                    bReg += Debuggerx86.REG_EAX - Debuggerx86.REG_AX;
                }
            }
        }
        return Debuggerx86.REGS[bReg];
    }

    /**
     * getSIBOperand(bMod, dbgAddr)
     *
     * @this {Debuggerx86}
     * @param {number} bMod
     * @param {DbgAddrx86} dbgAddr
     * @returns {string} (operand)
     */
    getSIBOperand(bMod, dbgAddr)
    {
        let bSIB = this.getByte(dbgAddr, 1);
        let bScale = bSIB >> 6;
        let bIndex = (bSIB >> 3) & 0x7;
        let bBase = bSIB & 0x7;
        let sOperand = "";
        /**
         * Unless bMod is zero AND bBase is 5, there's always a base register.
         */
        if (bMod || bBase != 5) {
            sOperand = Debuggerx86.RMS[bBase + 8];
        }
        if (bIndex != 4) {
            if (sOperand) sOperand += '+';
            sOperand += Debuggerx86.RMS[bIndex + 8];
            if (bScale) sOperand += '*' + (0x1 << bScale);
        }
        /**
         * If bMod is zero AND bBase is 5, there's a 32-bit displacement instead of a base register.
         */
        if (!bMod && bBase == 5) {
            if (sOperand) sOperand += '+';
            sOperand += StrLib.toHex(this.getLong(dbgAddr, 4));
        }
        return sOperand;
    }

    /**
     * getModRMOperand(sOpcode, sSegment, bModRM, type, cOperands, dbgAddr)
     *
     * @this {Debuggerx86}
     * @param {string} sOpcode
     * @param {string} sSegment
     * @param {number} bModRM
     * @param {number} type
     * @param {number} cOperands (if 1, memory operands are prefixed with the size; otherwise, size can be inferred)
     * @param {DbgAddrx86} dbgAddr
     * @returns {string} (operand)
     */
    getModRMOperand(sOpcode, sSegment, bModRM, type, cOperands, dbgAddr)
    {
        let sOperand = "";
        let bMod = bModRM >> 6;
        let bRM = bModRM & 0x7;
        if (bMod < 3) {
            let disp;
            let fInteger = (sOpcode.indexOf("FI") == 0);
            if (!bMod && (!dbgAddr.fAddr32 && bRM == 6 || dbgAddr.fAddr32 && bRM == 5)) {
                bMod = 2;
            } else {
                if (dbgAddr.fAddr32) {
                    if (bRM != 4) {
                        bRM += 8;
                    } else {
                        sOperand = this.getSIBOperand(bMod, dbgAddr);
                    }
                }
                if (!sOperand) sOperand = Debuggerx86.RMS[bRM];
            }
            if (bMod == 1) {
                disp = this.getByte(dbgAddr, 1);
                if (!(disp & 0x80)) {
                    sOperand += '+' + StrLib.toHex(disp, 2);
                }
                else {
                    disp = ((disp << 24) >> 24);
                    sOperand += '-' + StrLib.toHex(-disp, 2);
                }
            }
            else if (bMod == 2) {
                if (sOperand) sOperand += '+';
                if (!dbgAddr.fAddr32) {
                    disp = this.getShort(dbgAddr, 2);
                    sOperand += StrLib.toHex(disp, 4);
                } else {
                    disp = this.getLong(dbgAddr, 4);
                    sOperand += StrLib.toHex(disp);
                }
            }
            sOperand = sSegment + '[' + sOperand + ']';
            if (cOperands == 1) {
                let sType = "";
                type &= Debuggerx86.TYPE_SIZE;
                if (type == Debuggerx86.TYPE_WORD) {
                    type = (dbgAddr.fData32? Debuggerx86.TYPE_LONG : Debuggerx86.TYPE_SHORT);
                }
                switch(type) {
                case Debuggerx86.TYPE_FARP:
                    sType = "FAR";
                    break;
                case Debuggerx86.TYPE_BYTE:
                    sType = "BYTE";
                    break;
                case Debuggerx86.TYPE_SHORT:
                    if (fInteger) {
                        sType = "INT16";
                        break;
                    }
                    /* falls through */
                    sType = "WORD";
                    break;
                case Debuggerx86.TYPE_LONG:
                    sType = "DWORD";
                    break;
                case Debuggerx86.TYPE_SINT:
                    if (fInteger) {
                        sType = "INT32";
                        break;
                    }
                    /* falls through */
                case Debuggerx86.TYPE_SREAL:
                    sType = "REAL32";
                    break;
                case Debuggerx86.TYPE_LINT:
                    if (fInteger) {
                        sType = "INT64";
                        break;
                    }
                    /* falls through */
                case Debuggerx86.TYPE_LREAL:
                    sType = "REAL64";
                    break;
                case Debuggerx86.TYPE_TREAL:
                    sType = "REAL80";
                    break;
                case Debuggerx86.TYPE_BCD80:
                    sType = "BCD80";
                    break;
                }
                if (sType) sOperand = sType + ' ' + sOperand;
            }
        }
        else {
            sOperand = this.getRegOperand(bRM, type, dbgAddr);
        }
        return sOperand;
    }

    /**
     * parseInstruction(sOp, sOperand, addr)
     *
     * TODO: Unimplemented.  See parseInstruction() in /machines/osi/c1p/modules/v2/debugger.js for a working implementation.
     *
     * @this {Debuggerx86}
     * @param {string} sOp
     * @param {string|undefined} sOperand
     * @param {DbgAddrx86} dbgAddr of memory where this instruction is being assembled
     * @returns {Array.<number>} (of opcode bytes; if the instruction can't be parsed, the array will be empty)
     */
    parseInstruction(sOp, sOperand, dbgAddr)
    {
        let aOpBytes = [];
        this.printf("not supported yet\n");
        return aOpBytes;
    }

    /**
     * getFlagOutput(sFlag)
     *
     * @this {Debuggerx86}
     * @param {string} sFlag
     * @returns {string} (value of flag)
     */
    getFlagOutput(sFlag)
    {
        let b;
        switch (sFlag) {
        case 'V':
            b = this.cpu.getOF();
            break;
        case 'D':
            b = this.cpu.getDF();
            break;
        case 'I':
            b = this.cpu.getIF();
            break;
        case 'T':
            b = this.cpu.getTF();
            break;
        case 'S':
            b = this.cpu.getSF();
            break;
        case 'Z':
            b = this.cpu.getZF();
            break;
        case 'A':
            b = this.cpu.getAF();
            break;
        case 'P':
            b = this.cpu.getPF();
            break;
        case 'C':
            b = this.cpu.getCF();
            break;
        default:
            b = 0;
            break;
        }
        return sFlag + (b? '1' : '0') + ' ';
    }

    /**
     * getLimitString(l)
     *
     * @this {Debuggerx86}
     * @param {number} l
     * @returns {string}
     */
    getLimitString(l)
    {
        return StrLib.toHex(l, (l & ~0xffff)? 8 : 4);
    }

    /**
     * getRegOutput(iReg)
     *
     * @this {Debuggerx86}
     * @param {number} iReg
     * @returns {string}
     */
    getRegOutput(iReg)
    {
        if (iReg >= Debuggerx86.REG_AX && iReg <= Debuggerx86.REG_DI && this.cchReg > 4) iReg += Debuggerx86.REG_EAX - Debuggerx86.REG_AX;
        let sReg = Debuggerx86.REGS[iReg];
        if (iReg == Debuggerx86.REG_CR0 && this.cpu.model == X86.MODEL_80286) sReg = "MS";
        return sReg + '=' + this.getRegString(iReg) + ' ';
    }

    /**
     * getSegOutput(seg, fProt)
     *
     * @this {Debuggerx86}
     * @param {Segx86} seg
     * @param {boolean} [fProt]
     * @returns {string}
     */
    getSegOutput(seg, fProt)
    {
        return seg.sName + '=' + StrLib.toHex(seg.sel, 4) + (fProt? '[' + StrLib.toHex(seg.base, this.cchAddr) + ',' + this.getLimitString(seg.limit) + ']' : "");
    }

    /**
     * getDTROutput(sName, sel, addr, addrLimit)
     *
     * @this {Debuggerx86}
     * @param {string} sName
     * @param {number|null|*} sel
     * @param {number} addr
     * @param {number} addrLimit
     * @returns {string}
     */
    getDTROutput(sName, sel, addr, addrLimit)
    {
        return sName + '=' + (sel != null? StrLib.toHex(sel, 4) : "") + '[' + StrLib.toHex(addr, this.cchAddr) + ',' + StrLib.toHex(addrLimit - addr, 4) + ']';
    }

    /**
     * getRegDump(fProt)
     *
     * Sample 8086 and 80286 real-mode register dump:
     *
     *      AX=0000 BX=0000 CX=0000 DX=0000 SP=0000 BP=0000 SI=0000 DI=0000
     *      SS=0000 DS=0000 ES=0000 PS=0002 V0 D0 I0 T0 S0 Z0 A0 P0 C0
     *      F000:FFF0 EA5BE000F0    JMP      F000:E05B
     *
     * Sample 80386 real-mode register dump:
     *
     *      EAX=00000000 EBX=00000000 ECX=00000000 EDX=00000000
     *      ESP=00000000 EBP=00000000 ESI=00000000 EDI=00000000
     *      SS=0000 DS=0000 ES=0000 FS=0000 GS=0000 PS=00000002 V0 D0 I0 T0 S0 Z0 A0 P0 C0
     *      F000:FFF0 EA05F900F0    JMP      F000:F905
     *
     * Sample 80286 protected-mode register dump:
     *
     *      AX=0000 BX=0000 CX=0000 DX=0000 SP=0000 BP=0000 SI=0000 DI=0000
     *      SS=0000[000000,FFFF] DS=0000[000000,FFFF] ES=0000[000000,FFFF] A20=ON
     *      CS=F000[FF0000,FFFF] LD=0000[000000,FFFF] GD=[000000,FFFF] ID=[000000,03FF]
     *      TR=0000 MS=FFF0 PS=0002 V0 D0 I0 T0 S0 Z0 A0 P0 C0
     *      F000:FFF0 EA5BE000F0    JMP      F000:E05B
     *
     * Sample 80386 protected-mode register dump:
     *
     *      EAX=00000000 EBX=00000000 ECX=00000000 EDX=00000000
     *      ESP=00000000 EBP=00000000 ESI=00000000 EDI=00000000
     *      SS=0000[00000000,FFFF] DS=0000[00000000,FFFF] ES=0000[00000000,FFFF]
     *      CS=F000[FFFF0000,FFFF] FS=0000[00000000,FFFF] GS=0000[00000000,FFFF]
     *      LD=0000[00000000,FFFF] GD=[00000000,FFFF] ID=[00000000,03FF] TR=0000 A20=ON
     *      CR0=00000010 CR2=00000000 CR3=00000000 PS=00000002 V0 D0 I0 T0 S0 Z0 A0 P0 C0
     *      F000:0000FFF0 EA05F900F0    JMP      F000:0000F905
     *
     * This no longer includes CS in real-mode (or EIP in any mode), because that information can be obtained from the
     * first line of disassembly, which an "r" or "rp" command will also display.
     *
     * Note that even when the processor is in real mode, you can always use the "rp" command to force a protected-mode
     * dump, in case you need to verify any selector base or limit values, since those also affect real-mode operation.
     *
     * @this {Debuggerx86}
     * @param {boolean} [fProt]
     * @returns {string}
     */
    getRegDump(fProt)
    {
        let s;
        if (fProt === undefined) fProt = this.getCPUMode();

        s = this.getRegOutput(Debuggerx86.REG_AX) +
            this.getRegOutput(Debuggerx86.REG_BX) +
            this.getRegOutput(Debuggerx86.REG_CX) +
            this.getRegOutput(Debuggerx86.REG_DX) + (this.cchReg > 4? '\n' : '') +
            this.getRegOutput(Debuggerx86.REG_SP) +
            this.getRegOutput(Debuggerx86.REG_BP) +
            this.getRegOutput(Debuggerx86.REG_SI) +
            this.getRegOutput(Debuggerx86.REG_DI) + '\n' +
            this.getSegOutput(this.cpu.segSS, fProt) + ' ' +
            this.getSegOutput(this.cpu.segDS, fProt) + ' ' +
            this.getSegOutput(this.cpu.segES, fProt) + ' ';

        if (fProt) {
            let sTR = "TR=" + StrLib.toHex(this.cpu.segTSS.sel, 4);
            let sA20 = "A20=" + (this.bus.getA20()? "ON " : "OFF ");
            if (this.cpu.model < X86.MODEL_80386) {
                sTR = '\n' + sTR;
                s += sA20; sA20 = '';
            }
            s += '\n' + this.getSegOutput(this.cpu.segCS, fProt) + ' ';
            if (I386 && this.cpu.model >= X86.MODEL_80386) {
                sA20 += '\n';
                s += this.getSegOutput(this.cpu.segFS, fProt) + ' ' +
                     this.getSegOutput(this.cpu.segGS, fProt) + '\n';
            }
            s += this.getDTROutput("LD", this.cpu.segLDT.sel, this.cpu.segLDT.base, this.cpu.segLDT.base + this.cpu.segLDT.limit) + ' ' +
                 this.getDTROutput("GD", null, this.cpu.addrGDT, this.cpu.addrGDTLimit) + ' ' +
                 this.getDTROutput("ID", null, this.cpu.addrIDT, this.cpu.addrIDTLimit) + ' ';
            s += sTR + ' ' + sA20;
            s += this.getRegOutput(Debuggerx86.REG_CR0);
            if (I386 && this.cpu.model >= X86.MODEL_80386) {
                s += this.getRegOutput(Debuggerx86.REG_CR2) + this.getRegOutput(Debuggerx86.REG_CR3);
            }
        } else {
            if (I386 && this.cpu.model >= X86.MODEL_80386) {
                s += this.getSegOutput(this.cpu.segFS, fProt) + ' ' +
                     this.getSegOutput(this.cpu.segGS, fProt) + ' ';
            }
        }

        s += this.getRegOutput(Debuggerx86.REG_PS) +
             this.getFlagOutput('V') + this.getFlagOutput('D') + this.getFlagOutput('I') + this.getFlagOutput('T') +
             this.getFlagOutput('S') + this.getFlagOutput('Z') + this.getFlagOutput('A') + this.getFlagOutput('P') + this.getFlagOutput('C');

        return s;
    }

    /**
     * comparePairs(p1, p2)
     *
     * @this {Debuggerx86}
     * @param {number|string|Array|Object} p1
     * @param {number|string|Array|Object} p2
     * @returns {number}
     */
    comparePairs(p1, p2)
    {
        return p1[0] > p2[0]? 1 : p1[0] < p2[0]? -1 : 0;
    }

    /**
     * addSymbols(sModule, nSegment, sel, off, addr, len, aSymbols)
     *
     * As fileimage.js (formerly filedump.js, which was formerly convrom.php) explains, aSymbols is a
     * JSON-encoded object whose properties consist of all the symbols (in upper-case), and the values of
     * those properties are objects containing any or all of the following properties:
     *
     *      'v': the value of an absolute (unsized) value
     *      'b': either 1, 2, 4 or undefined if an unsized value
     *      's': either a hard-coded segment or undefined
     *      'o': the offset of the symbol within the associated address space
     *      'l': the original-case version of the symbol, present only if it wasn't originally upper-case
     *      'a': annotation for the specified offset; eg, the original assembly language, with optional comment
     *
     * To that list of properties, we also add:
     *
     *      'p': the physical address (calculated whenever both 's' and 'o' properties are defined)
     *
     * Note that values for any 'v', 'b', 's' and 'o' properties are unquoted decimal values, and the values
     * for any 'l' or 'a' properties are quoted strings. Also, if double-quotes were used in any of the original
     * annotation ('a') values, they will have been converted to two single-quotes, so we're responsible for
     * converting them back to individual double-quotes.
     *
     * For example:
     *      {
     *          'HF_PORT': {
     *              'v':800
     *          },
     *          'HDISK_INT': {
     *              'b':4, 's':0, 'o':52
     *          },
     *          'ORG_VECTOR': {
     *              'b':4, 's':0, 'o':76
     *          },
     *          'CMD_BLOCK': {
     *              'b':1, 's':64, 'o':66
     *          },
     *          'DISK_SETUP': {
     *              'o':3
     *          },
     *          '.40': {
     *              'o':40, 'a':"MOV AX,WORD PTR ORG_VECTOR ;GET DISKETTE VECTOR"
     *          }
     *      }
     *
     * If a symbol only has an offset, then that offset value can be assigned to the symbol property directly:
     *
     *          'DISK_SETUP': 3
     *
     * The last property is an example of an "anonymous" entry, for offsets where there is no associated symbol.
     * Such entries are identified by a period followed by a unique number (usually the offset of the entry), and
     * they usually only contain offset ('o') and annotation ('a') properties.  I could eliminate the leading
     * period, but it offers a very convenient way of quickly discriminating among genuine vs. anonymous symbols.
     *
     * We add all these entries to our internal symbol table, which is an array of 4-element arrays, each of which
     * look like:
     *
     *      [sel, off, addr, len, aSymbols, aOffsets]
     *
     * There are two basic symbol operations: findSymbol(), which takes an address and finds the symbol, if any,
     * at that address, and findSymbolAddr(), which takes a string and attempts to match it to a non-anonymous
     * symbol with a matching offset ('o') property.
     *
     * To implement findSymbol() efficiently, addSymbols() creates an array of [offset, sSymbol] pairs
     * (aOffsets), one pair for each symbol that corresponds to an offset within the specified address space.
     *
     * We guarantee the elements of aOffsets are in offset order, because we build it using binaryInsert();
     * it's quite likely that the MAP file already ordered all its symbols in offset order, but since they're
     * hand-edited files, we can't assume that, and we need to ensure that findSymbol()'s binarySearch() operates
     * properly.
     *
     * @this {Debuggerx86}
     * @param {string|null} sModule
     * @param {number} nSegment (zero if undefined)
     * @param {number} sel (the default segment/selector for all symbols in this group)
     * @param {number} off (from the base of the given selector)
     * @param {number|null|*} addr (physical address where the symbols are located, if the memory is physical; eg, ROM)
     * @param {number} len (the size of the region, in bytes)
     * @param {Object} aSymbols (collection of symbols in this group; the format of this collection is described below)
     */
    addSymbols(sModule, nSegment, sel, off, addr, len, aSymbols)
    {
        let dbgAddr = {};
        let aOffsets = [];
        for (let sSymbol in aSymbols) {
            let symbol = aSymbols[sSymbol];
            if (typeof symbol == "number") {
                aSymbols[sSymbol] = symbol = {'o': symbol};
            }
            let offSymbol = symbol['o'];
            let selSymbol = symbol['s'];
            let sAnnotation = symbol['a'];
            if (offSymbol !== undefined) {
                if (selSymbol !== undefined) {
                    dbgAddr.off = offSymbol;
                    dbgAddr.sel = selSymbol;
                    dbgAddr.addr = undefined;
                    /**
                     * getAddr() computes the corresponding physical address and saves it in dbgAddr.addr.
                     */
                    this.getAddr(dbgAddr);
                    /**
                     * The physical address for any symbol located in the top 64Kb of the machine's address space
                     * should be relocated to the top 64Kb of the first 1Mb, so that we're immune from any changes
                     * to the A20 line.
                     */
                    if ((dbgAddr.addr & ~0xffff) == (this.bus.nBusLimit & ~0xffff)) {
                        dbgAddr.addr &= 0x000fffff;
                    }
                    symbol['p'] = dbgAddr.addr;
                }
                UsrLib.binaryInsert(aOffsets, [offSymbol >>> 0, sSymbol], this.comparePairs);
            }
            if (sAnnotation) symbol['a'] = sAnnotation.replace(/''/g, "\"");
        }
        let symbolTable = {
            sModule: sModule,
            nSegment: nSegment,
            sel: sel,
            off: off,
            addr: addr,
            len: len,
            aSymbols: aSymbols,
            aOffsets: aOffsets
        };
        let iTable = this.aSymbolTable.findIndex(function(symbolTable) {
            return symbolTable.sModule == sModule && symbolTable.nSegment == nSegment;
        });
        if (iTable < 0) iTable = this.aSymbolTable.length;
        this.aSymbolTable[iTable] = symbolTable;
    }

    /**
     * addVxDSymbol(id, dbgAddr, fPrint)
     *
     * @this {Debuggerx86}
     * @param {number} id
     * @param {DbgAddrx86} dbgAddr
     * @param {boolean} [fPrint]
     * @returns {boolean|null} (true if symbol added OR matching symbol already exists, false if not)
     */
    addVxDSymbol(id, dbgAddr, fPrint)
    {
        let idSrv = id & 0xffff;
        let idVxD = (id >> 16) & 0xffff;
        let aVxDs = Object.keys(Interrupts.VxD);
        for (let sVxD of aVxDs) {
            if (idVxD == Interrupts.VxD[sVxD].id) {
                if (Interrupts.VxD[sVxD].fn) {
                    let sService = Interrupts.VxD[sVxD].fn[idSrv];
                    if (sService) {
                        let dbg = this;
                        let addSymbol = function(sSymbol, addr) {
                            let offSymbol = addr >>> 0;
                            let iTable = dbg.aSymbolTable.findIndex(function(symbolTable) {
                                return /* symbolTable.sModule == sVxD */ symbolTable.sel == 0x28 &&
                                        offSymbol >= (symbolTable.off >>> 0) && offSymbol < ((symbolTable.off + symbolTable.len) >>> 0);
                            });
                            if (iTable >= 0) {
                                let keySymbol = sSymbol.toUpperCase();
                                let symbolTable = dbg.aSymbolTable[iTable];
                                let symbol = symbolTable.aSymbols[keySymbol];
                                if (symbol) {
                                    if (symbol['o'] == offSymbol && symbol['s'] == symbolTable.sel) {
                                        return true;
                                    }
                                    dbg.printf(MESSAGE.DEBUG + MESSAGE.ERROR, "%s.%s (%%%X) does not match previous value (%%%X)\n", sVxD, sSymbol, offSymbol, symbol['o']);
                                    return false;
                                }
                                let pair = [offSymbol, keySymbol];
                                let result = UsrLib.binarySearch(symbolTable.aOffsets, pair, dbg.comparePairs);
                                if (result < 0) {
                                    symbolTable.aOffsets.splice(-(result + 1), 0, pair);
                                    symbolTable.aSymbols[keySymbol] = {'o': offSymbol, 's': symbolTable.sel};
                                    if (fPrint && sSymbol[0] != '$') {
                                        dbg.printf(MESSAGE.DEBUG + MESSAGE.LOG, "%s.%s: %%%X\n", sVxD, sSymbol, offSymbol);
                                    }
                                } else {
                                    // dbg.printf(MESSAGE.DEBUG + MESSAGE.WARNING, "%s.%s (%%%X) already has symbol: %s\n", sVxD, sSymbol, offSymbol, symbolTable.aOffsets[result][1]);
                                    symbolTable.aOffsets[result] = pair;
                                    symbolTable.aSymbols[keySymbol] = {'o': offSymbol, 's': symbolTable.sel};
                                }
                                return true;
                            }
                            dbg.printf(MESSAGE.DEBUG + MESSAGE.ERROR, "%s.%s (%%%X) out of range (check %%%X)\n", sVxD, sSymbol, offSymbol, dbgAddr.addr-2);
                            return false;
                        };
                        /**
                         * We actually need to add TWO symbols for every VxD service: one with a prefix (eg, '$') that
                         * represents the jump table entry for the service, and one without the prefix that represents the
                         * initial value in the jump table.
                         */
                        let addr = dbg.getLong(dbgAddr);
                        if (addSymbol('$' + sService, addr)) {
                            dbgAddr.addr = addr;
                            return addSymbol(sService, dbg.getLong(dbgAddr));
                        }
                        return false;
                    }
                    if (idSrv < 32768) {        // TODO: Figure out what the larger service numbers represent
                        this.printf(MESSAGE.DEBUG + MESSAGE.WARNING, "%s service %d: unrecognized (check %%%X)\n", sVxD, idSrv, dbgAddr.addr-2);
                    }
                    return false;
                }
                return false;                   // if our VxD table doesn't have a function list yet, don't bother with a warning
            }
        }
        this.printf(MESSAGE.DEBUG + MESSAGE.WARNING, "VxD %d: unrecognized (check %%%X)\n", idVxD, dbgAddr.addr-2);
        return false;
    }

    /**
     * removeSymbols(sModule, nSegment)
     *
     * @this {Debuggerx86}
     * @param {string|null|*} sModule
     * @param {number} [nSegment] (segment # if sModule set, selector if sModule clear)
     * @returns {string|null} (name of the module removed, or null if no module was found)
     */
    removeSymbols(sModule, nSegment)
    {
        let sModuleRemoved = null;
        for (let iTable = 0; iTable < this.aSymbolTable.length; iTable++) {
            let symbolTable = this.aSymbolTable[iTable];
            if (sModule && symbolTable.sModule != sModule) continue;
            if (sModule && nSegment == symbolTable.nSegment || !sModule && nSegment == symbolTable.sel) {
                sModuleRemoved = symbolTable.sModule;
                this.aSymbolTable.splice(iTable, 1);
                break;
            }
        }
        return sModuleRemoved;
    }

    /**
     * dumpSymbols()
     *
     * TODO: Add "numerical" and "alphabetical" dump options. This is simply dumping them in whatever
     * order they appeared in the original MAP file.
     *
     * @this {Debuggerx86}
     */
    dumpSymbols()
    {
        let cSymbols = 0;
        for (let iTable = 0; iTable < this.aSymbolTable.length; iTable++) {
            let symbolTable = this.aSymbolTable[iTable];
            for (let sSymbol in symbolTable.aSymbols) {
                if (sSymbol.charAt(0) == '.') continue;
                let symbol = symbolTable.aSymbols[sSymbol];
                let offSymbol = symbol['o'];
                if (offSymbol === undefined) continue;
                let selSymbol = symbol['s'];
                if (selSymbol === undefined) selSymbol = symbolTable.sel;
                let sSymbolOrig = symbolTable.aSymbols[sSymbol]['l'];
                if (sSymbolOrig) sSymbol = sSymbolOrig;
                this.printf("%s %s\n", this.toHexOffset(offSymbol, selSymbol), sSymbol);
                cSymbols++;
            }
        }
        if (!cSymbols) this.printf("no symbols\n");
    }

    /**
     * findSymbol(dbgAddr, fNearest)
     *
     * Search aSymbolTable for dbgAddr, and return an Array for the corresponding symbol (empty if not found).
     *
     * If fNearest is true, and no exact match was found, then the Array returned will contain TWO sets of
     * entries: [0]-[3] will refer to closest preceding symbol, and [4]-[7] will refer to the closest subsequent symbol.
     *
     * @this {Debuggerx86}
     * @param {DbgAddrx86} dbgAddr
     * @param {boolean} [fNearest]
     * @returns {Array} (where [0] == symbol name, [1] == symbol value, [2] == any annotation, and [3] == any associated comment)
     */
    findSymbol(dbgAddr, fNearest)
    {
        let aSymbol = [];
        let offSymbol = dbgAddr.off >>> 0;
        let addrSymbol = this.getAddr(dbgAddr) >>> 0;
        for (let iTable = 0; iTable < this.aSymbolTable.length; iTable++) {
            let symbolTable = this.aSymbolTable[iTable];
            let sel = symbolTable.sel;
            let off = symbolTable.off >>> 0;
            let addr = symbolTable.addr;
            if (addr != null) addr >>>= 0;
            let len = symbolTable.len;
            if (sel == 0x30) sel = 0x28;        // TODO: Remove this hack once we're able to differentiate Windows 95 ring 0 code and data
            if (sel == dbgAddr.sel && offSymbol >= off && offSymbol < off + len || addr != null && addrSymbol >= addr && addrSymbol < addr + len) {
                let result = UsrLib.binarySearch(symbolTable.aOffsets, [offSymbol], this.comparePairs);
                if (result >= 0) {
                    this.returnSymbol(iTable, result, aSymbol);
                }
                else if (fNearest) {
                    result = ~result;
                    this.returnSymbol(iTable, result-1, aSymbol);
                    this.returnSymbol(iTable, result, aSymbol);
                }
                break;
            }
        }
        if (!aSymbol.length) {
            let sSymbol = this.bus.getSymbol(addrSymbol, true);
            if (sSymbol) {
                aSymbol.push(sSymbol);
                aSymbol.push(addrSymbol);
            }
        }
        return aSymbol;
    }

    /**
     * findSymbolAddr(sSymbol)
     *
     * Search aSymbolTable for sSymbol, and if found, return a dbgAddr (same as parseAddr())
     *
     * @this {Debuggerx86}
     * @param {string} sSymbol
     * @returns {DbgAddrx86|undefined}
     */
    findSymbolAddr(sSymbol)
    {
        let dbgAddr;
        if (sSymbol.match(/^[a-z_][a-z0-9_]*$/i)) {
            let sUpperCase = sSymbol.toUpperCase();
            for (let iTable = 0; iTable < this.aSymbolTable.length; iTable++) {
                let symbolTable = this.aSymbolTable[iTable];
                let symbol = symbolTable.aSymbols[sUpperCase];
                if (symbol !== undefined) {
                    let offSymbol = symbol['o'];
                    if (offSymbol !== undefined) {
                        /**
                         * We assume that every ROM is ORG'ed at 0x0000, and therefore unless the symbol has an
                         * explicitly-defined segment, we return the segment associated with the entire group; for
                         * a ROM, that segment is normally "addrROM >>> 4".  Down the road, we may want/need to
                         * support a special symbol entry (eg, ".ORG") that defines an alternate origin.
                         */
                        let selSymbol = symbol['s'];
                        if (selSymbol === undefined) selSymbol = symbolTable.sel;
                        dbgAddr = this.newAddr(offSymbol, selSymbol, symbol['p']);
                    }
                    /**
                     * The symbol matched, but it wasn't for an address (no 'o' offset), and there's no point
                     * looking any farther, since each symbol appears only once, so we indicate it's an unknown symbol.
                     */
                    break;
                }
            }
        }
        return dbgAddr;
    }

    /**
     * returnSymbol(iTable, iOffset, aSymbol)
     *
     * Helper function for findSymbol().
     *
     * @param {number} iTable
     * @param {number} iOffset
     * @param {Array} aSymbol (updated with the specified symbol, if it exists)
     */
    returnSymbol(iTable, iOffset, aSymbol)
    {
        let symbol = {};
        let aOffsets = this.aSymbolTable[iTable].aOffsets;
        let offset = 0, sSymbol = null;
        if (iOffset >= 0 && iOffset < aOffsets.length) {
            offset = aOffsets[iOffset][0];
            sSymbol = aOffsets[iOffset][1];
        }
        if (sSymbol) {
            symbol = this.aSymbolTable[iTable].aSymbols[sSymbol];
            sSymbol = (sSymbol.charAt(0) == '.'? null : (symbol['l'] || sSymbol));
        }
        aSymbol.push(sSymbol);
        aSymbol.push(offset);
        aSymbol.push(symbol['a']);
        aSymbol.push(symbol['c']);
    }

    /**
     * doHelp()
     *
     * @this {Debuggerx86}
     */
    doHelp()
    {
        let s = "debugger commands:";
        for (let sCommand in Debuggerx86.COMMANDS) {
            s += '\n  ' + StrLib.pad(sCommand, -7) + Debuggerx86.COMMANDS[sCommand];
        }
        if (!this.checksEnabled()) s += "\nnote: frequency/history disabled if no exec breakpoints";
        this.printf("%s\n", s);
    }

    /**
     * doAssemble(asArgs)
     *
     * This always receives the complete argument array, where the order of the arguments is:
     *
     *      [0]: the assemble command (assumed to be "a")
     *      [1]: the target address (eg, "200")
     *      [2]: the operation code, aka instruction name (eg, "adc")
     *      [3]: the operation mode operand, if any (eg, "14", "[1234]", etc)
     *
     * The Debugger enters "assemble mode" whenever only the first (or first and second) arguments are present.
     * As long as "assemble mode is active, the user can omit the first two arguments on all later assemble commands
     * until "assemble mode" is cancelled with an empty command line; the command processor automatically prepends "a"
     * and the next available target address to the argument array.
     *
     * Entering "assemble mode" is optional; one could enter a series of fully-qualified assemble commands; eg:
     *
     *      a ff00 cld
     *      a ff01 ldx 28
     *      ...
     *
     * without ever entering "assemble mode", but of course, that requires more typing and doesn't take advantage
     * of automatic target address advancement (see dbgAddrAssemble).
     *
     * NOTE: As the previous example implies, you can even assemble new instructions into ROM address space;
     * as our setByte() function explains, the ROM write-notification handlers only refuse writes from the CPU.
     *
     * @this {Debuggerx86}
     * @param {Array.<string>} asArgs is the complete argument array, beginning with the "a" command in asArgs[0]
     */
    doAssemble(asArgs)
    {
        let dbgAddr = this.parseAddr(asArgs[1], true);
        if (!dbgAddr) return;

        this.dbgAddrAssemble = dbgAddr;
        if (asArgs[2] === undefined) {
            this.printf("begin assemble at %s\n", this.toHexAddr(dbgAddr));
            this.fAssemble = true;
            this.cpu.updateCPU();
            return;
        }

        let aOpBytes = this.parseInstruction(asArgs[2], asArgs[3], dbgAddr);
        if (aOpBytes.length) {
            for (let i = 0; i < aOpBytes.length; i++) {
                this.setByte(dbgAddr, aOpBytes[i], 1);
            }
            /**
             * Since getInstruction() also updates the specified address, dbgAddrAssemble is automatically advanced.
             */
            this.printf("%s\n", this.getInstruction(this.dbgAddrAssemble));
        }
    }

    /**
     * doBreak(asArgs, sLine)
     *
     * As the "help" output below indicates, the following breakpoint commands are supported:
     *
     *      bp [a]  set exec breakpoint on linear addr [a]
     *      br [a]  set read breakpoint on linear addr [a]
     *      bw [a]  set write breakpoint on linear addr [a]
     *      bc [a]  clear breakpoint on linear addr [a] (use "*" for all breakpoints)
     *      bl      list breakpoints
     *
     * to which we have recently added the following I/O breakpoint commands:
     *
     *      bi [p]  toggle input breakpoint on port [p] (use "*" for all input ports)
     *      bo [p]  toggle output breakpoint on port [p] (use "*" for all output ports)
     *
     * These two new commands operate as toggles so that if "*" is used to trap all input (or output),
     * you can also use these commands to NOT trap specific ports.
     *
     *      bn [n]  break after [n] instructions
     *
     * TODO: Update the "bl" command to include any/all I/O breakpoints, and the "bc" command to
     * clear them.  Because "bi" and "bo" commands are piggy-backing on Bus functions, those breakpoints
     * are currently outside the realm of what the "bl" and "bc" commands are aware of.
     *
     * @this {Debuggerx86}
     * @param {Array.<string>} asArgs
     * @param {string} [sLine] (the complete command-line)
     */
    doBreak(asArgs, sLine)
    {
        let sCmd = asArgs.shift();
        let sAddr = asArgs.shift();
        if (sAddr == '?') {
            this.printf("breakpoint commands:\n");
            this.printf("\tbi [p]\ttoggle break on input port [p]\n");
            this.printf("\tbo [p]\ttoggle break on output port [p]\n");
            this.printf("\tbp [a]\tset exec breakpoint at addr [a]\n");
            this.printf("\tbr [a]\tset read breakpoint at addr [a]\n");
            this.printf("\tbw [a]\tset write breakpoint at addr [a]\n");
            this.printf("\tbc [a]\tclear breakpoint at addr [a]\n");
            this.printf("\tbl\tlist all breakpoints\n");
            this.printf("\tbn [n]\tbreak after [n] instruction(s)\n");
            this.printf("\tbv [n]\ttoggle break on interrupt vector [n]\n");
            return;
        }
        let sParm = sCmd.charAt(1);
        if (sParm == 'l') {
            let cBreaks = 0;
            cBreaks += this.listBreakpoints(this.aBreakExec);
            cBreaks += this.listBreakpoints(this.aBreakRead);
            cBreaks += this.listBreakpoints(this.aBreakWrite);
            if (!cBreaks) this.printf("no breakpoints\n");
            return;
        }
        if (sParm == 'n') {
            this.nBreakIns = this.parseValue(sAddr);
            this.printf("break after %d instruction(s)\n", this.nBreakIns);
            return;
        }
        if (sParm == 'v') {
            if (!sAddr) {
                this.listVectorBP();
                return;
            }
            do {
                let chType = sAddr[0];
                if (chType == '&' || chType == '#') {
                    sAddr = sAddr.slice(1);
                } else {
                    chType = '';
                }
                let vector = this.parseValue(sAddr);
                if (vector != undefined) {
                    if (this.removeVectorBP(vector)) {
                        continue;
                    }
                    if (this.addVectorBP(vector, chType)) {
                        continue;
                    }
                }
                this.printf("vector %s invalid\n", sAddr);
                break;
            } while ((sAddr = asArgs.shift()));
            return;
        }
        if (sAddr === undefined) {
            this.printf("missing breakpoint address\n");
            return;
        }
        let dbgAddr = {};
        if (sAddr != '*') {
            dbgAddr = this.parseAddr(sAddr, true, true);
            if (!dbgAddr) return;
        }

        sAddr = (dbgAddr.off == null? sAddr : StrLib.toHexWord(dbgAddr.off));

        if (sParm == 'c') {
            if (dbgAddr.off == null) {
                this.clearBreakpoints();
                this.printf("all breakpoints cleared\n");
                return;
            }
            if (this.findBreakpoint(this.aBreakExec, dbgAddr, true)) return;
            if (this.findBreakpoint(this.aBreakRead, dbgAddr, true)) return;
            if (this.findBreakpoint(this.aBreakWrite, dbgAddr, true)) return;
            this.printf("breakpoint missing: %s\n", this.toHexAddr(dbgAddr));
            return;
        }

        if (sParm == 'i') {
            this.printf("breakpoint %s: port %s (input)\n", (this.bus.addPortInputBreak(dbgAddr.off)? "enabled" : "cleared"), sAddr);
            return;
        }

        if (sParm == 'o') {
            this.printf("breakpoint %s: port %s (output)\n", (this.bus.addPortOutputBreak(dbgAddr.off)? "enabled" : "cleared"), sAddr);
            return;
        }

        if (dbgAddr.off == null) return;

        this.parseAddrOptions(dbgAddr, sLine);

        if (sParm == 'p') {
            this.addBreakpoint(this.aBreakExec, dbgAddr);
            return;
        }
        if (sParm == 'r') {
            this.addBreakpoint(this.aBreakRead, dbgAddr);
            return;
        }
        if (sParm == 'w') {
            this.addBreakpoint(this.aBreakWrite, dbgAddr);
            return;
        }
        this.printf("unknown breakpoint command: %s\n", sParm);
    }

    /**
     * doClear(sCmd)
     *
     * @this {Debuggerx86}
     * @param {string} [sCmd] (eg, "cls" or "clear")
     */
    doClear(sCmd)
    {
        this.cmp.clearPanel();
    }

    /**
     * doDump(asArgs)
     *
     * For memory dumps, the second parameter (sLen) is interpreted as a length (by default, in hex)
     * only if it contains an 'l' prefix; otherwise it's interpreted as an ending address (inclusive).
     *
     * @this {Debuggerx86}
     * @param {Array.<string>} asArgs (formerly sCmd, [sAddr], [sLen] and [sBytes])
     */
    doDump(asArgs)
    {
        let m;
        let sCmd = asArgs[0];
        let sAddr = asArgs[1];
        let sLen = asArgs[2];
        let sBytes = asArgs[3];

        if (sAddr == '?') {
            let sDumpers = "";
            for (m in MESSAGE.NAMES) {
                if (this.afnDumpers[m]) {
                    if (sDumpers) sDumpers += ',';
                    sDumpers += m;
                }
            }
            sDumpers += ",state,symbols";
            this.printf("dump memory commands:\n");
            this.printf("\tda [a] [#]    dump # ASCII chars at address a\n");
            this.printf("\tdb [a] [#]    dump # bytes at address a\n");
            this.printf("\tdw [a] [#]    dump # words at address a\n");
            this.printf("\tdd [a] [#]    dump # dwords at address a\n");
            this.printf("\tdh [n] [#]    dump # instructions from history n\n");
            this.printf("\tdi [#]        dump descriptor info for IDT #\n");
            this.printf("\tds [#]        dump descriptor info for selector #\n");
            if (BACKTRACK) {
                this.printf("\tdt [a]        dump backtrack info for address a\n");
            }
            this.printf("\tdby,dwy,ddy   dump data in binary\n");
            if (sDumpers.length) this.printf("dump extension commands:\n\t%s\n", sDumpers);
            return;
        }

        if (sAddr == "state") {
            let sState = this.cmp.powerOff(true);
            if (!sState) {
                this.printf("powerOff() error\n");
            }
            else if (sLen == "console") {
                /**
                 * Console buffers are notoriously small, and even the following code, which breaks the
                 * data into parts (eg, "d state console 1", "d state console 2", etc) just isn't that helpful.
                 *
                 *      let nPart = +sBytes;
                 *      if (nPart) sState = sState.substr(1000000 * (nPart-1), 1000000);
                 *
                 * So, the best way to capture a large machine state is to use the new "Save Machine" link
                 * that downloads a machine's entire state.  Alternatively, run your own local server and use
                 * server-side storage.  Take a look at the "Save" binding in computer.js, which binds an HTML
                 * control to the computer.powerOff() and computer.saveServerState() functions.
                 */
                console.log(sState);
            } else {
                this.doClear();
                this.printf("%s\n", sState);
            }
            return;
        }

        if (sAddr == "symbols") {
            this.dumpSymbols();
            return;
        }

        /**
         * Transform a "ds" command into a "d desc" command (simply as shorthand); ditto for "dg" and "dl",
         * only because that's the syntax that WDEB386 used.  I'm uncertain what WDEB386 would do with an LDT
         * selector passed to "dg" or a GDT selector passed to "dl" (because I'm too lazy to check right now),
         * but that seems nonsensical.
         */
        if (sCmd == "ds" || sCmd == "dg" || sCmd == "dl") {
            sCmd = "d";
            asArgs = [sCmd, "desc", sAddr];
        }

        /**
         * Handle the "dp" (aka "d page") commands here.
         */
        if (sCmd == "d" && sAddr == "page") {
            sCmd = "dp";
            asArgs.shift();
        }
        if (sCmd == "dp") {
            asArgs.shift();
            this.dumpPage(asArgs);
            return;
        }

        if (sCmd == "d") {
            /**
             * Transform a "d disk" command into a "l json" command (TODO: Register a dumper for "disk" instead?)
             */
            if (sAddr == "disk") {
                asArgs[0] = "l";
                asArgs[1] = "json";
                this.doLoad(asArgs);
                return;
            }
            for (m in MESSAGE.NAMES) {
                if (asArgs[1] == m) {
                    let fnDumper = this.afnDumpers[m];
                    if (fnDumper) {
                        asArgs.shift();
                        asArgs.shift();
                        fnDumper(asArgs);
                    } else {
                        this.printf("no dump registered for %s\n", sAddr);
                    }
                    return;
                }
            }
            if (!sAddr) sCmd = this.sCmdDumpPrev || "db";
        }

        if (sCmd == "dh") {
            this.dumpHistory(sAddr, sLen, sBytes);
            return;
        }

        if (sCmd == "di") {
            asArgs.shift();
            this.dumpIDT(asArgs);
            return;
        }

        if (sCmd == "dt") {
            asArgs.shift();
            let sInfo = this.dumpBackTrack(asArgs);
            this.printf("%s\n", sInfo);
            return;
        }

        if (sCmd[1] && "abwd".indexOf(sCmd[1]) < 0) {
            this.printf("unrecognized dump command\n");
            return;
        }

        this.sCmdDumpPrev = sCmd;

        let dbgAddr = this.parseAddr(sAddr);
        if (!dbgAddr || dbgAddr.sel == null && dbgAddr.addr == null) return;

        let len = 0;
        if (sLen) {
            if (sLen.charAt(0) == 'l') {
                sLen = sLen.substr(1) || sBytes;
                len = this.parseValue(sLen);
            } else {
                let dbgAddrEnd = this.parseAddr(sLen);
                if (!dbgAddrEnd) return;
                /**
                 * To be more DEBUG-like, when an ending address is used instead of a length, we treat it inclusively, hence the "+ 1".
                 */
                if (dbgAddr.type != Debuggerx86.ADDRTYPE.LINEAR) {
                    len = dbgAddrEnd.off - dbgAddr.off + 1;
                } else {
                    len = dbgAddrEnd.addr - dbgAddr.addr + 1;
                }
            }
            if (len < 0 || len > 0x10000) len = 0;
        }

        let sDump = "", fASCII = false, cchBinary = 0;
        let size = (sCmd[1] == 'd'? 4 : (sCmd[1] == 'w'? 2 : 1));
        let cb = (size * len) || 128;
        let cLines = ((cb + 15) >> 4) || 1;
        let cbLine = (size == 4? 16 : this.nBase);  // the base also happens to be a reasonable number of bytes/line

        /**
         * The "da" variation uses a line size of 160 bytes, because that's the number of characters
         * per line in a text frame buffer; if no ending address or length is specified, the number of
         * lines defaults to 25 (the typical number of visible lines in a frame buffer).
         *
         * Beyond that, the command doesn't make any other assumptions about the memory format.  Video
         * frame buffers usually dump nicely because all the attribute bytes tend to be non-ASCII.
         */
        if (sCmd[1] == 'a') {
            fASCII = true;
            cbLine = 160;
            cLines = (len <= 1? 25 : Math.ceil(len / cbLine));
            cb = cLines * cbLine;
        }
        else if (sCmd[2] == 'y') {
            cbLine = size;
            if (!len) cb = 8;
            cLines = cb;
            cchBinary = size * 8;
        }

        while (cLines-- && cb > 0) {
            let data = 0, iByte = 0, i;
            let sData = "", sChars = "";
            sAddr = this.toHexAddr(dbgAddr);
            for (i = cbLine; i > 0 && cb > 0; i--) {
                let b = this.getByte(dbgAddr, 1);
                data |= (b << (iByte++ << 3));
                if (iByte == size) {
                    sData += (this.nBase == 8? StrLib.toOct(data, size * 3) : StrLib.toHex(data, size * 2));
                    sData += (size == 1? (i == 9? '-' : ' ') : "  ");
                    if (cchBinary) sChars += StrLib.toBin(data, cchBinary);
                    data = iByte = 0;
                }
                if (!cchBinary) sChars += (b >= 32 && b < 127? String.fromCharCode(b) : (fASCII? '' : '.'));
                cb--;
            }
            if (sDump) sDump += '\n';
            if (fASCII) {
                sDump += sChars;
            } else {
                sDump += sAddr + "  " + sData + StrLib.pad(sChars, sChars.length + i * 3 + 1);
            }
        }
        if (sDump) this.print(sDump.replace(/\s*$/, "") + "\n");
        this.dbgAddrNextData = dbgAddr;
    }

    /**
     * doEdit(asArgs)
     *
     * @this {Debuggerx86}
     * @param {Array.<string>} asArgs
     */
    doEdit(asArgs)
    {
        let sAddr = asArgs[1];
        if (sAddr == null) {
            this.printf("edit memory commands:\n");
            this.printf("\teb [a] [...]  edit bytes at address a\n");
            this.printf("\tew [a] [...]  edit words at address a\n");
            return;
        }
        let dbgAddr = this.parseAddr(sAddr);
        if (!dbgAddr) return;

        /**
         * Use "ev b000:0000" to fill MDA video memory with test data (and "ev b800:0000" to fill CGA video memory).
         */
        if (asArgs[0] == "ev") {
            for (let i = 0; i < 256; i++) {
                let sHex = StrLib.toHex(i, 2);
                if (i && !(i & 0xf)) this.incAddr(dbgAddr, 64);
                this.setShort(dbgAddr, (i << 8) | sHex.charCodeAt(0), 2, true);
                this.setShort(dbgAddr, (i << 8) | sHex.charCodeAt(1), 2, true);
                this.setShort(dbgAddr, (i << 8) | 0x20, 2, i < 255);
            }
            return;
        }

        let size = 1;
        let mask = 0xff;
        let fnGet = this.getByte;
        let fnSet = this.setByte;
        if (asArgs[0] == "ew") {
            size = 2;
            mask = 0xffff;
            fnGet = this.getShort;
            fnSet = this.setShort;
        }

        let cch = size << 1;
        let fASCII = false;
        for (let i = 2; i < asArgs.length; i++) {
            let sArg = asArgs[i];
            /**
             * Now that all debugger commands go through parseCommand(), we can accept interesting commands like this:
             *
             *      ew b800:0 "Happy Birthday"
             *
             * and the quoted string will arrive as a single argument.  We now parse such a string into a series of byte
             * values, and additionally, if you're using "ew" instead of "eb", only the low byte of every word will be
             * updated.  This is what we call ASCII replacement mode (fASCII is true), which ends as soon as we encounter
             * the empty string that we add to the end of the series.
             */
            if (sArg[0] == '"' || sArg[0] == "'") {
                let asNum = [];
                for (let j = 1; j < sArg.length; j++) {
                    let ch = sArg[j];
                    if (ch == sArg[0]) break;
                    asNum.push(StrLib.toHexByte(ch.charCodeAt(0)));
                }
                asNum.push("");
                asArgs.splice(i, 1, ...asNum);
                sArg = asArgs[i];
                fASCII = true;
            }
            if (!sArg) {
                fASCII = false;
                continue;
            }
            let vNew = this.parseExpression(sArg);
            if (vNew === undefined) {
                this.printf("unrecognized value: %s\n", sArg);
                break;
            }
            if (vNew & ~mask) {
                this.printf("warning: %x exceeds %s-byte value\n", vNew, size);
            }
            let vOld = fnGet.call(this, dbgAddr);
            if (fASCII) vNew = (vOld & ~0xff) | (vNew & 0x7f);
            this.printf("changing %s from %#0*x to %#0*x\n", this.toHexAddr(dbgAddr), cch, vOld, cch, vNew);
            fnSet.call(this, dbgAddr, vNew, size);
        }
    }

    /**
     * doFreqs(sParm)
     *
     * @this {Debuggerx86}
     * @param {string|undefined} sParm
     */
    doFreqs(sParm)
    {
        if (sParm == '?') {
            this.printf("frequency commands:\n");
            this.printf("\tclear\tclear all frequency counts\n");
            return;
        }
        let i;
        let cData = 0;
        if (this.aaOpcodeCounts) {
            if (sParm == "clear") {
                for (i = 0; i < this.aaOpcodeCounts.length; i++) {
                    this.aaOpcodeCounts[i] = [i, 0];
                }
                this.printf("frequency data cleared\n");
                cData++;
            }
            else if (sParm !== undefined) {
                this.printf("unknown frequency command: %s\n", sParm);
                cData++;
            }
            else {
                let aaSortedOpcodeCounts = this.aaOpcodeCounts.slice();
                aaSortedOpcodeCounts.sort(function(p, q) {
                    return q[1] - p[1];
                });
                for (i = 0; i < aaSortedOpcodeCounts.length; i++) {
                    let bOpcode = aaSortedOpcodeCounts[i][0];
                    let cFreq = aaSortedOpcodeCounts[i][1];
                    if (cFreq) {
                        this.printf("%s (%#04x): %d times\n", (Debuggerx86.INS_NAMES[this.aaOpDescs[bOpcode][0]] + "  ").substr(0, 5), bOpcode, cFreq);
                        cData++;
                    }
                }
            }
        }
        if (!cData) {
            this.printf("no frequency data available\n");
        }
    }

    /**
     * doHalt(fQuiet)
     *
     * @this {Debuggerx86}
     * @param {boolean} [fQuiet]
     */
    doHalt(fQuiet)
    {
        if (!this.stopCPU()) {
            if (this.isBusy(true)) return;
            if (!fQuiet) this.printf("already halted\n");
        }
    }

    /**
     * doIf(sCmd, fQuiet)
     *
     * NOTE: Don't forget that the default base for all numeric constants is 16 (hex), so when you evaluate
     * an expression like "a==10", it will compare the value of the variable "a" to 0x10; use a trailing period
     * (eg, "10.") if you really intend decimal.
     *
     * Also, if no variable named "a" exists, "a" will evaluate to 0x0A, so the expression "a==10" becomes
     * "0x0A==0x10" (false), whereas the expression "a==10." becomes "0x0A==0x0A" (true).
     *
     * @this {Debuggerx86}
     * @param {string} sCmd
     * @param {boolean} [fQuiet]
     * @returns {boolean} (true if expression is non-zero, false if zero (or undefined due to a parse error))
     */
    doIf(sCmd, fQuiet)
    {
        sCmd = StrLib.trim(sCmd);
        if (!this.parseExpression(sCmd)) {
            if (!fQuiet) this.printf("false: %s\n", sCmd);
            return false;
        }
        if (!fQuiet) this.printf("true: %s\n", sCmd);
        return true;
    }

    /**
     * doInfo(asArgs)
     *
     * @this {Debuggerx86}
     * @param {Array.<string>} asArgs
     * @returns {boolean} (true only if the instruction info command ("n") is supported)
     */
    doInfo(asArgs)
    {
        if (DEBUG) {
            this.printf("msPerYield: %d\n", this.cpu.msPerYield);
            this.printf("nCyclesPerYield: %d\n", this.cpu.nCyclesPerYield);
            return true;
        }
        return false;
    }

    /**
     * doInput(sPort)
     *
     * Simulate a 1-byte port input operation.
     *
     * @this {Debuggerx86}
     * @param {string|undefined} sPort
     */
    doInput(sPort)
    {
        if (!sPort || sPort == '?') {
            this.printf("input commands:\n");
            this.printf("\ti [p]\tread port [p]\n");
            /**
             * TODO: Regarding this warning, consider adding an "unchecked" version of
             * bus.checkPortInputNotify(), since all Debugger memory accesses are unchecked, too.
             *
             * All port I/O handlers ARE aware when the Debugger is calling (addrFrom is undefined),
             * but changing them all to be non-destructive would take time, and situations where you
             * actually want to affect the hardware state are just as likely as not....
             */
            this.printf("warning: port accesses can affect hardware state\n");
            return;
        }
        let port = this.parseValue(sPort);
        if (port !== undefined) {
            let bIn = this.bus.checkPortInputNotify(port, 1);
            this.printf("%#06x: %#04x\n", port, bIn);
        }
    }

    /**
     * doInt(sInt)
     *
     * Displays information about the given software interrupt (assuming that said interrupt is in progress).
     *
     * These messages also reset the system variable $ops (by updating cOpcodesStart), to make it easier to see
     * how many opcodes were executed since these interrupts "started".
     *
     * @this {Debuggerx86}
     * @param {string|undefined} sInt
     * @returns {boolean} (true if successful, false if not)
     */
    doInt(sInt)
    {
        switch(this.parseValue(sInt)) {
        case 0x13:
            this.messageInt(Interrupts.DISK, this.cpu.regLIP, true);
            this.cOpcodesStart = this.cOpcodes;
            return true;
        case 0x21:
            this.messageInt(Interrupts.DOS, this.cpu.regLIP, true);
            this.cOpcodesStart = this.cOpcodes;
            return true;
        default:
            return false;
        }
    }

    /**
     * doVar(sCmd)
     *
     * The command must be of the form "{variable} = [{expression}]", where expression may contain constants,
     * operators, registers, symbols, other variables, or nothing at all; in the latter case, the variable, if
     * any, is deleted.
     *
     * Other supported shorthand: "var" with no parameters prints the values of all variables, and "let {variable}"
     * prints the value of the specified variable.
     *
     * @this {Debuggerx86}
     * @param {string} sCmd
     * @returns {boolean} (true if valid "var" assignment, false if not)
     */
    doVar(sCmd)
    {
        let a = sCmd.match(/^\s*([A-Z_]?[A-Z0-9_]*)\s*(=?)\s*(.*)$/i);
        if (a) {
            if (!a[1]) {
                if (!this.printVariable()) this.printf("no variables\n");
                return true;    // it's not considered an error to print an empty list of variables
            }
            if (!a[2]) {
                return this.printVariable(a[1]);
            }
            if (!a[3]) {
                this.delVariable(a[1]);
                return true;    // it's not considered an error to delete a variable that didn't exist
            }
            let v = this.parseExpression(a[3]);
            if (v !== undefined) {
                this.setVariable(a[1], v);
                return true;
            }
            return false;
        }
        this.printf("invalid assignment:%s\n", sCmd);
        return false;
    }

    /**
     * doList(sAddr, fPrint)
     *
     * @this {Debuggerx86}
     * @param {string} sAddr
     * @param {boolean} [fPrint]
     * @returns {string|null}
     */
    doList(sAddr, fPrint)
    {
        let sSymbol = null;

        let dbgAddr = this.parseAddr(sAddr, true);
        if (dbgAddr) {

            let addr = this.getAddr(dbgAddr);
            if (MAXDEBUG && fPrint) {
                this.printf("%s (%%0*x)\n", this.toHexAddr(dbgAddr), this.cchAddr, addr);
            }

            let aSymbol = this.findSymbol(dbgAddr, true);
            if (aSymbol.length) {
                let nDelta, sDelta, s;
                if (aSymbol[0]) {
                    sDelta = "";
                    nDelta = (dbgAddr.off >>> 0) - aSymbol[1];
                    if (nDelta) sDelta = " + " + StrLib.toHex(nDelta, 0, true);
                    s = aSymbol[0] + " (" + this.toHexOffset(aSymbol[1], dbgAddr.sel) + ')' + sDelta;
                    if (fPrint) this.printf("%s\n", s);
                    sSymbol = s;
                }
                if (aSymbol.length > 4 && aSymbol[4]) {
                    sDelta = "";
                    nDelta = aSymbol[5] - (dbgAddr.off >>> 0);
                    if (nDelta) sDelta = " - " + StrLib.toHex(nDelta, 0, true);
                    s = aSymbol[4] + " (" + this.toHexOffset(aSymbol[5], dbgAddr.sel) + ')' + sDelta;
                    if (fPrint) this.printf("%s\n", s);
                    if (!sSymbol) sSymbol = s;
                }
            } else {
                if (fPrint) this.printf("no symbols\n");
            }
        }
        return sSymbol;
    }

    /**
     * doLoad(asArgs)
     *
     * The format of this command mirrors the DOS DEBUG "L" command:
     *
     *      l [address] [drive #] [sector #] [# sectors]
     *
     * The only optional parameter is the last, which defaults to 1 sector if not specified.
     *
     * As a quick-and-dirty way of getting the current contents of a disk image as a JSON dump
     * (which you can then save as .json disk image file), I also support this command:
     *
     *      l json [drive #]
     *
     * which is aliased to this command:
     *
     *      d disk [drive #]
     *
     * @this {Debuggerx86}
     * @param {Array.<string>} asArgs
     */
    doLoad(asArgs)
    {
        if (!asArgs[1] || asArgs[1] == '?') {
            this.printf("load commands:\n");
            this.printf("\tl [address] [drive #] [sector #] [# sectors]\n");
            return;
        }

        let fJSON = (asArgs[1] == "json");
        let iDrive, iSector = 0, nSectors = 0;

        let dbgAddr = (fJSON? {} : this.parseAddr(asArgs[1]));
        if (!dbgAddr) return;

        iDrive = this.parseValue(asArgs[2], "drive #");
        if (iDrive === undefined) return;
        if (!fJSON) {
            iSector = this.parseValue(asArgs[3], "sector #");
            if (iSector === undefined) return;
            nSectors = this.parseValue(asArgs[4], "# of sectors");
            if (nSectors === undefined) nSectors = 1;
        }

        /**
         * We choose the disk controller very simplistically: FDC for drives 0 or 1, and HDC for drives 2
         * and up, unless no HDC is present, in which case we assume FDC for all drive numbers.
         *
         * Both controllers must obviously support the same interfaces; ie, copyDrive(), seekDrive(),
         * and readData().  We also rely on the disk property to determine whether the drive is "loaded".
         *
         * In the case of the HDC, if the drive is valid, then by definition it is also "loaded", since an HDC
         * drive and its disk are inseparable; it's certainly possible that the disk object may be empty at
         * this point (ie, if the disk is uninitialized and unformatted), but that will only affect whether the
         * read succeeds or not.
         */
        let dc = this.fdc;
        if (iDrive >= 2 && this.hdc) {
            iDrive -= 2;
            dc = this.hdc;
        }
        if (dc) {
            let drive = dc.copyDrive(iDrive);
            if (drive) {
                if (drive.disk) {
                    if (fJSON) {
                        /**
                         * This is an interim solution to dumping disk images in JSON.  It has many problems, the
                         * "biggest" being that the large disk images really need to be compressed first, because they
                         * get "inflated" with use.  See the dump() method in the Disk component for more details.
                         */
                        this.doClear();
                        this.printf("%s\n", drive.disk.convertToJSON());
                        return;
                    }
                    if (dc.seekDrive(drive, iSector, nSectors)) {
                        let cb = 0;
                        let fAbort = false;
                        let sAddr = this.toHexAddr(dbgAddr);
                        while (!fAbort && drive.nBytes-- > 0) {
                            (function(dbg, dbgAddrCur) {
                                dc.readData(drive, function(b, fAsync) {
                                    if (b < 0) {
                                        dbg.printf("out of data at address %s\n", dbg.toHexAddr(dbgAddrCur));
                                        fAbort = true;
                                        return;
                                    }
                                    dbg.setByte(dbgAddrCur, b, 1, true);
                                    cb++;
                                });
                            }(this, dbgAddr));
                        }
                        /**
                         * Call updateCPU() now, since we forced setByte() to defer all updates
                         */
                        this.cpu.updateCPU(true);
                        this.printf("%d bytes read at %s\n", cb, sAddr);
                    } else {
                        this.printf("sector %d request out of range\n", iSector);
                    }
                } else {
                    this.printf("drive %d not loaded\n", iDrive);
                }
            } else {
                this.printf("invalid drive: %d\n", iDrive);
            }
        } else {
            this.printf("disk controller not present\n");
        }
    }

    /**
     * doMessages(asArgs)
     *
     * @this {Debuggerx86}
     * @param {Array.<string>} asArgs
     */
    doMessages(asArgs)
    {
        let m;
        let fCriteria = null;
        let sCategory = asArgs[1];
        let bitsMessage = this.bitsMessage;

        if (sCategory == '?') sCategory = undefined;

        if (sCategory !== undefined) {
            let bits = 0;
            if (sCategory == "all") {
                bits = MESSAGE.ALL - MESSAGE.HALT - MESSAGE.BUFFER;
                sCategory = null;
            } else if (sCategory == "on") {
                fCriteria = true;
                sCategory = null;
            } else if (sCategory == "off") {
                fCriteria = false;
                sCategory = null;
            } else {
                for (m in MESSAGE.NAMES) {
                    if (sCategory == m) {
                        bits = MESSAGE.NAMES[m];
                        fCriteria = Component.testBits(bitsMessage, bits);
                        break;
                    }
                }
                if (!bits) {
                    this.printf("unknown message category: %s\n", sCategory);
                    return;
                }
            }
            if (bits) {
                if (asArgs[2] == "on") {
                    bitsMessage = Component.setBits(bitsMessage, bits);
                    fCriteria = true;
                }
                else if (asArgs[2] == "off") {
                    bitsMessage = Component.clearBits(bitsMessage, bits);
                    fCriteria = false;
                    if (bits == MESSAGE.BUFFER) {
                        this.printf("%s\n", this.aMessageBuffer.join(""));
                        this.aMessageBuffer = [];
                    }
                }
            }
        }

        /**
         * Display those message categories that match the current criteria (on or off)
         */
        let n = 0;
        let sCategories = "";
        for (m in MESSAGE.NAMES) {
            if (!sCategory || sCategory == m) {
                let bits = MESSAGE.NAMES[m];
                let fEnabled = Component.testBits(bitsMessage, bits);
                if (fCriteria !== null && fCriteria != fEnabled) continue;
                if (sCategories) sCategories += ',';
                if (!(++n % 10)) sCategories += "\n\t";
                sCategories += m;
            }
        }

        if (sCategory === undefined) {
            this.printf("message commands:\n\tm [category] [on|off]\tturn categories on/off\n");
        }

        this.printf("%s%s\n", (fCriteria !== null? (fCriteria? "messages on:  " : "messages off: ") : "message categories:\n\t"), (sCategories || "none"));

        this.bitsMessage = bitsMessage;

        this.historyInit();     // call this just in case MESSAGE.INT was turned on
    }

    /**
     * doMouse(sAction, sDelta)
     *
     * When using the "click" action, specify 0 for Mouse.BUTTON.LEFT or 2 for Mouse.BUTTON.RIGHT.
     *
     * @this {Debuggerx86}
     * @param {string} sAction
     * @param {string} sDelta
     */
    doMouse(sAction, sDelta)
    {
        if (this.mouse) {
            let n = 0, sign = 1;
            if (sDelta) {
                if (sDelta.charAt(0) == '-') {
                    sign = -1;
                    sDelta = sDelta.substr(1);
                }
                n = this.parseValue(sDelta, sAction);
                if (n === undefined) return;
                n = (n * sign)|0;
            }
            switch(sAction) {
            case "x":
                this.mouse.moveMouse(n, 0);
                break;
            case "y":
                this.mouse.moveMouse(0, n);
                break;
            case "click":
                this.mouse.clickMouse(n, true);
                this.mouse.clickMouse(n, false);
                break;
            default:
                this.printf("unknown action: %s\n", sAction);
                break;
            }
            return;
        }
        this.printf("no mouse\n");
    }

    /**
     * doExecOptions(asArgs)
     *
     * @this {Debuggerx86}
     * @param {Array.<string>} asArgs
     */
    doExecOptions(asArgs)
    {
        if (asArgs[0].length > 1) {
            asArgs.splice(1, 0, asArgs[0].slice(1));
            asArgs[0] = asArgs[0].charAt(0);
        }
        if (!asArgs[1] || asArgs[1] == '?') {
            this.printf("execution options:\n");
            this.printf("\tbv [halt|trace]\n");
            this.printf("\tcs int #\tset checksum cycle interval to #\n");
            this.printf("\tcs start #\tset checksum cycle start count to #\n");
            this.printf("\tcs stop #\tset checksum cycle stop count to #\n");
            this.printf("\tsp #\t\tset speed multiplier to #\n");
            return;
        }
        let nCycles;
        switch (asArgs[1]) {
        case "bv":
            switch (asArgs[2]) {
            case "halt":
                this.vectorHalt = true;
                break;
            case "trace":
                this.vectorHalt = false;
                break;
            default:
                if (asArgs[2]) {
                    this.printf("unknown vector option: %s\n", asArgs[2]);
                    return;
                }
            }
            this.printf("vector breakpoints: %s\n", (this.vectorHalt? "halt" : "trace"));
            break;
        case "cs":
            if (asArgs[3] !== undefined) nCycles = +asArgs[3];          // warning: decimal instead of hex conversion
            switch (asArgs[2]) {
            case "int":
                this.cpu.nCyclesChecksumInterval = nCycles;
                break;
            case "start":
                this.cpu.nCyclesChecksumStart = nCycles;
                break;
            case "stop":
                this.cpu.nCyclesChecksumStop = nCycles;
                break;
            default:
                this.printf("unknown cs option\n");
                return;
            }
            if (nCycles !== undefined) {
                this.cpu.resetChecksum();
            }
            this.printf("checksums %s\n", (this.cpu.flags.checksum? "enabled" : "disabled"));
            break;
        case "sp":
            if (asArgs[2] !== undefined) {
                if (!this.cpu.setSpeed(+asArgs[2])) {
                    this.printf("warning: using 1x multiplier, previous target not reached\n");
                }
            }
            this.printf("target speed: %s (%dx)\n", this.cpu.getSpeedTarget(), this.cpu.getSpeed());
            break;
        default:
            this.printf("unknown option: %s\n", asArgs[1]);
            break;
        }
    }

    /**
     * doOutput(sPort, sByte)
     *
     * Simulate a 1-byte port output operation.
     *
     * @this {Debuggerx86}
     * @param {string|undefined} sPort
     * @param {string|undefined} sByte (string representation of 1 byte)
     */
    doOutput(sPort, sByte)
    {
        if (!sPort || sPort == '?') {
            this.printf("output commands:\n");
            this.printf("\to [p] [b]\twrite byte [b] to port [p]\n");
            /**
             * TODO: Regarding this warning, consider adding an "unchecked" version of
             * bus.checkPortOutputNotify(), since all Debugger memory accesses are unchecked, too.
             *
             * All port I/O handlers ARE aware when the Debugger is calling (addrFrom is undefined),
             * but changing them all to be non-destructive would take time, and situations where you
             * actually want to affect the hardware state are just as likely as not....
             */
            this.printf("warning: port accesses can affect hardware state\n");
            return;
        }
        let port = this.parseValue(sPort, "port #");
        let bOut = this.parseValue(sByte);
        if (port !== undefined && bOut !== undefined) {
            this.bus.checkPortOutputNotify(port, 1, bOut);
            this.printf("%#06x: %#04x\n", port, bOut);
        }
    }

    /**
     * doRegisters(asArgs, fInstruction)
     *
     * @this {Debuggerx86}
     * @param {Array.<string>} [asArgs]
     * @param {boolean} [fInstruction] (true to include the current instruction; default is true)
     */
    doRegisters(asArgs, fInstruction)
    {
        if (asArgs && asArgs[1] == '?') {
            this.printf("register commands:\n");
            this.printf("\tr\tdump registers\n");
            if (this.fpuActive) this.printf("\trfp\tdump floating-point registers\n");
            this.printf("\trp\tdump all registers\n");
            this.printf("\trx [#]\tset flag or register x to [#]\n");
            return;
        }

        let fProt;
        if (fInstruction == null) fInstruction = true;

        if (asArgs != null && asArgs.length > 1) {
            let sReg = asArgs[1];
            if (this.fpuActive && sReg == "fp") {
                this.doFPURegisters(asArgs);
                return;
            }
            if (sReg == 'p') {
                fProt = (this.cpu.model >= X86.MODEL_80286);
            }
            else {
             // fInstruction = false;
                let sValue = null;
                let i = sReg.indexOf('=');
                if (i > 0) {
                    sValue = sReg.substr(i + 1);
                    sReg = sReg.substr(0, i);
                }
                else if (asArgs.length > 2) {
                    sValue = asArgs[2];
                }
                else {
                    this.printf("missing value for %s\n", asArgs[1]);
                    return;
                }

                let w = this.parseExpression(sValue);
                if (w === undefined) return;

                let fUnknown, fValid = true;
                let sRegMatch = sReg.toUpperCase();
                if (sRegMatch[0] == 'E' && sRegMatch[1] != 'S' && this.cchReg <= 4) {
                    sRegMatch = null;
                }
                switch (sRegMatch) {
                case "AL":
                    this.cpu.regEAX = (this.cpu.regEAX & ~0xff) | (w & 0xff);
                    break;
                case "AH":
                    this.cpu.regEAX = (this.cpu.regEAX & ~0xff00) | ((w << 8) & 0xff);
                    break;
                case "AX":
                    this.cpu.regEAX = (this.cpu.regEAX & ~0xffff) | (w & 0xffff);
                    break;
                case "BL":
                    this.cpu.regEBX = (this.cpu.regEBX & ~0xff) | (w & 0xff);
                    break;
                case "BH":
                    this.cpu.regEBX = (this.cpu.regEBX & ~0xff00) | ((w << 8) & 0xff);
                    break;
                case "BX":
                    this.cpu.regEBX = (this.cpu.regEBX & ~0xffff) | (w & 0xffff);
                    break;
                case "CL":
                    this.cpu.regECX = (this.cpu.regECX & ~0xff) | (w & 0xff);
                    break;
                case "CH":
                    this.cpu.regECX = (this.cpu.regECX & ~0xff00) | ((w << 8) & 0xff);
                    break;
                case "CX":
                    this.cpu.regECX = (this.cpu.regECX & ~0xffff) | (w & 0xffff);
                    break;
                case "DL":
                    this.cpu.regEDX = (this.cpu.regEDX & ~0xff) | (w & 0xff);
                    break;
                case "DH":
                    this.cpu.regEDX = (this.cpu.regEDX & ~0xff00) | ((w << 8) & 0xff);
                    break;
                case "DX":
                    this.cpu.regEDX = (this.cpu.regEDX & ~0xffff) | (w & 0xffff);
                    break;
                case "SP":
                    this.cpu.setSP((this.cpu.getSP() & ~0xffff) | (w & 0xffff));
                    break;
                case "BP":
                    this.cpu.regEBP = (this.cpu.regEBP & ~0xffff) | (w & 0xffff);
                    break;
                case "SI":
                    this.cpu.regESI = (this.cpu.regESI & ~0xffff) | (w & 0xffff);
                    break;
                case "DI":
                    this.cpu.regEDI = (this.cpu.regEDI & ~0xffff) | (w & 0xffff);
                    break;
                /**
                 * DANGER: For any of the segment loads below, by going through the normal CPU
                 * segment load procedure, you run the risk of generating a fault in the machine
                 * if you're not careful.  So, um, be careful.
                 */
                case "DS":
                    this.cpu.setDS(w);
                    break;
                case "ES":
                    this.cpu.setES(w);
                    break;
                case "SS":
                    this.cpu.setSS(w);
                    break;
                case "CS":
                 // fInstruction = true;
                    this.cpu.setCS(w);
                    this.dbgAddrNextCode = this.newAddr(this.cpu.getIP(), this.cpu.getCS());
                    break;
                case "IP":
                case "EIP":
                 // fInstruction = true;
                    this.cpu.setIP(w);
                    this.dbgAddrNextCode = this.newAddr(this.cpu.getIP(), this.cpu.getCS());
                    break;
                /**
                 * I used to alias "PC" (Program Counter) to "IP" (Instruction Pointer), because in PC-DOS 1.00
                 * through 2.10, DEBUG.COM did the same thing.  Then I discovered that, starting with PC-DOS 3.00,
                 * DEBUG.COM changed "PC" to refer to the 16-bit flags register (Program or Processor Control?)
                 * I've elected to go for PC-DOS 3.00+ compatibility, since that will be more widely known.
                 *
                 * PCx86 prefers "PS" (Processor Status) for accessing the FLAGS register in its 16-bit (or 32-bit)
                 * entirety.  Individual flag bits can also be accessed as 1-bit registers, using the names shown
                 * below ("C", "P", "A", "Z", etc.)
                 */
                case "PC":
                case "PS":
                    this.cpu.setPS(w);
                    break;
                case 'C':
                    if (w) this.cpu.setCF(); else this.cpu.clearCF();
                    break;
                case 'P':
                    if (w) this.cpu.setPF(); else this.cpu.clearPF();
                    break;
                case 'A':
                    if (w) this.cpu.setAF(); else this.cpu.clearAF();
                    break;
                case 'Z':
                    if (w) this.cpu.setZF(); else this.cpu.clearZF();
                    break;
                case 'S':
                    if (w) this.cpu.setSF(); else this.cpu.clearSF();
                    break;
                case 'I':
                    if (w) this.cpu.setIF(); else this.cpu.clearIF();
                    break;
                case 'D':
                    if (w) this.cpu.setDF(); else this.cpu.clearDF();
                    break;
                case 'V':
                    if (w) this.cpu.setOF(); else this.cpu.clearOF();
                    break;
                default:
                    fUnknown = true;
                    if (this.cpu.model >= X86.MODEL_80286) {
                        fUnknown = false;
                        switch(sRegMatch){
                        case "MS":
                            this.cpu.setMSW(w);
                            break;
                        case "TR":
                            /**
                             * DANGER: Like any of the segment loads above, by going through the normal CPU
                             * segment load procedure, you run the risk of generating a fault in the machine
                             * if you're not careful.  So, um, be careful.
                             */
                            if (this.cpu.segTSS.load(w) === X86.ADDR_INVALID) {
                                fValid = false;
                            }
                            break;
                        /**
                         * TODO: Add support for GDTR (addr and limit), IDTR (addr and limit), and perhaps
                         * even the ability to edit descriptor information associated with each segment register.
                         */
                        default:
                            fUnknown = true;
                            if (I386 && this.cpu.model >= X86.MODEL_80386) {
                                fUnknown = false;
                                switch(sRegMatch){
                                case "EAX":
                                    this.cpu.regEAX = w;
                                    break;
                                case "EBX":
                                    this.cpu.regEBX = w;
                                    break;
                                case "ECX":
                                    this.cpu.regECX = w;
                                    break;
                                case "EDX":
                                    this.cpu.regEDX = w;
                                    break;
                                case "ESP":
                                    this.cpu.setSP(w);
                                    break;
                                case "EBP":
                                    this.cpu.regEBP = w;
                                    break;
                                case "ESI":
                                    this.cpu.regESI = w;
                                    break;
                                case "EDI":
                                    this.cpu.regEDI = w;
                                    break;
                                /**
                                 * DANGER: For any of the segment loads below, by going through the normal CPU
                                 * segment load procedure, you run the risk of generating a fault in the machine
                                 * if you're not careful.  So, um, be careful.
                                 */
                                case "FS":
                                    this.cpu.setFS(w);
                                    break;
                                case "GS":
                                    this.cpu.setGS(w);
                                    break;
                                case "CR0":
                                    this.cpu.regCR0 = w;
                                    X86.helpLoadCR0.call(this.cpu, w);
                                    break;
                                case "CR2":
                                    this.cpu.regCR2 = w;
                                    break;
                                case "CR3":
                                    this.cpu.regCR3 = w;
                                    X86.helpLoadCR3.call(this.cpu, w);
                                    break;
                                /**
                                 * TODO: Add support for DR0-DR7 and TR6-TR7.
                                 */
                                default:
                                    fUnknown = true;
                                    break;
                                }
                            }
                            break;
                        }
                    }
                    if (fUnknown) {
                        this.printf("unknown register: %s\n", sReg);
                        return;
                    }
                }
                if (!fValid) {
                    this.printf("invalid value: %s\n", sValue);
                    return;
                }
                this.cpu.updateCPU();
                this.printf("updated registers:\n");
            }
        }

        this.printf("%s\n", this.getRegDump(fProt));

        if (fInstruction) {
            this.dbgAddrNextCode = this.newAddr(this.cpu.getIP(), this.cpu.getCS());
            this.doUnassemble(this.toHexAddr(this.dbgAddrNextCode));
        }
    }

    /**
     * doFPURegisters(asArgs)
     *
     * NOTE: If we're called, the existence of an FPU has already been verified.
     *
     * @this {Debuggerx86}
     * @param {Array.<string>} [asArgs]
     */
    doFPURegisters(asArgs)
    {
        let fpu = this.fpuActive;

        let wStatus = fpu.getStatus(), wControl = fpu.getControl();
        for (let i = 0; i < 8; i++) {
            let a = fpu.readFPUStack(i);
            if (!a) break;
            let sValue = StrLib.pad(a[2].toFixed(15), 24);
            this.printf("ST%d: %s  %x,%x  [%d:%s]\n", i, sValue, a[4], a[3], a[0], Debuggerx86.FPU_TAGS[a[1]]);
            // this.printf("  REG%d %s%s%s\n", a[0], StrLib.toBin(a[7], 16), StrLib.toBin(a[6]), StrLib.toBin(a[5]));
        }
        this.printf("    B3SSS210ESPUOZDI               xxxIRRPPIxPUOZDI\n");
        this.printf("SW: %s (%#06x)  CW: %s (%#06x)\n", StrLib.toBin(wStatus, 16), wStatus, StrLib.toBin(wControl, 16), wControl);
    }

    /**
     * doRun(sCmd, sAddr, sLine, fQuiet)
     *
     * @this {Debuggerx86}
     * @param {string} sCmd
     * @param {string|undefined} [sAddr]
     * @param {string} [sLine] (the complete command-line)
     * @param {boolean} [fQuiet]
     */
    doRun(sCmd, sAddr, sLine, fQuiet)
    {
        if (sCmd == "gt") {
            this.fIgnoreNextCheckFault = true;
        }
        if (sAddr !== undefined) {
            let dbgAddr = this.parseAddr(sAddr, true);
            if (!dbgAddr) return;
            this.parseAddrOptions(dbgAddr, sLine);
            this.setTempBreakpoint(dbgAddr);
        }
        this.startCPU(true, fQuiet);
    }

    /**
     * doPrint(sCmd)
     *
     * NOTE: If the string to print is a quoted string, then we run it through replaceRegs(), so that
     * you can take advantage of all the special replacement options used for software interrupt logging.
     *
     * @this {Debuggerx86}
     * @param {string} sCmd
     */
    doPrint(sCmd)
    {
        sCmd = StrLib.trim(sCmd);
        let a = sCmd.match(/^(['"])(.*?)\1$/);
        if (!a) {
            this.parseExpression(sCmd, false);
        } else {
            this.printf("%s\n", this.replaceRegs(a[2]));
        }
    }

    /**
     * doStep(sCmd)
     *
     * @this {Debuggerx86}
     * @param {string} [sCmd] "p" or "pr"
     */
    doStep(sCmd)
    {
        let fCallStep = true;
        let nRegs = (sCmd == "pr"? 1 : 0);
        /**
         * Set up the value for this.nStep (ie, 1 or 2) depending on whether the user wants
         * a subsequent register dump ("pr") or not ("p").
         */
        let nStep = 1 + nRegs;
        if (!this.nStep) {
            let fPrefix;
            let fRepeat = false;
            let dbgAddr = this.newAddr(this.cpu.getIP(), this.cpu.getCS());
            do {
                fPrefix = false;
                let bOpcode = this.getByte(dbgAddr), bOp2;
                switch (bOpcode) {
                case X86.OPCODE.ES:
                case X86.OPCODE.CS:
                case X86.OPCODE.SS:
                case X86.OPCODE.DS:
                case X86.OPCODE.FS:     // I386 only
                case X86.OPCODE.GS:     // I386 only
                case X86.OPCODE.OS:     // I386 only
                case X86.OPCODE.AS:     // I386 only
                case X86.OPCODE.LOCK:
                    this.incAddr(dbgAddr, 1);
                    fPrefix = true;
                    break;
                case X86.OPCODE.INT3:
                case X86.OPCODE.INTO:
                    this.nStep = nStep;
                    this.incAddr(dbgAddr, 1);
                    break;
                case X86.OPCODE.INTN:
                    this.nStep = nStep;
                    this.incAddr(dbgAddr, 1);
                    bOp2 = this.getByte(dbgAddr);
                    this.incAddr(dbgAddr, 1);
                    /**
                     * Look for INT 0x32 functions 4-6 and skip over the null-terminated string following the interrupt.
                     */
                    if (bOp2 == 0x32) {
                        let regAH = (this.cpu.regEAX >> 8) & 0xFF;
                        if (regAH >= 0x04 && regAH <= 0x06) {
                            let limit = 128;
                            while ((bOp2 = this.getByte(dbgAddr)) && limit--) {
                                this.incAddr(dbgAddr, 1);
                            }
                            this.incAddr(dbgAddr, 1);
                        }
                    }
                    break;
                case X86.OPCODE.LOOPNZ:
                case X86.OPCODE.LOOPZ:
                case X86.OPCODE.LOOP:
                    this.nStep = nStep;
                    this.incAddr(dbgAddr, dbgAddr.fData32? 4 : 2);
                    break;
                case X86.OPCODE.CALL:
                    if (fCallStep) {
                        this.nStep = nStep;
                        this.incAddr(dbgAddr, dbgAddr.fData32? 5 : 3);
                    }
                    break;
                case X86.OPCODE.CALLF:
                    if (fCallStep) {
                        this.nStep = nStep;
                        this.incAddr(dbgAddr, dbgAddr.fData32? 7 : 5);
                    }
                    break;
                case X86.OPCODE.GRP4W:
                    if (fCallStep) {
                        let w = this.getWord(dbgAddr) & X86.OPCODE.CALLMASK;
                        if (w == X86.OPCODE.CALLW || w == X86.OPCODE.CALLFDW) {
                            this.nStep = nStep;
                            this.getInstruction(dbgAddr);       // advance dbgAddr past this variable-length CALL
                        }
                    }
                    break;
                case X86.OPCODE.REPZ:
                case X86.OPCODE.REPNZ:
                    this.incAddr(dbgAddr, 1);
                    fRepeat = fPrefix = true;
                    break;
                case X86.OPCODE.INSB:
                case X86.OPCODE.INSW:
                case X86.OPCODE.OUTSB:
                case X86.OPCODE.OUTSW:
                case X86.OPCODE.MOVSB:
                case X86.OPCODE.MOVSW:
                case X86.OPCODE.CMPSB:
                case X86.OPCODE.CMPSW:
                case X86.OPCODE.STOSB:
                case X86.OPCODE.STOSW:
                case X86.OPCODE.LODSB:
                case X86.OPCODE.LODSW:
                case X86.OPCODE.SCASB:
                case X86.OPCODE.SCASW:
                    if (fRepeat) {
                        this.nStep = nStep;
                        this.incAddr(dbgAddr, 1);
                    }
                    break;
                default:
                    break;
                }
            } while (fPrefix);

            if (this.nStep) {
                this.setTempBreakpoint(dbgAddr);
                if (!this.startCPU()) {
                    if (this.cmp) this.cmp.updateFocus();
                    this.nStep = 0;
                }
                /**
                 * A successful run will ultimately call stop(), which will in turn call clearTempBreakpoint(),
                 * which will clear nStep, so there's your assurance that nStep will be reset.  Now we may have
                 * stopped for reasons unrelated to the temporary breakpoint, but that's OK.
                 */
            } else {
                this.doTrace(nRegs? "tr" : "t");
            }
        } else {
            this.printf("step in progress\n");
        }
    }

    /**
     * getCall(dbgAddr, fFar)
     *
     * Given a possible return address (typically from the stack), look for a matching CALL (or INT) that
     * immediately precedes that address.
     *
     * @this {Debuggerx86}
     * @param {DbgAddrx86} dbgAddr
     * @param {boolean} [fFar]
     * @returns {string|null} (CALL instruction at or near dbgAddr, or null if none)
     */
    getCall(dbgAddr, fFar)
    {
        let sCall = null;
        let off = dbgAddr.off;
        let offOrig = off;
        for (let n = 1; n <= 6 && !!off; n++) {
            if (n > 2) {
                dbgAddr.off = off;
                dbgAddr.addr = undefined;
                let s = this.getInstruction(dbgAddr);
                if (s.indexOf("CALL") >= 0 || fFar && s.indexOf("INT") >= 0) {
                    /**
                     * Verify that the length of this CALL (or INT), when added to the address of the CALL (or INT),
                     * matches the original return address.  We do this by getting the string index of the opcode bytes,
                     * subtracting that from the string index of the next space, and dividing that difference by two,
                     * to yield the length of the CALL (or INT) instruction, in bytes.
                     */
                    let i = s.indexOf(' ');
                    let j = s.indexOf(' ', i+1);
                    if (off + (j - i - 1)/2 == offOrig) {
                        sCall = s;
                        break;
                    }
                }
            }
            off--;
        }
        dbgAddr.off = offOrig;
        return sCall;
    }

    /**
     * doStackTrace(sCmd, sAddr)
     *
     * Use "k" for a normal stack trace and "ks" for a stack trace with symbolic info.
     *
     * @this {Debuggerx86}
     * @param {string} [sCmd]
     * @param {string} [sAddr] (not used yet)
     */
    doStackTrace(sCmd, sAddr)
    {
        if (sAddr == '?') {
            this.printf("stack trace commands:\n");
            this.printf("\tk\tshow frame addresses\n");
            this.printf("\tks\tshow symbol information\n");
            return;
        }

        let nFrames = 10, cFrames = 0;
        let selCode = this.cpu.segCS.sel;
        let dbgAddrCall = this.newAddr();
        let dbgAddrStack = this.newAddr(this.cpu.getSP(), this.cpu.getSS());
        this.printf("stack trace for %s\n", this.toHexAddr(dbgAddrStack));

        while (cFrames < nFrames) {
            let sCall = null, sCallPrev = null, cTests = 256;
            while ((dbgAddrStack.off >>> 0) < this.cpu.regLSPLimit) {
                dbgAddrCall.off = this.getWord(dbgAddrStack, true);
                /**
                 * Because we're using the auto-increment feature of getWord(), and because that will automatically
                 * wrap the offset around the end of the segment, we must also check the addr property to detect the wrap.
                 */
                if (dbgAddrStack.addr == null || !cTests--) break;
                dbgAddrCall.sel = selCode;
                sCall = this.getCall(dbgAddrCall);
                if (sCall) break;
                dbgAddrCall.sel = this.getWord(dbgAddrStack);
                sCall = this.getCall(dbgAddrCall, true);
                if (sCall) {
                    selCode = this.getWord(dbgAddrStack, true);
                    /**
                     * It's not strictly necessary that we skip over the flags word that's pushed as part of any INT
                     * instruction, but it reduces the risk of misinterpreting it as a return address on the next iteration.
                     */
                    if (sCall.indexOf("INT") > 0) this.getWord(dbgAddrStack, true);
                    break;
                }
            }
            /**
             * The sCallPrev check eliminates duplicate sequential calls, which are usually (but not always)
             * indicative of a false positive, in which case the previous call is probably bogus as well, but
             * at least we won't duplicate that mistake.  Of course, there are always exceptions, recursion
             * being one of them, but it's rare that we're debugging recursive code.
             */
            if (!sCall || sCall == sCallPrev) break;
            let sSymbol = null;
            if (sCmd == "ks") {
                let a = sCall.match(/[0-9A-F]+$/);
                if (a) sSymbol = this.doList(a[0]);
            }
            sCall = StrLib.pad(sCall, dbgAddrCall.fAddr32? -74 : -62) + ';' + (sSymbol || "stack=" + this.toHexAddr(dbgAddrStack)); // + " return=" + this.toHexAddr(dbgAddrCall));
            this.printf("%s\n", sCall);
            sCallPrev = sCall;
            cFrames++;
        }
        if (!cFrames) this.printf("no return addresses found\n");
    }

    /**
     * doTrace(sCmd, sCount)
     *
     * The "t" and "tr" commands interpret the count as a number of instructions, and since
     * we call the Debugger's stepCPU() for each iteration, a single instruction includes
     * any/all prefixes; the CPU's stepCPU() treats prefixes as discrete operations.  The only
     * difference between "t" and "tr": the former displays only the next instruction, while
     * the latter also displays the (updated) registers.
     *
     * The "tc" command interprets the count as a number of cycles rather than instructions,
     * allowing you to quickly execute large chunks of instructions with a single command; it
     * doesn't display anything until the the chunk has finished.
     *
     * However, generally a more useful command is "bn", which allows you to break after some
     * number of instructions have been executed (as opposed to some number of cycles).
     *
     * @this {Debuggerx86}
     * @param {string} [sCmd] ("t", "tc", or "tr")
     * @param {string} [sCount] # of instructions to step
     */
    doTrace(sCmd, sCount)
    {
        let dbg = this;
        let fRegs = (sCmd != "t");
        let nCount = this.parseValue(sCount, undefined, true) || 1;
        let nCycles = (nCount == 1? 0 : 1);
        if (sCmd == "tc") {
            nCycles = nCount;
            nCount = 1;
        }
        WebLib.onCountRepeat(
            nCount,
            function onCountStep() {
                return dbg.setBusy(true) && dbg.stepCPU(nCycles, fRegs, false);
            },
            function onCountStepComplete() {
                /**
                 * We explicitly called stepCPU() with fUpdateCPU === false, because repeatedly
                 * calling updateCPU() can be very slow, especially when fDisplayLiveRegs is true,
                 * so once the repeat count has been exhausted, we must perform a final updateCPU().
                 */
                dbg.cpu.updateCPU(true);
                dbg.setBusy(false);
            }
        );
    }

    /**
     * initAddrSize(dbgAddr)
     *
     * @this {Debuggerx86}
     * @param {DbgAddrx86} dbgAddr
     */
    initAddrSize(dbgAddr)
    {
        /**
         * For proper disassembly of instructions preceded by an OPERAND (0x66) size prefix, we set
         * dbgAddr.fData32 to true whenever the operand size is 32-bit; similarly, for an ADDRESS (0x67)
         * size prefix, we set dbgAddr.fAddr32 to true whenever the address size is 32-bit.
         *
         * Initially (and every time we've processed a complete instruction), both fields must be
         * set to their original value.
         */
        if (dbgAddr.fData32Orig != null) dbgAddr.fData32 = dbgAddr.fData32Orig;
        if (dbgAddr.fAddr32Orig != null) dbgAddr.fAddr32 = dbgAddr.fAddr32Orig;
        dbgAddr.fData32Orig = dbgAddr.fData32;
        dbgAddr.fAddr32Orig = dbgAddr.fAddr32;
    }

    /**
     * isStringIns(bOpcode)
     *
     * @this {Debuggerx86}
     * @param {number} bOpcode
     * @returns {boolean} (true if string instruction, false if not)
     */
    isStringIns(bOpcode)
    {
        return (bOpcode >= X86.OPCODE.MOVSB && bOpcode <= X86.OPCODE.CMPSW || bOpcode >= X86.OPCODE.STOSB && bOpcode <= X86.OPCODE.SCASW);
    }

    /**
     * doUnassemble(sAddr, sAddrEnd, n)
     *
     * @this {Debuggerx86}
     * @param {string} [sAddr]
     * @param {string} [sAddrEnd]
     * @param {number} [n]
     */
    doUnassemble(sAddr, sAddrEnd, n)
    {
        let dbgAddr = this.parseAddr(sAddr, true);
        if (!dbgAddr) return;

        if (n === undefined) n = 1;

        let cb = 0x100;
        if (sAddrEnd !== undefined) {

            let dbgAddrEnd = this.parseAddr(sAddrEnd, true);
            if (!dbgAddrEnd || dbgAddrEnd.off < dbgAddr.off) return;

            /**
             * We now +1 the count to make the ending address inclusive (just like the dump command).
             */
            cb = dbgAddrEnd.off - dbgAddr.off + 1;
            if (cb < 0) cb = 1;
            /**
             * Limiting the amount of disassembled code to 4K helps prevent the user from wedging the browser.
             */
            if (cb > 0x1000) cb = 0x1000;
            n = -1;
        }

        let cLines = 0;
        let sInstruction;
        this.initAddrSize(dbgAddr);

        while (cb > 0 && n--) {

            let nSequence = (this.isBusy(false) || this.nStep)? this.nCycles : -1;
            let sComment = (nSequence >= 0? "cycles" : "");
            let aSymbol = this.findSymbol(dbgAddr);

            let addr = dbgAddr.addr;    // we snap dbgAddr.addr *after* calling findSymbol(), which re-evaluates it

            if (aSymbol[0] && n) {
                if (!cLines && n || aSymbol[0].indexOf('+') < 0) {
                    let sLabel = aSymbol[0] + ':';
                    if (aSymbol[2]) sLabel += ' ' + aSymbol[2];
                    this.printf("%s\n", sLabel);
                }
            }

            if (aSymbol[3]) {
                sComment = aSymbol[3];
                nSequence = -1;
            }

            sInstruction = this.getInstruction(dbgAddr, sComment, nSequence);

            this.printf("%s\n", sInstruction);
            this.dbgAddrNextCode = dbgAddr;
            cb -= dbgAddr.addr - addr;
            cLines++;
        }
    }

    /**
     * parseCommand(sCmd, fSave, chSep)
     *
     * @this {Debuggerx86}
     * @param {string|undefined} sCmd
     * @param {boolean} [fSave] is true to save the command, false if not
     * @param {string} [chSep] is the command separator character (default is ';')
     * @returns {Array.<string>}
     */
    parseCommand(sCmd, fSave, chSep = ';')
    {
        if (fSave) {
            if (!sCmd) {
                sCmd = this.aPrevCmds[this.iPrevCmd+1];
            } else {
                if (this.iPrevCmd < 0 && this.aPrevCmds.length) {
                    this.iPrevCmd = 0;
                }
                if (this.iPrevCmd < 0 || sCmd != this.aPrevCmds[this.iPrevCmd]) {
                    this.aPrevCmds.splice(0, 0, sCmd);
                    this.iPrevCmd = 0;
                }
                this.iPrevCmd--;
            }
        }
        let asArgs = [];
        if (sCmd) {
            /**
             * With the introduction of breakpoint commands (ie, quoted command sequences
             * associated with a breakpoint), we can no longer perform simplistic splitting.
             *
             *      asArgs = sCmd.split(chSep);
             *      for (let i = 0; i < asArgs.length; i++) asArgs[i] = StrLib.trim(asArgs[i]);
             *
             * We may now split on semi-colons ONLY if they are outside a quoted sequence.
             *
             * Also, to allow quoted strings *inside* breakpoint commands, we first replace all
             * DOUBLE double-quotes with single quotes.
             */
            sCmd = sCmd.replace(/""/g, "'");

            let iPrev = 0;
            let chQuote = null;
            /**
             * NOTE: Processing charAt() up to and INCLUDING length is not a typo; we're taking
             * advantage of the fact that charAt() with an invalid index returns an empty string,
             * allowing us to use the same substring() call to capture the final portion of sCmd.
             *
             * In a sense, it allows us to pretend that the string ends with a zero terminator.
             */
            let fQuoted = false;
            for (let i = 0, chPrev = null; i <= sCmd.length; i++) {
                let ch = sCmd.charAt(i);
                if (ch == '"' || ch == "'") {
                    if (!chQuote) {
                        chQuote = ch;
                        fQuoted = true;
                    } else if (ch == chQuote) {
                        chQuote = null;
                    }
                }
                else if (ch == chSep && !chQuote && ch != chPrev || !ch) {
                    /**
                     * Recall that substring() accepts starting (inclusive) and ending (exclusive)
                     * indexes, whereas substr() accepts a starting index and a length.  We need the former.
                     */
                    let s = StrLib.trim(sCmd.substring(iPrev, i));
                    if (!fQuoted) s = s.toLowerCase();
                    asArgs.push(s);
                    iPrev = i + 1;
                    fQuoted = false;
                }
                chPrev = ch;
            }
            if (chSep == ' ' && asArgs.length) {
                /**
                 * I've folded in the old shiftArgs() code here: deal with any command (eg, "r") that allows but
                 * doesn't require whitespace between the command and first argument, and break them apart anyway.
                 */
                let s0 = asArgs[0];
                let ch0 = s0.charAt(0);
                for (let i = 1; i < s0.length; i++) {
                    let ch = s0.charAt(i);
                    if (ch0 == '?' || ch0 == 'r' || ch < 'a' || ch > 'z') {
                        asArgs[0] = s0.substr(i);
                        asArgs.unshift(s0.substr(0, i));
                        break;
                    }
                }
            }
        }
        return asArgs;
    }

    /**
     * doCommand(sCmd, fQuiet)
     *
     * @this {Debuggerx86}
     * @param {string} sCmd
     * @param {boolean} [fQuiet]
     * @returns {boolean} (true if command processed, false if unrecognized)
     */
    doCommand(sCmd, fQuiet)
    {
        let result = true;

        if (!this.cpu) {
            this.printf("no CPU attached\n");
            return false;
        }

        try {
            if (!sCmd.length || sCmd == "end") {
                if (this.fAssemble) {
                    this.printf("ended assemble at %s\n", this.toHexAddr(this.dbgAddrAssemble));
                    this.dbgAddrNextCode = this.dbgAddrAssemble;
                    this.fAssemble = false;
                }
                sCmd = "";
            }
            else if (!fQuiet) {
                let sPrompt = ">> ";
                if (this.cpu.regCR0 & X86.CR0.MSW.PE) {
                    sPrompt = (this.cpu.regPS & X86.PS.VM)? "-- " : "## ";
                }
                this.printf("%s%s\n", sPrompt, sCmd);
            }

            let ch = sCmd.charAt(0);
            if (ch == '"' || ch == "'") return true;

            /**
             * Zap the previous message buffer to ensure the new command's output is not tossed out as a repeat.
             */
            this.sMessagePrev = null;

            /**
             * I've relaxed the !isBusy() requirement, to maximize our ability to issue Debugger commands externally.
             */
            if (this.isReady() /* && !this.isBusy(true) */ && sCmd.length > 0) {

                if (this.fAssemble) {
                    sCmd = "a " + this.toHexAddr(this.dbgAddrAssemble) + ' ' + sCmd;
                }

                let asArgs = this.parseCommand(sCmd, false, ' ');

                switch (asArgs[0].charAt(0)) {
                case 'a':
                    this.doAssemble(asArgs);
                    break;
                case 'b':
                    this.doBreak(asArgs, sCmd);
                    break;
                case 'c':
                    this.doClear(asArgs[0]);
                    break;
                case 'd':
                    if (!COMPILED && sCmd == "debug") {
                        window.DEBUG = true;
                        this.printf("DEBUG checks on\n");
                        break;
                    }
                    this.doDump(asArgs);
                    break;
                case 'e':
                    if (asArgs[0] == "else") break;
                    this.doEdit(asArgs);
                    break;
                case 'f':
                    this.doFreqs(asArgs[1]);
                    break;
                case 'g':
                    this.doRun(asArgs[0], asArgs[1], sCmd, fQuiet);
                    break;
                case 'h':
                    this.doHalt(fQuiet);
                    break;
                case 'i':
                    if (asArgs[0] == "if") {
                        if (!this.doIf(sCmd.substr(2), fQuiet)) {
                            result = false;
                        }
                        break;
                    }
                    if (asArgs[0] == "int") {
                        if (!this.doInt(asArgs[1])) {
                            result = false;
                        }
                        break;
                    }
                    this.doInput(asArgs[1]);
                    break;
                case 'k':
                    this.doStackTrace(asArgs[0], asArgs[1]);
                    break;
                case 'l':
                    if (asArgs[0] == "ln") {
                        this.doList(asArgs[1], true);
                        break;
                    }
                    this.doLoad(asArgs);
                    break;
                case 'm':
                    if (asArgs[0] == "mouse") {
                        this.doMouse(asArgs[1], asArgs[2]);
                        break;
                    }
                    this.doMessages(asArgs);
                    break;
                case 'o':
                    this.doOutput(asArgs[1], asArgs[2]);
                    break;
                case 'p':
                    if (asArgs[0] == "print") {
                        this.doPrint(sCmd.substr(5));
                        break;
                    }
                    this.doStep(asArgs[0]);
                    break;
                case 'r':
                    if (sCmd == "reset") {
                        if (this.cmp) this.cmp.reset();
                        break;
                    }
                    this.doRegisters(asArgs);
                    break;
                case 't':
                    this.doTrace(asArgs[0], asArgs[1]);
                    break;
                case 'u':
                    this.doUnassemble(asArgs[1], asArgs[2], 8);
                    break;
                case 'v':
                    if (asArgs[0] == "var") {
                        if (!this.doVar(sCmd.substr(3))) {
                            result = false;
                        }
                        break;
                    }
                    this.printf("%s version %s (%s%s%s%s%s)\n", (APPNAME || "PCx86"), APPVERSION, this.cpu.model, (COMPILED? ",RELEASE" : (DEBUG? ",DEBUG" : ",NODEBUG")), (PREFETCH? ",PREFETCH" : ",NOPREFETCH"), (TYPEDARRAYS? ",TYPEDARRAYS" : (BYTEARRAYS? ",BYTEARRAYS" : ",LONGARRAYS")), (BACKTRACK? ",BACKTRACK" : ",NOBACKTRACK"));
                    this.printf("%s\n", WebLib.getUserAgent());
                    break;
                case 'x':
                    this.doExecOptions(asArgs);
                    break;
                case '?':
                    if (asArgs[1]) {
                        this.doPrint(sCmd.substr(1));
                        break;
                    }
                    this.doHelp();
                    break;
                case 'n':
                    if (!COMPILED && sCmd == "nodebug") {
                        window.DEBUG = false;
                        this.printf("DEBUG checks off\n");
                        break;
                    }
                    if (this.doInfo(asArgs)) break;
                    /* falls through */
                default:
                    if (!fQuiet) this.printf("unknown command: %s\n", sCmd);
                    result = false;
                    break;
                }
            }
        } catch(e) {
            this.printf("debugger error: %s\n", (e.stack || e.message));
            result = false;
        }
        return result;
    }

    /**
     * doCommands(sCommands, fSave, fQuiet)
     *
     * @this {Debuggerx86}
     * @param {string} sCommands
     * @param {boolean} [fSave]
     * @param {boolean} [fQuiet]
     * @returns {boolean} (true if all commands processed, false if not)
     */
    doCommands(sCommands, fSave = false, fQuiet = false)
    {
        let a = this.parseCommand(sCommands, fSave);
        for (let s in a) {
            if (!this.doCommand(a[+s], fQuiet)) return false;
        }
        return true;
    }

    /**
     * Debuggerx86.init()
     *
     * This function operates on every HTML element of class "debugger", extracting the
     * JSON-encoded parameters for the Debugger constructor from the element's "data-value"
     * attribute, invoking the constructor to create a Debugger component, and then binding
     * any associated HTML controls to the new component.
     */
    static init()
    {
        let aeDbg = Component.getElementsByClass(APPCLASS, "debugger");
        for (let iDbg = 0; iDbg < aeDbg.length; iDbg++) {
            let eDbg = aeDbg[iDbg];
            let parmsDbg = Component.getComponentParms(eDbg);
            let dbg = new Debuggerx86(parmsDbg);
            Component.bindComponentControls(dbg, eDbg, APPCLASS);
        }
    }
}

if (DEBUGGER) {

    /**
     * NOTE: The Debugger properties below are considered "class constants"; most of them use our "all-caps"
     * convention (and all of them SHOULD, but that wouldn't help us catch any bugs).
     *
     * Technically, all of them should ALSO be preceded by a "@const" annotation, but that's a lot of work and it
     * really clutters the code.  I wish the Closure Compiler had a way to annotate every definition with a given
     * section with a single annotation....
     *
     * Bugs can slip through the cracks without those annotations; for example, I unthinkingly redefined TYPE_SI
     * at one point, and if all the definitions had been preceded by an "@const", that mistake would have been
     * caught at compile-time.
     */

    /**
     * Information regarding interrupts of interest (used by messageInt() and others)
     */
    Debuggerx86.INT_MESSAGES = {
        0x10:       MESSAGE.VIDEO,
        0x13:       MESSAGE.FDC,
        0x15:       MESSAGE.CHIPSET,
        0x16:       MESSAGE.KBD,
     // 0x1A:       MESSAGE.RTC,       // ChipSet contains its own custom messageInt() handler for the RTC
        0x1C:       MESSAGE.TIMER,
        0x21:       MESSAGE.DOS,
        0x33:       MESSAGE.MOUSE
    };

    /**
     * Information regarding "annoying" interrupts (which aren't annoying so much as too frequent);
     * note that some of these can still be enabled if you really want them (eg, RTC can be turned on
     * with RTC messages, ALT_TIMER with TIMER messages, etc).
     */
    Debuggerx86.INT_ANNOYING = [Interrupts.TIMER, Interrupts.TMR_BREAK, Interrupts.DOS_IDLE, Interrupts.DOS_NETBIOS, Interrupts.VIDEO_VGA];

    Debuggerx86.COMMANDS = {
        '?':     "help/print",
        'a [#]': "assemble",            // TODO: Implement this command someday
        'b [#]': "breakpoint",          // multiple variations (use b? to list them)
        'c':     "clear output",
        'd [#]': "dump memory",         // additional syntax: d [#] [l#], where l# is a number of bytes to dump
        'e [#]': "edit memory",
        'f':     "frequencies",
        'g [#]': "go [to #]",
        'h':     "halt",
        'i [#]': "input port #",
        'if':    "eval expression",
        'k':     "stack trace",
        'l':     "load sector(s)",
        "ln":    "list nearest symbol(s)",
        'm':     "messages",
        'mouse': "mouse action",        // syntax: mouse {action} {delta} (eg, mouse x 10, mouse click 0, etc)
        'o [#]': "output port #",
        'p':     "step over",           // other variations: pr (step and dump registers)
        'print': "print expression",
        'r':     "dump/set registers",
        'reset': "reset machine",
        't [#]': "trace",               // other variations: tr (trace and dump registers)
        'u [#]': "unassemble",
        'x':     "execution options",
        'v':     "print version",
        'var':   "assign variable"
    };

    /**
     * Supported address types; the type field in a DbgAddrx86 object may be one of:
     *
     *      NONE, REAL, PROT, V86, LINEAR or PHYSICAL
     *
     * REAL and V86 addresses are specified with a '&' prefix, PROT addresses with a '#' prefix,
     * LINEAR addresses with '%', and PHYSICAL addresses with '%%'.
     */
    Debuggerx86.ADDRTYPE = {
        NONE:       0x00,
        REAL:       0x01,
        PROT:       0x02,
        V86:        0x03,
        LINEAR:     0x04,
        PHYSICAL:   0x05
    };

    /**
     * CPU instruction ordinals
     *
     * Note that individual instructions end with ordinal 163 and instruction groups begin with ordinal 164;
     * the disassembler knows it's dealing with a group whenever the ordinal is not a valid index into INS_NAMES.
     *
     * NOTE: While this list started alphabetical, there are a few wrinkles; eg, POPA/POPF/PUSHF/PUSHA are
     * sequential to make it easier to detect instructions that require a D suffix when the operand size is 32 bits.
     */
    Debuggerx86.INS = {
        NONE:   0,   AAA:    1,   AAD:    2,   AAM:    3,   AAS:    4,   ADC:    5,   ADD:    6,   AND:    7,
        ARPL:   8,   AS:     9,   BOUND:  10,  BSF:    11,  BSR:    12,  BT:     13,  BTC:    14,  BTR:    15,
        BTS:    16,  CALL:   17,  CBW:    18,  CLC:    19,  CLD:    20,  CLI:    21,  CLTS:   22,  CMC:    23,
        CMP:    24,  CMPSB:  25,  CMPSW:  26,  CS:     27,  CWD:    28,  DAA:    29,  DAS:    30,  DEC:    31,
        DIV:    32,  DS:     33,  ENTER:  34,  ES:     35,  ESC:    36,  FS:     37,  GS:     38,  HLT:    39,
        IBTS:   40,  IDIV:   41,  IMUL:   42,  IN:     43,  INC:    44,  INS:    45,  INT:    46,  INT1:   47,
        INT3:   48,  INTO:   49,  IRET:   50,  JBE:    51,  JC:     52,  JCXZ:   53,  JG:     54,  JGE:    55,
        JL:     56,  JLE:    57,  JMP:    58,  JA:     59,  JNC:    60,  JNO:    61,  JNP:    62,  JNS:    63,
        JNZ:    64,  JO:     65,  JP:     66,  JS:     67,  JZ:     68,  LAHF:   69,  LAR:    70,  LDS:    71,
        LEA:    72,  LEAVE:  73,  LES:    74,  LFS:    75,  LGDT:   76,  LGS:    77,  LIDT:   78,  LLDT:   79,
        LMSW:   80,  LOADALL:81,  LOCK:   82,  LODSB:  83,  LODSW:  84,  LOOP:   85,  LOOPNZ: 86,  LOOPZ:  87,
        LSL:    88,  LSS:    89,  LTR:    90,  MOV:    91,  MOVSB:  92,  MOVSW:  93,  MOVSX:  94,  MOVZX:  95,
        MUL:    96,  NEG:    97,  NOP:    98,  NOT:    99,  OR:     100, OS:     101, OUT:    102, OUTS:   103,
        POP:    104, POPA:   105, POPF:   106, PUSHF:  107, PUSHA:  108, PUSH:   109, RCL:    110, RCR:    111,
        REPNZ:  112, REPZ:   113, RET:    114, RETF:   115, ROL:    116, ROR:    117, SAHF:   118, SALC:   119,
        SAR:    120, SBB:    121, SCASB:  122, SCASW:  123, SETBE:  124, SETC:   125, SETG:   126, SETGE:  127,
        SETL:   128, SETLE:  129, SETNBE: 130, SETNC:  131, SETNO:  132, SETNP:  133, SETNS:  134, SETNZ:  135,
        SETO:   136, SETP:   137, SETS:   138, SETZ:   139, SGDT:   140, SHL:    141, SHLD:   142, SHR:    143,
        SHRD:   144, SIDT:   145, SLDT:   146, SMSW:   147, SS:     148, STC:    149, STD:    150, STI:    151,
        STOSB:  152, STOSW:  153, STR:    154, SUB:    155, TEST:   156, VERR:   157, VERW:   158, WAIT:   159,
        XBTS:   160, XCHG:   161, XLAT:   162, XOR:    163, GRP1B:  164, GRP1W:  165, GRP1SW: 166, GRP2B:  167,
        GRP2W:  168, GRP2B1: 169, GRP2W1: 170, GRP2BC: 171, GRP2WC: 172, GRP3B:  173, GRP3W:  174, GRP4B:  175,
        GRP4W:  176, OP0F:   177, GRP6:   178, GRP7:   179, GRP8:   180
    };

    /**
     * CPU instruction names (mnemonics), indexed by CPU instruction ordinal (above)
     */
    Debuggerx86.INS_NAMES = [
        "INVALID","AAA",    "AAD",    "AAM",    "AAS",    "ADC",    "ADD",    "AND",
        "ARPL",   "AS:",    "BOUND",  "BSF",    "BSR",    "BT",     "BTC",    "BTR",
        "BTS",    "CALL",   "CBW",    "CLC",    "CLD",    "CLI",    "CLTS",   "CMC",
        "CMP",    "CMPSB",  "CMPSW",  "CS:",    "CWD",    "DAA",    "DAS",    "DEC",
        "DIV",    "DS:",    "ENTER",  "ES:",    "ESC",    "FS:",    "GS:",    "HLT",
        "IBTS",   "IDIV",   "IMUL",   "IN",     "INC",    "INS",    "INT",    "INT1",
        "INT3",   "INTO",   "IRET",   "JBE",    "JC",     "JCXZ",   "JG",     "JGE",
        "JL",     "JLE",    "JMP",    "JA",     "JNC",    "JNO",    "JNP",    "JNS",
        "JNZ",    "JO",     "JP",     "JS",     "JZ",     "LAHF",   "LAR",    "LDS",
        "LEA",    "LEAVE",  "LES",    "LFS",    "LGDT",   "LGS",    "LIDT",   "LLDT",
        "LMSW",   "LOADALL","LOCK",   "LODSB",  "LODSW",  "LOOP",   "LOOPNZ", "LOOPZ",
        "LSL",    "LSS",    "LTR",    "MOV",    "MOVSB",  "MOVSW",  "MOVSX",  "MOVZX",
        "MUL",    "NEG",    "NOP",    "NOT",    "OR",     "OS:",    "OUT",    "OUTS",
        "POP",    "POPA",   "POPF",   "PUSHF",  "PUSHA",  "PUSH",   "RCL",    "RCR",
        "REPNZ",  "REPZ",   "RET",    "RETF",   "ROL",    "ROR",    "SAHF",   "SALC",
        "SAR",    "SBB",    "SCASB",  "SCASW",  "SETBE",  "SETC",   "SETG",   "SETGE",
        "SETL",   "SETLE",  "SETNBE", "SETNC",  "SETNO",  "SETNP",  "SETNS",  "SETNZ",
        "SETO",   "SETP",   "SETS",   "SETZ",   "SGDT",   "SHL",    "SHLD",   "SHR",
        "SHRD",   "SIDT",   "SLDT",   "SMSW",   "SS:",    "STC",    "STD",    "STI",
        "STOSB",  "STOSW",  "STR",    "SUB",    "TEST",   "VERR",   "VERW",   "WAIT",
        "XBTS",   "XCHG",   "XLAT",   "XOR"
    ];

    /**
     * FPU instruction ordinals
     *
     * Unlike CPU instruction ordinals, these are not organized alphabetically (which I did only for the
     * sake of tidiness), but rather by functionality; ie:
     *
     *      0-3:    real transfers
     *      4-6:    integer transfers
     *      7-8:    packed decimal transfers
     *      9-11:   addition
     *      12-17:  subtraction
     *      18-20:  multiplication
     *      21-26:  division
     *      27-33:  other
     *      34-40:  comparisons
     *      41-45:  transcendental
     *      46-52:  constants
     *      53-77:  coprocessor control
     *      78---:  new for 80287 or higher
     *
     * Also, unlike the CPU instructions, there is no NONE ("INVALID") instruction; if an ESC instruction
     * can't be decoded as a valid FPU instruction, then it should remain an ESC instruction.
     */
    Debuggerx86.FINS = {
        FLD:    0,   FST:    1,   FSTP:   2,   FXCH:   3,   FILD:   4,   FIST:   5,   FISTP:  6,   FBLD:   7,
        FBSTP:  8,   FADD:   9,   FADDP:  10,  FIADD:  11,  FSUB:   12,  FSUBP:  13,  FISUB:  14,  FSUBR:  15,
        FSUBRP: 16,  FISUBR: 17,  FMUL:   18,  FMULP:  19,  FIMUL:  20,  FDIV:   21,  FDIVP:  22,  FIDIV:  23,
        FDIVR:  24,  FDIVRP: 25,  FIDIVR: 26,  FSQRT:  27,  FSCALE: 28,  FPREM:  29,  FRNDINT:30,  FXTRACT:31,
        FABS:   32,  FCHS:   33,  FCOM:   34,  FCOMP:  35,  FCOMPP: 36,  FICOM:  37,  FICOMP: 38,  FTST:   39,
        FXAM:   40,  FPTAN:  41,  FPATAN: 42,  F2XM1:  43,  FYL2X:  44,  FYL2XP1:45,  FLDZ:   46,  FLD1:   47,
        FLDPI:  48,  FLDL2T: 49,  FLDL2E: 50,  FLDLG2: 51,  FLDLN2: 52,  FINIT:  53,  FNINIT: 54,  FDISI:  55,
        FNDISI: 56,  FENI:   57,  FNENI:  58,  FLDCW:  59,  FSTCW:  60,  FNSTCW: 61,  FSTSW:  62,  FNSTSW: 63,
        FCLEX:  64,  FNCLEX: 65,  FSTENV: 66,  FNSTENV:67,  FLDENV: 68,  FSAVE:  69,  FNSAVE: 70,  FRSTOR: 71,
        FINCSTP:72,  FDECSTP:73,  FFREE:  74,  FFREEP: 75,  FNOP:   76,  FWAIT:  77,  FSETPM: 78,  FSINCOS:79,
        FSTSWAX:80
    };

    /**
     * FPU instruction names (mnemonics), indexed by FPU instruction ordinal (above)
     */
    Debuggerx86.FINS_NAMES = [
        "FLD",    "FST",    "FSTP",   "FXCH",   "FILD",   "FIST",   "FISTP",  "FBLD",
        "FBSTP",  "FADD",   "FADDP",  "FIADD",  "FSUB",   "FSUBP",  "FISUB",  "FSUBR",
        "FSUBRP", "FISUBR", "FMUL",   "FMULP",  "FIMUL",  "FDIV",   "FDIVP",  "FIDIV",
        "FDIVR",  "FDIVRP", "FIDIVR", "FSQRT",  "FSCALE", "FPREM",  "FRNDINT","FXTRACT",
        "FABS",   "FCHS",   "FCOM",   "FCOMP",  "FCOMPP", "FICOM",  "FICOMP", "FTST",
        "FXAM",   "FPTAN",  "FPATAN", "F2XM1",  "FYL2X",  "FYL2XP1","FLDZ",   "FLD1",
        "FLDPI",  "FLDL2T", "FLDL2E", "FLDLG2", "FLDLN2", "FINIT",  "FNINIT", "FDISI",
        "FNDISI", "FENI",   "FNENI",  "FLDCW",  "FSTCW",  "FNSTCW", "FSTSW",  "FNSTSW",
        "FCLEX",  "FNCLEX", "FSTENV", "FNSTENV","FLDENV", "FSAVE",  "FNSAVE", "FRSTOR",
        "FINCSTP","FDECSTP","FFREE",  "FFREEP", "FNOP",   "FWAIT",  "FSETPM", "FSINCOS",
        "FSTSWAX"
    ];

    Debuggerx86.FPU_TAGS = ["VALID", "ZERO ", "SPEC ", "EMPTY"];

    Debuggerx86.CPU_8086  = 0;
    Debuggerx86.CPU_80186 = 1;
    Debuggerx86.CPU_80286 = 2;
    Debuggerx86.CPU_80386 = 3;
    Debuggerx86.CPUS = [8086, 80186, 80286, 80386];

    /**
     * ModRM masks and definitions
     */
    Debuggerx86.REG_AL         = 0x00;          // bits 0-2 are standard Reg encodings
    Debuggerx86.REG_CL         = 0x01;
    Debuggerx86.REG_DL         = 0x02;
    Debuggerx86.REG_BL         = 0x03;
    Debuggerx86.REG_AH         = 0x04;
    Debuggerx86.REG_CH         = 0x05;
    Debuggerx86.REG_DH         = 0x06;
    Debuggerx86.REG_BH         = 0x07;
    Debuggerx86.REG_AX         = 0x08;
    Debuggerx86.REG_CX         = 0x09;
    Debuggerx86.REG_DX         = 0x0A;
    Debuggerx86.REG_BX         = 0x0B;
    Debuggerx86.REG_SP         = 0x0C;
    Debuggerx86.REG_BP         = 0x0D;
    Debuggerx86.REG_SI         = 0x0E;
    Debuggerx86.REG_DI         = 0x0F;
    Debuggerx86.REG_SEG        = 0x10;
    Debuggerx86.REG_IP         = 0x16;
    Debuggerx86.REG_PS         = 0x17;
    Debuggerx86.REG_EAX        = 0x18;
    Debuggerx86.REG_ECX        = 0x19;
    Debuggerx86.REG_EDX        = 0x1A;
    Debuggerx86.REG_EBX        = 0x1B;
    Debuggerx86.REG_ESP        = 0x1C;
    Debuggerx86.REG_EBP        = 0x1D;
    Debuggerx86.REG_ESI        = 0x1E;
    Debuggerx86.REG_EDI        = 0x1F;
    Debuggerx86.REG_CR0        = 0x20;
    Debuggerx86.REG_CR1        = 0x21;
    Debuggerx86.REG_CR2        = 0x22;
    Debuggerx86.REG_CR3        = 0x23;
    Debuggerx86.REG_DR0        = 0x28;
    Debuggerx86.REG_DR1        = 0x29;
    Debuggerx86.REG_DR2        = 0x2A;
    Debuggerx86.REG_DR3        = 0x2B;
    Debuggerx86.REG_DR6        = 0x2E;
    Debuggerx86.REG_DR7        = 0x2F;
    Debuggerx86.REG_TR0        = 0x30;
    Debuggerx86.REG_TR6        = 0x36;
    Debuggerx86.REG_TR7        = 0x37;
    Debuggerx86.REG_EIP        = 0x38;

    Debuggerx86.REGS = [
        "AL",  "CL",  "DL",  "BL",  "AH",  "CH",  "DH",  "BH",
        "AX",  "CX",  "DX",  "BX",  "SP",  "BP",  "SI",  "DI",
        "ES",  "CS",  "SS",  "DS",  "FS",  "GS",  "IP",  "PS",
        "EAX", "ECX", "EDX", "EBX", "ESP", "EBP", "ESI", "EDI",
        "CR0", "CR1", "CR2", "CR3", null,  null,  null,  null,  // register names used with TYPE_CTLREG
        "DR0", "DR1", "DR2", "DR3", null,  null,  "DR6", "DR7", // register names used with TYPE_DBGREG
        null,  null,  null,  null,  null,  null,  "TR6", "TR7", // register names used with TYPE_TSTREG
        "EIP"
    ];

    Debuggerx86.REG_ES         = 0x00;          // bits 0-1 are standard SegReg encodings
    Debuggerx86.REG_CS         = 0x01;
    Debuggerx86.REG_SS         = 0x02;
    Debuggerx86.REG_DS         = 0x03;
    Debuggerx86.REG_FS         = 0x04;
    Debuggerx86.REG_GS         = 0x05;
    Debuggerx86.REG_UNKNOWN    = 0x00;

    Debuggerx86.MOD_NODISP     = 0x00;          // use RM below, no displacement
    Debuggerx86.MOD_DISP8      = 0x01;          // use RM below + 8-bit displacement
    Debuggerx86.MOD_DISP16     = 0x02;          // use RM below + 16-bit displacement
    Debuggerx86.MOD_REGISTER   = 0x03;          // use REG above

    Debuggerx86.RM_BXSI        = 0x00;
    Debuggerx86.RM_BXDI        = 0x01;
    Debuggerx86.RM_BPSI        = 0x02;
    Debuggerx86.RM_BPDI        = 0x03;
    Debuggerx86.RM_SI          = 0x04;
    Debuggerx86.RM_DI          = 0x05;
    Debuggerx86.RM_BP          = 0x06;
    Debuggerx86.RM_IMMOFF      = Debuggerx86.RM_BP;       // only if MOD_NODISP
    Debuggerx86.RM_BX          = 0x07;

    Debuggerx86.RMS = [
        "BX+SI", "BX+DI", "BP+SI", "BP+DI", "SI",    "DI",    "BP",    "BX",
        "EAX",   "ECX",   "EDX",   "EBX",   "ESP",   "EBP",   "ESI",   "EDI"
    ];

    /**
     * Operand type descriptor masks and definitions
     *
     * Note that the letters in () in the comments refer to Intel's
     * nomenclature used in Appendix A of the 80386 Programmers Reference Manual.
     */
    Debuggerx86.TYPE_SIZE      = 0x000F;        // size field
    Debuggerx86.TYPE_MODE      = 0x00F0;        // mode field
    Debuggerx86.TYPE_IREG      = 0x0F00;        // implied register field
    Debuggerx86.TYPE_OTHER     = 0xF000;        // "other" field

    /**
     * TYPE_SIZE values.  Some definitions use duplicate values when the operands are the
     * same size and the Debugger doesn't need to make a distinction.
     */
    Debuggerx86.TYPE_NONE      = 0x0000;        //     (all other TYPE fields ignored)
    Debuggerx86.TYPE_BYTE      = 0x0001;        // (b) byte, regardless of operand size
    Debuggerx86.TYPE_SBYTE     = 0x0002;        //     byte sign-extended to word
    Debuggerx86.TYPE_SHORT     = 0x0003;        // (w) 16-bit value
    Debuggerx86.TYPE_WORD      = 0x0004;        // (v) 16-bit or 32-bit value
    Debuggerx86.TYPE_LONG      = 0x0005;        // (d) 32-bit value
    Debuggerx86.TYPE_SEGP      = 0x0006;        // (p) 32-bit or 48-bit pointer
    Debuggerx86.TYPE_FARP      = 0x0007;        // (p) 32-bit or 48-bit pointer for JMP/CALL
    Debuggerx86.TYPE_PREFIX    = 0x0008;        //     (treat similarly to TYPE_NONE)
    /**
     * The remaining TYPE_SIZE values are for the FPU.  Note that there are not enough values
     * within this nibble for every type to have a unique value, so to differentiate between two
     * types of the same size (eg, SINT and SREAL), we can inspect the opcode string, because only
     * FI* instructions use INT operands.  Also, some FPU sizes are not in this list (eg, the
     * so-called "word-integer"); since a word-integer is always 16 bits, we specify TYPE_SHORT,
     * which the Debugger should display as "INT16" for FI* instructions.
     */
    Debuggerx86.TYPE_ST        = 0x0009;        //     FPU ST (implicit stack top)
    Debuggerx86.TYPE_STREG     = 0x000A;        //     FPU ST (explicit stack register, relative to top)
    Debuggerx86.TYPE_SINT      = 0x000B;        //     FPU SI (short-integer; 32-bit); displayed as "INT32"
    Debuggerx86.TYPE_SREAL     = 0x000B;        //     FPU SR (short-real; 32-bit); displayed as "REAL32"
    Debuggerx86.TYPE_LINT      = 0x000C;        //     FPU LI (long-integer; 64-bit); displayed as "INT64"
    Debuggerx86.TYPE_LREAL     = 0x000C;        //     FPU LR (long-real; 64-bit); displayed as "REAL64"
    Debuggerx86.TYPE_TREAL     = 0x000D;        //     FPU TR (temp-real; 80-bit); displayed as "REAL80"
    Debuggerx86.TYPE_BCD80     = 0x000E;        //     FPU PD (packed-decimal; 18 BCD digits in 80 bits, bits 72-78 unused, sign in bit 79); displayed as "BCD80"
    Debuggerx86.TYPE_ENV       = 0x000F;        //     FPU ENV (environment; 14 bytes in real-mode, 28 bytes in protected-mode)
    Debuggerx86.TYPE_FPU       = 0x000F;        //     FPU SAVE (save/restore; 94 bytes in real-mode, 108 bytes in protected-mode)

    /**
     * TYPE_MODE values.  Order is somewhat important, as all values implying the presence
     * of a ModRM byte are assumed to be >= TYPE_MODRM.
     */
    Debuggerx86.TYPE_IMM       = 0x0000;        // (I) immediate data
    Debuggerx86.TYPE_ONE       = 0x0010;        //     implicit 1 (eg, shifts/rotates)
    Debuggerx86.TYPE_IMMOFF    = 0x0020;        // (A) immediate offset
    Debuggerx86.TYPE_IMMREL    = 0x0030;        // (J) immediate relative
    Debuggerx86.TYPE_DSSI      = 0x0040;        // (X) memory addressed by DS:SI
    Debuggerx86.TYPE_ESDI      = 0x0050;        // (Y) memory addressed by ES:DI
    Debuggerx86.TYPE_IMPREG    = 0x0060;        //     implicit register in TYPE_IREG
    Debuggerx86.TYPE_IMPSEG    = 0x0070;        //     implicit segment reg in TYPE_IREG
    Debuggerx86.TYPE_MODRM     = 0x0080;        // (E) standard ModRM decoding
    Debuggerx86.TYPE_MODMEM    = 0x0090;        // (M) ModRM refers to memory only
    Debuggerx86.TYPE_MODREG    = 0x00A0;        // (R) ModRM refers to register only
    Debuggerx86.TYPE_REG       = 0x00B0;        // (G) standard Reg decoding
    Debuggerx86.TYPE_SEGREG    = 0x00C0;        // (S) Reg selects segment register
    Debuggerx86.TYPE_CTLREG    = 0x00D0;        // (C) Reg selects control register
    Debuggerx86.TYPE_DBGREG    = 0x00E0;        // (D) Reg selects debug register
    Debuggerx86.TYPE_TSTREG    = 0x00F0;        // (T) Reg selects test register

    /**
     * TYPE_IREG values, based on the REG_* constants.
     * For convenience, they include TYPE_IMPREG or TYPE_IMPSEG as appropriate.
     */
    Debuggerx86.TYPE_AL = (Debuggerx86.REG_AL << 8 | Debuggerx86.TYPE_IMPREG | Debuggerx86.TYPE_BYTE);
    Debuggerx86.TYPE_CL = (Debuggerx86.REG_CL << 8 | Debuggerx86.TYPE_IMPREG | Debuggerx86.TYPE_BYTE);
    Debuggerx86.TYPE_DL = (Debuggerx86.REG_DL << 8 | Debuggerx86.TYPE_IMPREG | Debuggerx86.TYPE_BYTE);
    Debuggerx86.TYPE_BL = (Debuggerx86.REG_BL << 8 | Debuggerx86.TYPE_IMPREG | Debuggerx86.TYPE_BYTE);
    Debuggerx86.TYPE_AH = (Debuggerx86.REG_AH << 8 | Debuggerx86.TYPE_IMPREG | Debuggerx86.TYPE_BYTE);
    Debuggerx86.TYPE_CH = (Debuggerx86.REG_CH << 8 | Debuggerx86.TYPE_IMPREG | Debuggerx86.TYPE_BYTE);
    Debuggerx86.TYPE_DH = (Debuggerx86.REG_DH << 8 | Debuggerx86.TYPE_IMPREG | Debuggerx86.TYPE_BYTE);
    Debuggerx86.TYPE_BH = (Debuggerx86.REG_BH << 8 | Debuggerx86.TYPE_IMPREG | Debuggerx86.TYPE_BYTE);
    Debuggerx86.TYPE_AX = (Debuggerx86.REG_AX << 8 | Debuggerx86.TYPE_IMPREG | Debuggerx86.TYPE_WORD);
    Debuggerx86.TYPE_CX = (Debuggerx86.REG_CX << 8 | Debuggerx86.TYPE_IMPREG | Debuggerx86.TYPE_WORD);
    Debuggerx86.TYPE_DX = (Debuggerx86.REG_DX << 8 | Debuggerx86.TYPE_IMPREG | Debuggerx86.TYPE_WORD);
    Debuggerx86.TYPE_BX = (Debuggerx86.REG_BX << 8 | Debuggerx86.TYPE_IMPREG | Debuggerx86.TYPE_WORD);
    Debuggerx86.TYPE_SP = (Debuggerx86.REG_SP << 8 | Debuggerx86.TYPE_IMPREG | Debuggerx86.TYPE_WORD);
    Debuggerx86.TYPE_BP = (Debuggerx86.REG_BP << 8 | Debuggerx86.TYPE_IMPREG | Debuggerx86.TYPE_WORD);
    Debuggerx86.TYPE_SI = (Debuggerx86.REG_SI << 8 | Debuggerx86.TYPE_IMPREG | Debuggerx86.TYPE_WORD);
    Debuggerx86.TYPE_DI = (Debuggerx86.REG_DI << 8 | Debuggerx86.TYPE_IMPREG | Debuggerx86.TYPE_WORD);
    Debuggerx86.TYPE_ES = (Debuggerx86.REG_ES << 8 | Debuggerx86.TYPE_IMPSEG | Debuggerx86.TYPE_SHORT);
    Debuggerx86.TYPE_CS = (Debuggerx86.REG_CS << 8 | Debuggerx86.TYPE_IMPSEG | Debuggerx86.TYPE_SHORT);
    Debuggerx86.TYPE_SS = (Debuggerx86.REG_SS << 8 | Debuggerx86.TYPE_IMPSEG | Debuggerx86.TYPE_SHORT);
    Debuggerx86.TYPE_DS = (Debuggerx86.REG_DS << 8 | Debuggerx86.TYPE_IMPSEG | Debuggerx86.TYPE_SHORT);
    Debuggerx86.TYPE_FS = (Debuggerx86.REG_FS << 8 | Debuggerx86.TYPE_IMPSEG | Debuggerx86.TYPE_SHORT);
    Debuggerx86.TYPE_GS = (Debuggerx86.REG_GS << 8 | Debuggerx86.TYPE_IMPSEG | Debuggerx86.TYPE_SHORT);

    /**
     * TYPE_OTHER bit definitions
     */
    Debuggerx86.TYPE_IN    = 0x1000;            // operand is input
    Debuggerx86.TYPE_OUT   = 0x2000;            // operand is output
    Debuggerx86.TYPE_BOTH  = (Debuggerx86.TYPE_IN | Debuggerx86.TYPE_OUT);
    Debuggerx86.TYPE_8086  = (Debuggerx86.CPU_8086 << 14);
    Debuggerx86.TYPE_8087  = Debuggerx86.TYPE_8086;
    Debuggerx86.TYPE_80186 = (Debuggerx86.CPU_80186 << 14);
    Debuggerx86.TYPE_80286 = (Debuggerx86.CPU_80286 << 14);
    Debuggerx86.TYPE_80287 = Debuggerx86.TYPE_80286;
    Debuggerx86.TYPE_80386 = (Debuggerx86.CPU_80386 << 14);
    Debuggerx86.TYPE_80387 = Debuggerx86.TYPE_80386;
    Debuggerx86.TYPE_CPU_SHIFT = 14;

    Debuggerx86.HISTORY_LIMIT = DEBUG? 100000 : 1000;

    /**
     * Opcode 0x0F has a distinguished history:
     *
     *      On the 8086, it functioned as POP CS
     *      On the 80186, it generated an Invalid Opcode (UD_FAULT) exception
     *      On the 80286, it introduced a new (and growing) series of two-byte opcodes
     *
     * Based on the active CPU model, we make every effort to execute and disassemble this (and every other)
     * opcode appropriately, by setting the opcode's entry in aaOpDescs accordingly.  0x0F in aaOpDescs points
     * to the 8086 table: aOpDescPopCS.
     *
     * Note that we must NOT modify aaOpDescs directly.  this.aaOpDescs will point to Debuggerx86.aaOpDescs
     * if the processor is an 8086, because that's the processor that the hard-coded contents of the table
     * represent; for all other processors, this.aaOpDescs will contain a copy of the table that we can modify.
     */
    Debuggerx86.aOpDescPopCS     = [Debuggerx86.INS.POP,  Debuggerx86.TYPE_CS   | Debuggerx86.TYPE_OUT];
    Debuggerx86.aOpDescUndefined = [Debuggerx86.INS.NONE, Debuggerx86.TYPE_NONE];
    Debuggerx86.aOpDesc0F        = [Debuggerx86.INS.OP0F, Debuggerx86.TYPE_SHORT | Debuggerx86.TYPE_BOTH];

    /**
     * The aaOpDescs array is indexed by opcode, and each element is a sub-array (aOpDesc) that describes
     * the corresponding opcode. The sub-elements are as follows:
     *
     *      [0]: {number} of the opcode name (see INS.*)
     *      [1]: {number} containing the destination operand descriptor bit(s), if any
     *      [2]: {number} containing the source operand descriptor bit(s), if any
     *      [3]: {number} containing the occasional third operand descriptor bit(s), if any
     *
     * These sub-elements are all optional. If [0] is not present, the opcode is undefined; if [1] is not
     * present (or contains zero), the opcode has no (or only implied) operands; if [2] is not present, the
     * opcode has only a single operand.  And so on.
     */
    Debuggerx86.aaOpDescs = [
    /* 0x00 */ [Debuggerx86.INS.ADD,   Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_BYTE  | Debuggerx86.TYPE_BOTH, Debuggerx86.TYPE_REG   | Debuggerx86.TYPE_BYTE  | Debuggerx86.TYPE_IN],
    /* 0x01 */ [Debuggerx86.INS.ADD,   Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_BOTH, Debuggerx86.TYPE_REG   | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_IN],
    /* 0x02 */ [Debuggerx86.INS.ADD,   Debuggerx86.TYPE_REG    | Debuggerx86.TYPE_BYTE  | Debuggerx86.TYPE_BOTH, Debuggerx86.TYPE_MODRM | Debuggerx86.TYPE_BYTE  | Debuggerx86.TYPE_IN],
    /* 0x03 */ [Debuggerx86.INS.ADD,   Debuggerx86.TYPE_REG    | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_BOTH, Debuggerx86.TYPE_MODRM | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_IN],
    /* 0x04 */ [Debuggerx86.INS.ADD,   Debuggerx86.TYPE_AL     | Debuggerx86.TYPE_BOTH,   Debuggerx86.TYPE_IMM | Debuggerx86.TYPE_BYTE  | Debuggerx86.TYPE_IN],
    /* 0x05 */ [Debuggerx86.INS.ADD,   Debuggerx86.TYPE_AX     | Debuggerx86.TYPE_BOTH,   Debuggerx86.TYPE_IMM | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_IN],
    /* 0x06 */ [Debuggerx86.INS.PUSH,  Debuggerx86.TYPE_ES     | Debuggerx86.TYPE_IN],
    /* 0x07 */ [Debuggerx86.INS.POP,   Debuggerx86.TYPE_ES     | Debuggerx86.TYPE_OUT],

    /* 0x08 */ [Debuggerx86.INS.OR,    Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_BYTE  | Debuggerx86.TYPE_BOTH, Debuggerx86.TYPE_REG   | Debuggerx86.TYPE_BYTE  | Debuggerx86.TYPE_IN],
    /* 0x09 */ [Debuggerx86.INS.OR,    Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_BOTH, Debuggerx86.TYPE_REG   | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_IN],
    /* 0x0A */ [Debuggerx86.INS.OR,    Debuggerx86.TYPE_REG    | Debuggerx86.TYPE_BYTE  | Debuggerx86.TYPE_BOTH, Debuggerx86.TYPE_MODRM | Debuggerx86.TYPE_BYTE  | Debuggerx86.TYPE_IN],
    /* 0x0B */ [Debuggerx86.INS.OR,    Debuggerx86.TYPE_REG    | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_BOTH, Debuggerx86.TYPE_MODRM | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_IN],
    /* 0x0C */ [Debuggerx86.INS.OR,    Debuggerx86.TYPE_AL     | Debuggerx86.TYPE_BOTH,   Debuggerx86.TYPE_IMM | Debuggerx86.TYPE_BYTE  | Debuggerx86.TYPE_IN],
    /* 0x0D */ [Debuggerx86.INS.OR,    Debuggerx86.TYPE_AX     | Debuggerx86.TYPE_BOTH,   Debuggerx86.TYPE_IMM | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_IN],
    /* 0x0E */ [Debuggerx86.INS.PUSH,  Debuggerx86.TYPE_CS     | Debuggerx86.TYPE_IN],
    /* 0x0F */ Debuggerx86.aOpDescPopCS,

    /* 0x10 */ [Debuggerx86.INS.ADC,   Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_BYTE  | Debuggerx86.TYPE_BOTH, Debuggerx86.TYPE_REG   | Debuggerx86.TYPE_BYTE  | Debuggerx86.TYPE_IN],
    /* 0x11 */ [Debuggerx86.INS.ADC,   Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_BOTH, Debuggerx86.TYPE_REG   | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_IN],
    /* 0x12 */ [Debuggerx86.INS.ADC,   Debuggerx86.TYPE_REG    | Debuggerx86.TYPE_BYTE  | Debuggerx86.TYPE_BOTH, Debuggerx86.TYPE_MODRM | Debuggerx86.TYPE_BYTE  | Debuggerx86.TYPE_IN],
    /* 0x13 */ [Debuggerx86.INS.ADC,   Debuggerx86.TYPE_REG    | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_BOTH, Debuggerx86.TYPE_MODRM | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_IN],
    /* 0x14 */ [Debuggerx86.INS.ADC,   Debuggerx86.TYPE_AL     | Debuggerx86.TYPE_BOTH,   Debuggerx86.TYPE_IMM | Debuggerx86.TYPE_BYTE  | Debuggerx86.TYPE_IN],
    /* 0x15 */ [Debuggerx86.INS.ADC,   Debuggerx86.TYPE_AX     | Debuggerx86.TYPE_BOTH,   Debuggerx86.TYPE_IMM | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_IN],
    /* 0x16 */ [Debuggerx86.INS.PUSH,  Debuggerx86.TYPE_SS     | Debuggerx86.TYPE_IN],
    /* 0x17 */ [Debuggerx86.INS.POP,   Debuggerx86.TYPE_SS     | Debuggerx86.TYPE_OUT],

    /* 0x18 */ [Debuggerx86.INS.SBB,   Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_BYTE  | Debuggerx86.TYPE_BOTH, Debuggerx86.TYPE_REG   | Debuggerx86.TYPE_BYTE  | Debuggerx86.TYPE_IN],
    /* 0x19 */ [Debuggerx86.INS.SBB,   Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_BOTH, Debuggerx86.TYPE_REG   | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_IN],
    /* 0x1A */ [Debuggerx86.INS.SBB,   Debuggerx86.TYPE_REG    | Debuggerx86.TYPE_BYTE  | Debuggerx86.TYPE_BOTH, Debuggerx86.TYPE_MODRM | Debuggerx86.TYPE_BYTE  | Debuggerx86.TYPE_IN],
    /* 0x1B */ [Debuggerx86.INS.SBB,   Debuggerx86.TYPE_REG    | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_BOTH, Debuggerx86.TYPE_MODRM | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_IN],
    /* 0x1C */ [Debuggerx86.INS.SBB,   Debuggerx86.TYPE_AL     | Debuggerx86.TYPE_BOTH,   Debuggerx86.TYPE_IMM | Debuggerx86.TYPE_BYTE  | Debuggerx86.TYPE_IN],
    /* 0x1D */ [Debuggerx86.INS.SBB,   Debuggerx86.TYPE_AX     | Debuggerx86.TYPE_BOTH,   Debuggerx86.TYPE_IMM | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_IN],
    /* 0x1E */ [Debuggerx86.INS.PUSH,  Debuggerx86.TYPE_DS     | Debuggerx86.TYPE_IN],
    /* 0x1F */ [Debuggerx86.INS.POP,   Debuggerx86.TYPE_DS     | Debuggerx86.TYPE_OUT],

    /* 0x20 */ [Debuggerx86.INS.AND,   Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_BYTE  | Debuggerx86.TYPE_BOTH, Debuggerx86.TYPE_REG   | Debuggerx86.TYPE_BYTE  | Debuggerx86.TYPE_IN],
    /* 0x21 */ [Debuggerx86.INS.AND,   Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_BOTH, Debuggerx86.TYPE_REG   | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_IN],
    /* 0x22 */ [Debuggerx86.INS.AND,   Debuggerx86.TYPE_REG    | Debuggerx86.TYPE_BYTE  | Debuggerx86.TYPE_BOTH, Debuggerx86.TYPE_MODRM | Debuggerx86.TYPE_BYTE  | Debuggerx86.TYPE_IN],
    /* 0x23 */ [Debuggerx86.INS.AND,   Debuggerx86.TYPE_REG    | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_BOTH, Debuggerx86.TYPE_MODRM | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_IN],
    /* 0x24 */ [Debuggerx86.INS.AND,   Debuggerx86.TYPE_AL     | Debuggerx86.TYPE_BOTH,   Debuggerx86.TYPE_IMM | Debuggerx86.TYPE_BYTE  | Debuggerx86.TYPE_IN],
    /* 0x25 */ [Debuggerx86.INS.AND,   Debuggerx86.TYPE_AX     | Debuggerx86.TYPE_BOTH,   Debuggerx86.TYPE_IMM | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_IN],
    /* 0x26 */ [Debuggerx86.INS.ES,    Debuggerx86.TYPE_PREFIX],
    /* 0x27 */ [Debuggerx86.INS.DAA],

    /* 0x28 */ [Debuggerx86.INS.SUB,   Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_BYTE  | Debuggerx86.TYPE_BOTH, Debuggerx86.TYPE_REG   | Debuggerx86.TYPE_BYTE  | Debuggerx86.TYPE_IN],
    /* 0x29 */ [Debuggerx86.INS.SUB,   Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_BOTH, Debuggerx86.TYPE_REG   | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_IN],
    /* 0x2A */ [Debuggerx86.INS.SUB,   Debuggerx86.TYPE_REG    | Debuggerx86.TYPE_BYTE  | Debuggerx86.TYPE_BOTH, Debuggerx86.TYPE_MODRM | Debuggerx86.TYPE_BYTE  | Debuggerx86.TYPE_IN],
    /* 0x2B */ [Debuggerx86.INS.SUB,   Debuggerx86.TYPE_REG    | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_BOTH, Debuggerx86.TYPE_MODRM | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_IN],
    /* 0x2C */ [Debuggerx86.INS.SUB,   Debuggerx86.TYPE_AL     | Debuggerx86.TYPE_BOTH,   Debuggerx86.TYPE_IMM | Debuggerx86.TYPE_BYTE  | Debuggerx86.TYPE_IN],
    /* 0x2D */ [Debuggerx86.INS.SUB,   Debuggerx86.TYPE_AX     | Debuggerx86.TYPE_BOTH,   Debuggerx86.TYPE_IMM | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_IN],
    /* 0x2E */ [Debuggerx86.INS.CS,    Debuggerx86.TYPE_PREFIX],
    /* 0x2F */ [Debuggerx86.INS.DAS],

    /* 0x30 */ [Debuggerx86.INS.XOR,   Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_BYTE  | Debuggerx86.TYPE_BOTH, Debuggerx86.TYPE_REG   | Debuggerx86.TYPE_BYTE  | Debuggerx86.TYPE_IN],
    /* 0x31 */ [Debuggerx86.INS.XOR,   Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_BOTH, Debuggerx86.TYPE_REG   | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_IN],
    /* 0x32 */ [Debuggerx86.INS.XOR,   Debuggerx86.TYPE_REG    | Debuggerx86.TYPE_BYTE  | Debuggerx86.TYPE_BOTH, Debuggerx86.TYPE_MODRM | Debuggerx86.TYPE_BYTE  | Debuggerx86.TYPE_IN],
    /* 0x33 */ [Debuggerx86.INS.XOR,   Debuggerx86.TYPE_REG    | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_BOTH, Debuggerx86.TYPE_MODRM | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_IN],
    /* 0x34 */ [Debuggerx86.INS.XOR,   Debuggerx86.TYPE_AL     | Debuggerx86.TYPE_BOTH,   Debuggerx86.TYPE_IMM | Debuggerx86.TYPE_BYTE  | Debuggerx86.TYPE_IN],
    /* 0x35 */ [Debuggerx86.INS.XOR,   Debuggerx86.TYPE_AX     | Debuggerx86.TYPE_BOTH,   Debuggerx86.TYPE_IMM | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_IN],
    /* 0x36 */ [Debuggerx86.INS.SS,    Debuggerx86.TYPE_PREFIX],
    /* 0x37 */ [Debuggerx86.INS.AAA],

    /* 0x38 */ [Debuggerx86.INS.CMP,   Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_BYTE  | Debuggerx86.TYPE_IN,   Debuggerx86.TYPE_REG   | Debuggerx86.TYPE_BYTE  | Debuggerx86.TYPE_IN],
    /* 0x39 */ [Debuggerx86.INS.CMP,   Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_IN,   Debuggerx86.TYPE_REG   | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_IN],
    /* 0x3A */ [Debuggerx86.INS.CMP,   Debuggerx86.TYPE_REG    | Debuggerx86.TYPE_BYTE  | Debuggerx86.TYPE_IN,   Debuggerx86.TYPE_MODRM | Debuggerx86.TYPE_BYTE  | Debuggerx86.TYPE_IN],
    /* 0x3B */ [Debuggerx86.INS.CMP,   Debuggerx86.TYPE_REG    | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_IN,   Debuggerx86.TYPE_MODRM | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_IN],
    /* 0x3C */ [Debuggerx86.INS.CMP,   Debuggerx86.TYPE_AL     | Debuggerx86.TYPE_IN,     Debuggerx86.TYPE_IMM | Debuggerx86.TYPE_BYTE  | Debuggerx86.TYPE_IN],
    /* 0x3D */ [Debuggerx86.INS.CMP,   Debuggerx86.TYPE_AX     | Debuggerx86.TYPE_IN,     Debuggerx86.TYPE_IMM | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_IN],
    /* 0x3E */ [Debuggerx86.INS.DS,    Debuggerx86.TYPE_PREFIX],
    /* 0x3F */ [Debuggerx86.INS.AAS],

    /* 0x40 */ [Debuggerx86.INS.INC,   Debuggerx86.TYPE_AX     | Debuggerx86.TYPE_BOTH],
    /* 0x41 */ [Debuggerx86.INS.INC,   Debuggerx86.TYPE_CX     | Debuggerx86.TYPE_BOTH],
    /* 0x42 */ [Debuggerx86.INS.INC,   Debuggerx86.TYPE_DX     | Debuggerx86.TYPE_BOTH],
    /* 0x43 */ [Debuggerx86.INS.INC,   Debuggerx86.TYPE_BX     | Debuggerx86.TYPE_BOTH],
    /* 0x44 */ [Debuggerx86.INS.INC,   Debuggerx86.TYPE_SP     | Debuggerx86.TYPE_BOTH],
    /* 0x45 */ [Debuggerx86.INS.INC,   Debuggerx86.TYPE_BP     | Debuggerx86.TYPE_BOTH],
    /* 0x46 */ [Debuggerx86.INS.INC,   Debuggerx86.TYPE_SI     | Debuggerx86.TYPE_BOTH],
    /* 0x47 */ [Debuggerx86.INS.INC,   Debuggerx86.TYPE_DI     | Debuggerx86.TYPE_BOTH],

    /* 0x48 */ [Debuggerx86.INS.DEC,   Debuggerx86.TYPE_AX     | Debuggerx86.TYPE_BOTH],
    /* 0x49 */ [Debuggerx86.INS.DEC,   Debuggerx86.TYPE_CX     | Debuggerx86.TYPE_BOTH],
    /* 0x4A */ [Debuggerx86.INS.DEC,   Debuggerx86.TYPE_DX     | Debuggerx86.TYPE_BOTH],
    /* 0x4B */ [Debuggerx86.INS.DEC,   Debuggerx86.TYPE_BX     | Debuggerx86.TYPE_BOTH],
    /* 0x4C */ [Debuggerx86.INS.DEC,   Debuggerx86.TYPE_SP     | Debuggerx86.TYPE_BOTH],
    /* 0x4D */ [Debuggerx86.INS.DEC,   Debuggerx86.TYPE_BP     | Debuggerx86.TYPE_BOTH],
    /* 0x4E */ [Debuggerx86.INS.DEC,   Debuggerx86.TYPE_SI     | Debuggerx86.TYPE_BOTH],
    /* 0x4F */ [Debuggerx86.INS.DEC,   Debuggerx86.TYPE_DI     | Debuggerx86.TYPE_BOTH],

    /* 0x50 */ [Debuggerx86.INS.PUSH,  Debuggerx86.TYPE_AX     | Debuggerx86.TYPE_IN],
    /* 0x51 */ [Debuggerx86.INS.PUSH,  Debuggerx86.TYPE_CX     | Debuggerx86.TYPE_IN],
    /* 0x52 */ [Debuggerx86.INS.PUSH,  Debuggerx86.TYPE_DX     | Debuggerx86.TYPE_IN],
    /* 0x53 */ [Debuggerx86.INS.PUSH,  Debuggerx86.TYPE_BX     | Debuggerx86.TYPE_IN],
    /* 0x54 */ [Debuggerx86.INS.PUSH,  Debuggerx86.TYPE_SP     | Debuggerx86.TYPE_IN],
    /* 0x55 */ [Debuggerx86.INS.PUSH,  Debuggerx86.TYPE_BP     | Debuggerx86.TYPE_IN],
    /* 0x56 */ [Debuggerx86.INS.PUSH,  Debuggerx86.TYPE_SI     | Debuggerx86.TYPE_IN],
    /* 0x57 */ [Debuggerx86.INS.PUSH,  Debuggerx86.TYPE_DI     | Debuggerx86.TYPE_IN],

    /* 0x58 */ [Debuggerx86.INS.POP,   Debuggerx86.TYPE_AX     | Debuggerx86.TYPE_OUT],
    /* 0x59 */ [Debuggerx86.INS.POP,   Debuggerx86.TYPE_CX     | Debuggerx86.TYPE_OUT],
    /* 0x5A */ [Debuggerx86.INS.POP,   Debuggerx86.TYPE_DX     | Debuggerx86.TYPE_OUT],
    /* 0x5B */ [Debuggerx86.INS.POP,   Debuggerx86.TYPE_BX     | Debuggerx86.TYPE_OUT],
    /* 0x5C */ [Debuggerx86.INS.POP,   Debuggerx86.TYPE_SP     | Debuggerx86.TYPE_OUT],
    /* 0x5D */ [Debuggerx86.INS.POP,   Debuggerx86.TYPE_BP     | Debuggerx86.TYPE_OUT],
    /* 0x5E */ [Debuggerx86.INS.POP,   Debuggerx86.TYPE_SI     | Debuggerx86.TYPE_OUT],
    /* 0x5F */ [Debuggerx86.INS.POP,   Debuggerx86.TYPE_DI     | Debuggerx86.TYPE_OUT],

    /* 0x60 */ [Debuggerx86.INS.PUSHA, Debuggerx86.TYPE_NONE   | Debuggerx86.TYPE_80186],
    /* 0x61 */ [Debuggerx86.INS.POPA,  Debuggerx86.TYPE_NONE   | Debuggerx86.TYPE_80186],
    /* 0x62 */ [Debuggerx86.INS.BOUND, Debuggerx86.TYPE_REG    | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_IN   | Debuggerx86.TYPE_80186, Debuggerx86.TYPE_MODRM | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_IN],
    /* 0x63 */ [Debuggerx86.INS.ARPL,  Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_SHORT | Debuggerx86.TYPE_OUT  | Debuggerx86.TYPE_80286, Debuggerx86.TYPE_REG   | Debuggerx86.TYPE_SHORT | Debuggerx86.TYPE_IN],
    /* 0x64 */ [Debuggerx86.INS.FS,    Debuggerx86.TYPE_PREFIX | Debuggerx86.TYPE_80386],
    /* 0x65 */ [Debuggerx86.INS.GS,    Debuggerx86.TYPE_PREFIX | Debuggerx86.TYPE_80386],
    /* 0x66 */ [Debuggerx86.INS.OS,    Debuggerx86.TYPE_PREFIX | Debuggerx86.TYPE_80386],
    /* 0x67 */ [Debuggerx86.INS.AS,    Debuggerx86.TYPE_PREFIX | Debuggerx86.TYPE_80386],

    /* 0x68 */ [Debuggerx86.INS.PUSH,  Debuggerx86.TYPE_IMM    | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_IN   | Debuggerx86.TYPE_80186],
    /* 0x69 */ [Debuggerx86.INS.IMUL,  Debuggerx86.TYPE_REG    | Debuggerx86.TYPE_SHORT | Debuggerx86.TYPE_BOTH | Debuggerx86.TYPE_80186, Debuggerx86.TYPE_MODRM | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_IN, Debuggerx86.TYPE_IMM | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_IN],
    /* 0x6A */ [Debuggerx86.INS.PUSH,  Debuggerx86.TYPE_IMM    | Debuggerx86.TYPE_SBYTE | Debuggerx86.TYPE_IN   | Debuggerx86.TYPE_80186],
    /* 0x6B */ [Debuggerx86.INS.IMUL,  Debuggerx86.TYPE_REG    | Debuggerx86.TYPE_SHORT | Debuggerx86.TYPE_OUT  | Debuggerx86.TYPE_80186, Debuggerx86.TYPE_MODRM | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_IN, Debuggerx86.TYPE_IMM | Debuggerx86.TYPE_BYTE  | Debuggerx86.TYPE_IN],
    /* 0x6C */ [Debuggerx86.INS.INS,   Debuggerx86.TYPE_ESDI   | Debuggerx86.TYPE_BYTE  | Debuggerx86.TYPE_OUT  | Debuggerx86.TYPE_80186, Debuggerx86.TYPE_DX    | Debuggerx86.TYPE_IN],
    /* 0x6D */ [Debuggerx86.INS.INS,   Debuggerx86.TYPE_ESDI   | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_OUT  | Debuggerx86.TYPE_80186, Debuggerx86.TYPE_DX    | Debuggerx86.TYPE_IN],
    /* 0x6E */ [Debuggerx86.INS.OUTS,  Debuggerx86.TYPE_DX     | Debuggerx86.TYPE_IN    | Debuggerx86.TYPE_80186, Debuggerx86.TYPE_DSSI | Debuggerx86.TYPE_BYTE  | Debuggerx86.TYPE_IN],
    /* 0x6F */ [Debuggerx86.INS.OUTS,  Debuggerx86.TYPE_DX     | Debuggerx86.TYPE_IN    | Debuggerx86.TYPE_80186, Debuggerx86.TYPE_DSSI | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_IN],

    /* 0x70 */ [Debuggerx86.INS.JO,    Debuggerx86.TYPE_IMMREL | Debuggerx86.TYPE_BYTE  | Debuggerx86.TYPE_IN],
    /* 0x71 */ [Debuggerx86.INS.JNO,   Debuggerx86.TYPE_IMMREL | Debuggerx86.TYPE_BYTE  | Debuggerx86.TYPE_IN],
    /* 0x72 */ [Debuggerx86.INS.JC,    Debuggerx86.TYPE_IMMREL | Debuggerx86.TYPE_BYTE  | Debuggerx86.TYPE_IN],
    /* 0x73 */ [Debuggerx86.INS.JNC,   Debuggerx86.TYPE_IMMREL | Debuggerx86.TYPE_BYTE  | Debuggerx86.TYPE_IN],
    /* 0x74 */ [Debuggerx86.INS.JZ,    Debuggerx86.TYPE_IMMREL | Debuggerx86.TYPE_BYTE  | Debuggerx86.TYPE_IN],
    /* 0x75 */ [Debuggerx86.INS.JNZ,   Debuggerx86.TYPE_IMMREL | Debuggerx86.TYPE_BYTE  | Debuggerx86.TYPE_IN],
    /* 0x76 */ [Debuggerx86.INS.JBE,   Debuggerx86.TYPE_IMMREL | Debuggerx86.TYPE_BYTE  | Debuggerx86.TYPE_IN],
    /* 0x77 */ [Debuggerx86.INS.JA,    Debuggerx86.TYPE_IMMREL | Debuggerx86.TYPE_BYTE  | Debuggerx86.TYPE_IN],

    /* 0x78 */ [Debuggerx86.INS.JS,    Debuggerx86.TYPE_IMMREL | Debuggerx86.TYPE_BYTE  | Debuggerx86.TYPE_IN],
    /* 0x79 */ [Debuggerx86.INS.JNS,   Debuggerx86.TYPE_IMMREL | Debuggerx86.TYPE_BYTE  | Debuggerx86.TYPE_IN],
    /* 0x7A */ [Debuggerx86.INS.JP,    Debuggerx86.TYPE_IMMREL | Debuggerx86.TYPE_BYTE  | Debuggerx86.TYPE_IN],
    /* 0x7B */ [Debuggerx86.INS.JNP,   Debuggerx86.TYPE_IMMREL | Debuggerx86.TYPE_BYTE  | Debuggerx86.TYPE_IN],
    /* 0x7C */ [Debuggerx86.INS.JL,    Debuggerx86.TYPE_IMMREL | Debuggerx86.TYPE_BYTE  | Debuggerx86.TYPE_IN],
    /* 0x7D */ [Debuggerx86.INS.JGE,   Debuggerx86.TYPE_IMMREL | Debuggerx86.TYPE_BYTE  | Debuggerx86.TYPE_IN],
    /* 0x7E */ [Debuggerx86.INS.JLE,   Debuggerx86.TYPE_IMMREL | Debuggerx86.TYPE_BYTE  | Debuggerx86.TYPE_IN],
    /* 0x7F */ [Debuggerx86.INS.JG,    Debuggerx86.TYPE_IMMREL | Debuggerx86.TYPE_BYTE  | Debuggerx86.TYPE_IN],

    /* 0x80 */ [Debuggerx86.INS.GRP1B, Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_BYTE  | Debuggerx86.TYPE_BOTH, Debuggerx86.TYPE_IMM   | Debuggerx86.TYPE_BYTE  | Debuggerx86.TYPE_IN],
    /* 0x81 */ [Debuggerx86.INS.GRP1W, Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_BOTH, Debuggerx86.TYPE_IMM   | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_IN],
    /* 0x82 */ [Debuggerx86.INS.GRP1B, Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_BYTE  | Debuggerx86.TYPE_BOTH, Debuggerx86.TYPE_IMM   | Debuggerx86.TYPE_BYTE  | Debuggerx86.TYPE_IN],
    /* 0x83 */ [Debuggerx86.INS.GRP1SW,Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_BOTH, Debuggerx86.TYPE_IMM   | Debuggerx86.TYPE_BYTE  | Debuggerx86.TYPE_IN],
    /* 0x84 */ [Debuggerx86.INS.TEST,  Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_BYTE  | Debuggerx86.TYPE_IN,   Debuggerx86.TYPE_REG   | Debuggerx86.TYPE_BYTE  | Debuggerx86.TYPE_IN],
    /* 0x85 */ [Debuggerx86.INS.TEST,  Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_IN,   Debuggerx86.TYPE_REG   | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_IN],
    /* 0x86 */ [Debuggerx86.INS.XCHG,  Debuggerx86.TYPE_REG    | Debuggerx86.TYPE_BYTE  | Debuggerx86.TYPE_BOTH, Debuggerx86.TYPE_MODRM | Debuggerx86.TYPE_BYTE  | Debuggerx86.TYPE_BOTH],
    /* 0x87 */ [Debuggerx86.INS.XCHG,  Debuggerx86.TYPE_REG    | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_BOTH, Debuggerx86.TYPE_MODRM | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_BOTH],

    /* 0x88 */ [Debuggerx86.INS.MOV,   Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_BYTE  | Debuggerx86.TYPE_OUT,  Debuggerx86.TYPE_REG    | Debuggerx86.TYPE_BYTE  | Debuggerx86.TYPE_IN],
    /* 0x89 */ [Debuggerx86.INS.MOV,   Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_OUT,  Debuggerx86.TYPE_REG    | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_IN],
    /* 0x8A */ [Debuggerx86.INS.MOV,   Debuggerx86.TYPE_REG    | Debuggerx86.TYPE_BYTE  | Debuggerx86.TYPE_OUT,  Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_BYTE  | Debuggerx86.TYPE_IN],
    /* 0x8B */ [Debuggerx86.INS.MOV,   Debuggerx86.TYPE_REG    | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_OUT,  Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_IN],
    /* 0x8C */ [Debuggerx86.INS.MOV,   Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_OUT,  Debuggerx86.TYPE_SEGREG | Debuggerx86.TYPE_SHORT | Debuggerx86.TYPE_IN],
    /* 0x8D */ [Debuggerx86.INS.LEA,   Debuggerx86.TYPE_REG    | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_OUT,  Debuggerx86.TYPE_MODMEM | Debuggerx86.TYPE_WORD ],
    /* 0x8E */ [Debuggerx86.INS.MOV,   Debuggerx86.TYPE_SEGREG | Debuggerx86.TYPE_SHORT | Debuggerx86.TYPE_OUT,  Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_IN],
    /* 0x8F */ [Debuggerx86.INS.POP,   Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_OUT],

    /* 0x90 */ [Debuggerx86.INS.NOP],
    /* 0x91 */ [Debuggerx86.INS.XCHG,  Debuggerx86.TYPE_AX     | Debuggerx86.TYPE_BOTH,   Debuggerx86.TYPE_CX  | Debuggerx86.TYPE_BOTH],
    /* 0x92 */ [Debuggerx86.INS.XCHG,  Debuggerx86.TYPE_AX     | Debuggerx86.TYPE_BOTH,   Debuggerx86.TYPE_DX  | Debuggerx86.TYPE_BOTH],
    /* 0x93 */ [Debuggerx86.INS.XCHG,  Debuggerx86.TYPE_AX     | Debuggerx86.TYPE_BOTH,   Debuggerx86.TYPE_BX  | Debuggerx86.TYPE_BOTH],
    /* 0x94 */ [Debuggerx86.INS.XCHG,  Debuggerx86.TYPE_AX     | Debuggerx86.TYPE_BOTH,   Debuggerx86.TYPE_SP  | Debuggerx86.TYPE_BOTH],
    /* 0x95 */ [Debuggerx86.INS.XCHG,  Debuggerx86.TYPE_AX     | Debuggerx86.TYPE_BOTH,   Debuggerx86.TYPE_BP  | Debuggerx86.TYPE_BOTH],
    /* 0x96 */ [Debuggerx86.INS.XCHG,  Debuggerx86.TYPE_AX     | Debuggerx86.TYPE_BOTH,   Debuggerx86.TYPE_SI  | Debuggerx86.TYPE_BOTH],
    /* 0x97 */ [Debuggerx86.INS.XCHG,  Debuggerx86.TYPE_AX     | Debuggerx86.TYPE_BOTH,   Debuggerx86.TYPE_DI  | Debuggerx86.TYPE_BOTH],

    /* 0x98 */ [Debuggerx86.INS.CBW],
    /* 0x99 */ [Debuggerx86.INS.CWD],
    /* 0x9A */ [Debuggerx86.INS.CALL,  Debuggerx86.TYPE_IMM    | Debuggerx86.TYPE_FARP |  Debuggerx86.TYPE_IN],
    /* 0x9B */ [Debuggerx86.INS.WAIT],
    /* 0x9C */ [Debuggerx86.INS.PUSHF],
    /* 0x9D */ [Debuggerx86.INS.POPF],
    /* 0x9E */ [Debuggerx86.INS.SAHF],
    /* 0x9F */ [Debuggerx86.INS.LAHF],

    /* 0xA0 */ [Debuggerx86.INS.MOV,   Debuggerx86.TYPE_AL     | Debuggerx86.TYPE_OUT,    Debuggerx86.TYPE_IMMOFF | Debuggerx86.TYPE_BYTE  | Debuggerx86.TYPE_IN],
    /* 0xA1 */ [Debuggerx86.INS.MOV,   Debuggerx86.TYPE_AX     | Debuggerx86.TYPE_OUT,    Debuggerx86.TYPE_IMMOFF | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_IN],
    /* 0xA2 */ [Debuggerx86.INS.MOV,   Debuggerx86.TYPE_IMMOFF | Debuggerx86.TYPE_BYTE  | Debuggerx86.TYPE_OUT,     Debuggerx86.TYPE_AL    | Debuggerx86.TYPE_IN],
    /* 0xA3 */ [Debuggerx86.INS.MOV,   Debuggerx86.TYPE_IMMOFF | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_OUT,     Debuggerx86.TYPE_AX    | Debuggerx86.TYPE_IN],
    /* 0xA4 */ [Debuggerx86.INS.MOVSB, Debuggerx86.TYPE_ESDI   | Debuggerx86.TYPE_BYTE  | Debuggerx86.TYPE_OUT,     Debuggerx86.TYPE_DSSI  | Debuggerx86.TYPE_BYTE  | Debuggerx86.TYPE_IN],
    /* 0xA5 */ [Debuggerx86.INS.MOVSW, Debuggerx86.TYPE_ESDI   | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_OUT,     Debuggerx86.TYPE_DSSI  | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_IN],
    /* 0xA6 */ [Debuggerx86.INS.CMPSB, Debuggerx86.TYPE_ESDI   | Debuggerx86.TYPE_BYTE  | Debuggerx86.TYPE_IN,      Debuggerx86.TYPE_DSSI  | Debuggerx86.TYPE_BYTE  | Debuggerx86.TYPE_IN],
    /* 0xA7 */ [Debuggerx86.INS.CMPSW, Debuggerx86.TYPE_ESDI   | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_IN,      Debuggerx86.TYPE_DSSI  | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_IN],

    /* 0xA8 */ [Debuggerx86.INS.TEST,  Debuggerx86.TYPE_AL     | Debuggerx86.TYPE_IN,     Debuggerx86.TYPE_IMM  | Debuggerx86.TYPE_BYTE  | Debuggerx86.TYPE_IN],
    /* 0xA9 */ [Debuggerx86.INS.TEST,  Debuggerx86.TYPE_AX     | Debuggerx86.TYPE_IN,     Debuggerx86.TYPE_IMM  | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_IN],
    /* 0xAA */ [Debuggerx86.INS.STOSB, Debuggerx86.TYPE_ESDI   | Debuggerx86.TYPE_BYTE  | Debuggerx86.TYPE_OUT,   Debuggerx86.TYPE_AL    | Debuggerx86.TYPE_IN],
    /* 0xAB */ [Debuggerx86.INS.STOSW, Debuggerx86.TYPE_ESDI   | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_OUT,   Debuggerx86.TYPE_AX    | Debuggerx86.TYPE_IN],
    /* 0xAC */ [Debuggerx86.INS.LODSB, Debuggerx86.TYPE_AL     | Debuggerx86.TYPE_OUT,    Debuggerx86.TYPE_DSSI | Debuggerx86.TYPE_BYTE  | Debuggerx86.TYPE_IN],
    /* 0xAD */ [Debuggerx86.INS.LODSW, Debuggerx86.TYPE_AX     | Debuggerx86.TYPE_OUT,    Debuggerx86.TYPE_DSSI | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_IN],
    /* 0xAE */ [Debuggerx86.INS.SCASB, Debuggerx86.TYPE_AL     | Debuggerx86.TYPE_IN,     Debuggerx86.TYPE_ESDI | Debuggerx86.TYPE_BYTE  | Debuggerx86.TYPE_IN],
    /* 0xAF */ [Debuggerx86.INS.SCASW, Debuggerx86.TYPE_AX     | Debuggerx86.TYPE_IN,     Debuggerx86.TYPE_ESDI | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_IN],

    /* 0xB0 */ [Debuggerx86.INS.MOV,   Debuggerx86.TYPE_AL     | Debuggerx86.TYPE_OUT,    Debuggerx86.TYPE_IMM  | Debuggerx86.TYPE_BYTE  | Debuggerx86.TYPE_IN],
    /* 0xB1 */ [Debuggerx86.INS.MOV,   Debuggerx86.TYPE_CL     | Debuggerx86.TYPE_OUT,    Debuggerx86.TYPE_IMM  | Debuggerx86.TYPE_BYTE  | Debuggerx86.TYPE_IN],
    /* 0xB2 */ [Debuggerx86.INS.MOV,   Debuggerx86.TYPE_DL     | Debuggerx86.TYPE_OUT,    Debuggerx86.TYPE_IMM  | Debuggerx86.TYPE_BYTE  | Debuggerx86.TYPE_IN],
    /* 0xB3 */ [Debuggerx86.INS.MOV,   Debuggerx86.TYPE_BL     | Debuggerx86.TYPE_OUT,    Debuggerx86.TYPE_IMM  | Debuggerx86.TYPE_BYTE  | Debuggerx86.TYPE_IN],
    /* 0xB4 */ [Debuggerx86.INS.MOV,   Debuggerx86.TYPE_AH     | Debuggerx86.TYPE_OUT,    Debuggerx86.TYPE_IMM  | Debuggerx86.TYPE_BYTE  | Debuggerx86.TYPE_IN],
    /* 0xB5 */ [Debuggerx86.INS.MOV,   Debuggerx86.TYPE_CH     | Debuggerx86.TYPE_OUT,    Debuggerx86.TYPE_IMM  | Debuggerx86.TYPE_BYTE  | Debuggerx86.TYPE_IN],
    /* 0xB6 */ [Debuggerx86.INS.MOV,   Debuggerx86.TYPE_DH     | Debuggerx86.TYPE_OUT,    Debuggerx86.TYPE_IMM  | Debuggerx86.TYPE_BYTE  | Debuggerx86.TYPE_IN],
    /* 0xB7 */ [Debuggerx86.INS.MOV,   Debuggerx86.TYPE_BH     | Debuggerx86.TYPE_OUT,    Debuggerx86.TYPE_IMM  | Debuggerx86.TYPE_BYTE  | Debuggerx86.TYPE_IN],

    /* 0xB8 */ [Debuggerx86.INS.MOV,   Debuggerx86.TYPE_AX     | Debuggerx86.TYPE_OUT,    Debuggerx86.TYPE_IMM  | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_IN],
    /* 0xB9 */ [Debuggerx86.INS.MOV,   Debuggerx86.TYPE_CX     | Debuggerx86.TYPE_OUT,    Debuggerx86.TYPE_IMM  | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_IN],
    /* 0xBA */ [Debuggerx86.INS.MOV,   Debuggerx86.TYPE_DX     | Debuggerx86.TYPE_OUT,    Debuggerx86.TYPE_IMM  | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_IN],
    /* 0xBB */ [Debuggerx86.INS.MOV,   Debuggerx86.TYPE_BX     | Debuggerx86.TYPE_OUT,    Debuggerx86.TYPE_IMM  | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_IN],
    /* 0xBC */ [Debuggerx86.INS.MOV,   Debuggerx86.TYPE_SP     | Debuggerx86.TYPE_OUT,    Debuggerx86.TYPE_IMM  | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_IN],
    /* 0xBD */ [Debuggerx86.INS.MOV,   Debuggerx86.TYPE_BP     | Debuggerx86.TYPE_OUT,    Debuggerx86.TYPE_IMM  | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_IN],
    /* 0xBE */ [Debuggerx86.INS.MOV,   Debuggerx86.TYPE_SI     | Debuggerx86.TYPE_OUT,    Debuggerx86.TYPE_IMM  | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_IN],
    /* 0xBF */ [Debuggerx86.INS.MOV,   Debuggerx86.TYPE_DI     | Debuggerx86.TYPE_OUT,    Debuggerx86.TYPE_IMM  | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_IN],

    /* 0xC0 */ [Debuggerx86.INS.GRP2B, Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_BYTE  | Debuggerx86.TYPE_BOTH | Debuggerx86.TYPE_80186,  Debuggerx86.TYPE_IMM | Debuggerx86.TYPE_BYTE | Debuggerx86.TYPE_IN],
    /* 0xC1 */ [Debuggerx86.INS.GRP2W, Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_BOTH | Debuggerx86.TYPE_80186,  Debuggerx86.TYPE_IMM | Debuggerx86.TYPE_BYTE | Debuggerx86.TYPE_IN],
    /* 0xC2 */ [Debuggerx86.INS.RET,   Debuggerx86.TYPE_IMM    | Debuggerx86.TYPE_SHORT | Debuggerx86.TYPE_IN],
    /* 0xC3 */ [Debuggerx86.INS.RET],
    /* 0xC4 */ [Debuggerx86.INS.LES,   Debuggerx86.TYPE_REG    | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_OUT,   Debuggerx86.TYPE_MODMEM  | Debuggerx86.TYPE_SEGP  | Debuggerx86.TYPE_IN],
    /* 0xC5 */ [Debuggerx86.INS.LDS,   Debuggerx86.TYPE_REG    | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_OUT,   Debuggerx86.TYPE_MODMEM  | Debuggerx86.TYPE_SEGP  | Debuggerx86.TYPE_IN],
    /* 0xC6 */ [Debuggerx86.INS.MOV,   Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_BYTE  | Debuggerx86.TYPE_OUT,   Debuggerx86.TYPE_IMM     | Debuggerx86.TYPE_BYTE  | Debuggerx86.TYPE_IN],
    /* 0xC7 */ [Debuggerx86.INS.MOV,   Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_OUT,   Debuggerx86.TYPE_IMM     | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_IN],

    /* 0xC8 */ [Debuggerx86.INS.ENTER, Debuggerx86.TYPE_IMM    | Debuggerx86.TYPE_SHORT | Debuggerx86.TYPE_IN   | Debuggerx86.TYPE_80186,    Debuggerx86.TYPE_IMM   | Debuggerx86.TYPE_BYTE | Debuggerx86.TYPE_IN],
    /* 0xC9 */ [Debuggerx86.INS.LEAVE, Debuggerx86.TYPE_NONE   | Debuggerx86.TYPE_80186],
    /* 0xCA */ [Debuggerx86.INS.RETF,  Debuggerx86.TYPE_IMM    | Debuggerx86.TYPE_SHORT | Debuggerx86.TYPE_IN],
    /* 0xCB */ [Debuggerx86.INS.RETF],
    /* 0xCC */ [Debuggerx86.INS.INT3],
    /* 0xCD */ [Debuggerx86.INS.INT,   Debuggerx86.TYPE_IMM    | Debuggerx86.TYPE_BYTE  | Debuggerx86.TYPE_IN],
    /* 0xCE */ [Debuggerx86.INS.INTO],
    /* 0xCF */ [Debuggerx86.INS.IRET],

    /* 0xD0 */ [Debuggerx86.INS.GRP2B1,Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_BYTE  | Debuggerx86.TYPE_BOTH,  Debuggerx86.TYPE_ONE    | Debuggerx86.TYPE_BYTE | Debuggerx86.TYPE_IN],
    /* 0xD1 */ [Debuggerx86.INS.GRP2W1,Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_BOTH,  Debuggerx86.TYPE_ONE    | Debuggerx86.TYPE_BYTE | Debuggerx86.TYPE_IN],
    /* 0xD2 */ [Debuggerx86.INS.GRP2BC,Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_BYTE  | Debuggerx86.TYPE_BOTH,  Debuggerx86.TYPE_CL     | Debuggerx86.TYPE_IN],
    /* 0xD3 */ [Debuggerx86.INS.GRP2WC,Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_BOTH,  Debuggerx86.TYPE_CL     | Debuggerx86.TYPE_IN],
    /* 0xD4 */ [Debuggerx86.INS.AAM,   Debuggerx86.TYPE_IMM    | Debuggerx86.TYPE_BYTE],
    /* 0xD5 */ [Debuggerx86.INS.AAD,   Debuggerx86.TYPE_IMM    | Debuggerx86.TYPE_BYTE],
    /* 0xD6 */ [Debuggerx86.INS.SALC],
    /* 0xD7 */ [Debuggerx86.INS.XLAT],

    /* 0xD8 */ [Debuggerx86.INS.ESC,   Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_IN],
    /* 0xD9 */ [Debuggerx86.INS.ESC,   Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_IN],
    /* 0xDA */ [Debuggerx86.INS.ESC,   Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_IN],
    /* 0xDB */ [Debuggerx86.INS.ESC,   Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_IN],
    /* 0xDC */ [Debuggerx86.INS.ESC,   Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_IN],
    /* 0xDD */ [Debuggerx86.INS.ESC,   Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_IN],
    /* 0xDE */ [Debuggerx86.INS.ESC,   Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_IN],
    /* 0xDF */ [Debuggerx86.INS.ESC,   Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_IN],

    /* 0xE0 */ [Debuggerx86.INS.LOOPNZ,Debuggerx86.TYPE_IMMREL | Debuggerx86.TYPE_BYTE  | Debuggerx86.TYPE_IN],
    /* 0xE1 */ [Debuggerx86.INS.LOOPZ, Debuggerx86.TYPE_IMMREL | Debuggerx86.TYPE_BYTE  | Debuggerx86.TYPE_IN],
    /* 0xE2 */ [Debuggerx86.INS.LOOP,  Debuggerx86.TYPE_IMMREL | Debuggerx86.TYPE_BYTE  | Debuggerx86.TYPE_IN],
    /* 0xE3 */ [Debuggerx86.INS.JCXZ,  Debuggerx86.TYPE_IMMREL | Debuggerx86.TYPE_BYTE  | Debuggerx86.TYPE_IN],
    /* 0xE4 */ [Debuggerx86.INS.IN,    Debuggerx86.TYPE_AL     | Debuggerx86.TYPE_OUT,    Debuggerx86.TYPE_IMM  | Debuggerx86.TYPE_BYTE | Debuggerx86.TYPE_IN],
    /* 0xE5 */ [Debuggerx86.INS.IN,    Debuggerx86.TYPE_AX     | Debuggerx86.TYPE_OUT,    Debuggerx86.TYPE_IMM  | Debuggerx86.TYPE_BYTE | Debuggerx86.TYPE_IN],
    /* 0xE6 */ [Debuggerx86.INS.OUT,   Debuggerx86.TYPE_IMM    | Debuggerx86.TYPE_BYTE  | Debuggerx86.TYPE_IN,    Debuggerx86.TYPE_AL   | Debuggerx86.TYPE_IN],
    /* 0xE7 */ [Debuggerx86.INS.OUT,   Debuggerx86.TYPE_IMM    | Debuggerx86.TYPE_BYTE  | Debuggerx86.TYPE_IN,    Debuggerx86.TYPE_AX   | Debuggerx86.TYPE_IN],

    /* 0xE8 */ [Debuggerx86.INS.CALL,  Debuggerx86.TYPE_IMMREL | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_IN],
    /* 0xE9 */ [Debuggerx86.INS.JMP,   Debuggerx86.TYPE_IMMREL | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_IN],
    /* 0xEA */ [Debuggerx86.INS.JMP,   Debuggerx86.TYPE_IMM    | Debuggerx86.TYPE_FARP  | Debuggerx86.TYPE_IN],
    /* 0xEB */ [Debuggerx86.INS.JMP,   Debuggerx86.TYPE_IMMREL | Debuggerx86.TYPE_BYTE  | Debuggerx86.TYPE_IN],
    /* 0xEC */ [Debuggerx86.INS.IN,    Debuggerx86.TYPE_AL     | Debuggerx86.TYPE_OUT,    Debuggerx86.TYPE_DX   | Debuggerx86.TYPE_SHORT | Debuggerx86.TYPE_IN],
    /* 0xED */ [Debuggerx86.INS.IN,    Debuggerx86.TYPE_AX     | Debuggerx86.TYPE_OUT,    Debuggerx86.TYPE_DX   | Debuggerx86.TYPE_SHORT | Debuggerx86.TYPE_IN],
    /* 0xEE */ [Debuggerx86.INS.OUT,   Debuggerx86.TYPE_DX     | Debuggerx86.TYPE_SHORT | Debuggerx86.TYPE_IN,    Debuggerx86.TYPE_AL    | Debuggerx86.TYPE_IN],
    /* 0xEF */ [Debuggerx86.INS.OUT,   Debuggerx86.TYPE_DX     | Debuggerx86.TYPE_SHORT | Debuggerx86.TYPE_IN,    Debuggerx86.TYPE_AX    | Debuggerx86.TYPE_IN],

    /* 0xF0 */ [Debuggerx86.INS.LOCK,  Debuggerx86.TYPE_PREFIX],
    /* 0xF1 */ [Debuggerx86.INS.INT1,  Debuggerx86.TYPE_NONE   | Debuggerx86.TYPE_80386],
    /* 0xF2 */ [Debuggerx86.INS.REPNZ, Debuggerx86.TYPE_PREFIX],
    /* 0xF3 */ [Debuggerx86.INS.REPZ,  Debuggerx86.TYPE_PREFIX],
    /* 0xF4 */ [Debuggerx86.INS.HLT],
    /* 0xF5 */ [Debuggerx86.INS.CMC],
    /* 0xF6 */ [Debuggerx86.INS.GRP3B, Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_BYTE  | Debuggerx86.TYPE_BOTH],
    /* 0xF7 */ [Debuggerx86.INS.GRP3W, Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_BOTH],

    /* 0xF8 */ [Debuggerx86.INS.CLC],
    /* 0xF9 */ [Debuggerx86.INS.STC],
    /* 0xFA */ [Debuggerx86.INS.CLI],
    /* 0xFB */ [Debuggerx86.INS.STI],
    /* 0xFC */ [Debuggerx86.INS.CLD],
    /* 0xFD */ [Debuggerx86.INS.STD],
    /* 0xFE */ [Debuggerx86.INS.GRP4B, Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_BYTE  | Debuggerx86.TYPE_BOTH],
    /* 0xFF */ [Debuggerx86.INS.GRP4W, Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_BOTH]
    ];

    Debuggerx86.aaOp0FDescs = {
        0x00: [Debuggerx86.INS.GRP6,   Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_SHORT | Debuggerx86.TYPE_BOTH],
        0x01: [Debuggerx86.INS.GRP7,   Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_SHORT | Debuggerx86.TYPE_BOTH],
        0x02: [Debuggerx86.INS.LAR,    Debuggerx86.TYPE_REG    | Debuggerx86.TYPE_SHORT | Debuggerx86.TYPE_OUT  | Debuggerx86.TYPE_80286, Debuggerx86.TYPE_MODMEM | Debuggerx86.TYPE_SHORT| Debuggerx86.TYPE_IN],
        0x03: [Debuggerx86.INS.LSL,    Debuggerx86.TYPE_REG    | Debuggerx86.TYPE_SHORT | Debuggerx86.TYPE_OUT  | Debuggerx86.TYPE_80286, Debuggerx86.TYPE_MODMEM | Debuggerx86.TYPE_SHORT| Debuggerx86.TYPE_IN],
        0x05: [Debuggerx86.INS.LOADALL,Debuggerx86.TYPE_80286],
        0x06: [Debuggerx86.INS.CLTS,   Debuggerx86.TYPE_80286],
        0x07: [Debuggerx86.INS.LOADALL,Debuggerx86.TYPE_80386],   // TODO: implied operand is ES:[(E)DI]
        0x20: [Debuggerx86.INS.MOV,    Debuggerx86.TYPE_MODREG | Debuggerx86.TYPE_LONG  | Debuggerx86.TYPE_OUT  | Debuggerx86.TYPE_80386, Debuggerx86.TYPE_CTLREG | Debuggerx86.TYPE_LONG  | Debuggerx86.TYPE_IN],
        0x21: [Debuggerx86.INS.MOV,    Debuggerx86.TYPE_MODREG | Debuggerx86.TYPE_LONG  | Debuggerx86.TYPE_OUT  | Debuggerx86.TYPE_80386, Debuggerx86.TYPE_DBGREG | Debuggerx86.TYPE_LONG  | Debuggerx86.TYPE_IN],
        0x22: [Debuggerx86.INS.MOV,    Debuggerx86.TYPE_CTLREG | Debuggerx86.TYPE_LONG  | Debuggerx86.TYPE_OUT  | Debuggerx86.TYPE_80386, Debuggerx86.TYPE_MODREG | Debuggerx86.TYPE_LONG  | Debuggerx86.TYPE_IN],
        0x23: [Debuggerx86.INS.MOV,    Debuggerx86.TYPE_DBGREG | Debuggerx86.TYPE_LONG  | Debuggerx86.TYPE_OUT  | Debuggerx86.TYPE_80386, Debuggerx86.TYPE_MODREG | Debuggerx86.TYPE_LONG  | Debuggerx86.TYPE_IN],
        0x24: [Debuggerx86.INS.MOV,    Debuggerx86.TYPE_MODREG | Debuggerx86.TYPE_LONG  | Debuggerx86.TYPE_OUT  | Debuggerx86.TYPE_80386, Debuggerx86.TYPE_TSTREG | Debuggerx86.TYPE_LONG  | Debuggerx86.TYPE_IN],
        0x26: [Debuggerx86.INS.MOV,    Debuggerx86.TYPE_TSTREG | Debuggerx86.TYPE_LONG  | Debuggerx86.TYPE_OUT  | Debuggerx86.TYPE_80386, Debuggerx86.TYPE_MODREG | Debuggerx86.TYPE_LONG  | Debuggerx86.TYPE_IN],
        0x80: [Debuggerx86.INS.JO,     Debuggerx86.TYPE_IMMREL | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_IN   | Debuggerx86.TYPE_80386],
        0x81: [Debuggerx86.INS.JNO,    Debuggerx86.TYPE_IMMREL | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_IN   | Debuggerx86.TYPE_80386],
        0x82: [Debuggerx86.INS.JC,     Debuggerx86.TYPE_IMMREL | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_IN   | Debuggerx86.TYPE_80386],
        0x83: [Debuggerx86.INS.JNC,    Debuggerx86.TYPE_IMMREL | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_IN   | Debuggerx86.TYPE_80386],
        0x84: [Debuggerx86.INS.JZ,     Debuggerx86.TYPE_IMMREL | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_IN   | Debuggerx86.TYPE_80386],
        0x85: [Debuggerx86.INS.JNZ,    Debuggerx86.TYPE_IMMREL | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_IN   | Debuggerx86.TYPE_80386],
        0x86: [Debuggerx86.INS.JBE,    Debuggerx86.TYPE_IMMREL | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_IN   | Debuggerx86.TYPE_80386],
        0x87: [Debuggerx86.INS.JA,     Debuggerx86.TYPE_IMMREL | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_IN   | Debuggerx86.TYPE_80386],
        0x88: [Debuggerx86.INS.JS,     Debuggerx86.TYPE_IMMREL | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_IN   | Debuggerx86.TYPE_80386],
        0x89: [Debuggerx86.INS.JNS,    Debuggerx86.TYPE_IMMREL | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_IN   | Debuggerx86.TYPE_80386],
        0x8A: [Debuggerx86.INS.JP,     Debuggerx86.TYPE_IMMREL | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_IN   | Debuggerx86.TYPE_80386],
        0x8B: [Debuggerx86.INS.JNP,    Debuggerx86.TYPE_IMMREL | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_IN   | Debuggerx86.TYPE_80386],
        0x8C: [Debuggerx86.INS.JL,     Debuggerx86.TYPE_IMMREL | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_IN   | Debuggerx86.TYPE_80386],
        0x8D: [Debuggerx86.INS.JGE,    Debuggerx86.TYPE_IMMREL | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_IN   | Debuggerx86.TYPE_80386],
        0x8E: [Debuggerx86.INS.JLE,    Debuggerx86.TYPE_IMMREL | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_IN   | Debuggerx86.TYPE_80386],
        0x8F: [Debuggerx86.INS.JG,     Debuggerx86.TYPE_IMMREL | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_IN   | Debuggerx86.TYPE_80386],
        0x90: [Debuggerx86.INS.SETO,   Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_BYTE  | Debuggerx86.TYPE_OUT  | Debuggerx86.TYPE_80386],
        0x91: [Debuggerx86.INS.SETNO,  Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_BYTE  | Debuggerx86.TYPE_OUT  | Debuggerx86.TYPE_80386],
        0x92: [Debuggerx86.INS.SETC,   Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_BYTE  | Debuggerx86.TYPE_OUT  | Debuggerx86.TYPE_80386],
        0x93: [Debuggerx86.INS.SETNC,  Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_BYTE  | Debuggerx86.TYPE_OUT  | Debuggerx86.TYPE_80386],
        0x94: [Debuggerx86.INS.SETZ,   Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_BYTE  | Debuggerx86.TYPE_OUT  | Debuggerx86.TYPE_80386],
        0x95: [Debuggerx86.INS.SETNZ,  Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_BYTE  | Debuggerx86.TYPE_OUT  | Debuggerx86.TYPE_80386],
        0x96: [Debuggerx86.INS.SETBE,  Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_BYTE  | Debuggerx86.TYPE_OUT  | Debuggerx86.TYPE_80386],
        0x97: [Debuggerx86.INS.SETNBE, Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_BYTE  | Debuggerx86.TYPE_OUT  | Debuggerx86.TYPE_80386],
        0x98: [Debuggerx86.INS.SETS,   Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_BYTE  | Debuggerx86.TYPE_OUT  | Debuggerx86.TYPE_80386],
        0x99: [Debuggerx86.INS.SETNS,  Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_BYTE  | Debuggerx86.TYPE_OUT  | Debuggerx86.TYPE_80386],
        0x9A: [Debuggerx86.INS.SETP,   Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_BYTE  | Debuggerx86.TYPE_OUT  | Debuggerx86.TYPE_80386],
        0x9B: [Debuggerx86.INS.SETNP,  Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_BYTE  | Debuggerx86.TYPE_OUT  | Debuggerx86.TYPE_80386],
        0x9C: [Debuggerx86.INS.SETL,   Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_BYTE  | Debuggerx86.TYPE_OUT  | Debuggerx86.TYPE_80386],
        0x9D: [Debuggerx86.INS.SETGE,  Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_BYTE  | Debuggerx86.TYPE_OUT  | Debuggerx86.TYPE_80386],
        0x9E: [Debuggerx86.INS.SETLE,  Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_BYTE  | Debuggerx86.TYPE_OUT  | Debuggerx86.TYPE_80386],
        0x9F: [Debuggerx86.INS.SETG,   Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_BYTE  | Debuggerx86.TYPE_OUT  | Debuggerx86.TYPE_80386],
        0xA0: [Debuggerx86.INS.PUSH,   Debuggerx86.TYPE_FS     | Debuggerx86.TYPE_IN    | Debuggerx86.TYPE_80386],
        0xA1: [Debuggerx86.INS.POP,    Debuggerx86.TYPE_FS     | Debuggerx86.TYPE_OUT   | Debuggerx86.TYPE_80386],
        0xA3: [Debuggerx86.INS.BT,     Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_IN   | Debuggerx86.TYPE_80386, Debuggerx86.TYPE_REG    | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_IN],
        0xA4: [Debuggerx86.INS.SHLD,   Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_OUT  | Debuggerx86.TYPE_80386, Debuggerx86.TYPE_REG    | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_IN, Debuggerx86.TYPE_IMM | Debuggerx86.TYPE_BYTE | Debuggerx86.TYPE_IN],
        0xA5: [Debuggerx86.INS.SHLD,   Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_OUT  | Debuggerx86.TYPE_80386, Debuggerx86.TYPE_REG    | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_IN, Debuggerx86.TYPE_CL  | Debuggerx86.TYPE_IN],
        0xA6: [Debuggerx86.INS.XBTS,   Debuggerx86.TYPE_REG    | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_OUT  | Debuggerx86.TYPE_80386, Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_IN, Debuggerx86.TYPE_AX  | Debuggerx86.TYPE_IN,  Debuggerx86.TYPE_CL    | Debuggerx86.TYPE_IN],
        0xA7: [Debuggerx86.INS.IBTS,   Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_OUT  | Debuggerx86.TYPE_80386, Debuggerx86.TYPE_AX     | Debuggerx86.TYPE_IN, Debuggerx86.TYPE_CL  | Debuggerx86.TYPE_IN, Debuggerx86.TYPE_REG    | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_IN],
        0xA8: [Debuggerx86.INS.PUSH,   Debuggerx86.TYPE_GS     | Debuggerx86.TYPE_IN    | Debuggerx86.TYPE_80386],
        0xA9: [Debuggerx86.INS.POP,    Debuggerx86.TYPE_GS     | Debuggerx86.TYPE_OUT   | Debuggerx86.TYPE_80386],
        0xAB: [Debuggerx86.INS.BTS,    Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_OUT  | Debuggerx86.TYPE_80386, Debuggerx86.TYPE_REG    | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_IN],
        0xAC: [Debuggerx86.INS.SHRD,   Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_OUT  | Debuggerx86.TYPE_80386, Debuggerx86.TYPE_REG    | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_IN, Debuggerx86.TYPE_IMM | Debuggerx86.TYPE_BYTE | Debuggerx86.TYPE_IN],
        0xAD: [Debuggerx86.INS.SHRD,   Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_OUT  | Debuggerx86.TYPE_80386, Debuggerx86.TYPE_REG    | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_IN, Debuggerx86.TYPE_CL  | Debuggerx86.TYPE_IN],
        0xAF: [Debuggerx86.INS.IMUL,   Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_BOTH | Debuggerx86.TYPE_80386, Debuggerx86.TYPE_REG    | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_IN],
        0xB2: [Debuggerx86.INS.LSS,    Debuggerx86.TYPE_REG    | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_OUT,                           Debuggerx86.TYPE_MODMEM | Debuggerx86.TYPE_SEGP  | Debuggerx86.TYPE_IN],
        0xB3: [Debuggerx86.INS.BTR,    Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_OUT  | Debuggerx86.TYPE_80386, Debuggerx86.TYPE_REG    | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_IN],
        0xB4: [Debuggerx86.INS.LFS,    Debuggerx86.TYPE_REG    | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_OUT,                           Debuggerx86.TYPE_MODMEM | Debuggerx86.TYPE_SEGP  | Debuggerx86.TYPE_IN],
        0xB5: [Debuggerx86.INS.LGS,    Debuggerx86.TYPE_REG    | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_OUT,                           Debuggerx86.TYPE_MODMEM | Debuggerx86.TYPE_SEGP  | Debuggerx86.TYPE_IN],
        0xB6: [Debuggerx86.INS.MOVZX,  Debuggerx86.TYPE_REG    | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_OUT  | Debuggerx86.TYPE_80386, Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_BYTE  | Debuggerx86.TYPE_IN],
        0xB7: [Debuggerx86.INS.MOVZX,  Debuggerx86.TYPE_REG    | Debuggerx86.TYPE_LONG  | Debuggerx86.TYPE_OUT  | Debuggerx86.TYPE_80386, Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_SHORT | Debuggerx86.TYPE_IN],
        0xBA: [Debuggerx86.INS.GRP8,   Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_BOTH | Debuggerx86.TYPE_80386, Debuggerx86.TYPE_IMM    | Debuggerx86.TYPE_BYTE  | Debuggerx86.TYPE_IN],
        0xBB: [Debuggerx86.INS.BTC,    Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_OUT  | Debuggerx86.TYPE_80386, Debuggerx86.TYPE_REG    | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_IN],
        0xBC: [Debuggerx86.INS.BSF,    Debuggerx86.TYPE_REG    | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_OUT  | Debuggerx86.TYPE_80386, Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_IN],
        0xBD: [Debuggerx86.INS.BSR,    Debuggerx86.TYPE_REG    | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_OUT  | Debuggerx86.TYPE_80386, Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_IN],
        0xBE: [Debuggerx86.INS.MOVSX,  Debuggerx86.TYPE_REG    | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_OUT  | Debuggerx86.TYPE_80386, Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_BYTE  | Debuggerx86.TYPE_IN],
        0xBF: [Debuggerx86.INS.MOVSX,  Debuggerx86.TYPE_REG    | Debuggerx86.TYPE_LONG  | Debuggerx86.TYPE_OUT  | Debuggerx86.TYPE_80386, Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_SHORT | Debuggerx86.TYPE_IN]
    };

    /**
     * Be sure to keep the following table in sync with FPUx86.aaOps
     */
    Debuggerx86.aaaOpFPUDescs = {
        0xD8: {
            0x00: [Debuggerx86.FINS.FADD,   Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_SREAL | Debuggerx86.TYPE_IN],
            0x01: [Debuggerx86.FINS.FMUL,   Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_SREAL | Debuggerx86.TYPE_IN],
            0x02: [Debuggerx86.FINS.FCOM,   Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_SREAL | Debuggerx86.TYPE_IN],
            0x03: [Debuggerx86.FINS.FCOMP,  Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_SREAL | Debuggerx86.TYPE_IN],
            0x04: [Debuggerx86.FINS.FSUB,   Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_SREAL | Debuggerx86.TYPE_IN],
            0x05: [Debuggerx86.FINS.FSUBR,  Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_SREAL | Debuggerx86.TYPE_IN],
            0x06: [Debuggerx86.FINS.FDIV,   Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_SREAL | Debuggerx86.TYPE_IN],
            0x07: [Debuggerx86.FINS.FDIVR,  Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_SREAL | Debuggerx86.TYPE_IN],
            0x30: [Debuggerx86.FINS.FADD,   Debuggerx86.TYPE_IMPREG | Debuggerx86.TYPE_ST    | Debuggerx86.TYPE_OUT, Debuggerx86.TYPE_IMPREG | Debuggerx86.TYPE_STREG | Debuggerx86.TYPE_IN],
            0x31: [Debuggerx86.FINS.FMUL,   Debuggerx86.TYPE_IMPREG | Debuggerx86.TYPE_ST    | Debuggerx86.TYPE_OUT, Debuggerx86.TYPE_IMPREG | Debuggerx86.TYPE_STREG | Debuggerx86.TYPE_IN],
            0x32: [Debuggerx86.FINS.FCOM,   Debuggerx86.TYPE_IMPREG | Debuggerx86.TYPE_ST    | Debuggerx86.TYPE_OUT, Debuggerx86.TYPE_IMPREG | Debuggerx86.TYPE_STREG | Debuggerx86.TYPE_IN],
            0x33: [Debuggerx86.FINS.FCOMP,  Debuggerx86.TYPE_IMPREG | Debuggerx86.TYPE_ST    | Debuggerx86.TYPE_OUT, Debuggerx86.TYPE_IMPREG | Debuggerx86.TYPE_STREG | Debuggerx86.TYPE_IN],
            0x34: [Debuggerx86.FINS.FSUB,   Debuggerx86.TYPE_IMPREG | Debuggerx86.TYPE_ST    | Debuggerx86.TYPE_OUT, Debuggerx86.TYPE_IMPREG | Debuggerx86.TYPE_STREG | Debuggerx86.TYPE_IN],
            0x35: [Debuggerx86.FINS.FSUBR,  Debuggerx86.TYPE_IMPREG | Debuggerx86.TYPE_ST    | Debuggerx86.TYPE_OUT, Debuggerx86.TYPE_IMPREG | Debuggerx86.TYPE_STREG | Debuggerx86.TYPE_IN],
            0x36: [Debuggerx86.FINS.FDIV,   Debuggerx86.TYPE_IMPREG | Debuggerx86.TYPE_ST    | Debuggerx86.TYPE_OUT, Debuggerx86.TYPE_IMPREG | Debuggerx86.TYPE_STREG | Debuggerx86.TYPE_IN],
            0x37: [Debuggerx86.FINS.FDIVR,  Debuggerx86.TYPE_IMPREG | Debuggerx86.TYPE_ST    | Debuggerx86.TYPE_OUT, Debuggerx86.TYPE_IMPREG | Debuggerx86.TYPE_STREG | Debuggerx86.TYPE_IN]
        },
        0xD9: {
            0x00: [Debuggerx86.FINS.FLD,    Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_SREAL | Debuggerx86.TYPE_IN],
            0x02: [Debuggerx86.FINS.FST,    Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_SREAL | Debuggerx86.TYPE_OUT],
            0x03: [Debuggerx86.FINS.FSTP,   Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_SREAL | Debuggerx86.TYPE_OUT],
            0x04: [Debuggerx86.FINS.FLDENV, Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_ENV   | Debuggerx86.TYPE_IN],
            0x05: [Debuggerx86.FINS.FLDCW,  Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_SHORT | Debuggerx86.TYPE_IN],
            0x06: [Debuggerx86.FINS.FSTENV, Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_ENV   | Debuggerx86.TYPE_OUT],
            0x07: [Debuggerx86.FINS.FSTCW,  Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_SHORT | Debuggerx86.TYPE_OUT],
            0x30: [Debuggerx86.FINS.FLD,    Debuggerx86.TYPE_IMPREG | Debuggerx86.TYPE_STREG | Debuggerx86.TYPE_OUT],
            0x31: [Debuggerx86.FINS.FXCH,   Debuggerx86.TYPE_IMPREG | Debuggerx86.TYPE_STREG | Debuggerx86.TYPE_OUT],
            0x32: [Debuggerx86.FINS.FNOP],
            0x33: [Debuggerx86.FINS.FSTP,   Debuggerx86.TYPE_IMPREG | Debuggerx86.TYPE_STREG | Debuggerx86.TYPE_OUT],   // Obsolete encoding
            0x40: [Debuggerx86.FINS.FCHS],
            0x41: [Debuggerx86.FINS.FABS],
            0x44: [Debuggerx86.FINS.FTST],
            0x45: [Debuggerx86.FINS.FXAM],
            0x50: [Debuggerx86.FINS.FLD1],
            0x51: [Debuggerx86.FINS.FLDL2T],
            0x52: [Debuggerx86.FINS.FLDL2E],
            0x53: [Debuggerx86.FINS.FLDPI],
            0x54: [Debuggerx86.FINS.FLDLG2],
            0x55: [Debuggerx86.FINS.FLDLN2],
            0x56: [Debuggerx86.FINS.FLDZ],
            0x60: [Debuggerx86.FINS.F2XM1],
            0x61: [Debuggerx86.FINS.FYL2X],
            0x62: [Debuggerx86.FINS.FPTAN],
            0x63: [Debuggerx86.FINS.FPATAN],
            0x64: [Debuggerx86.FINS.FXTRACT],
            0x66: [Debuggerx86.FINS.FDECSTP],
            0x67: [Debuggerx86.FINS.FINCSTP],
            0x70: [Debuggerx86.FINS.FPREM],
            0x71: [Debuggerx86.FINS.FYL2XP1],
            0x72: [Debuggerx86.FINS.FSQRT],
            0x74: [Debuggerx86.FINS.FRNDINT],
            0x75: [Debuggerx86.FINS.FSCALE]
        },
        0xDA: {
            0x00: [Debuggerx86.FINS.FIADD,  Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_SINT | Debuggerx86.TYPE_IN],
            0x01: [Debuggerx86.FINS.FIMUL,  Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_SINT | Debuggerx86.TYPE_IN],
            0x02: [Debuggerx86.FINS.FICOM,  Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_SINT | Debuggerx86.TYPE_IN],
            0x03: [Debuggerx86.FINS.FICOMP, Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_SINT | Debuggerx86.TYPE_IN],
            0x04: [Debuggerx86.FINS.FISUB,  Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_SINT | Debuggerx86.TYPE_IN],
            0x05: [Debuggerx86.FINS.FISUBR, Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_SINT | Debuggerx86.TYPE_IN],
            0x06: [Debuggerx86.FINS.FIDIV,  Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_SINT | Debuggerx86.TYPE_IN],
            0x07: [Debuggerx86.FINS.FIDIVR, Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_SINT | Debuggerx86.TYPE_IN]
        },
        0xDB: {
            0x00: [Debuggerx86.FINS.FILD,   Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_SINT  | Debuggerx86.TYPE_IN],
            0x02: [Debuggerx86.FINS.FIST,   Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_SINT  | Debuggerx86.TYPE_OUT],
            0x03: [Debuggerx86.FINS.FISTP,  Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_SINT  | Debuggerx86.TYPE_OUT],
            0x05: [Debuggerx86.FINS.FLD,    Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_TREAL | Debuggerx86.TYPE_IN],
            0x07: [Debuggerx86.FINS.FSTP,   Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_TREAL | Debuggerx86.TYPE_OUT],
            0x40: [Debuggerx86.FINS.FENI],
            0x41: [Debuggerx86.FINS.FDISI],
            0x42: [Debuggerx86.FINS.FCLEX],
            0x43: [Debuggerx86.FINS.FINIT],
            0x44: [Debuggerx86.FINS.FSETPM,  Debuggerx86.TYPE_80287],
            0x73: [Debuggerx86.FINS.FSINCOS, Debuggerx86.TYPE_80387]
        },
        0xDC: {
            0x00: [Debuggerx86.FINS.FADD,   Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_LREAL | Debuggerx86.TYPE_IN],
            0x01: [Debuggerx86.FINS.FMUL,   Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_LREAL | Debuggerx86.TYPE_IN],
            0x02: [Debuggerx86.FINS.FCOM,   Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_LREAL | Debuggerx86.TYPE_IN],
            0x03: [Debuggerx86.FINS.FCOMP,  Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_LREAL | Debuggerx86.TYPE_IN],
            0x04: [Debuggerx86.FINS.FSUB,   Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_LREAL | Debuggerx86.TYPE_IN],
            0x05: [Debuggerx86.FINS.FSUBR,  Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_LREAL | Debuggerx86.TYPE_IN],
            0x06: [Debuggerx86.FINS.FDIV,   Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_LREAL | Debuggerx86.TYPE_IN],
            0x07: [Debuggerx86.FINS.FDIVR,  Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_LREAL | Debuggerx86.TYPE_IN],
            0x30: [Debuggerx86.FINS.FADD,   Debuggerx86.TYPE_IMPREG | Debuggerx86.TYPE_STREG | Debuggerx86.TYPE_OUT, Debuggerx86.TYPE_IMPREG | Debuggerx86.TYPE_ST | Debuggerx86.TYPE_IN],
            0x31: [Debuggerx86.FINS.FMUL,   Debuggerx86.TYPE_IMPREG | Debuggerx86.TYPE_STREG | Debuggerx86.TYPE_OUT, Debuggerx86.TYPE_IMPREG | Debuggerx86.TYPE_ST | Debuggerx86.TYPE_IN],
            0x32: [Debuggerx86.FINS.FCOM,   Debuggerx86.TYPE_IMPREG | Debuggerx86.TYPE_STREG | Debuggerx86.TYPE_IN],    // Obsolete encoding
            0x33: [Debuggerx86.FINS.FCOMP,  Debuggerx86.TYPE_IMPREG | Debuggerx86.TYPE_STREG | Debuggerx86.TYPE_IN],    // Obsolete encoding
            0x34: [Debuggerx86.FINS.FSUBR,  Debuggerx86.TYPE_IMPREG | Debuggerx86.TYPE_STREG | Debuggerx86.TYPE_OUT, Debuggerx86.TYPE_IMPREG | Debuggerx86.TYPE_ST | Debuggerx86.TYPE_IN],
            0x35: [Debuggerx86.FINS.FSUB,   Debuggerx86.TYPE_IMPREG | Debuggerx86.TYPE_STREG | Debuggerx86.TYPE_OUT, Debuggerx86.TYPE_IMPREG | Debuggerx86.TYPE_ST | Debuggerx86.TYPE_IN],
            0x36: [Debuggerx86.FINS.FDIVR,  Debuggerx86.TYPE_IMPREG | Debuggerx86.TYPE_STREG | Debuggerx86.TYPE_OUT, Debuggerx86.TYPE_IMPREG | Debuggerx86.TYPE_ST | Debuggerx86.TYPE_IN],
            0x37: [Debuggerx86.FINS.FDIV,   Debuggerx86.TYPE_IMPREG | Debuggerx86.TYPE_STREG | Debuggerx86.TYPE_OUT, Debuggerx86.TYPE_IMPREG | Debuggerx86.TYPE_ST | Debuggerx86.TYPE_IN]
        },
        0xDD: {
            0x00: [Debuggerx86.FINS.FLD,    Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_LREAL | Debuggerx86.TYPE_IN],
            0x02: [Debuggerx86.FINS.FST,    Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_LREAL | Debuggerx86.TYPE_OUT],
            0x03: [Debuggerx86.FINS.FSTP,   Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_LREAL | Debuggerx86.TYPE_OUT],
            0x04: [Debuggerx86.FINS.FRSTOR, Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_FPU   | Debuggerx86.TYPE_IN],
            0x06: [Debuggerx86.FINS.FSAVE,  Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_FPU   | Debuggerx86.TYPE_OUT],
            0x07: [Debuggerx86.FINS.FSTSW,  Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_SHORT | Debuggerx86.TYPE_OUT],
            0x30: [Debuggerx86.FINS.FFREE,  Debuggerx86.TYPE_IMPREG | Debuggerx86.TYPE_STREG | Debuggerx86.TYPE_IN],
            0x31: [Debuggerx86.FINS.FXCH,   Debuggerx86.TYPE_IMPREG | Debuggerx86.TYPE_STREG | Debuggerx86.TYPE_OUT],   // Obsolete encoding
            0x32: [Debuggerx86.FINS.FST,    Debuggerx86.TYPE_IMPREG | Debuggerx86.TYPE_STREG | Debuggerx86.TYPE_IN],
            0x33: [Debuggerx86.FINS.FSTP,   Debuggerx86.TYPE_IMPREG | Debuggerx86.TYPE_STREG | Debuggerx86.TYPE_IN]
        },
        0xDE: {
            0x00: [Debuggerx86.FINS.FIADD,  Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_SHORT | Debuggerx86.TYPE_IN],
            0x01: [Debuggerx86.FINS.FIMUL,  Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_SHORT | Debuggerx86.TYPE_IN],
            0x02: [Debuggerx86.FINS.FICOM,  Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_SHORT | Debuggerx86.TYPE_IN],
            0x03: [Debuggerx86.FINS.FICOMP, Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_SHORT | Debuggerx86.TYPE_IN],
            0x04: [Debuggerx86.FINS.FISUB,  Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_SHORT | Debuggerx86.TYPE_IN],
            0x05: [Debuggerx86.FINS.FISUBR, Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_SHORT | Debuggerx86.TYPE_IN],
            0x06: [Debuggerx86.FINS.FIDIV,  Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_SHORT | Debuggerx86.TYPE_IN],
            0x07: [Debuggerx86.FINS.FIDIVR, Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_SHORT | Debuggerx86.TYPE_IN],
            0x30: [Debuggerx86.FINS.FADDP,  Debuggerx86.TYPE_IMPREG | Debuggerx86.TYPE_STREG | Debuggerx86.TYPE_OUT, Debuggerx86.TYPE_IMPREG | Debuggerx86.TYPE_ST | Debuggerx86.TYPE_IN],
            0x31: [Debuggerx86.FINS.FMULP,  Debuggerx86.TYPE_IMPREG | Debuggerx86.TYPE_STREG | Debuggerx86.TYPE_OUT, Debuggerx86.TYPE_IMPREG | Debuggerx86.TYPE_ST | Debuggerx86.TYPE_IN],
            0x32: [Debuggerx86.FINS.FCOMP,  Debuggerx86.TYPE_IMPREG | Debuggerx86.TYPE_STREG | Debuggerx86.TYPE_IN],    // Obsolete encoding
            0x33: [Debuggerx86.FINS.FCOMPP, Debuggerx86.TYPE_IMPREG | Debuggerx86.TYPE_STREG | Debuggerx86.TYPE_IN],
            0x34: [Debuggerx86.FINS.FSUBRP, Debuggerx86.TYPE_IMPREG | Debuggerx86.TYPE_STREG | Debuggerx86.TYPE_OUT, Debuggerx86.TYPE_IMPREG | Debuggerx86.TYPE_ST | Debuggerx86.TYPE_IN],
            0x35: [Debuggerx86.FINS.FSUBP,  Debuggerx86.TYPE_IMPREG | Debuggerx86.TYPE_STREG | Debuggerx86.TYPE_OUT, Debuggerx86.TYPE_IMPREG | Debuggerx86.TYPE_ST | Debuggerx86.TYPE_IN],
            0x36: [Debuggerx86.FINS.FDIVRP, Debuggerx86.TYPE_IMPREG | Debuggerx86.TYPE_STREG | Debuggerx86.TYPE_OUT, Debuggerx86.TYPE_IMPREG | Debuggerx86.TYPE_ST | Debuggerx86.TYPE_IN],
            0x37: [Debuggerx86.FINS.FDIVP,  Debuggerx86.TYPE_IMPREG | Debuggerx86.TYPE_STREG | Debuggerx86.TYPE_OUT, Debuggerx86.TYPE_IMPREG | Debuggerx86.TYPE_ST | Debuggerx86.TYPE_IN]
        },
        0xDF: {
            0x00: [Debuggerx86.FINS.FILD,   Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_SHORT | Debuggerx86.TYPE_IN],
            0x02: [Debuggerx86.FINS.FIST,   Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_SHORT | Debuggerx86.TYPE_OUT],
            0x03: [Debuggerx86.FINS.FISTP,  Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_SHORT | Debuggerx86.TYPE_OUT],
            0x04: [Debuggerx86.FINS.FBLD,   Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_BCD80 | Debuggerx86.TYPE_IN],
            0x05: [Debuggerx86.FINS.FILD,   Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_LINT  | Debuggerx86.TYPE_IN],
            0x06: [Debuggerx86.FINS.FBSTP,  Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_BCD80 | Debuggerx86.TYPE_OUT],
            0x07: [Debuggerx86.FINS.FISTP,  Debuggerx86.TYPE_MODRM  | Debuggerx86.TYPE_LINT  | Debuggerx86.TYPE_OUT],
            0x30: [Debuggerx86.FINS.FFREEP, Debuggerx86.TYPE_IMPREG | Debuggerx86.TYPE_STREG | Debuggerx86.TYPE_IN],    // Obsolete encoding
            0x31: [Debuggerx86.FINS.FXCH,   Debuggerx86.TYPE_IMPREG | Debuggerx86.TYPE_STREG | Debuggerx86.TYPE_OUT],   // Obsolete encoding
            0x32: [Debuggerx86.FINS.FSTP,   Debuggerx86.TYPE_IMPREG | Debuggerx86.TYPE_STREG | Debuggerx86.TYPE_IN],    // Obsolete encoding
            0x33: [Debuggerx86.FINS.FSTP,   Debuggerx86.TYPE_IMPREG | Debuggerx86.TYPE_STREG | Debuggerx86.TYPE_IN],    // Obsolete encoding
            0x34: [Debuggerx86.FINS.FSTSWAX, Debuggerx86.TYPE_80287]
        }
    };

    Debuggerx86.aaGrpDescs = [
      [
        /* GRP1B */
        [Debuggerx86.INS.ADD,  Debuggerx86.TYPE_MODRM | Debuggerx86.TYPE_BYTE | Debuggerx86.TYPE_BOTH, Debuggerx86.TYPE_IMM | Debuggerx86.TYPE_BYTE | Debuggerx86.TYPE_IN],
        [Debuggerx86.INS.OR,   Debuggerx86.TYPE_MODRM | Debuggerx86.TYPE_BYTE | Debuggerx86.TYPE_BOTH, Debuggerx86.TYPE_IMM | Debuggerx86.TYPE_BYTE | Debuggerx86.TYPE_IN],
        [Debuggerx86.INS.ADC,  Debuggerx86.TYPE_MODRM | Debuggerx86.TYPE_BYTE | Debuggerx86.TYPE_BOTH, Debuggerx86.TYPE_IMM | Debuggerx86.TYPE_BYTE | Debuggerx86.TYPE_IN],
        [Debuggerx86.INS.SBB,  Debuggerx86.TYPE_MODRM | Debuggerx86.TYPE_BYTE | Debuggerx86.TYPE_BOTH, Debuggerx86.TYPE_IMM | Debuggerx86.TYPE_BYTE | Debuggerx86.TYPE_IN],
        [Debuggerx86.INS.AND,  Debuggerx86.TYPE_MODRM | Debuggerx86.TYPE_BYTE | Debuggerx86.TYPE_BOTH, Debuggerx86.TYPE_IMM | Debuggerx86.TYPE_BYTE | Debuggerx86.TYPE_IN],
        [Debuggerx86.INS.SUB,  Debuggerx86.TYPE_MODRM | Debuggerx86.TYPE_BYTE | Debuggerx86.TYPE_BOTH, Debuggerx86.TYPE_IMM | Debuggerx86.TYPE_BYTE | Debuggerx86.TYPE_IN],
        [Debuggerx86.INS.XOR,  Debuggerx86.TYPE_MODRM | Debuggerx86.TYPE_BYTE | Debuggerx86.TYPE_BOTH, Debuggerx86.TYPE_IMM | Debuggerx86.TYPE_BYTE | Debuggerx86.TYPE_IN],
        [Debuggerx86.INS.CMP,  Debuggerx86.TYPE_MODRM | Debuggerx86.TYPE_BYTE | Debuggerx86.TYPE_IN,   Debuggerx86.TYPE_IMM | Debuggerx86.TYPE_BYTE | Debuggerx86.TYPE_IN]
      ],
      [
        /* GRP1W */
        [Debuggerx86.INS.ADD,  Debuggerx86.TYPE_MODRM | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_BOTH, Debuggerx86.TYPE_IMM | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_IN],
        [Debuggerx86.INS.OR,   Debuggerx86.TYPE_MODRM | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_BOTH, Debuggerx86.TYPE_IMM | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_IN],
        [Debuggerx86.INS.ADC,  Debuggerx86.TYPE_MODRM | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_BOTH, Debuggerx86.TYPE_IMM | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_IN],
        [Debuggerx86.INS.SBB,  Debuggerx86.TYPE_MODRM | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_BOTH, Debuggerx86.TYPE_IMM | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_IN],
        [Debuggerx86.INS.AND,  Debuggerx86.TYPE_MODRM | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_BOTH, Debuggerx86.TYPE_IMM | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_IN],
        [Debuggerx86.INS.SUB,  Debuggerx86.TYPE_MODRM | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_BOTH, Debuggerx86.TYPE_IMM | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_IN],
        [Debuggerx86.INS.XOR,  Debuggerx86.TYPE_MODRM | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_BOTH, Debuggerx86.TYPE_IMM | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_IN],
        [Debuggerx86.INS.CMP,  Debuggerx86.TYPE_MODRM | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_IN,   Debuggerx86.TYPE_IMM | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_IN]
      ],
      [
        /* GRP1SW */
        [Debuggerx86.INS.ADD,  Debuggerx86.TYPE_MODRM | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_BOTH, Debuggerx86.TYPE_IMM | Debuggerx86.TYPE_SBYTE | Debuggerx86.TYPE_IN],
        [Debuggerx86.INS.OR,   Debuggerx86.TYPE_MODRM | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_BOTH, Debuggerx86.TYPE_IMM | Debuggerx86.TYPE_SBYTE | Debuggerx86.TYPE_IN],
        [Debuggerx86.INS.ADC,  Debuggerx86.TYPE_MODRM | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_BOTH, Debuggerx86.TYPE_IMM | Debuggerx86.TYPE_SBYTE | Debuggerx86.TYPE_IN],
        [Debuggerx86.INS.SBB,  Debuggerx86.TYPE_MODRM | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_BOTH, Debuggerx86.TYPE_IMM | Debuggerx86.TYPE_SBYTE | Debuggerx86.TYPE_IN],
        [Debuggerx86.INS.AND,  Debuggerx86.TYPE_MODRM | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_BOTH, Debuggerx86.TYPE_IMM | Debuggerx86.TYPE_SBYTE | Debuggerx86.TYPE_IN],
        [Debuggerx86.INS.SUB,  Debuggerx86.TYPE_MODRM | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_BOTH, Debuggerx86.TYPE_IMM | Debuggerx86.TYPE_SBYTE | Debuggerx86.TYPE_IN],
        [Debuggerx86.INS.XOR,  Debuggerx86.TYPE_MODRM | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_BOTH, Debuggerx86.TYPE_IMM | Debuggerx86.TYPE_SBYTE | Debuggerx86.TYPE_IN],
        [Debuggerx86.INS.CMP,  Debuggerx86.TYPE_MODRM | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_IN,   Debuggerx86.TYPE_IMM | Debuggerx86.TYPE_SBYTE | Debuggerx86.TYPE_IN]
      ],
      [
        /* GRP2B */
        [Debuggerx86.INS.ROL,  Debuggerx86.TYPE_MODRM | Debuggerx86.TYPE_BYTE | Debuggerx86.TYPE_BOTH | Debuggerx86.TYPE_80286, Debuggerx86.TYPE_IMM | Debuggerx86.TYPE_BYTE | Debuggerx86.TYPE_IN],
        [Debuggerx86.INS.ROR,  Debuggerx86.TYPE_MODRM | Debuggerx86.TYPE_BYTE | Debuggerx86.TYPE_BOTH | Debuggerx86.TYPE_80286, Debuggerx86.TYPE_IMM | Debuggerx86.TYPE_BYTE | Debuggerx86.TYPE_IN],
        [Debuggerx86.INS.RCL,  Debuggerx86.TYPE_MODRM | Debuggerx86.TYPE_BYTE | Debuggerx86.TYPE_BOTH | Debuggerx86.TYPE_80286, Debuggerx86.TYPE_IMM | Debuggerx86.TYPE_BYTE | Debuggerx86.TYPE_IN],
        [Debuggerx86.INS.RCR,  Debuggerx86.TYPE_MODRM | Debuggerx86.TYPE_BYTE | Debuggerx86.TYPE_BOTH | Debuggerx86.TYPE_80286, Debuggerx86.TYPE_IMM | Debuggerx86.TYPE_BYTE | Debuggerx86.TYPE_IN],
        [Debuggerx86.INS.SHL,  Debuggerx86.TYPE_MODRM | Debuggerx86.TYPE_BYTE | Debuggerx86.TYPE_BOTH | Debuggerx86.TYPE_80286, Debuggerx86.TYPE_IMM | Debuggerx86.TYPE_BYTE | Debuggerx86.TYPE_IN],
        [Debuggerx86.INS.SHR,  Debuggerx86.TYPE_MODRM | Debuggerx86.TYPE_BYTE | Debuggerx86.TYPE_BOTH | Debuggerx86.TYPE_80286, Debuggerx86.TYPE_IMM | Debuggerx86.TYPE_BYTE | Debuggerx86.TYPE_IN],
         Debuggerx86.aOpDescUndefined,
        [Debuggerx86.INS.SAR,  Debuggerx86.TYPE_MODRM | Debuggerx86.TYPE_BYTE | Debuggerx86.TYPE_BOTH | Debuggerx86.TYPE_80286, Debuggerx86.TYPE_IMM | Debuggerx86.TYPE_BYTE | Debuggerx86.TYPE_IN]
      ],
      [
        /* GRP2W */
        [Debuggerx86.INS.ROL,  Debuggerx86.TYPE_MODRM | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_BOTH | Debuggerx86.TYPE_80286, Debuggerx86.TYPE_IMM | Debuggerx86.TYPE_BYTE | Debuggerx86.TYPE_IN],
        [Debuggerx86.INS.ROR,  Debuggerx86.TYPE_MODRM | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_BOTH | Debuggerx86.TYPE_80286, Debuggerx86.TYPE_IMM | Debuggerx86.TYPE_BYTE | Debuggerx86.TYPE_IN],
        [Debuggerx86.INS.RCL,  Debuggerx86.TYPE_MODRM | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_BOTH | Debuggerx86.TYPE_80286, Debuggerx86.TYPE_IMM | Debuggerx86.TYPE_BYTE | Debuggerx86.TYPE_IN],
        [Debuggerx86.INS.RCR,  Debuggerx86.TYPE_MODRM | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_BOTH | Debuggerx86.TYPE_80286, Debuggerx86.TYPE_IMM | Debuggerx86.TYPE_BYTE | Debuggerx86.TYPE_IN],
        [Debuggerx86.INS.SHL,  Debuggerx86.TYPE_MODRM | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_BOTH | Debuggerx86.TYPE_80286, Debuggerx86.TYPE_IMM | Debuggerx86.TYPE_BYTE | Debuggerx86.TYPE_IN],
        [Debuggerx86.INS.SHR,  Debuggerx86.TYPE_MODRM | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_BOTH | Debuggerx86.TYPE_80286, Debuggerx86.TYPE_IMM | Debuggerx86.TYPE_BYTE | Debuggerx86.TYPE_IN],
         Debuggerx86.aOpDescUndefined,
        [Debuggerx86.INS.SAR,  Debuggerx86.TYPE_MODRM | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_BOTH | Debuggerx86.TYPE_80286, Debuggerx86.TYPE_IMM | Debuggerx86.TYPE_BYTE | Debuggerx86.TYPE_IN]
      ],
      [
        /* GRP2B1 */
        [Debuggerx86.INS.ROL,  Debuggerx86.TYPE_MODRM | Debuggerx86.TYPE_BYTE | Debuggerx86.TYPE_BOTH, Debuggerx86.TYPE_ONE | Debuggerx86.TYPE_BYTE | Debuggerx86.TYPE_IN],
        [Debuggerx86.INS.ROR,  Debuggerx86.TYPE_MODRM | Debuggerx86.TYPE_BYTE | Debuggerx86.TYPE_BOTH, Debuggerx86.TYPE_ONE | Debuggerx86.TYPE_BYTE | Debuggerx86.TYPE_IN],
        [Debuggerx86.INS.RCL,  Debuggerx86.TYPE_MODRM | Debuggerx86.TYPE_BYTE | Debuggerx86.TYPE_BOTH, Debuggerx86.TYPE_ONE | Debuggerx86.TYPE_BYTE | Debuggerx86.TYPE_IN],
        [Debuggerx86.INS.RCR,  Debuggerx86.TYPE_MODRM | Debuggerx86.TYPE_BYTE | Debuggerx86.TYPE_BOTH, Debuggerx86.TYPE_ONE | Debuggerx86.TYPE_BYTE | Debuggerx86.TYPE_IN],
        [Debuggerx86.INS.SHL,  Debuggerx86.TYPE_MODRM | Debuggerx86.TYPE_BYTE | Debuggerx86.TYPE_BOTH, Debuggerx86.TYPE_ONE | Debuggerx86.TYPE_BYTE | Debuggerx86.TYPE_IN],
        [Debuggerx86.INS.SHR,  Debuggerx86.TYPE_MODRM | Debuggerx86.TYPE_BYTE | Debuggerx86.TYPE_BOTH, Debuggerx86.TYPE_ONE | Debuggerx86.TYPE_BYTE | Debuggerx86.TYPE_IN],
         Debuggerx86.aOpDescUndefined,
        [Debuggerx86.INS.SAR,  Debuggerx86.TYPE_MODRM | Debuggerx86.TYPE_BYTE | Debuggerx86.TYPE_BOTH, Debuggerx86.TYPE_ONE | Debuggerx86.TYPE_BYTE | Debuggerx86.TYPE_IN]
      ],
      [
        /* GRP2W1 */
        [Debuggerx86.INS.ROL,  Debuggerx86.TYPE_MODRM | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_BOTH, Debuggerx86.TYPE_ONE | Debuggerx86.TYPE_BYTE | Debuggerx86.TYPE_IN],
        [Debuggerx86.INS.ROR,  Debuggerx86.TYPE_MODRM | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_BOTH, Debuggerx86.TYPE_ONE | Debuggerx86.TYPE_BYTE | Debuggerx86.TYPE_IN],
        [Debuggerx86.INS.RCL,  Debuggerx86.TYPE_MODRM | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_BOTH, Debuggerx86.TYPE_ONE | Debuggerx86.TYPE_BYTE | Debuggerx86.TYPE_IN],
        [Debuggerx86.INS.RCR,  Debuggerx86.TYPE_MODRM | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_BOTH, Debuggerx86.TYPE_ONE | Debuggerx86.TYPE_BYTE | Debuggerx86.TYPE_IN],
        [Debuggerx86.INS.SHL,  Debuggerx86.TYPE_MODRM | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_BOTH, Debuggerx86.TYPE_ONE | Debuggerx86.TYPE_BYTE | Debuggerx86.TYPE_IN],
        [Debuggerx86.INS.SHR,  Debuggerx86.TYPE_MODRM | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_BOTH, Debuggerx86.TYPE_ONE | Debuggerx86.TYPE_BYTE | Debuggerx86.TYPE_IN],
         Debuggerx86.aOpDescUndefined,
        [Debuggerx86.INS.SAR,  Debuggerx86.TYPE_MODRM | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_BOTH, Debuggerx86.TYPE_ONE | Debuggerx86.TYPE_BYTE | Debuggerx86.TYPE_IN]
      ],
      [
        /* GRP2BC */
        [Debuggerx86.INS.ROL,  Debuggerx86.TYPE_MODRM | Debuggerx86.TYPE_BYTE  | Debuggerx86.TYPE_BOTH, Debuggerx86.TYPE_CL | Debuggerx86.TYPE_IN],
        [Debuggerx86.INS.ROR,  Debuggerx86.TYPE_MODRM | Debuggerx86.TYPE_BYTE  | Debuggerx86.TYPE_BOTH, Debuggerx86.TYPE_CL | Debuggerx86.TYPE_IN],
        [Debuggerx86.INS.RCL,  Debuggerx86.TYPE_MODRM | Debuggerx86.TYPE_BYTE  | Debuggerx86.TYPE_BOTH, Debuggerx86.TYPE_CL | Debuggerx86.TYPE_IN],
        [Debuggerx86.INS.RCR,  Debuggerx86.TYPE_MODRM | Debuggerx86.TYPE_BYTE  | Debuggerx86.TYPE_BOTH, Debuggerx86.TYPE_CL | Debuggerx86.TYPE_IN],
        [Debuggerx86.INS.SHL,  Debuggerx86.TYPE_MODRM | Debuggerx86.TYPE_BYTE  | Debuggerx86.TYPE_BOTH, Debuggerx86.TYPE_CL | Debuggerx86.TYPE_IN],
        [Debuggerx86.INS.SHR,  Debuggerx86.TYPE_MODRM | Debuggerx86.TYPE_BYTE  | Debuggerx86.TYPE_BOTH, Debuggerx86.TYPE_CL | Debuggerx86.TYPE_IN],
         Debuggerx86.aOpDescUndefined,
        [Debuggerx86.INS.SAR,  Debuggerx86.TYPE_MODRM | Debuggerx86.TYPE_BYTE  | Debuggerx86.TYPE_BOTH, Debuggerx86.TYPE_CL | Debuggerx86.TYPE_IN]
      ],
      [
        /* GRP2WC */
        [Debuggerx86.INS.ROL,  Debuggerx86.TYPE_MODRM | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_BOTH, Debuggerx86.TYPE_CL | Debuggerx86.TYPE_IN],
        [Debuggerx86.INS.ROR,  Debuggerx86.TYPE_MODRM | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_BOTH, Debuggerx86.TYPE_CL | Debuggerx86.TYPE_IN],
        [Debuggerx86.INS.RCL,  Debuggerx86.TYPE_MODRM | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_BOTH, Debuggerx86.TYPE_CL | Debuggerx86.TYPE_IN],
        [Debuggerx86.INS.RCR,  Debuggerx86.TYPE_MODRM | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_BOTH, Debuggerx86.TYPE_CL | Debuggerx86.TYPE_IN],
        [Debuggerx86.INS.SHL,  Debuggerx86.TYPE_MODRM | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_BOTH, Debuggerx86.TYPE_CL | Debuggerx86.TYPE_IN],
        [Debuggerx86.INS.SHR,  Debuggerx86.TYPE_MODRM | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_BOTH, Debuggerx86.TYPE_CL | Debuggerx86.TYPE_IN],
         Debuggerx86.aOpDescUndefined,
        [Debuggerx86.INS.SAR,  Debuggerx86.TYPE_MODRM | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_BOTH, Debuggerx86.TYPE_CL | Debuggerx86.TYPE_IN]
      ],
      [
        /* GRP3B */
        [Debuggerx86.INS.TEST, Debuggerx86.TYPE_MODRM | Debuggerx86.TYPE_BYTE  | Debuggerx86.TYPE_IN,   Debuggerx86.TYPE_IMM | Debuggerx86.TYPE_BYTE | Debuggerx86.TYPE_IN],
         Debuggerx86.aOpDescUndefined,
        [Debuggerx86.INS.NOT,  Debuggerx86.TYPE_MODRM | Debuggerx86.TYPE_BYTE  | Debuggerx86.TYPE_BOTH],
        [Debuggerx86.INS.NEG,  Debuggerx86.TYPE_MODRM | Debuggerx86.TYPE_BYTE  | Debuggerx86.TYPE_BOTH],
        [Debuggerx86.INS.MUL,  Debuggerx86.TYPE_MODRM | Debuggerx86.TYPE_BYTE  | Debuggerx86.TYPE_IN],
        [Debuggerx86.INS.IMUL, Debuggerx86.TYPE_MODRM | Debuggerx86.TYPE_BYTE  | Debuggerx86.TYPE_BOTH],
        [Debuggerx86.INS.DIV,  Debuggerx86.TYPE_MODRM | Debuggerx86.TYPE_BYTE  | Debuggerx86.TYPE_IN],
        [Debuggerx86.INS.IDIV, Debuggerx86.TYPE_MODRM | Debuggerx86.TYPE_BYTE  | Debuggerx86.TYPE_BOTH]
      ],
      [
        /* GRP3W */
        [Debuggerx86.INS.TEST, Debuggerx86.TYPE_MODRM | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_IN,   Debuggerx86.TYPE_IMM | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_IN],
         Debuggerx86.aOpDescUndefined,
        [Debuggerx86.INS.NOT,  Debuggerx86.TYPE_MODRM | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_BOTH],
        [Debuggerx86.INS.NEG,  Debuggerx86.TYPE_MODRM | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_BOTH],
        [Debuggerx86.INS.MUL,  Debuggerx86.TYPE_MODRM | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_IN],
        [Debuggerx86.INS.IMUL, Debuggerx86.TYPE_MODRM | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_BOTH],
        [Debuggerx86.INS.DIV,  Debuggerx86.TYPE_MODRM | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_IN],
        [Debuggerx86.INS.IDIV, Debuggerx86.TYPE_MODRM | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_BOTH]
      ],
      [
        /* GRP4B */
        [Debuggerx86.INS.INC,  Debuggerx86.TYPE_MODRM | Debuggerx86.TYPE_BYTE  | Debuggerx86.TYPE_BOTH],
        [Debuggerx86.INS.DEC,  Debuggerx86.TYPE_MODRM | Debuggerx86.TYPE_BYTE  | Debuggerx86.TYPE_BOTH],
         Debuggerx86.aOpDescUndefined,
         Debuggerx86.aOpDescUndefined,
         Debuggerx86.aOpDescUndefined,
         Debuggerx86.aOpDescUndefined,
         Debuggerx86.aOpDescUndefined,
         Debuggerx86.aOpDescUndefined
      ],
      [
        /* GRP4W */
        [Debuggerx86.INS.INC,  Debuggerx86.TYPE_MODRM | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_BOTH],
        [Debuggerx86.INS.DEC,  Debuggerx86.TYPE_MODRM | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_BOTH],
        [Debuggerx86.INS.CALL, Debuggerx86.TYPE_MODRM | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_IN],
        [Debuggerx86.INS.CALL, Debuggerx86.TYPE_MODRM | Debuggerx86.TYPE_FARP  | Debuggerx86.TYPE_IN],
        [Debuggerx86.INS.JMP,  Debuggerx86.TYPE_MODRM | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_IN],
        [Debuggerx86.INS.JMP,  Debuggerx86.TYPE_MODRM | Debuggerx86.TYPE_FARP  | Debuggerx86.TYPE_IN],
        [Debuggerx86.INS.PUSH, Debuggerx86.TYPE_MODRM | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_IN],
         Debuggerx86.aOpDescUndefined
      ],
      [ /* OP0F */ ],
      [
        /* GRP6 */
        [Debuggerx86.INS.SLDT, Debuggerx86.TYPE_MODRM | Debuggerx86.TYPE_SHORT| Debuggerx86.TYPE_OUT | Debuggerx86.TYPE_80286],
        [Debuggerx86.INS.STR,  Debuggerx86.TYPE_MODRM | Debuggerx86.TYPE_SHORT| Debuggerx86.TYPE_OUT | Debuggerx86.TYPE_80286],
        [Debuggerx86.INS.LLDT, Debuggerx86.TYPE_MODRM | Debuggerx86.TYPE_SHORT| Debuggerx86.TYPE_IN  | Debuggerx86.TYPE_80286],
        [Debuggerx86.INS.LTR,  Debuggerx86.TYPE_MODRM | Debuggerx86.TYPE_SHORT| Debuggerx86.TYPE_IN  | Debuggerx86.TYPE_80286],
        [Debuggerx86.INS.VERR, Debuggerx86.TYPE_MODRM | Debuggerx86.TYPE_SHORT| Debuggerx86.TYPE_IN  | Debuggerx86.TYPE_80286],
        [Debuggerx86.INS.VERW, Debuggerx86.TYPE_MODRM | Debuggerx86.TYPE_SHORT| Debuggerx86.TYPE_IN  | Debuggerx86.TYPE_80286],
         Debuggerx86.aOpDescUndefined,
         Debuggerx86.aOpDescUndefined
      ],
      [
        /* GRP7 */
        [Debuggerx86.INS.SGDT, Debuggerx86.TYPE_MODRM | Debuggerx86.TYPE_SHORT| Debuggerx86.TYPE_OUT | Debuggerx86.TYPE_80286],
        [Debuggerx86.INS.SIDT, Debuggerx86.TYPE_MODRM | Debuggerx86.TYPE_SHORT| Debuggerx86.TYPE_OUT | Debuggerx86.TYPE_80286],
        [Debuggerx86.INS.LGDT, Debuggerx86.TYPE_MODRM | Debuggerx86.TYPE_SHORT| Debuggerx86.TYPE_IN  | Debuggerx86.TYPE_80286],
        [Debuggerx86.INS.LIDT, Debuggerx86.TYPE_MODRM | Debuggerx86.TYPE_SHORT| Debuggerx86.TYPE_IN  | Debuggerx86.TYPE_80286],
        [Debuggerx86.INS.SMSW, Debuggerx86.TYPE_MODRM | Debuggerx86.TYPE_SHORT| Debuggerx86.TYPE_OUT | Debuggerx86.TYPE_80286],
         Debuggerx86.aOpDescUndefined,
        [Debuggerx86.INS.LMSW, Debuggerx86.TYPE_MODRM | Debuggerx86.TYPE_SHORT| Debuggerx86.TYPE_IN  | Debuggerx86.TYPE_80286],
         Debuggerx86.aOpDescUndefined
      ],
      [
        /* GRP8 */
         Debuggerx86.aOpDescUndefined,
         Debuggerx86.aOpDescUndefined,
         Debuggerx86.aOpDescUndefined,
         Debuggerx86.aOpDescUndefined,
        [Debuggerx86.INS.BT,  Debuggerx86.TYPE_MODRM | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_IN  | Debuggerx86.TYPE_80386, Debuggerx86.TYPE_IMM | Debuggerx86.TYPE_BYTE | Debuggerx86.TYPE_IN],
        [Debuggerx86.INS.BTS, Debuggerx86.TYPE_MODRM | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_OUT | Debuggerx86.TYPE_80386, Debuggerx86.TYPE_IMM | Debuggerx86.TYPE_BYTE | Debuggerx86.TYPE_IN],
        [Debuggerx86.INS.BTR, Debuggerx86.TYPE_MODRM | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_OUT | Debuggerx86.TYPE_80386, Debuggerx86.TYPE_IMM | Debuggerx86.TYPE_BYTE | Debuggerx86.TYPE_IN],
        [Debuggerx86.INS.BTC, Debuggerx86.TYPE_MODRM | Debuggerx86.TYPE_WORD  | Debuggerx86.TYPE_OUT | Debuggerx86.TYPE_80386, Debuggerx86.TYPE_IMM | Debuggerx86.TYPE_BYTE | Debuggerx86.TYPE_IN]
      ]
    ];

    /**
     * Table of system (non-segment) descriptors, including indicators of which ones are gates.
     */
    Debuggerx86.SYSDESCS = {
        0x0100: ["tss286",       false],
        0x0200: ["ldt",          false],
        0x0300: ["busy tss286",  false],
        0x0400: ["call gate",    true],
        0x0500: ["task gate",    true],
        0x0600: ["int gate286",  true],
        0x0700: ["trap gate286", true],
        0x0900: ["tss386",       false],
        0x0B00: ["busy tss386",  false],
        0x0C00: ["call gate386", true],
        0x0E00: ["int gate386",  true],
        0x0F00: ["trap gate386", true]
    };

    /**
     * TSS field names and offsets used by dumpTSS()
     */
    Debuggerx86.TSS286 = {
        "PREV_TSS":     0x00,
        "CPL0_SP":      0x02,
        "CPL0_SS":      0x04,
        "CPL1_SP":      0x06,
        "CPL1_SS":      0x08,
        "CPL2_SP":      0x0a,
        "CPL2_SS":      0x0c,
        "TASK_IP":      0x0e,
        "TASK_PS":      0x10,
        "TASK_AX":      0x12,
        "TASK_CX":      0x14,
        "TASK_DX":      0x16,
        "TASK_BX":      0x18,
        "TASK_SP":      0x1a,
        "TASK_BP":      0x1c,
        "TASK_SI":      0x1e,
        "TASK_DI":      0x20,
        "TASK_ES":      0x22,
        "TASK_CS":      0x24,
        "TASK_SS":      0x26,
        "TASK_DS":      0x28,
        "TASK_LDT":     0x2a
    };
    Debuggerx86.TSS386 = {
        "PREV_TSS":     0x00,
        "CPL0_ESP":     0x04,
        "CPL0_SS":      0x08,
        "CPL1_ESP":     0x0c,
        "CPL1_SS":      0x10,
        "CPL2_ESP":     0x14,
        "CPL2_SS":      0x18,
        "TASK_CR3":     0x1C,
        "TASK_EIP":     0x20,
        "TASK_PS":      0x24,
        "TASK_EAX":     0x28,
        "TASK_ECX":     0x2C,
        "TASK_EDX":     0x30,
        "TASK_EBX":     0x34,
        "TASK_ESP":     0x38,
        "TASK_EBP":     0x3C,
        "TASK_ESI":     0x40,
        "TASK_EDI":     0x44,
        "TASK_ES":      0x48,
        "TASK_CS":      0x4C,
        "TASK_SS":      0x50,
        "TASK_DS":      0x54,
        "TASK_FS":      0x58,
        "TASK_GS":      0x5C,
        "TASK_LDT":     0x60,
        "TASK_IOPM":    0x64
    };

    /**
     * Initialize every Debugger module on the page (as IF there's ever going to be more than one ;-))
     */
    WebLib.onInit(Debuggerx86.init);

}   // endif DEBUGGER

/**
 * @copyright https://www.pcjs.org/machines/pcx86/modules/v2/computer.js (C) 2012-2024 Jeff Parsons
 */

/**
 * @class Computer
 * @unrestricted (allows the class to define properties, both dot and named, outside of the constructor)
 */
class Computer extends Component {

    static STATE_FAILSAFE  = "failsafe";
    static STATE_VALIDATE  = "validate";
    static STATE_TIMESTAMP = "timestamp";
    static STATE_VERSION   = "version";
    static STATE_HOSTURL   = "url";
    static STATE_BROWSER   = "browser";
    static STATE_USERID    = "user";

    /**
     * The following constants define all the resume options.  Negative values (eg, RESUME_REPOWER) are for
     * internal use only, and RESUME_DELETE is not documented (it provides a way of deleting ALL saved states
     * whenever a resume is declined).  As a result, the only "end-user" values are 0, 1 and 2.
     */
    static RESUME_REPOWER  = -1;    // resume without changing any state (for internal use only)
    static RESUME_NONE     =  0;    // default (no resume)
    static RESUME_AUTO     =  1;    // automatically save/restore state
    static RESUME_PROMPT   =  2;    // automatically save but conditionally restore (WARNING: if restore is declined, any state is discarded)
    static RESUME_DELETE   =  3;    // same as RESUME_PROMPT but discards ALL machines states whenever ANY machine restore is declined (undocumented)

    static UPDATES_PER_SECOND = 2;

    /**
     * Computer(parmsComputer, parmsMachine, fSuspended)
     *
     * The Computer component has no required (parmsComputer) properties, but it does
     * support the following:
     *
     *      autoPower: true to automatically power the computer (default), false to wait;
     *      false is honored only if a "power" button binding exists.
     *
     *      busWidth: number of memory address lines (address bits) on the computer's "bus";
     *      20 is the minimum (and the default), which implies 8086/8088 real-mode addressing,
     *      while 24 is required for 80286 protected-mode addressing.  This value is passed
     *      directly through to the Bus component; see that component for more details.
     *
     *      resume: one of the Computer.RESUME constants, which are as follows:
     *          '0' if resume disabled (default)
     *          '1' if enabled without prompting
     *          '2' if enabled with prompting
     *          '3' if enabled with prompting and auto-delete
     *          or a string containing the path of a predefined JSON-encoded state
     *
     *      state: the path to JSON-encoded state file (see details regarding 'state' below)
     *
     * The parmsMachine object, if provided, may contain any of:
     *
     *      autoMount: overrides any 'autoMount' property in the FDC's parmsFDC object
     *      autoPower: overrides any 'autoPower' property in the Computer's parmsComputer object
     *      autoScript: overrides any 'autoScript' property in the Computer's parmsComputer object
     *      messages: overrides any 'messages' property in the Debugger's  parmsDbg object
     *      resume: override any 'resume' property in the Computer's parmsComputer object
     *      state: overrides any 'state' property in the Computer's parmsComputer object
     *      url: the location of the machine XML file
     *      diagnostics: 0 for none, 1 for normal diagnostics, and 2 for diagnostics with prompting
     *
     * If a predefined state is supplied AND it's successfully loaded, then resume behavior
     * defaults to '1' (ie, resume enabled without prompting).
     *
     * This component insures that all components are ready before "powering" them.
     *
     * Different components become ready at different times, and initialization order (ie,
     * the order the scripts are combined on the page) only partially determines readiness.
     * This is because components like ROM and Video must finish loading their resource files
     * before they are ready.  Other components become ready after we call their initBus()
     * function, because they have a Bus or CPU dependency, such as access to memory management
     * functions.  And other components, like CPU and Panel, are ready as soon as their
     * constructor finishes.
     *
     * Once a component has indicated it's ready, we call its powerUp() notification
     * function (if it has one--it's optional).  We call the CPU's powerUp() function last,
     * so that the CPU is assured that all other components are ready and "powered".
     *
     * @this {Computer}
     * @param {Object} parmsComputer
     * @param {Object} [parmsMachine]
     * @param {boolean} [fSuspended]
     */
    constructor(parmsComputer, parmsMachine, fSuspended)
    {
        super("Computer", parmsComputer, MESSAGE.COMPUTER);

        let cmp = this;
        this.setMachineParms(parmsMachine);

        this.fAutoPower = this.getMachineParm('autoPower', parmsComputer);
        this.nDiagnostics = +this.getMachineParm('diagnostics', parmsComputer);
        if (!(this.nDiagnostics >= 0 && this.nDiagnostics <= 2)) this.nDiagnostics = 1;

        /**
         * nPowerChange is 0 while the power state is stable, 1 while power is transitioning
         * to "on", and -1 while power is transitioning to "off".
         */
        this.nPowerChange = 0;

        /**
         * TODO: Deprecate 'buswidth' (it should have always used camelCase)
         */
        this.nBusWidth = parmsComputer['busWidth'] || parmsComputer['buswidth'];

        this.resume = Computer.RESUME_NONE;
        this.sStateData = null;
        this.fStateData = false;            // remembers if sStateData was loaded
        this.fServerState = false;

        this.url = this.getMachineParm('url') || "";

        /**
         * Generate a random number x (where 0 <= x < 1), add 0.1 so that it's guaranteed to be
         * non-zero, convert to base 36, and chop off the leading digit and "decimal" point.
         */
        this.sMachineID = (Math.random() + 0.1).toString(36).substr(2,12);
        this.sUserID = this.queryUserID();

        /**
         * Find the appropriate CPU (and Debugger and Control Panel, if any)
         *
         * CLOSURE COMPILER TIP: To override the type of a right-hand expression (as we need to do here,
         * where we know getComponentByType() will only return an CPUx86 object or null), wrap the expression
         * in parentheses.  I never knew this until I stumbled across it in "Closure: The Definitive Guide".
         */
        this.cpu = /** @type {CPUx86} */ (Component.getComponentByType("CPU", this.id));
        if (!this.cpu) {
            Component.error("Unable to find CPU component");
            return;
        }

        /**
         * We now record whether or not the machine was originally configured with an FPU (this.fpu),
         * but even when not, we still initialize an FPU, so that the machine can be dynamically reconfigured.
         */
        this.fpu = /** @type {FPUx86} */ (Component.getComponentByType("FPU", this.id));
        if (!this.fpu) new FPUx86({'id': this.idMachine + ".fpu"});

        this.dbg = /** @type {Debuggerx86} */ (Component.getComponentByType("Debugger", this.id));

        /**
         * Enumerate all the Video components for diagnostic displays, focus changes, and updateStatus() calls.
         */
        this.aVideo = [];
        for (let video = null; (video = this.getMachineComponent("Video", video));) {
            this.aVideo.push(video);
        }

        /**
         * Initialize the Bus component
         */
        this.bus = new Busx86({'id': this.idMachine + '.bus', 'busWidth': this.nBusWidth}, this.cpu, this.dbg);

        /**
         * Iterate through all the components and override their notice() and print() methods
         * so that their output can be rerouted to a Diagnostic Display or Control Panel, if any.
         */
        let iComponent;
        let component;
        let aComponents = Component.getComponents(this.id);

        this.panel = /** @type {Panel} */ (Component.getComponentByType("Panel", this.id));
        this.controlPanel = this.panel && this.panel.bindings['print'];

        this.printComputer = this.print;
        if (this.controlPanel) {
            this.printComputer = this.panel.print;
        }

        for (iComponent = 0; iComponent < aComponents.length; iComponent++) {
            component = aComponents[iComponent];
            component.print = function printComputer(s, bitsMessage) {
                cmp.outputDiagnostics(s, bitsMessage);
                return cmp.printComputer.call(this, s, bitsMessage);
            }.bind(component);
        }

        this.cDiagnosticScreens = 0;
        if (!this.controlPanel && this.nDiagnostics) {
            this.enableDiagnostics();
        }

        this.printf(MESSAGE.NONE, "%s v%s\n%s\n%s\n", APPNAME, APPVERSION, COPYRIGHT, LICENSE);

        if (MAXDEBUG) this.printf(MESSAGE.DEBUG, "PREFETCH: %b, TYPEDARRAYS: %b\n", PREFETCH, TYPEDARRAYS);

        /**
         * Iterate through all the components again and call their initBus() handler, if any
         */
        for (iComponent = 0; iComponent < aComponents.length; iComponent++) {
            component = aComponents[iComponent];
            if (component.initBus) component.initBus(this, this.bus, this.cpu, this.dbg);
        }

        /**
         * This timer replaces the CPU's old dedicated STATUS_UPDATES_PER_SECOND logic; periodic updateStatus()
         * calls are now our own responsibility.
         */
        this.cpu.addTimer(this.id, function updateStatusTimer() {
            cmp.updateStatus();
        }, 1000 / Computer.UPDATES_PER_SECOND);

        let sStatePath = null;
        let sResume = this.getMachineParm('resume');
        if (sResume !== undefined) {
            /**
             * Decide whether the 'resume' property is a number or the path of a state file to resume.
             */
            if (sResume.length > 1) {
                sStatePath = this.sResumePath = sResume;
            } else {
                this.resume = parseInt(sResume, 10);
            }
        }

        /**
         * The Computer 'state' property allows a state file to be specified independent of the 'resume' feature;
         * previously, you could only use 'resume' to load a state file -- which we still support, but loading a state
         * file that way prevents the machine's state from being saved, since we always resume from the 'resume' file.
         *
         * The other wrinkle is on the restore side: we need to IGNORE the 'state' property if a saved state now exists.
         * So we have to peek at localStorage, and unfortunately, the only way to "peek" is to actually load the data,
         * but we're not ready to use it yet, so powerUp() has been changed to use any existing stateComputer that we've
         * already loaded.
         *
         * However, there's now a wrinkle to the wrinkle: if a 'state' parameter has been passed via the URL, then that
         * OVERRIDES everything; it overrides any 'state' Computer parameter AND it disables resume of any saved state in
         * localStorage (in other words, it prevents fAllowResume from being true, and forcing resume off).
         */
        let fAllowResume = false;
        let sState = WebLib.getURLParm('state');
        if (!sState) {
            fAllowResume = true;
            sState = this.getMachineParm('state', parmsComputer);
        }
        if (sState) {
            sStatePath = this.sStatePath = sState;
            if (!fAllowResume) {
                this.fServerState = true;
                this.resume = Computer.RESUME_NONE;
            }
            if (this.resume) {
                this.stateComputer = new State(this, APPVERSION);
                if (this.stateComputer.load()) {
                    sStatePath = null;
                } else {
                    delete this.stateComputer;
                }
            }
        }

        /**
         * If sStatePath is set, we must use it.  But if there's no sStatePath AND resume is set,
         * then we have the option of resuming from a server-side state, assuming a valid USERID.
         */
        if (!sStatePath && this.resume) {
            sStatePath = this.getServerStatePath();
            if (sStatePath) this.fServerState = true;
        }

        this.sStateURL = sStatePath;

        if (!this.sStateURL) {
            this.setReady();
        } else {
            let sProgress = "Loading " + this.sStateURL + "...";
            WebLib.getResource(this.sStateURL, null, true, function(sURL, sResource, nErrorCode) {
                cmp.doneLoad(sURL, sResource, nErrorCode);
            }, function(nState) {
                cmp.printf(MESSAGE.PROGRESS, "%s\n", sProgress);
            });
        }

        if (!this.bindings["power"]) this.fAutoPower = true;

        /**
         * Power on the computer, giving every component the opportunity to reset or restore itself.
         */
        if (!fSuspended && this.fAutoPower) this.wait(this.powerOn);
    }

    /**
     * clearPanel()
     *
     * @this {Computer}
     */
    clearPanel()
    {
        if (this.controlPanel) {
            this.controlPanel.value = "";
        }
    }

    /**
     * enableDiagnostics()
     *
     * @this {Computer}
     */
    enableDiagnostics()
    {
        if (!this.cDiagnosticScreens) {
            for (let i = 0; i < this.aVideo.length; i++) {
                let video = this.aVideo[i];
                if (video) {
                    let control = video.getTextArea();
                    if (control) {
                        /**
                         * By default, the Video textarea overlay has opacity and lineHeight styles set to "0"
                         * to make the overall textarea and its blinking caret invisible (respectively), so in order
                         * to use it as a diagnostic display, we must temporarily set both those styles to "1".
                         */
                        control.style.opacity = "1";
                        control.style.lineHeight = "1";
                        // control.style.fontSize = "1.5vw";    // this is a nice idea, but it doesn't work well with side-by-side machines
                        this.cDiagnosticScreens++;
                    }
                }
            }
        }
    }

    /**
     * disableDiagnostics()
     *
     * @this {Computer}
     */
    disableDiagnostics()
    {
        if (this.cDiagnosticScreens) {
            for (let i = 0; i < this.aVideo.length; i++) {
                let video = this.aVideo[i];
                if (video) {
                    let control = video.getTextArea();
                    if (control) {
                        /**
                         * Return the Video textarea overlay's opacity and lineHeight styles to their original values.
                         */
                        control.style.opacity = "0";
                        control.style.lineHeight = "0";
                        /**
                         * Setting lineHeight in IE isn't sufficient to hide the caret; we must also set fontSize to "0",
                         * and we make the change IE-specific because it can have weird side-effects in other browsers (eg,
                         * it makes Safari on iOS over-zoom whenever the textarea receives focus).
                         */
                        if (WebLib.isUserAgent("MSIE")) control.style.fontSize = "0";
                        /**
                         * We no longer clear the text, to give the user/system a chance to copy it to the clipboard.
                         *
                         *      control.value = "";
                         */
                    }
                }
            }
            this.cDiagnosticScreens = 0;
        }
        this.nDiagnostics = 0;
    }

    /**
     * doneDiagnostics(aParms)
     *
     * Examines nDiagnostics state and reacts accordingly.  The states are:
     *
     *      0: diagnostics disabled
     *      1: diagnostics enabled with timeout
     *      2: diagnostics enabled with key prompt
     *      3: diagnostics prompt issued, waiting for timeout
     *      4: diagnostics prompt issues, waiting for key
     *      5: diagnostics output complete (eg, timeout fired or key received)
     *
     * @this {Computer}
     * @param {Array} aParms (array of parameters to pass to donePowerOn)
     * @returns {boolean} (true if diagnostics have been turned off, false if they remain enabled)
     */
    doneDiagnostics(aParms)
    {
        if (this.cDiagnosticScreens) {
            if (this.nDiagnostics == 1) {
                /**
                 * If non-prompting diagnostic output is enabled, immediately advance the
                 * state to completion and wait briefly before continuing with donePowerOn();
                 * this allows the user to pause the machine (by tapping a shift key) if desired.
                 */
                this.nDiagnostics += 2;
                setTimeout(function(cmp) {
                    return function onDiagnosticTimeout() {
                        cmp.notifyKbdEvent();
                    };
                }(this), 2000);
                this.printf(MESSAGE.NONE, "Initialization complete\n");
            }
            if (this.nDiagnostics == 2) {
                this.nDiagnostics += 2;
                this.printf(MESSAGE.NONE, "Initialization complete, press a key to continue...\n");
            }
            if (this.nDiagnostics == 3 || this.nDiagnostics == 4) {
                /**
                 * When notifyKbdEvent() is called, it will call setReady(true), ending the wait().
                 */
                this.setReady(false);
                this.wait(this.donePowerOn, aParms);
                return false;
            }
        }
        this.disableDiagnostics();
        return true;
    }

    /**
     * outputDiagnostics(sMessage, bitsMessage)
     *
     * @this {Computer}
     * @param {string} sMessage
     * @param {number} [bitsMessage]
     */
    outputDiagnostics(sMessage, bitsMessage = 0)
    {
        if (this.cDiagnosticScreens) {
            for (let i = 0; i < this.aVideo.length; i++) {
                let video = this.aVideo[i];
                if (video) {
                    let control = video.getTextArea();
                    if (control) {
                        if (bitsMessage == MESSAGE.PROGRESS && sMessage.slice(-4) == "...\n") {
                            Component.replaceControl(control, sMessage.slice(0, -1), sMessage.slice(0, -1) + ".");
                        } else {
                            Component.appendControl(control, sMessage);
                        }
                    }
                }
            }
        }
    }

    /**
     * notifyKbdEvent(event, fDown)
     *
     * This is called by the Keyboard component for all key presses, and it is effectively a no-op except
     * in the one special case where disableDiagnostics() has delayed powerOn until a key is pressed.  This is
     * also called without an event if we're waiting for a timeout to fire.
     *
     * @this {Computer}
     * @param {Object} [event]
     * @param {boolean} [fDown] is true for a keyDown event, false for a keyUp event
     * @returns {boolean} (true if diagnostics disabled, false if enabled -- at the time of the call)
     */
    notifyKbdEvent(event, fDown)
    {
        let nDiagnostics = this.nDiagnostics;
        if (event && event.keyCode == 16 && this.nDiagnostics == 3) {
            this.nDiagnostics++;        // if we're waiting for a timeout and a shift key was pressed, wait for another key
            this.printf(MESSAGE.NONE, "Machine paused, press another key to continue...\n");
            event = null;
        }
        if (!event && this.nDiagnostics == 3 || event && fDown && this.nDiagnostics == 4) {
            this.nDiagnostics = 5;
            this.setReady();            // this may trigger a call to disableDiagnostics(), which is why we snapshot nDiagnostics
        }
        return !nDiagnostics;
    }

    /**
     * getMachineID()
     *
     * @this {Computer}
     * @returns {string}
     */
    getMachineID()
    {
        return this.sMachineID;
    }

    /**
     * setMachineParms(parmsMachine)
     *
     * If no explicit machine parms were provided, then we check for 'parms' in the bundled resources (if any).
     *
     * @this {Computer}
     * @param {Object} [parmsMachine]
     */
    setMachineParms(parmsMachine)
    {
        if (!parmsMachine) {
            let sParms, resMachine, resources = globals.window['resources'];
            if (typeof resources == 'object' && (sParms = resources['parms']) || (resMachine = Component.getMachineResources(this.idMachine)) && (sParms = resMachine['parms'])) {
                try {
                    parmsMachine = /** @type {Object} */ (eval('(' + sParms + ')'));
                } catch(err) {
                    Component.error(err.message + " (" + sParms + ")");
                }
            }
        }
        this.parmsMachine = parmsMachine;
    }

    /**
     * getMachineBoolean(sParm, fDefault)
     *
     * Boolean-specific version of getMachineParm().
     *
     * @this {Computer}
     * @param {string} sParm
     * @param {boolean} [fDefault]
     * @returns {boolean|undefined}
     */
    getMachineBoolean(sParm, fDefault)
    {
        let f = fDefault;
        let s = this.getMachineParm(sParm);
        if (s != undefined) {
            f = (s == "true"? true : (s == "false"? false : !!s));
        }
        return f;
    }

    /**
     * getMachineParm(sParm, parmsComponent)
     *
     * If the machine parameter doesn't exist, we check for a matching component parameter (if parmsComponent
     * is provided), and failing that, we check the bundled resources (if any).
     *
     * At the moment, the only bundled resource request we expect to encounter is 'state'; if it exists, then
     * we return 'state' back to the caller (ie, the name of the resource), so that the caller will then attempt
     * to load the 'state' resource to obtain the actual state.
     *
     * TODO: This function could (and perhaps should) be modified to accept an optional type parameter (ie,
     * one of the values in Component.TYPE), so that parms like autoMount could be eval'ed here rather than by
     * the caller (eg, FDC.parseConfig()).  The downside is that this function would have to return multiple types,
     * so every call would have to be cast to the expected type.
     *
     * @this {Computer}
     * @param {string} sParm
     * @param {Object} [parmsComponent] (eg, this.parms)
     * @returns {string|undefined}
     */
    getMachineParm(sParm, parmsComponent)
    {
        let value = WebLib.getURLParm(sParm);
        if (value) {
            try {
                /**
                 * Ideally, we could simply use strings as-is, but unfortunately, we need to convert all
                 * supported escape sequences to their underlying characters, and using eval() is the simplest
                 * way to deal with them; eg:
                 *
                 *      \', \", \r, \n, \t, and \xNN
                 *
                 * When a string containing the above sequences is passed as a machine or component parameter
                 * (ie, as an embedPC() machine parameter or as XML component attribute), that conversion happens
                 * automatically, either by virtue of implicit script evaluation, or by explicit eval() in
                 * getComponentParms().  But when they're passed as a URL parameter, any backslashes are passed
                 * through as-is.
                 *
                 * The complete list of backslash sequences supported by JavaScript:
                 *
                 *      \0  \'  \"  \\  \n  \r  \v  \t  \b  \f  \uXXXX \xXX
                 *                      ^J  ^M  ^K  ^I  ^H  ^L
                 *
                 * and of course, eval() will convert them all, but there's no expectation of any but those I've
                 * listed above, in part because of Jekyll limitations in some of our templates; eg:
                 *
                 *      https://github.com/jeffpar/pcjs.v1/blob/jekyll/_includes/machine-engines.html
                 *
                 * which could be overcome, but there's really no need to support more, since \xNN can be used to
                 * represent anything else.
                 *
                 * Finally, while the user should escape any quotation characters, to be safe, we now ensure that all
                 * double-quotes are escaped, so that we can safely double-quote the entire string.
                 */
                value = value.replace(/([^\\])"/g, '$1\\"');
                value = /** @type {string} */ (eval('"' + value + '"'));
            } catch(err) {
                Component.error(err.message + " (" + value + ")");
                value = undefined;
            }
        }
        if (value === undefined && this.parmsMachine) {
            value = this.parmsMachine[sParm];
        }
        if (value === undefined && parmsComponent) {
            value = parmsComponent[sParm];
        }
        let resources = globals.window['resources'];
        if (!value && typeof resources == 'object') {
            if (resources[sParm]) {
                value = sParm;
            }
            else {
                try {
                    let parms = JSON.parse(resources['parms']);
                    value = parms[sParm];
                }
                catch(err) {
                    Component.error(err.message + " (" + resources['parms'] + ")");
                }
            }
        }
        return value;
    }

    /**
     * saveMachineParms()
     *
     * @this {Computer}
     * @returns {string|null}
     */
    saveMachineParms()
    {
        return this.parmsMachine? JSON.stringify(this.parmsMachine) : null;
    }

    /**
     * getUserID()
     *
     * @this {Computer}
     * @returns {string}
     */
    getUserID()
    {
        return this.sUserID || "";
    }

    /**
     * doneLoad(sURL, sStateData, nErrorCode)
     *
     * @this {Computer}
     * @param {string} sURL
     * @param {string} sStateData
     * @param {number} nErrorCode
     */
    doneLoad(sURL, sStateData, nErrorCode)
    {
        if (!nErrorCode) {
            Component.addMachineResource(this.idMachine, sURL, sStateData);
            this.sStateData = sStateData;
            this.fStateData = true;
            if (DEBUG) this.printf("loaded state file %s\n", sURL.replace(this.sUserID || "xxx", "xxx"));
        } else {
            this.sResumePath = null;
            this.fServerState = false;
            this.printf(MESSAGE.NOTICE, "Unable to load machine state (%s) from server (error %d%s)\n", sURL, nErrorCode, (sStateData? ': ' + StrLib.trim(sStateData) : ''));
        }
        this.setReady();
    }

    /**
     * wait(fn, parms)
     *
     * wait() waits until every component is ready (including ourselves, the last component we check), then calls the
     * specified Computer method.
     *
     * TODO: The Closure Compiler makes it difficult for us to define a function type for "fn" that works in all cases;
     * sometimes we want to pass a function that takes only a "number", and other times we want to pass a function that
     * takes only an "Array" (the type will mirror that of the "parms" parameter).  However, the Closure Compiler insists
     * that both functions must be declared as accepting both types of parameters.  So once again, we must use an untyped
     * function declaration, instead of something stricter like:
     *
     *      param {function(this:Computer, (number|Array|undefined)): undefined} fn
     *
     * @this {Computer}
     * @param {function(...)} fn
     * @param {number|Array} [parms] optional parameters
     */
    wait(fn, parms)
    {
        let computer = this;
        let aComponents = Component.getComponents(this.id);
        for (let iComponent = 0; iComponent <= aComponents.length; iComponent++) {
            let component = (iComponent < aComponents.length? aComponents[iComponent] : this);
            if (!component.isReady()) {
                component.isReady(function onComponentReady() {
                    computer.wait(fn, parms);
                });
                return;
            }
        }
        if (DEBUG) this.printf("Computer.wait(ready)\n");
        fn.call(this, parms);
    }

    /**
     * validateState(stateComputer)
     *
     * NOTE: We clear() stateValidate only when there's no stateComputer.
     *
     * @this {Computer}
     * @param {State|null} [stateComputer]
     * @returns {boolean} true if state passes validation, false if not
     */
    validateState(stateComputer)
    {
        let fValid = true;
        let stateValidate = new State(this, APPVERSION, Computer.STATE_VALIDATE);
        if (stateValidate.load() && stateValidate.parse()) {
            let sTimestampValidate = stateValidate.get(Computer.STATE_TIMESTAMP);
            let sTimestampComputer = stateComputer ? stateComputer.get(Computer.STATE_TIMESTAMP) : "unknown";
            if (sTimestampValidate != sTimestampComputer) {
                this.printf(MESSAGE.NOTICE, "Machine state may be out-of-date\n(%s vs. %s)\nCheck your browser's local storage limits\n", sTimestampValidate, sTimestampComputer);
                fValid = false;
                if (!stateComputer) stateValidate.clear();
            } else {
                if (DEBUG) this.printf("Last state: %s (validate: %s)\n", sTimestampComputer, sTimestampValidate);
            }
        }
        return fValid;
    }

    /**
     * powerOn(resume)
     *
     * Power every component "up", applying any previously available state information.
     *
     * @this {Computer}
     * @param {number} [resume] is a valid RESUME value; default is this.resume
     */
    powerOn(resume)
    {
        if (resume === undefined) {
            resume = this.resume || (this.sStateData? Computer.RESUME_AUTO : Computer.RESUME_NONE);
        }

        if (DEBUG) this.printf("Computer.powerOn(%s)\n", (resume == Computer.RESUME_REPOWER ? "repower" : (resume ? "resume" : "")));

        if (this.nPowerChange) {
            return;
        }
        this.nPowerChange++;

        let fRepower = false;
        let fRestore = false;
        this.fRestoreError = false;
        let stateComputer = this.stateComputer || new State(this, APPVERSION);

        if (resume == Computer.RESUME_REPOWER) {
            fRepower = true;
        }
        else if (resume > Computer.RESUME_NONE) {
            if (stateComputer.load(this.sStateData)) {
                /**
                 * Since we're resuming something (either a predefined state or a state from localStorage), let's
                 * create a "failsafe" checkpoint in localStorage, and destroy it at the end of a successful powerOn().
                 * Which means, of course, that if a previous "failsafe" checkpoint already exists, something bad
                 * may have happened the last time around.
                 */
                this.stateFailSafe = new State(this, APPVERSION, Computer.STATE_FAILSAFE);

                if (this.stateFailSafe.load()) {
                    if (resume != Computer.RESUME_AUTO && this.powerReport(stateComputer)) {
                        /**
                         * Prompt the user; if they decline to restore, the state will be removed.
                         */
                        resume = Computer.RESUME_PROMPT;
                    }
                    /**
                     * To ensure that the set() below succeeds, we need to call unload(), otherwise it may fail
                     * with a "read only" error (eg, "TypeError: Cannot assign to read only property 'timestamp'").
                     */
                    this.stateFailSafe.unload();
                }

                this.stateFailSafe.set(Computer.STATE_TIMESTAMP, UsrLib.getTimestamp());
                this.stateFailSafe.store();

                let fValidate = this.resume && !this.fServerState;
                if (resume == Computer.RESUME_AUTO || Component.confirmUser("Click OK to restore the previous " + APPNAME + " machine state.")) {
                    fRestore = stateComputer.parse();
                    if (fRestore) {
                        let sCode = stateComputer.get(UserAPI.RES.CODE);
                        let sData = stateComputer.get(UserAPI.RES.DATA);
                        if (sCode) {
                            if (sCode == UserAPI.CODE.OK) {
                                stateComputer.load(/** @type {string} */ (sData));
                            } else {
                                /**
                                 * A missing (or not yet created) state file is no cause for alarm, but other errors might be
                                 */
                                if (sCode == UserAPI.CODE.FAIL && sData != UserAPI.FAIL.NOSTATE) {
                                    this.printf(MESSAGE.NOTICE, "Error: %s\n", sData);
                                    if (sData == UserAPI.FAIL.VERIFY) this.resetUserID();
                                } else {
                                    this.printf(MESSAGE.DEBUG, "%s: %s\n", sCode, sData);
                                }
                                /**
                                 * Try falling back to the state that we should have saved in localStorage, as a backup to the
                                 * server-side state.
                                 */
                                stateComputer.unload();     // discard the invalid server-side state first
                                if (stateComputer.load()) {
                                    fRestore = stateComputer.parse();
                                    fValidate = true;
                                } else {
                                    fRestore = false;       // hmmm, there was nothing in localStorage either
                                }
                            }
                        }
                    }
                    /**
                     * If the load/parse was successful, and it was from localStorage (not sStateData),
                     * then we should to try verify that localStorage snapshot is current.  One reason it may
                     * NOT be current is if localStorage was full and we got a quota error during the last
                     * powerOff().
                     */
                    if (fValidate) this.validateState(fRestore? stateComputer : null);
                } else {
                    /**
                     * RESUME_PROMPT indicates we should delete the state if they clicked Cancel to confirm() above.
                     */
                    if (resume == Computer.RESUME_PROMPT) stateComputer.clear();
                }
            } else {
                /**
                 * If there's no state, then there should also be no validation timestamp; if there is, then once again,
                 * we're probably dealing with a quota error.
                 */
                this.validateState();
            }
            delete this.sStateData;
            delete this.stateComputer;
        }

        /**
         * Start powering all components, including any data they may need to restore their state;
         * we restore power to the CPU last.
         */
        let aComponents = Component.getComponents(this.id);
        for (let iComponent = 0; iComponent < aComponents.length; iComponent++) {
            let component = aComponents[iComponent];
            if (component !== this && component != this.cpu) {
                try {
                    fRestore = this.powerRestore(component, stateComputer, fRepower, fRestore);
                } catch(err) {
                    Component.error(component.type + " restore failure: " + err.message);
                }
            }
        }

        /**
         * Assuming this is not a repower, we must perform another wait, because some components may
         * have marked themselves as "not ready" again (eg, the FDC component, if the restore forced it
         * to mount one or more additional disk images).
         */
        let aParms = [stateComputer, resume, fRestore];

        if (resume != Computer.RESUME_REPOWER) {
            this.wait(this.donePowerOn, aParms);
            return;
        }
        this.donePowerOn(aParms);
    }

    /**
     * powerRestore(component, stateComputer, fRepower, fRestore)
     *
     * @this {Computer}
     * @param {Component} component
     * @param {State} stateComputer
     * @param {boolean} fRepower
     * @param {boolean} fRestore
     * @returns {boolean} true if restore should continue, false if not
     */
    powerRestore(component, stateComputer, fRepower, fRestore)
    {
        if (!component.flags.powered) {

            component.flags.powered = true;

            if (component.powerUp) {

                let data = null;
                if (fRestore) {
                    data = stateComputer.get(component.id);
                    if (!data) {
                        /**
                         * This is a hack that makes it possible for a machine whose ID has been
                         * supplemented with a hyphenated numeric suffix to find object IDs in states
                         * created from a machine without such a suffix.
                         *
                         * For example, if a state file was created from a machine with ID "ibm5160"
                         * but the current machine is "ibm5160-1", this attempts a second lookup with
                         * "ibm5160", enabling us to find objects that match the original machine ID
                         * (eg, "ibm5160.romEGA").
                         *
                         * See /devices/pcx86/machine/5160/ega/640kb/array for examples of this.
                         */
                        data = stateComputer.get(component.id.replace(/-[0-9]+\./i, '.'));
                    }
                }

                /**
                 * State.get() will return whatever was originally passed to State.set() (eg, an
                 * Object or a string), but components are supposed to store only Objects, so if a
                 * string comes back, something went wrong.  By explicitly eliminating "string" data,
                 * the Closure Compiler stops complaining that we might be passing strings to our
                 * powerUp() functions (even though we know we're not).  We could also add @type
                 * overrides to the data assignments, but this seems like a useful runtime check.
                 */
                if (typeof data === "string") data = null;

                /**
                 * If computer is null, this is simply a repower notification, which most components
                 * don't do anything with.  Exceptions include: CPU (since it may be halted) and Video
                 * (since its screen may be "turned off").
                 */
                if (!component.powerUp(data, fRepower) && data) {

                    if (!this.flags.unloading) {
                        this.printf(MESSAGE.NOTICE, "Unable to restore hardware state\n");
                        /**
                         * If this is a resume error for a machine that also has a predefined state
                         * AND we're not restoring from that state, then throw away the current state,
                         * prevent any new state from being created, and then force a reload, which will
                         * hopefully restore us to the functioning predefined state.
                         *
                         * TODO: Considering doing this in ALL cases, not just in situations where a
                         * 'state' exists but we're not actually resuming from it.
                         */
                        if (this.sStatePath && !this.fStateData) {
                            stateComputer.clear();
                            this.resume = Computer.RESUME_NONE;
                            WebLib.reloadPage();
                        } else {
                            /**
                             * In all other cases, we set fRestoreError, which should trigger a call to
                             * powerReport() and then delete the offending state.
                             */
                            this.fRestoreError = true;
                        }
                    }

                    /**
                     * Any failure triggers an automatic to call powerUp() again, without any state,
                     * in the hopes that the component can recover by performing a reset.
                     */
                    component.powerUp(null);
                    /**
                     * We also disable the rest of the restore operation, because it's not clear
                     * the remaining state information can be trusted;  the machine is already in an
                     * inconsistent state, so we're not likely to make things worse, and the only
                     * alternative (starting over and performing a state-less reset) isn't likely to make
                     * the user any happier.  But, we'll see... we need some experience with the code.
                     */
                    fRestore = false;
                }
            }

            component.flags.initDone = true;

            if (!fRepower && component.comment) {
                let asComments = component.comment.split("|");
                for (let i = 0; i < asComments.length; i++) {
                    component.printf(MESSAGE.STATUS, "%s\n", asComments[i]);
                }
            }
        }
        return fRestore;
    }

    /**
     * donePowerOn(aParms)
     *
     * This is nothing more than a continuation of powerOn(), giving us the option of calling wait() one more time.
     *
     * @this {Computer}
     * @param {Array} aParms ([stateComputer, resume, fRestore])
     */
    donePowerOn(aParms)
    {
        if (!this.flags.initDone) {
            if (!this.doneDiagnostics(aParms)) return;
            this.flags.initDone = true;
        }

        if (DEBUG && this.flags.powered) this.printf("Computer.donePowerOn(): redundant\n");

        let stateComputer = aParms[0];
        let fRepower = (aParms[1] < 0);
        let fRestore = aParms[2];

        let controlPower = this.bindings["power"];
        if (controlPower) controlPower.textContent = "Shutdown";

        this.flags.powered = true;

        /**
         * Once we get to this point, we're guaranteed that all components are ready, so it's safe to power the CPU;
         * the CPU should begin executing immediately, unless a debugger is attached.
         */
        if (this.cpu) {
            /**
             * TODO: Do we not care about the return value here? (ie, is checking fRestoreError sufficient)?
             */
            this.powerRestore(this.cpu, stateComputer, fRepower, fRestore);
            this.cpu.autoStart();
        }

        /**
         * If the state was bad, offer to report it and then delete it.  Deleting may be moot, since invariably a new
         * state will be created on powerOff() before the next powerOn(), but it seems like good paranoia all the same.
         */
        if (this.fRestoreError) {
            this.powerReport(stateComputer);
            stateComputer.clear();
        }

        if (!fRepower && this.stateFailSafe) {
            this.stateFailSafe.clear();
            delete this.stateFailSafe;
        }

        this.nPowerChange = 0;

        Component.processScript(this.idMachine, this.getMachineParm('autoScript'));
    }

    /**
     * checkPower()
     *
     * @this {Computer}
     * @returns {boolean} true if the computer is fully powered, false otherwise
     */
    checkPower()
    {
        if (this.flags.unloading) {
            /**
             * We happen to know that we're currently only called by the CPU's onClickRun() function, so
             * if the unloading flag is set, then we've somehow gotten into a weird state where the machine
             * thinks it's being (or has been) unloaded by the browser, but in fact, it has not.
             *
             * The only time I've seen this happen is when the user clicks a link on a page that the browser
             * decided to treat as a download operation, instead of loading a new page.  The proper way to
             * resolve that confusion is to set the "download" attribute on the link (which will prevent the
             * page's "onbeforeunload" handler from being called in the first place), but we cannot guarantee
             * that all such links will have their "download" attribute properly set.
             *
             * Hence, this code: we do the same thing that the show() function does, which is to attempt a
             * REPOWER operation.  If that doesn't result in the powered flag getting turned back on, well,
             * then we're probably screwed.
             */
            this.flags.unloading = false;
            if (this.flags.initDone && !this.flags.powered) {
                this.powerOn(Computer.RESUME_REPOWER);
            }
        }

        if (this.flags.powered) return true;

        let component = null, iComponent;
        let aComponents = Component.getComponents(this.id);
        for (iComponent = 0; iComponent < aComponents.length; iComponent++) {
            component = aComponents[iComponent];
            if (component !== this && !component.flags.ready) break;
        }
        if (iComponent == aComponents.length) {
            for (iComponent = 0; iComponent < aComponents.length; iComponent++) {
                component = aComponents[iComponent];
                if (component !== this && !component.flags.powered) break;
            }
        }
        if (iComponent == aComponents.length) component = this;
        let status = (!component.flags.ready? "ready yet" + (component.fnReady? " (waiting for notification)" : "") : "powered yet");
        Component.printf(MESSAGE.NOTICE, "The %s component (%s) is not %s\n", component.type, component.id, status);
        return false;
    }

    /**
     * powerReport(stateComputer)
     *
     * TODO: Ever since I migrated the PCjs website from a Node-based web server on AWS to a GitHub Pages-based site,
     * the sendReport() API has been a bit-bucket.  To be honest though, even before that change, I never really had
     * the time (or desire) to look through all the anonymous machine states that were being posted.  Most of them were
     * probably due to the user switching away from a page before it finished loading anyway, leaving the machine in
     * an incomplete state.  That said, there should be SOME automated way for people to share their machine states
     * when there's a more serious problem -- not this misleading prompt.
     *
     * In the meantime, to help reduce those kind of useless alerts, there's the new 'unloading' flag.  However, I'm
     * not sure how reliably that's being set, so additionally, the default 'resume' setting (RESUME_AUTO) tries to be
     * MUCH more automatic now; this function, for example, shouldn't even be called now when RESUME_AUTO is in effect.
     * Another 'resume' setting (eg, RESUME_PROMPT) must be selected instead.
     *
     * @this {Computer}
     * @param {State} stateComputer
     * @returns {boolean}
     */
    powerReport(stateComputer)
    {
        if (!this.flags.unloading) {
            //
            // This is all we can realistically do for now.
            //
            WebLib.onError("There may be a problem with your " + APPNAME + " machine.");
            //
            // if (Component.confirmUser("There may be a problem with your " + APPNAME + " machine.\n\nTo help us diagnose it, click OK to send this " + APPNAME + " machine state to " + SITEURL + ".")) {
            //     WebLib.sendReport(APPNAME, APPVERSION, this.url, this.getUserID(), ReportAPI.TYPE.BUG, stateComputer.toString());
            // }
            //
            return true;
        }
        return false;
    }

    /**
     * powerOff(fSave, fShutdown)
     *
     * Power every component "down" and optionally save the machine state.
     *
     * There's one scenario that powerOff() isn't currently able to deal with very effectively: what to do when
     * the user switches away while it's still being restored, causing Disk getResource() calls to fail.  The
     * Disk component calls notify() when that happens -- see Disk.mount() -- but the FDC and HDC controllers don't
     * notify *us* of those problems, so Computer assumes that the restore was completely successful, when in fact
     * it was only partially successful.
     *
     * Then we immediately arrive here to perform a save, following that incomplete restore.  It would be wrong to
     * deal with that incomplete restore by setting fRestoreError, because we don't want to trigger a powerReport()
     * and the deletion of the previous state, because the state itself was presumably OK.  Unfortunately, the new
     * state we now save will no longer include manually mounted disk images whose remounts were interrupted, so future
     * restores won't remount them either.
     *
     * We could perhaps solve this by having the Disk component notify us in those situations, set a new flag
     * (fRestoreIncomplete?), and set fSave to false if that's ever set.  Be careful though: when fSave is false,
     * that means MORE than not saving; it also means deleting any previous state, which is NOT what you'd want to
     * do in a "fRestoreIncomplete" situation.  Also, we have to worry about Disk operations that fail for other reasons,
     * making sure those failures don't interfere with the save process in the same way.
     *
     * As it stands, the worst that happens is any manually mounted disk images might have to be manually remounted,
     * which doesn't seem like a huge problem.
     *
     * @this {Computer}
     * @param {boolean} [fSave] is true to request a saved state
     * @param {boolean} [fShutdown] is true if the machine is being shut down
     * @returns {string|null} string representing the saved state (or null if error)
     */
    powerOff(fSave, fShutdown)
    {
        let data;
        let sState = "none";

        if (DEBUG) this.printf("Computer.powerOff(%s%s)\n", (fSave? "save" : "nosave"), (fShutdown? ",shutdown" : ""));

        if (this.nPowerChange) {
            return null;
        }
        this.nPowerChange--;

        let stateComputer = new State(this, APPVERSION);
        let stateValidate = new State(this, APPVERSION, Computer.STATE_VALIDATE);

        let sTimestamp = UsrLib.getTimestamp();
        stateValidate.set(Computer.STATE_TIMESTAMP, sTimestamp);
        stateComputer.set(Computer.STATE_TIMESTAMP, sTimestamp);
        stateComputer.set(Computer.STATE_VERSION, APPVERSION);
        stateComputer.set(Computer.STATE_HOSTURL, WebLib.getHostURL());
        stateComputer.set(Computer.STATE_BROWSER, WebLib.getUserAgent());

        /**
         * Always power the CPU "down" first, just to help insure it doesn't ask other components to do anything
         * after they're no longer ready.
         */
        if (this.cpu && this.cpu.powerDown) {
            data = this.cpu.powerDown(fSave, fShutdown);
            if (typeof data === "object") stateComputer.set(this.cpu.id, data);
            if (fShutdown) {
                this.cpu.flags.powered = false;
                if (data === false) sState = null;
            }
        }

        let aComponents = Component.getComponents(this.id);
        for (let iComponent = 0; iComponent < aComponents.length; iComponent++) {
            let component = aComponents[iComponent];
            if (component.flags.powered) {
                if (component.powerDown) {
                    data = component.powerDown(fSave, fShutdown);
                    if (typeof data === "object") stateComputer.set(component.id, data);
                }
                if (fShutdown) {
                    component.flags.powered = false;
                    if (data === false) sState = null;
                }
            }
        }

        if (sState) {
            if (fShutdown) {
                let fClear = false;
                let fClearAll = false;
                if (fSave) {
                    if (this.sUserID) {
                        this.saveServerState(this.sUserID, stateComputer.toString());
                    }
                    if (!stateValidate.store() || !stateComputer.store()) {
                        sState = null;
                        /**
                         * New behavior as of v1.13.2:  if it appears that localStorage is full, we blow it ALL away.
                         * Dedicated server-side storage is the only way we'll ever be able to reliably preserve a
                         * particular machine's state.  Historically, attempting to limp along with whatever localStorage
                         * is left just generates the same useless and annoying warnings over and over.
                         */
                        fClear = fClearAll = true;
                    }
                }
                else {
                    /**
                     * I used to ALWAYS clear (ie, delete) any associated computer state, but now I do this only if the
                     * current machine is "resumable", because there are situations where I have two configurations
                     * for the same machine -- one resumable and one not -- and I don't want the latter throwing away the
                     * state of the former.
                     *
                     * So this code is here now strictly for callers to delete the state of a "resumable" machine, not as
                     * some paranoid clean-up operation.
                     *
                     * An undocumented feature of this operation is that if your configuration uses the special 'resume="3"'
                     * value, and you click the "Reset" button, and then you click OK to reset the everything, this will
                     * actually reset EVERYTHING (ie, all localStorage for ALL configs will be reclaimed).
                     */
                    if (this.resume) {
                        fClear = true;
                        fClearAll = (this.resume == Computer.RESUME_DELETE);
                    }
                }
                if (fClear) {
                    stateComputer.clear(fClearAll);
                }
            } else {
                sState = stateComputer.toString();
            }
        }

        if (fShutdown) {
            this.flags.powered = false;
            let controlPower = this.bindings["power"];
            if (controlPower) controlPower.textContent = "Power";
        }

        this.nPowerChange = 0;

        return sState;
    }

    /**
     * reset()
     *
     * Notify all (other) components with a reset() method that the Computer is being reset.
     *
     * NOTE: We'd like to reset the Bus first (due to the importance of the A20 line), but since we
     * allocated the Bus object ourselves, after all the other components were allocated, it ends
     * up near the end of Component's list of components.  Hence the special case for this.bus below.
     *
     * @this {Computer}
     */
    reset()
    {
        if (this.bus && this.bus.reset) {
            this.printf("Resetting %s\n", this.bus.type);
            this.bus.reset();
        }
        let aComponents = Component.getComponents(this.id);
        for (let iComponent = 0; iComponent < aComponents.length; iComponent++) {
            let component = aComponents[iComponent];
            if (component !== this && component !== this.bus && component.reset) {
                this.printf("Resetting %s\n", component.type);
                component.reset();
            }
        }
    }

    /**
     * start(ms, nCycles)
     *
     * Notify all (other) components with a start() method that the CPU has started.
     *
     * Note that we're called by startCPU(), which is why we exclude the CPU component,
     * as well as ourselves.
     *
     * @this {Computer}
     * @param {number} ms
     * @param {number} nCycles
     */
    start(ms, nCycles)
    {
        let aComponents = Component.getComponents(this.id);
        for (let iComponent = 0; iComponent < aComponents.length; iComponent++) {
            let component = aComponents[iComponent];
            if (component.type == "CPU" || component === this) continue;
            if (component.start) {
                component.start(ms, nCycles);
            }
        }
    }

    /**
     * stop(ms, nCycles)
     *
     * Notify all (other) components with a stop() method that the CPU has stopped.
     *
     * Note that we're called by stopCPU(), which is why we exclude the CPU component,
     * as well as ourselves.
     *
     * @this {Computer}
     * @param {number} ms
     * @param {number} nCycles
     */
    stop(ms, nCycles)
    {
        let aComponents = Component.getComponents(this.id);
        for (let iComponent = 0; iComponent < aComponents.length; iComponent++) {
            let component = aComponents[iComponent];
            if (component.type == "CPU" || component === this) continue;
            if (component.stop) {
                component.stop(ms, nCycles);
            }
        }
    }

    /**
     * setBinding(sHTMLType, sBinding, control, sValue)
     *
     * @this {Computer}
     * @param {string} sHTMLType is the type of the HTML control (eg, "button", "list", "text", "submit", "textarea", "canvas")
     * @param {string} sBinding is the value of the 'binding' parameter stored in the HTML control's "data-value" attribute (eg, "reset")
     * @param {HTMLElement} control is the HTML control DOM object (eg, HTMLButtonElement)
     * @param {string} [sValue] optional data value
     * @returns {boolean} true if binding was successful, false if unrecognized binding request
     */
    setBinding(sHTMLType, sBinding, control, sValue)
    {
        let computer = this;

        switch (sBinding) {
        case "power":
            this.bindings[sBinding] = control;
            control.onclick = function onClickPower() {
                computer.onPower();
            };
            return true;

        case "reset":
            this.bindings[sBinding] = control;
            control.onclick = function onClickReset() {
                computer.onReset();
            };
            return true;

        /**
         * Technically, this binding should now be called "saveState", to clearly distinguish it from
         * the "Save Machine" control that's normally bound to the savePC() function in save.js.  Saving
         * an entire machine includes everything needed to start/restore the machine; eg, the machine
         * XML configuration file(s) *and* the JSON-encoded machine state.
         */
        case "save":
            /**
             * Since this feature depends on the server supporting the PCjs User API (see userapi.js),
             * and since pcjs.org is no longer running a Node web server, we disable the feature for that
             * particular host.
             */
            if (StrLib.endsWith(WebLib.getHostName(), "pcjs.org")) {
                if (DEBUG) this.printf(MESSAGE.LOG, "Remote user API not available\n");
                /**
                 * We could also simply hide the control; eg:
                 *
                 *      control.style.display = "none";
                 *
                 * but removing the control altogether seems better.
                 */
                control.parentNode.removeChild(/** @type {Node} */ (control));
                return false;
            }
            this.bindings[sBinding] = control;
            control.onclick = function onClickSave() {
                let sUserID = computer.queryUserID(true);
                if (sUserID) {
                    /**
                     * I modified the test to include a check for sStatePath so that I could save new states
                     * for machines with existing states; otherwise, I'd have no (easy) way of capturing and
                     * updating their state.  Making the machine (even temporarily) resumable would have been
                     * one work-around, but it's not appropriate for some machines, as their state is simply
                     * too large (for localStorage anyway, which is the default storage solution).
                     */
                    let fSave = !!(computer.resume && !computer.sResumePath || computer.sStatePath);
                    let sState = computer.powerOff(fSave);
                    if (fSave) {
                        computer.saveServerState(sUserID, sState);
                    } else {
                        computer.printf(MESSAGE.NOTICE, "Resume disabled, machine state not saved\n");
                    }
                }
                /**
                 * This seemed like a handy alternative, but it turned out to be a no-go, at least for large states:
                 *
                 *      let sState = computer.powerOff(true);
                 *      if (sState) {
                 *          sState = "data:text/json;charset=utf-8," + encodeURIComponent(sState);
                 *          globals.window.open(sState);
                 *      }
                 *
                 * Perhaps if I embedded the data in a link on the current page instead; eg:
                 *
                 *      $('<a href="' + sState + '" download="state.json">Download</a>').appendTo('#container');
                 */
            };
            return true;

        default:
            break;
        }
        return false;
    }

    /**
     * resetUserID()
     *
     * @this {Computer}
     */
    resetUserID()
    {
        WebLib.setLocalStorageItem(Computer.STATE_USERID, "");
        this.sUserID = null;
    }

    /**
     * queryUserID(fPrompt)
     *
     * @this {Computer}
     * @param {boolean} [fPrompt]
     * @returns {string|null|undefined}
     */
    queryUserID(fPrompt)
    {
        let sUserID = this.sUserID;
        if (!sUserID) {
            sUserID = WebLib.getLocalStorageItem(Computer.STATE_USERID);
            if (sUserID !== undefined) {
                if (!sUserID && fPrompt) {
                    /**
                     * NOTE: Warning the user here that "Save" operations are not currently supported by pcjs.org is
                     * merely a precaution, because ordinarily, setBinding() should have already determined if we are
                     * running from pcjs.org and disabled any "Save" button.
                     */
                    sUserID = Component.promptUser("Saving machine states on the pcjs.org server is currently unsupported.\n\nIf you're running your own server, enter your user ID below.");
                    if (sUserID) {
                        sUserID = this.verifyUserID(sUserID);
                        if (!sUserID) this.printf(MESSAGE.NOTICE, "The user ID is invalid.\n");
                    }
                }
            } else if (fPrompt) {
                this.printf(MESSAGE.NOTICE, "Browser local storage is not available\n");
            }
        }
        return sUserID;
    }

    /**
     * verifyUserID(sUserID)
     *
     * @this {Computer}
     * @param {string} sUserID
     * @returns {string} validated user ID, or null if error
     */
    verifyUserID(sUserID)
    {
        this.sUserID = null;
        if (DEBUG) this.printf("verifyUserID(%s)\n", sUserID);
        let sRequest = WebLib.getHostOrigin() + UserAPI.ENDPOINT + '?' + UserAPI.QUERY.REQ + '=' + UserAPI.REQ.VERIFY + '&' + UserAPI.QUERY.USER + '=' + sUserID;
        let response = WebLib.getResource(sRequest);
        let nErrorCode = response[0];
        let sResponse = response[1];
        if (!nErrorCode && sResponse) {
            try {
                response = eval("(" + sResponse + ")");
                if (response.code && response.code == UserAPI.CODE.OK) {
                    WebLib.setLocalStorageItem(Computer.STATE_USERID, response.data);
                    if (DEBUG) this.printf("%s updated: %s\n" + Computer.STATE_USERID, response.data);
                    this.sUserID = response.data;
                } else {
                    if (DEBUG) this.printf("%s: %s\n", response.code, response.data);
                }
            } catch(err) {
                Component.error(err.message + " (" + sResponse + ")");
            }
        } else {
            if (DEBUG) this.printf("invalid response (error %d)\n", nErrorCode);
        }
        return this.sUserID;
    }

    /**
     * getServerStatePath()
     *
     * @this {Computer}
     * @returns {string|null} sStatePath (null if no localStorage or no USERID stored in localStorage)
     */
    getServerStatePath()
    {
        let sStatePath = null;
        if (this.sUserID) {
            if (DEBUG) this.printf("%s for load: %s\n", Computer.STATE_USERID, this.sUserID);
            sStatePath = WebLib.getHostOrigin() + UserAPI.ENDPOINT + '?' + UserAPI.QUERY.REQ + '=' + UserAPI.REQ.LOAD + '&' + UserAPI.QUERY.USER + '=' + this.sUserID + '&' + UserAPI.QUERY.STATE + '=' + State.getKey(this, APPVERSION);
        } else {
            if (DEBUG) this.printf("%s unavailable\n", Computer.STATE_USERID);
        }
        return sStatePath;
    }

    /**
     * saveServerState(sUserID, sState)
     *
     * @this {Computer}
     * @param {string} sUserID
     * @param {string|null} sState
     */
    saveServerState(sUserID, sState)
    {
        /**
         * We must pass fSync == true, because (as I understand it) browsers will blow off any async
         * requests when a page is being closed.  Since our request is synchronous, storeServerState()
         * should also return a result, but there's not much we can do with it, since browsers ALSO
         * tend to blow off alerts() and the like when closing down.
         */
        if (sState) {
            if (DEBUG) this.printf("size of server state: %d bytes\n", sState.length);
            let response = this.storeServerState(sUserID, sState, true);
            if (response && response[UserAPI.RES.CODE] == UserAPI.CODE.OK) {
                this.printf(MESSAGE.NOTICE, "Machine state saved to server\n");
            } else if (sState) {
                let sError = (response && response[UserAPI.RES.DATA]) || UserAPI.FAIL.BADSTORE;
                if (response[UserAPI.RES.CODE] == UserAPI.CODE.FAIL) {
                    sError = "Error: " + sError;
                } else {
                    sError = "Error " + response[UserAPI.RES.CODE] + ": " + sError;
                }
                this.printf(MESSAGE.NOTICE, "%s\n", sError);
                this.resetUserID();
            }
        } else {
            if (DEBUG) this.printf("no state to store\n");
        }
    }

    /**
     * storeServerState(sUserID, sState, fSync)
     *
     * @this {Computer}
     * @param {string} sUserID
     * @param {string} sState
     * @param {boolean} [fSync] is true if we're powering down and should perform a synchronous request (default is async)
     * @returns {*} server response if fSync is true and a response was received; otherwise null
     */
    storeServerState(sUserID, sState, fSync)
    {
        if (DEBUG) this.printf("%s for store: %s\n", Computer.STATE_USERID, sUserID);
        /**
         * TODO: Determine whether or not any browsers cancel our request if we're called during a browser "shutdown" event,
         * and whether or not it matters if we do an async request (currently, we're not, to try to ensure the request goes through).
         */
        let dataPost = {};
        dataPost[UserAPI.QUERY.REQ] = UserAPI.REQ.STORE;
        dataPost[UserAPI.QUERY.USER] = sUserID;
        dataPost[UserAPI.QUERY.STATE] = State.getKey(this, APPVERSION);
        dataPost[UserAPI.QUERY.DATA] = sState;
        let sRequest = WebLib.getHostOrigin() + UserAPI.ENDPOINT;
        if (!fSync) {
            WebLib.getResource(sRequest, dataPost, true);
        } else {
            let response = WebLib.getResource(sRequest, dataPost);
            let sResponse = response[0];
            if (response[1]) {
                if (sResponse) {
                    let i = sResponse.indexOf('\n');
                    if (i > 0) sResponse = sResponse.substr(0, i);
                    if (!sResponse.indexOf("Error: ")) sResponse = sResponse.substr(7);
                }
                sResponse = '{"' + UserAPI.RES.CODE + '":' + response[1] + ',"' + UserAPI.RES.DATA + '":"' + sResponse + '"}';
            }
            if (DEBUG) this.printf("%s\n", sResponse);
            return JSON.parse(sResponse);
        }
        return null;
    }

    /**
     * onPower()
     *
     * This handles UI requests to toggle the computer's power (eg, see the "power" button binding).
     *
     * @this {Computer}
     */
    onPower()
    {
        if (!this.nPowerChange) {
            if (!this.flags.powered) {
                this.wait(this.powerOn);
            } else {
                this.powerOff(false, true);
            }
        }
    }

    /**
     * onReset()
     *
     * This handles UI requests to reset the computer's state (eg, see the "reset" button binding).
     *
     * @this {Computer}
     */
    onReset()
    {
        /**
         * I'm going to start with the presumption that it makes little sense for an "unpowered" computer to be "reset";
         * ditto if the power state is currently being changed.
         */
        if (!this.flags.powered || this.nPowerChange) return;

        /**
         * Whether or not we autoStart on reset should depend at least in part on whether we were running originally.
         */
        if (this.cpu) {
            this.cpu.flags.autoStart = this.cpu.flags.running;
        }
        /**
         * If this is a "resumable" machine (and it's not using a predefined state), then we overload the reset
         * operation to offer an explicit "save or discard" option first.  This is currently the only UI we offer to
         * discard a machine's state, including any disk changes.  The traditional "reset" operation is still available
         * for non-resumable machines.
         *
         * TODO: Break this behavior out into a separate "discard" operation, in case the designer of the machine really
         * wants to clutter the UI with confusing options. ;-)
         */
        if (this.resume && !this.sResumePath) {
            /**
             * I used to bypass the prompt if this.resume == Computer.RESUME_AUTO, setting fSave to true automatically,
             * but that gives the user no means of resetting a resumable machine that contains errors in its resume state.
             */
            let fSave = (/* this.resume == Computer.RESUME_AUTO || */ this.flags.unloading || !Component.confirmUser("Click OK to reset this machine and discard all disk modifications."));
            this.powerOff(fSave, true);
            /**
             * Forcing the page to reload is an expedient option, but ugly. It's preferable to call powerOn()
             * and rely on all the components to reset themselves to their default state.  The components with
             * the greatest burden here are FDC and HDC, which must rely on the fReload flag to determine whether
             * or not to unload/reload all their original auto-mounted disk images.
             *
             * However, if we started with a predefined state (ie, sStatePath is set), we take this shortcut, because
             * we don't (yet) have code in place to gracefully reload the initial state (requires calling getResource()
             * again); alternatively, we could avoid throwing that state away, but it seems better to save the memory.
             *
             * TODO: Make this more graceful, so that we can stop using the reloadPage() sledgehammer.
             */
            if (!fSave && this.sStatePath) {
                WebLib.reloadPage();
                return;
            }
            if (!fSave) this.fReload = true;
            this.powerOn(Computer.RESUME_NONE);
            this.fReload = false;
        } else {
            this.reset();
            if (this.cpu) this.cpu.autoStart();
        }
        this.updateFocus(true);
    }

    /**
     * getMachineComponent(sType, componentPrev)
     *
     * @this {Computer}
     * @param {string} sType
     * @param {Component|boolean|null} [componentPrev] of previously returned component, if any
     * @returns {Component|null}
     */
    getMachineComponent(sType, componentPrev = null)
    {
        let componentLast = componentPrev;
        let aComponents = Component.getComponents(this.id);
        for (let iComponent = 0; iComponent < aComponents.length; iComponent++) {
            let component = aComponents[iComponent];
            if (componentPrev) {
                if (componentPrev == component) componentPrev = null;
                continue;
            }
            if (component.type == sType) return component;
        }
        if (!componentLast && DEBUG && componentPrev !== false) {
            this.printf(MESSAGE.WARNING, "Machine component type \"%s\" not found\n", sType);
        }
        return null;
    }

    /**
     * updateFocus(fScroll)
     *
     * NOTE: When soft keyboard buttons call us to return focus to the machine (and away from the button),
     * the browser's default behavior is to scroll the element into view, which can be annoying, especially on iOS,
     * where the display is more constrained, so we no longer do it by default (fScroll must be true).
     *
     * @this {Computer}
     * @param {boolean} [fScroll] (true if you really want the control scrolled into view)
     */
    updateFocus(fScroll)
    {
        if (globals.browser && this.aVideo.length) {
            /**
             * This seems to be recommended work-around to prevent the browser from scrolling the focused element
             * into view.  The CPU is not a visual component, so when the CPU wants to set focus, the primary intent
             * is to ensure that keyboard input is fielded properly.
             */
            let x = 0;
            let y = 0;
            if (!fScroll) {
                x = globals.window.scrollX;
                y = globals.window.scrollY;
            }

            /**
             * TODO: We need a mechanism to determine the "active" display, instead of hard-coding this to aVideo[0].
             */
            this.aVideo[0].setFocus(fScroll);

            if (!fScroll && globals.window.scrollTo) {
                globals.window.scrollTo(x, y);
            }
        }
    }

    /**
     * updateStatus(fForce)
     *
     * If any DOM controls were bound to the CPU, then we need to call its updateStatus() handler; if there are no
     * such bindings, then cpu.updateStatus() does nothing.
     *
     * Similarly, if there's a Panel, then we need to call its updateStatus() handler, in case it created its own canvas
     * and implemented its own register display (eg, dumpRegisters()); if not, then panel.updateStatus() also does nothing.
     *
     * In practice, there will *either* be a Panel with a custom canvas *or* a set of DOM controls bound to the CPU *or*
     * neither.  In theory, there could be BOTH, but that would be unusual.
     *
     * TODO: Consider alternate approaches to these largely register-oriented display updates.  Ordinarily, we like to
     * separate logic from presentation, and currently the CPUx86 contains both, since it's the component that intimately
     * knows the names, number, sizes, etc, of all the active registers.  The Panel component is the logical candidate,
     * but Panel is an optional component; generally, only machines that include Debugger also include Panel.
     *
     * @this {Computer}
     * @param {boolean} [fForce] (true will display registers even if the CPU is running and "live" registers are not enabled)
      */
    updateStatus(fForce)
    {
        /**
         * fForce is generally set to true whenever the CPU is transitioning to/from a running state, in which case
         * cpu.updateStatus() will definitely want to hide/show register contents; however, at other times, when the
         * CPU is running, constantly updating the DOM controls too frequently can adversely impact overall performance.
         *
         * So fForce serves as a hint to help cpu.updateStatus() make a more informed decision.  panel.updateStatus()
         * currently doesn't care, on the theory that canvas updates should be significantly faster than DOM updates,
         * but we still pass fForce on.
         */
        if (this.cpu) this.cpu.updateStatus(fForce);
        if (this.panel) this.panel.updateStatus(fForce);
        /**
         * When called by our own timer for relatively infrequent DOM (see Computer.UPDATES_PER_SECOND), fForce is
         * explicitly set to false, and in those cases, we should avoid performing screen updates, because it may
         * subtly interfere with the Video component's normal refresh rate.
         */
        if (fForce !== undefined) {
            for (let i = 0; i < this.aVideo.length; i++) {
                this.aVideo[i].updateScreen(fForce);
            }
        }
    }

    /**
     * Computer.init()
     *
     * For every machine represented by an HTML element of class "pcx86-machine", this function
     * locates the HTML element of class "computer", extracting the JSON-encoded parameters for the
     * Computer constructor from the element's "data-value" attribute, invoking the constructor to
     * create a Computer component, and then binding any associated HTML controls to the new component.
     */
    static init()
    {
        let aeMachines = Component.getElementsByClass(APPCLASS, "machine");

        for (let iMachine = 0; iMachine < aeMachines.length; iMachine++) {

            let eMachine = aeMachines[iMachine];
            let parmsMachine = Component.getComponentParms(eMachine);

            let aeComputers = Component.getElementsByClass(APPCLASS, "computer", eMachine);

            for (let iComputer = 0; iComputer < aeComputers.length; iComputer++) {

                let eComputer = aeComputers[iComputer];
                let parmsComputer = Component.getComponentParms(eComputer);

                /**
                 * We set fSuspended in the Computer constructor because we want to "power up" the
                 * computer ourselves, after any/all bindings are in place.
                 */
                let computer = new Computer(parmsComputer, parmsMachine, true);

                if (DEBUG) computer.printf("onInit(%b)\n", computer.flags.powered);

                /**
                 * Bind any "power", "reset" and "save" buttons.  An "erase" button was also considered,
                 * but "reset" now provides a way to force the machine to start from scratch again, so "erase"
                 * may be redundant now.
                 */
                Component.bindComponentControls(computer, eComputer, APPCLASS);

                /**
                 * Power on the computer, giving every component the opportunity to reset or restore itself.
                 */
                if (computer.fAutoPower) computer.wait(computer.powerOn);
            }
        }
    }

    /**
     * Computer.show()
     *
     * When exit() is using an "onbeforeunload" handler, this "onpageshow" handler allows us to repower everything,
     * without either resetting or restoring.  We call powerOn() with a special resume value (RESUME_REPOWER) if the
     * computer is already marked as "ready", meaning the browser didn't change anything.  This "repower" process
     * should be very quick, essentially just marking all components as powered again (so that, for example, the Video
     * component will start drawing again) and firing the CPU up again.
     */
    static show()
    {
        let aeComputers = Component.getElementsByClass(APPCLASS, "computer");
        for (let iComputer = 0; iComputer < aeComputers.length; iComputer++) {
            let eComputer = aeComputers[iComputer];
            let parmsComputer = Component.getComponentParms(eComputer);
            let computer = /** @type {Computer} */ (Component.getComponentByType("Computer", parmsComputer['id']));
            if (computer) {

                /**
                 * Clear new flag that Component functions (eg, notice()) should check before alerting the user.
                 */
                computer.flags.unloading = false;

                if (DEBUG) computer.printf("onShow(%b,%b)\n", computer.flags.initDone, computer.flags.powered);

                if (computer.flags.initDone && !computer.flags.powered) {
                    /**
                     * Repower the computer, notifying every component to continue running as-is.
                     */
                    computer.powerOn(Computer.RESUME_REPOWER);
                }
            }
        }
    }

    /**
     * Computer.exit()
     *
     * The Computer is currently the only component that uses an "exit" handler, which WebLib.onExit() defines as
     * either an "unload" or "onbeforeunload" handler.  This gives us the opportunity to save the machine state,
     * using our powerOff() function, before the page goes away.
     *
     * It's worth noting that "onbeforeunload" offers one nice feature when used instead of "onload": the entire
     * page (and therefore this entire application) is retained in its current state by the browser (well, some
     * browsers), so that if you go to a new URL, either by entering a new URL in the same window/tab, or by pressing
     * the FORWARD button, and then you press the BACK button, the page is immediately restored to its previous state.
     *
     * In fact, that's how some browsers operate whether you have an "onbeforeunload" handler or not; in other words,
     * an "onbeforeunload" handler doesn't change the page retention behavior of the browser.  By contrast, the mere
     * presence of an "onunload" handler generally causes a browser to throw the page away once the handler returns.
     *
     * However, in order to safely use "onbeforeunload", we must add yet another handler ("onpageshow") to repower
     * everything, without either resetting or restoring.  Hence, the Computer.show() function, which calls powerOn()
     * with a special resume value (RESUME_REPOWER) if the computer is already marked as "ready", meaning the browser
     * didn't change anything.  This "repower" process should be very quick, essentially just marking all components as
     * powered again (so that, for example, the Video component will start drawing again) and firing the CPU up again.
     *
     * Reportedly, some browsers (eg, Opera) don't support "onbeforeunload", in which case Component will have to use
     * "unload" instead.  But even when the page must be rebuilt from scratch, the combination of browser cache and
     * localStorage means the simulation should be restored and become operational almost immediately.
     */
    static exit()
    {
        let aeComputers = Component.getElementsByClass(APPCLASS, "computer");
        for (let iComputer = 0; iComputer < aeComputers.length; iComputer++) {
            let eComputer = aeComputers[iComputer];
            let parmsComputer = Component.getComponentParms(eComputer);
            let computer = /** @type {Computer} */ (Component.getComponentByType("Computer", parmsComputer['id']));
            if (computer) {

                /**
                 * Set new flag that Component functions (eg, notice()) should check before alerting the user.
                 */
                computer.flags.unloading = true;

                if (DEBUG) computer.printf("onExit(%b)\n", computer.flags.powered);

                if (computer.flags.powered) {
                    /**
                     * Power off the computer, giving every component an opportunity to save its state,
                     * but only if 'resume' has been set AND there is no valid resume path (because if a valid resume
                     * path exists, we'll always load our state from there, and not from whatever we save here).
                     */
                    computer.powerOff(!!(computer.resume && !computer.sResumePath), true);
                }
            }
        }
    }
}

/**
 * Initialize every Computer on the page.
 */
WebLib.onInit(Computer.init);
WebLib.onShow(Computer.show);
WebLib.onExit(Computer.exit);

/**
 * @copyright https://www.pcjs.org/machines/modules/v2/state.js (C) 2012-2024 Jeff Parsons
 */

/**
 * @class State
 * @unrestricted
 */
class State {
    /**
     * State(component, sVersion, sSuffix)
     *
     * State objects are used by components to save/restore their state.
     *
     * During a save operation, components add data to a State object via set(), and then return
     * the resulting data using data().
     *
     * During a restore operation, the Computer component passes the results of each data() call
     * back to the originating component.
     *
     * WARNING: Since State objects are low-level objects that have no UI requirements, they do not
     * inherit from the Component class, so you should only use class methods of Component, such as
     * Component.assert() (or Debugger methods if the Debugger is available).
     *
     * NOTE: 1.01 is the first version to provide limited save/restore support using localStorage.
     * From that point on, care must be taken to insure that any new version that's incompatible with
     * previous localStorage data be released with a version number that is at least 1 greater,
     * since we're tagging the localStorage data with the integer portion of the version string.
     *
     * @param {Component} component
     * @param {string} [sVersion] is used to append a major version number to the key
     * @param {string} [sSuffix] is used to append any additional suffixes to the key
     */
    constructor(component, sVersion, sSuffix)
    {
        this.id = component.id;
        this.dbg = component.dbg;
        this.json = "";
        this.state = {};
        this.fLoaded = this.fParsed = false;
        this.key = State.getKey(component, sVersion, sSuffix);
        this.unload(component.parms);
    }

    /**
     * set(id, data)
     *
     * @this {State}
     * @param {number|string} id
     * @param {Object|string} data
     */
    set(id, data)
    {
        try {
            this.state[id] = data;
        } catch(e) {
            Component.printf(MESSAGE.ERROR, e.message);
        }
    }

    /**
     * get(id)
     *
     * @this {State}
     * @param {number|string} id
     * @returns {Object|string|null}
     */
    get(id)
    {
        return this.state[id] || null;
    }

    /**
     * data()
     *
     * @this {State}
     * @returns {Object}
     */
    data()
    {
        return this.state;
    }

    /**
     * load(json)
     *
     * WARNING: Make sure you follow this call with either a call to parse() or unload(),
     * because any stringified data that we've loaded isn't usable until it's been parsed.
     *
     * @this {State}
     * @param {string|null} [json]
     * @returns {boolean} true if state exists in localStorage, false if not
     */
    load(json)
    {
        if (json) {
            this.json = json;
            this.fLoaded = true;
            this.fParsed = false;
            return true;
        }
        if (this.fLoaded) {
            /*
             * This is assumed to be a redundant load().
             */
            return true;
        }
        if (WebLib.hasLocalStorage()) {
            let s = WebLib.getLocalStorageItem(this.key);
            if (s) {
                this.json = s;
                this.fLoaded = true;
                Component.printf(MESSAGE.DEBUG, "localStorage(%s): %d bytes loaded\n", this.key, s.length);
                return true;
            }
        }
        return false;
    }

    /**
     * parse()
     *
     * This completes the load() operation, by parsing what was loaded, on the assumption there
     * might be some benefit to deferring parsing until we've given the user a chance to confirm.
     * Otherwise, load() could have just as easily done this, too.
     *
     * @this {State}
     * @returns {boolean} true if successful, false if error
     */
    parse()
    {
        let fSuccess = true;
        if (!this.fParsed) {
            try {
                this.state = JSON.parse(this.json);
                this.fParsed = true;
            } catch (e) {
                Component.error(e.message || e);
                fSuccess = false;
            }
        }
        return fSuccess;
    }

    /**
     * store()
     *
     * @this {State}
     * @returns {boolean} true if successful, false if error
     */
    store()
    {
        let fSuccess = true;
        if (WebLib.hasLocalStorage()) {
            let s = JSON.stringify(this.state);
            if (WebLib.setLocalStorageItem(this.key, s)) {
                Component.printf(MESSAGE.DEBUG, "localStorage(%s): %d bytes stored\n", this.key, s.length);
            } else {
                /*
                 * WARNING: Because browsers tend to disable all alerts() during an "unload" operation,
                 * it's unlikely anyone will ever see the "quota" errors that occur at this point.  Need to
                 * think of some way to notify the user that there's a problem, and offer a way of cleaning
                 * up old states.
                 */
                Component.printf(MESSAGE.ERROR, "Unable to store %d bytes in browser local storage\n", s.length);
                fSuccess = false;
            }
        }
        return fSuccess;
    }

    /**
     * toString()
     *
     * @this {State}
     * @returns {string} JSON-encoded state
     */
    toString()
    {
        return this.state? JSON.stringify(this.state) : this.json;
    }

    /**
     * unload(parms)
     *
     * This discards any data saved via set() or loaded via load(), creating an empty State object.
     * Note that you have to follow this call with an explicit call to store() if you want to remove
     * the state from localStorage as well.
     *
     * @this {State}
     * @param {Object} [parms]
     */
    unload(parms)
    {
        this.json = "";
        this.state = {};
        this.fLoaded = this.fParsed = false;
        if (parms) this.set("parms", parms);
    }

    /**
     * clear(fAll)
     *
     * This unloads the current state, and then clears ALL localStorage for the current machine,
     * independent of version, to reduce the chance of orphaned states wasting part of our limited allocation.
     *
     * @this {State}
     * @param {boolean} [fAll] true to unconditionally clear ALL localStorage for the current domain
     */
    clear(fAll)
    {
        this.unload();
        let aKeys = WebLib.getLocalStorageKeys();
        for (let i = 0; i < aKeys.length; i++) {
            let sKey = aKeys[i];
            if (sKey && (fAll || sKey.substr(0, this.key.length) == this.key)) {
                WebLib.removeLocalStorageItem(sKey);
                Component.printf(MESSAGE.DEBUG, "localStorage(%s) removed\n", sKey);
                aKeys.splice(i, 1);
                i = 0;
            }
        }
    }

    /**
     * State.getKey(component, sVersion, sSuffix)
     *
     * This encapsulates the key generation code.
     *
     * @param {Component} component
     * @param {string} [sVersion] is used to append a major version number to the key
     * @param {string} [sSuffix] is used to append any additional suffixes to the key
     * @returns {string} key
     */
    static getKey(component, sVersion, sSuffix)
    {
        let key = component.id;
        if (sVersion) {
            let i = sVersion.indexOf('.');
            if (i > 0) key += ".v" + sVersion.substr(0, i);
        }
        if (sSuffix) {
            key += "." + sSuffix;
        }
        return key;
    }

    /**
     * State.compress(aSrc)
     *
     * @param {Array.<number>|null} aSrc
     * @returns {Array.<number>|null} is either the original array (aSrc), or a smaller array of "count, value" pairs (aComp)
     */
    static compress(aSrc)
    {
        if (aSrc) {
            let iSrc = 0;
            let iComp = 0;
            let aComp = [];
            while (iSrc < aSrc.length) {
                let n = aSrc[iSrc];

                let iCompare = iSrc + 1;
                while (iCompare < aSrc.length && aSrc[iCompare] === n) iCompare++;
                aComp[iComp++] = iCompare - iSrc;
                aComp[iComp++] = n;
                iSrc = iCompare;
            }
            if (aComp.length < aSrc.length) return aComp;
        }
        return aSrc;
    }

    /**
     * State.decompress(aComp)
     *
     * @param {Array.<number>} aComp
     * @param {number} [nLength] (expected length of decompressed data)
     * @returns {Array.<number>}
     */
    static decompress(aComp, nLength)
    {
        let iDst = 0;
        let aDst = nLength? new Array(nLength) : [];
        let iComp = 0;
        while (iComp < aComp.length - 1) {
            let c = aComp[iComp++];
            let n = aComp[iComp++];
            while (c--) aDst[iDst++] = n;
        }

        return aDst;
    }

    /**
     * State.compressEvenOdd(aSrc)
     *
     * This is a very simple variation on compress() that compresses all the EVEN elements of aSrc first,
     * followed by all the ODD elements.  This tends to work better on EGA video memory, because when odd/even
     * addressing is enabled (eg, for text modes), the DWORD values tend to alternate, which is the worst case
     * for compress(), but the best case for compressEvenOdd().
     *
     * One wrinkle we support: if the first element is uninitialized, then we assume the entire array is undefined,
     * and return an empty compressed array.  Conversely, decompressEvenOdd() will take an empty compressed array
     * and return an uninitialized array.
     *
     * @param {Array.<number>|null} aSrc
     * @returns {Array.<number>|null} is either the original array (aSrc), or a smaller array of "count, value" pairs (aComp)
     */
    static compressEvenOdd(aSrc)
    {
        if (aSrc) {
            let iComp = 0, aComp = [];
            if (aSrc[0] !== undefined) {
                for (let off = 0; off < 2; off++) {
                    let iSrc = off;
                    while (iSrc < aSrc.length) {
                        let n = aSrc[iSrc];
                        let iCompare = iSrc + 2;
                        while (iCompare < aSrc.length && aSrc[iCompare] === n) iCompare += 2;
                        aComp[iComp++] = (iCompare - iSrc) >> 1;
                        aComp[iComp++] = n;
                        iSrc = iCompare;
                    }
                }
            }
            if (aComp.length < aSrc.length) return aComp;
        }
        return aSrc;
    }

    /**
     * State.decompressEvenOdd(aComp, nLength)
     *
     * This is the counterpart to compressEvenOdd().  Note that because there's nothing in the compressed sequence
     * that differentiates a compress() sequence from a compressEvenOdd() sequence, you simply have to be consistent:
     * if you used even/odd compression, then you must use even/odd decompression.
     *
     * @param {Array.<number>} aComp
     * @param {number} nLength is expected length of decompressed data
     * @returns {Array.<number>}
     */
    static decompressEvenOdd(aComp, nLength)
    {
        let iDst = 0;
        let aDst = new Array(nLength);
        let iComp = 0;
        while (iComp < aComp.length - 1) {
            let c = aComp[iComp++];
            let n = aComp[iComp++];
            while (c--) {
                aDst[iDst] = n;
                iDst += 2;
            }
            /*
             * The output of a "count,value" pair will never exceed the end of the output array, so as soon as we reach it
             * the first time, we know it's time to switch to ODD elements, and as soon as we reach it again, we should be
             * done.
             */

            if (iDst == nLength) iDst = 1;
        }

        return aDst;
    }
}

/**
 * @copyright https://www.pcjs.org/machines/modules/v2/embed.js (C) 2012-2024 Jeff Parsons
 */

/*
 * We now support asynchronous XML and XSL file loads; simply set fAsync (below) to true.
 *
 * NOTE: For that support to work, we have to keep track of the number of machines on the page
 * (ie, how many embedMachine() calls were issued), reduce the count as each machine XML file
 * is fully transformed into HTML, and when the count finally returns to zero, notify all the
 * machine component init() handlers.
 *
 * Also, to prevent those init() handlers from running prematurely, we must disable all page
 * notification events at the start of the embedding process (WebLib.enablePageEvents(false)) and
 * re-enable them at the end (WebLib.enablePageEvents(true)).
 */
var fAsync = true;
var cAsyncMachines = 0;

/**
 * loadXML(sFile, idMachine, sAppName, sAppClass, sParms, sClass, fResolve, display, done)
 *
 * This is the preferred way to load all XML and XSL files. It uses getResource()
 * to load them as strings, which parseXML() can massage before parsing/transforming them.
 *
 * For example, since I've been unable to get the XSLT document() function to work inside any
 * XSL document loaded by JavaScript's XSLT processor, that has prevented me from dynamically
 * loading any XML machine file that uses the "ref" attribute to refer to and incorporate
 * another XML document.
 *
 * To solve that, I've added an fResolve parameter that tells parseXML() to fetch any
 * referenced documents ITSELF and insert them into the XML string prior to parsing, instead
 * of relying on the XSLT template to pull them in.  That fetching is handled by resolveXML(),
 * which iterates over the XML until all "refs" have been resolved (including any nested
 * references).
 *
 * Also, XSL files with a <!DOCTYPE [...]> cause MSIE's Microsoft.XMLDOM.loadXML() function
 * to choke, so I strip that out prior to parsing as well.
 *
 * TODO: Figure out why the XSLT document() function works great when the web browser loads an
 * XML file (and the associated XSL file) itself, but does not work when loading documents via
 * JavaScript XSLT support. Is it broken, is it a security issue, or am I just calling it wrong?
 *
 * @param {string} sXMLFile
 * @param {string} idMachine
 * @param {string} sAppName
 * @param {string} sAppClass
 * @param {string} sParms (machine parameters, if any)
 * @param {string} sClass (an optional machine class name used to style the machine)
 * @param {boolean} fResolve is true to resolve any "ref" attributes
 * @param {function(string)} display
 * @param {function(string,string,Object)} done (string contains the unparsed XML string data, and Object contains a parsed XML object)
 */
function loadXML(sXMLFile, idMachine, sAppName, sAppClass, sParms, sClass, fResolve, display, done)
{
    let doneLoadXML = function(sURL, sXML, nErrorCode) {
        if (nErrorCode) {
            if (!sXML) sXML = "unable to load " + sXMLFile + " (" + nErrorCode + ")";
            done(sURL, sXML, null);
            return;
        }
        parseXML(sXML, sXMLFile, idMachine, sAppName, sAppClass, sParms, sClass, fResolve, display, done);
    };
    display("Loading " + sXMLFile + "...");
    WebLib.getResource(sXMLFile, null, fAsync, doneLoadXML);
}

/**
 * parseXML(sXML, sXMLFile, idMachine, sAppName, sAppClass, sParms, sClass, fResolve, display, done)
 *
 * Generates an XML document from an XML string. This function also provides a work-around for XSLT's
 * lack of support for the document() function (at least on some browsers), by replacing every reference
 * tag (ie, a tag with a "ref" attribute) with the contents of the referenced file.
 *
 * @param {string} sXML
 * @param {string} sXMLFile
 * @param {string} idMachine
 * @param {string} sAppName
 * @param {string} sAppClass
 * @param {string} sParms (machine parameters, if any)
 * @param {string} sClass (an optional machine class name used to style the machine)
 * @param {boolean} fResolve is true to resolve any "ref" attributes; default is false
 * @param {function(string)} display
 * @param {function(string,string,Object)} done (string contains the unparsed XML string data, and Object contains a parsed XML object)
 */
function parseXML(sXML, sXMLFile, idMachine, sAppName, sAppClass, sParms, sClass, fResolve, display, done)
{
    let buildXML = function(sURL, sXML, sError) {
        if (sError) {
            done(sURL, sError, null);
            return;
        }
        if (idMachine) {

            /*
             * A more sensible place to record the machine XML would be embedMachine(), like we do for the
             * XSL file, but since we're about to modify the original machine XML, it's best to record it now.
             */
            Component.addMachineResource(idMachine, sXMLFile, sXML);

            let match;
            let sURL = sXMLFile;
            if (sURL && sURL.indexOf('/') < 0 && window.location.pathname.slice(-1) == '/') {
                sURL = window.location.pathname + sURL;
            }

            /*
             * We embed the URL of the XML file both as a separate "xml" attribute for easy access from the
             * XSL file, and as part of the "parms" attribute for easy access from machines (see getMachineParm()).
             */
            if (!sParms) {
                sParms = '{';
            } else if (sParms.slice(-1) == '}') {
                sParms = sParms.slice(0, -1);
                if (sParms.length > 1) sParms += ',';
            } else {            // sParms must just be a "state" file, so encode it as a "state" property
                sParms = '{state:"' + sParms + '",';
            }
            sParms += 'url:"' + sURL + '"}';

            /*
             * Note that while we no longer generate a machine XML file with a "state" attribute (because it's
             * encoded inside the "parms" attribute), the XSL file must still cope with "state" attributes inside
             * other XML files; for example, manifest XML files like /apps/pcx86/1981/visicalc/manifest.xml contain
             * machine elements with "state" attributes that must still be passed down to the computer element
             * "the old fashioned way".
             *
             * Until/unless that changes, components.xsl cannot be simplified as much as I might have hoped.
             */
            if (typeof resources == 'object') sURL = null;      // turn off URL inclusion if we have embedded resources
            sParms = sParms.replace(/\$/g, "$$$$").replace(/'/g, "&apos;");
            if (sClass) {
                /*
                 * If there's no hard-coded "class" attribute in the machine tag, then we can set one in the final
                 * replacement below, just like we do for sParms and sURL.  However, if a "class" attribute already
                 * exists, we need alter it and then zap the sClass variable.
                 */
                match = sXML.match(/(<machine[^>]*\sclass=)(['"])(.*?)(\2[^>]*>)/);
                if (match) {
                    sXML = sXML.replace(match[0], match[1] + match[2] + sClass + match[4]);
                    sClass = "";
                }
            }

            /*
             * If the machine element contains a 'debugger' attribute set to 'available', we change it to 'optional',
             * which signals the XSL template to generate a "soft link" to the debugger (using a URL parameter), rather
             * than a "hard link" to the debugger XML file.
             */
            match = sXML.match(/(<machine[^>]*\sdebugger=)(['"])(available)(\2[^>]*>)/);
            if (match) {
                sXML = sXML.replace(match[0], match[1] + match[2] + "optional" + match[4]);
            }

            sXML = sXML.replace(/(<machine[^>]*\sid=)(['"]).*?\2/, "$1$2" + idMachine + "$2" + (sClass? ' class="' + sClass + '"' : '') + (sParms? " parms='" + sParms + "'" : "") + (sURL? ' url="' + sURL + '"' : ''));
        }

        if (!fResolve) {
            /*
             * I'm trying to switch to a shared components.xsl (at least for all PC-class machines),
             * but in the interim, that means hacking the XSL file on the fly to reflect the actual class.
             */
            sXML = sXML.replace(/(<xsl:variable name="APPNAME">).*?(<\/xsl:variable>)/, "$1" + sAppName + "$2");
            sXML = sXML.replace(/(<xsl:variable name="APPCLASS">).*?(<\/xsl:variable>)/, "$1" + sAppClass + "$2");

            /*
             * Replace the version number template in the XSL file (which we assume we're reading, since fResolve is false)
             * with the current APPVERSION.
             *
             * ES6 ALERT: Template strings.
             */
            sXML = sXML.replace(/<xsl:variable name="APPVERSION"(\/>|>[^<]*<\/xsl:variable>)/, `<xsl:variable name="APPVERSION">${APPVERSION}</xsl:variable>`);
        }

        /*
         * If the resource we requested is not really an XML file (or the file didn't exist and the server simply returned
         * a message like "Cannot GET /devices/pc/machine/5150/cga/64kb/donkey/machine.xml"), we'd like to display a more
         * meaningful message, because the XML DOM parsers will blithely return a document that contains nothing useful; eg:
         *
         *      This page contains the following errors:error on line 1 at column 1:
         *      Document is empty Below is a rendering of the page up to the first error.
         *
         * Supposedly, the IE XML DOM parser will throw an exception, but I haven't tested that, and unless all other
         * browsers do that, that's not helpful.
         *
         * The best I can do at this stage (assuming WebLib.getResource() didn't drop any error information on the floor)
         * is verify that the requested resource "looks like" valid XML (in other words, it begins with a '<').
         */
        let xmlDoc = null;
        if (sXML.charAt(0) == '<') {
            try {
                /*
                 * Another hack for MSIE, which fails to load XSL documents containing a <!DOCTYPE [...]> tag.
                 *
                 * This is also why the XSLTProcessor 'transformToFragment' method in Microsoft Edge silently failed,
                 * so I had pull this hack out of the "ActiveXObject" code.  And rather than add yet-another Microsoft
                 * browser check, I'm going to try doing this across the board, and hope that none of the other XSLT
                 * processors fail *without* the DOCTYPE tag.
                 */
                if (!fResolve) {
                    sXML = sXML.replace(/<!DOCTYPE(.|[\r\n])*]>\s*/g, "");
                }
                /*
                 * Beginning with Microsoft Edge and the corresponding release of Windows 10, all the
                 * 'ActiveXObject' crud has gone away; but of course, this code must remain in place if
                 * we want to continue supporting older Internet Explorer browsers (ie, back to IE9).
                 */
                /** @namespace window.ActiveXObject */
                if (window.ActiveXObject || 'ActiveXObject' in window) {        // second test is required for IE11 on Windows 8.1
                    xmlDoc = new window.ActiveXObject("Microsoft.XMLDOM");
                    xmlDoc.async = false;
                    xmlDoc['loadXML'](sXML);
                } else {
                    /** @namespace window.DOMParser */
                    xmlDoc = (new window.DOMParser()).parseFromString(sXML, "text/xml");
                }
            } catch(e) {
                xmlDoc = null;
                sXML = e.message;
            }
        } else {
            sXML = "unrecognized XML: " + (sXML.length > 255? sXML.substr(0, 255) + "..." : sXML);
        }
        done(sXMLFile, sXML, xmlDoc);
    };
    if (sXML) {
        if (PRIVATE) sXML = sXML.replace(/\/library.xml/, "/disks/private/library.xml");
        if (fResolve) {
            resolveXML(sXMLFile, sXML, display, buildXML);
            return;
        }
        buildXML(sXMLFile, sXML, "");
        return;
    }
    done(sXMLFile, "no data", null);
}

/**
 * resolveXML(sURL, sXML, display, done)
 *
 * Replaces every tag with a "ref" attribute with the contents of the corresponding file.
 *
 * TODO: Fix some of the limitations of this code, such as: 1) requiring the "ref" attribute
 * to appear as the tag's first attribute, 2) requiring the "ref" attribute to be double-quoted,
 * and 3) requiring the "ref" tag to be self-closing.
 *
 * @param {string} sURL
 * @param {string} sXML
 * @param {function(string)} display
 * @param {function(string,string,string)} done (the first string contains the resolved XML data, the second is for any error message)
 */
function resolveXML(sURL, sXML, display, done)
{
    let matchRef;
    let reRef = /<([a-z]+)\s+ref="(.*?)"(.*?)\/>/g;

    if ((matchRef = reRef.exec(sXML))) {

        let sRefFile = matchRef[2];

        let doneReadXML = function(sURL, sXMLRef, nErrorCode) {
            if (nErrorCode || !sXMLRef) {
                done(sURL, sXML, "unable to resolve XML reference: " + matchRef[0] + " (" + nErrorCode + ")");
                return;
            }
            /*
             * If there are additional attributes in the "referring" XML tag, we want to insert them
             * into the "referred" XML tag; attributes that don't exist in the referred tag should be
             * appended, and attributes that DO exist should be overwritten.
             */
            let sRefAttrs = matchRef[3];
            if (sRefAttrs) {
                let aXMLRefTag = sXMLRef.match(new RegExp("<" + matchRef[1] + "[^>]*>"));
                if (aXMLRefTag) {
                    let sXMLNewTag = aXMLRefTag[0];
                    /*
                     * Iterate over all the attributes in the "referring" XML tag (sRefAttrs)
                     */
                    let matchAttr;
                    let reAttr = /( [a-z]+=)(['"])(.*?)\2/gi;
                    while ((matchAttr = reAttr.exec(sRefAttrs))) {
                        if (sXMLNewTag.toLowerCase().indexOf(matchAttr[1].toLowerCase()) < 0) {
                            /*
                             * This is the append case....
                             */
                            sXMLNewTag = sXMLNewTag.replace(">", matchAttr[0] + ">");
                        } else {
                            /*
                             * This is the overwrite case....
                             */
                            sXMLNewTag = sXMLNewTag.replace(new RegExp(matchAttr[1] + "(['\"])(.*?)\\1"), matchAttr[0]);
                        }
                    }
                    if (aXMLRefTag[0] != sXMLNewTag) {
                        sXMLRef = sXMLRef.replace(aXMLRefTag[0], sXMLNewTag);
                    }
                } else {
                    done(sURL, sXML, "missing <" + matchRef[1] + "> in " + sRefFile);
                    return;
                }
            }

            /*
             * Apparently when a Windows Azure server delivers one of my XML files, it may modify the first line:
             *
             *      <?xml version="1.0" encoding="UTF-8"?>\n
             *
             * I didn't determine exactly what it was doing at this point (probably just changing the \n to \r\n),
             * but in any case, relaxing the following replace() solved it.
             */
            sXMLRef = sXMLRef.replace(/<\?xml[^>]*>[\r\n]*/, "");

            sXML = sXML.replace(matchRef[0], sXMLRef);

            resolveXML(sURL, sXML, display, done);
        };

        display("Loading " + sRefFile + "...");
        WebLib.getResource(sRefFile, null, fAsync, doneReadXML);
        return;
    }
    done(sURL, sXML, "");
}

/**
 * embedMachine(sAppName, sAppClass, idMachine, sXMLFile, sXSLFile, sParms, sClass)
 *
 * This allows to you embed a machine on a web page, by transforming the machine XML into HTML.
 *
 * @param {string} sAppName is the app name (eg, "PCx86")
 * @param {string} sAppClass is the app class (eg, "pcx86"); also known as the machine class
 * @param {string} idMachine
 * @param {string} [sXMLFile]
 * @param {string} [sXSLFile]
 * @param {string} [sParms] (machine parameters, if any)
 * @param {string} [sClass] (an optional machine class name used to style the machine)
 * @returns {boolean} true if successful, false if error
 */
function embedMachine(sAppName, sAppClass, idMachine, sXMLFile, sXSLFile, sParms, sClass)
{
    let eMachine, eWarning, fSuccess = true;

    cAsyncMachines++;
    Component.addMachine(idMachine);

    let doneMachine = function() {

        if (!--cAsyncMachines) {
            if (fAsync) WebLib.enablePageEvents(true);
        }
    };

    if (!sXMLFile) {
        /*
         * For a machine whose layout is now pre-built based on a JSON config file, the method of passing any machine "parms" to
         * the machine via a "parms" attribute of the XML <machine> tag no longer works, so we must also stash them as a property
         * of the machine's resource object.
         *
         * An alternative approach would be to change the machine HTML template file to build the parms directly into the machine
         * layout, but this is more expedient.
         */
        if (sParms) {
            Component.addMachineResource(idMachine, "parms", sParms);
        }
        /*
         * We used to replace a missing XML configuration file with a default path, but since we now support JSON-based configs,
         * that had to change.
         *
         *      sXMLFile = "machine.xml";
         *      if (!sXSLFile) sXSLFile = "components.xsl";
         */
        doneMachine();
        return fSuccess;
    }

    if (WebLib.getURLParm('debugger') == "true" && sXMLFile.indexOf("/debugger") < 0) {
        sXMLFile = sXMLFile.replace("/machine.xml", "/debugger/machine.xml");
    }

    let displayError = function(sURL, sError) {
        if (typeof sError == "string") {
            if (sError.indexOf("<!DOCTYPE html>") >= 0) {
                let match = sError.match(/<title>(?:PCjs: |)(.*?)<\/title>/);
                if (match) sError = match[1];
            }
        }
        Component.printf(MESSAGE.ERROR, "%s\n", sError);
        displayMessage("Error: " + sError + (sURL? " (" + sURL + ")" : ""));
        if (fSuccess) doneMachine();
        fSuccess = false;
    };

    let displayMessage = function(sMessage) {
        if (eWarning === undefined) {
            /*
             * Our MarkOut module (in convertMDMachineLinks()) creates machine containers that look like:
             *
             *      <div id="' + sMachineID + '" class="machine-placeholder"><p>Embedded PC</p><p class="machine-warning">...</p></div>
             *
             * with the "machine-warning" paragraph pre-populated with a warning message that the user will
             * see if nothing at all happens.  But hopefully, in the normal case (and especially the error case),
             * *something* will have happened.
             *
             * Note that it is the HTMLOut module (in processMachines()) that ultimately decides which scripts to
             * include and then generates the embedXXX() call.
             */
            let aeWarning = (eMachine && Component.getElementsByClass("machine-warning", "", eMachine));
            eWarning = (aeWarning && aeWarning[0]) || eMachine;
        }
        if (eWarning) eWarning.innerHTML = StrLib.escapeHTML(sMessage);
    };

    try {
        eMachine = document.getElementById(idMachine);
        if (eMachine) {

            /*
             * If we have a 'css' resource, add it to the page first.
             */
            let css;
            let resources = globals.window['resources'];
            if (typeof resources == "object" && (css = resources['css'])) {
                let head = document.head || document.getElementsByTagName('head')[0];
                let style = document.createElement('style');
                style.type = 'text/css';
                // noinspection JSDeprecatedSymbols
                if (style.styleSheet) {
                    // noinspection JSDeprecatedSymbols
                    style.styleSheet.cssText = css;
                } else {
                    style.appendChild(document.createTextNode(css));
                }
                head.appendChild(style);
            }

            if (!sXSLFile) {
                /*
                 * Now that PCjs is an open-source project, we can make the following test more flexible,
                 * and revert to the internal template if DEBUG *or* internal version (instead of *and*).
                 *
                 * Third-party sites that don't use the PCjs server will ALWAYS want to specify a fully-qualified
                 * path to the XSL file, unless they choose to mirror our folder structure.
                 */
                sXSLFile = "/machines/" + sAppClass + "/xsl/components.xsl";
            }

            /*
             * If sAppClass specified a folder (eg, "osi/c1p"), that was required for the location of the XSL file,
             * but now all we want is the final folder name (eg, "c1p") for any XSL "APPCLASS" variable replacement.
             */
            sAppClass = sAppClass.split('/').pop();

            let processXML = function(sURL, sXML, xml) {
                if (!xml) {
                    displayError(sURL, sXML);
                    return;
                }

                let transformXML = function(sURL, sXSL, xsl) {
                    if (!xsl) {
                        displayError(sURL, sXSL);
                        return;
                    }

                    /*
                     * Record the XSL file, in case someone wants to save the entire machine later.
                     *
                     * NOTE: sXSLFile will never be undefined by this point, but apparently the Closure Compiler doesn't realize that.
                     */
                    Component.addMachineResource(idMachine, sXSLFile || "", sXSL);

                    /*
                     * The <machine> template in components.xsl now generates a "machine div" that makes
                     * the div we required the caller of embedMachine() to provide redundant, so instead
                     * of appending this fragment to the caller's node, we REPLACE the caller's node.
                     * This works only because because we ALSO inject the caller's "machine div" ID into
                     * the fragment's ID during parseXML().
                     *
                     *      eMachine.innerHTML = sFragment;
                     *
                     * Also, if the transform function fails, make sure you're using the appropriate
                     * "components.xsl" and not a "machine.xsl", because the latter will not produce valid
                     * embeddable HTML (and is the most common cause of failure at this final stage).
                     */
                    displayMessage("Processing " + sXMLFile + "...");

                    /*
                     * Beginning with Microsoft Edge and the corresponding release of Windows 10, all the
                     * 'ActiveXObject' crud has gone away; but of course, this code must remain in place if
                     * we want to continue supporting older Internet Explorer browsers (ie, back to IE9).
                     */
                    if (window.ActiveXObject || 'ActiveXObject' in window) {        // second test is required for IE11 on Windows 8.1
                        let sFragment = xml['transformNode'](xsl);
                        if (sFragment) {
                            eMachine.outerHTML = sFragment;
                            doneMachine();
                        } else {
                            displayError(sURL, "transformNodeToObject failed");
                        }
                    }
                    else if (document.implementation && document.implementation.createDocument) {
                        let xsltProcessor = new XSLTProcessor();
                        xsltProcessor['importStylesheet'](xsl);
                        let eFragment = xsltProcessor['transformToFragment'](xml, document);
                        if (eFragment) {
                            /*
                             * This fails in Microsoft Edge...
                             *
                             *      let machine = eFragment.getElementById(idMachine);
                             *      if (!machine) {
                             *          displayError(sURL, "machine generation failed: " + idMachine);
                             *      }
                             */
                            let element = eMachine.parentNode;
                            if (element) {

                                let x = 0, y = 0;
                                let rectOld = eMachine.getBoundingClientRect();
                                if (rectOld.bottom < 0) {
                                    x = window.scrollX;
                                    y = window.scrollY;
                                }

                                element.replaceChild(eFragment, eMachine);

                                eMachine = document.getElementById(idMachine);
                                if (eMachine && rectOld.bottom < 0) {
                                    let rectNew = eMachine.getBoundingClientRect();
                                    if (window.performance && window.performance.navigation.type == window.performance.navigation.TYPE_RELOAD) {
                                        /*
                                         * TODO: I'm not sure what to do in this case, because the browser tries to be clever
                                         * on a reload and preserve the original scroll position, but there are multiple variables
                                         * (ie, the presence of a hash ID in the URL, and the fact that we just inserted an HTML
                                         * fragment) that can cause the browser to do the wrong thing.  I could look up any hash
                                         * element and call scrollIntoView(), but that addresses only one scenario.
                                         *
                                         * If I do nothing, then each successive reload simply causes the scroll position to creep
                                         * farther and farther down the page.  So, I'm electing to go to the top of the page instead.
                                         */
                                        y = 0;
                                    } else {
                                        y += Math.ceil(rectNew.height - rectOld.height);
                                    }
                                    window.scrollTo(x, y);
                                }
                                doneMachine();
                            } else {
                                /*
                                 * NOTE: This error can occur if our Node web server, when processing a folder with
                                 * both a manifest.xml with a machine.xml reference AND a README.md containing a
                                 * machine link, generates duplicate embedXXX() calls for the same machine; if the
                                 * first embedXXX() call finds its target, subsequent calls for the same target will
                                 * fail.
                                 *
                                 * Technically, such a folder is in a misconfigured state, but it happens, in part
                                 * because when we switched to the Jekyll web server, we had to add machine links to
                                 * all README.md files where we had previously relied on manifest.xml or machine.xml
                                 * processing.  This is because the Jekyll web server currently doesn't process XML
                                 * files, nor is support for that likely to be added any time soon; it was a nice
                                 * feature of the Node web server, but it's not clear that it's worth doing for Jekyll.
                                 */
                                displayError(sURL, "invalid machine element: " + idMachine);
                            }
                        } else {
                            displayError(sURL, "transformToFragment failed");
                        }
                    } else {
                        /*
                         * Perhaps I should have performed this test at the outset; on the other hand, I'm
                         * not aware of any browsers don't support one or both of the above XSLT transformation
                         * methods, so treat this as a bug.
                         */
                        displayError(sURL, "unable to transform XML: unsupported browser");
                    }
                };
                /*
                 * NOTE: sXSLFile will never be undefined by this point, but apparently the Closure Compiler doesn't realize that.
                 */
                loadXML(sXSLFile || "", "", sAppName, sAppClass, "", "", false, displayMessage, transformXML);
            };

            if (sXMLFile.charAt(0) != '<') {
                loadXML(sXMLFile, idMachine, sAppName, sAppClass, sParms || "", sClass || "", true, displayMessage, processXML);
            } else {
                parseXML(sXMLFile, "", idMachine, sAppName, sAppClass, sParms || "", sClass || "", false, displayMessage, processXML);
            }
        } else {
            displayError(sXMLFile, "missing machine element: " + idMachine);
        }
    } catch(e) {
        displayError(sXMLFile, e.message);
    }
    return fSuccess;
}

/**
 * embedC1P(idMachine, sXMLFile, sXSLFile, sParms, sClass)
 *
 * @param {string} idMachine
 * @param {string} [sXMLFile]
 * @param {string} [sXSLFile]
 * @param {string} [sParms]
 * @param {string} [sClass]
 * @returns {boolean} true if successful, false if error
 */
function embedC1P(idMachine, sXMLFile, sXSLFile, sParms, sClass)
{
    if (fAsync) WebLib.enablePageEvents(false);
    return embedMachine("C1Pjs", "osi/c1p", idMachine, sXMLFile, sXSLFile, undefined, sClass);
}

/**
 * embedPCx86(idMachine, sXMLFile, sXSLFile, sParms, sClass)
 *
 * @param {string} idMachine
 * @param {string} [sXMLFile]
 * @param {string} [sXSLFile]
 * @param {string} [sParms]
 * @param {string} [sClass]
 * @returns {boolean} true if successful, false if error
 */
function embedPCx86(idMachine, sXMLFile, sXSLFile, sParms, sClass)
{
    if (fAsync) WebLib.enablePageEvents(false);
    return embedMachine("PCx86", "pcx86", idMachine, sXMLFile, sXSLFile, sParms, sClass);
}

/**
 * embedPCx80(idMachine, sXMLFile, sXSLFile, sParms, sClass)
 *
 * @param {string} idMachine
 * @param {string} [sXMLFile]
 * @param {string} [sXSLFile]
 * @param {string} [sParms]
 * @param {string} [sClass]
 * @returns {boolean} true if successful, false if error
 */
function embedPCx80(idMachine, sXMLFile, sXSLFile, sParms, sClass)
{
    if (fAsync) WebLib.enablePageEvents(false);
    return embedMachine("PCx80", "pcx80", idMachine, sXMLFile, sXSLFile, sParms, sClass);
}

/**
 * embedPDP10(idMachine, sXMLFile, sXSLFile, sParms, sClass)
 *
 * @param {string} idMachine
 * @param {string} [sXMLFile]
 * @param {string} [sXSLFile]
 * @param {string} [sParms]
 * @param {string} [sClass]
 * @returns {boolean} true if successful, false if error
 */
function embedPDP10(idMachine, sXMLFile, sXSLFile, sParms, sClass)
{
    if (fAsync) WebLib.enablePageEvents(false);
    return embedMachine("PDPjs", "dec/pdp10", idMachine, sXMLFile, sXSLFile, sParms, sClass);
}

/**
 * embedPDP11(idMachine, sXMLFile, sXSLFile, sParms, sClass)
 *
 * @param {string} idMachine
 * @param {string} [sXMLFile]
 * @param {string} [sXSLFile]
 * @param {string} [sParms]
 * @param {string} [sClass]
 * @returns {boolean} true if successful, false if error
 */
function embedPDP11(idMachine, sXMLFile, sXSLFile, sParms, sClass)
{
    if (fAsync) WebLib.enablePageEvents(false);
    return embedMachine("PDPjs", "dec/pdp11", idMachine, sXMLFile, sXSLFile, sParms, sClass);
}

/**
 * findMachineComponent(idMachine, sType)
 *
 * @param {string} idMachine
 * @param {string} sType
 * @returns {Component|null}
 */
function findMachineComponent(idMachine, sType)
{
    return Component.getComponentByType(sType, idMachine + ".machine");
}

/**
 * commandMachine(control, fSingle, idMachine, sComponent, sCommand, sValue)
 *
 * Use Component methods to find the requested component for a specific machine, and if the component is found,
 * then check its 'exports' table for an entry matching the specified command string, and if an entry is found, then
 * the corresponding function is called with the specified data.
 *
 * @param {Object} control
 * @param {boolean} fSingle
 * @param {string} idMachine
 * @param {string} sComponent
 * @param {string} sCommand
 * @param {string} [sValue]
 * @returns {boolean}
 */
function commandMachine(control, fSingle, idMachine, sComponent, sCommand, sValue)
{
    if (sCommand == "script") {
        if (Component.processScript(idMachine, sValue)) {
            if (fSingle) control.disabled = true;
            return true;
        }
        return false;
    }
    if (sComponent) {
        let component = Component.getComponentByType(sComponent, idMachine + ".machine");
        if (component) {
            let exports = component['exports'];
            if (exports) {
                let fnCommand = exports[sCommand];
                if (fnCommand) {
                    if (fnCommand.call(component, sValue)) {
                        if (fSingle) control.disabled = true;
                        return true;
                    }
                    return false;
                }
            }
        }
    }
    console.log("unimplemented: commandMachine('" + idMachine + "','" + sComponent + "','" + sCommand + "','" + sValue + "')");
    return false;
}

globals.window['embedC1P']    = embedC1P;
globals.window['embedPC']     = embedPCx86;     // WARNING: embedPC() deprecated as of v1.23.0
globals.window['embedPCx86']  = embedPCx86;
globals.window['embedPCx80']  = embedPCx80;
globals.window['embedPDP10']  = embedPDP10;
globals.window['embedPDP11']  = embedPDP11;
globals.window['commandMachine'] = commandMachine;

globals.window['enableEvents'] = WebLib.enablePageEvents;
globals.window['sendEvent']    = WebLib.doPageEvent;


/**
 * @copyright https://www.pcjs.org/machines/modules/v2/save.js (C) 2012-2024 Jeff Parsons
 */

/**
 * savePC(idMachine, sPCJSFile, callback)
 *
 * @param {string} idMachine
 * @param {string} sPCJSFile
 * @param {function(Object)} [callback]
 * @returns {boolean} true if successful, false if error
 */
function savePC(idMachine, sPCJSFile, callback)
{
    let cmp = /** @type {Computer} */ (Component.getComponentByType("Computer", idMachine));
    let dbg = false; // /** @type {Debugger} */ (Component.getComponentByType("Debuggerx86", idMachine));
    if (cmp) {
        let sState = cmp.powerOff(true);
        let sParms = cmp.saveMachineParms();
        if (!sPCJSFile) {
            if (DEBUG) {
                sPCJSFile = "/machines/pcx86/releases/" + APPVERSION + "/pcx86-uncompiled.js";
            } else {
                sPCJSFile = "/machines/pcx86/releases/" + APPVERSION + "/pcx86" + (dbg? "-dbg" : "") + ".js";
            }
        }
        if (callback && callback({ state: sState, parms: sParms })) return true;
        WebLib.getResource(sPCJSFile, null, true, function(sURL, sResponse, nErrorCode) {
            downloadCSS(sURL, sResponse, nErrorCode, [idMachine, StrLib.getBaseName(sPCJSFile, true), sParms, sState]);
        });
        return true;
    }
    Component.alertUser("Unable to identify machine '" + idMachine + "'");
    return false;
}

/**
 * downloadCSS(sURL, sPCJS, nErrorCode, aMachineInfo)
 *
 * @param {string} sURL
 * @param {string} sPCJS
 * @param {number} nErrorCode
 * @param {Array} aMachineInfo ([0] = idMachine, [1] = sScript, [2] = sParms, [3] = sState)
 */
function downloadCSS(sURL, sPCJS, nErrorCode, aMachineInfo)
{
    if (!nErrorCode && sPCJS) {
        aMachineInfo.push(sPCJS);
        let res = Component.getMachineResources(aMachineInfo[0]);
        let sCSSFile = null;
        for (let sName in res) {
            if (StrLib.endsWith(sName, "components.xsl")) {
                sCSSFile = sName.replace(".xsl", ".css");
                break;
            }
        }
        if (!sCSSFile) {
            /*
             * This is probably a bad idea (ie, allowing downloadPC() to proceed with our stylesheet)...
             */
            downloadPC(sURL, "", 0, aMachineInfo);
        } else {
            WebLib.getResource(sCSSFile, null, true, function(sURL, sResponse, nErrorCode) {
                downloadPC(sURL, sResponse, nErrorCode, aMachineInfo);
            });
        }
        return;
    }
    Component.alertUser("Error (" + nErrorCode + ") requesting " + sURL);
}

/**
 * downloadPC(sURL, sCSS, nErrorCode, aMachineInfo)
 *
 * @param {string} sURL
 * @param {string} sCSS
 * @param {number} nErrorCode
 * @param {Array} aMachineInfo ([0] = idMachine, [1] = sScript, [2] = sParms, [3] = sState, [4] = sPCJS)
 */
function downloadPC(sURL, sCSS, nErrorCode, aMachineInfo)
{
    let matchScript, sXMLFile, sXSLFile;
    let idMachine = aMachineInfo[0], sScript = aMachineInfo[1], sPCJS = aMachineInfo[4];

    /*
     * sPCJS is supposed to contain the entire PCjs script, which has been wrapped with:
     *
     *      (function(){...
     *
     * at the top and:
     *
     *      ...})()
     *
     * at the bottom, thanks to the following Closure Compiler option:
     *
     *      --output_wrapper "(function(){%output%})()"
     *
     * NOTE: There may also be a source map comment appended to the script, which we now ignore; eg:
     *
     *      //# sourceMappingURL=/machines/pcx86/releases/1.76/pcx86.js.map
     *
     * Immediately inside that wrapping, we want to embed all the specified machine's resources, using:
     *
     *      var resources = {"xml": "...", "xsl": "...", ...};
     *
     * Note that the "resources" variable has been added to our externs.js, to prevent it from being renamed
     * by the Closure Compiler.
     */
    matchScript = sPCJS.match(/^(\s*\(function\(\){)([\s\S]*)(}\)\(\);?)/);
    if (!matchScript) {
        /*
         * If the match failed, we assume that a DEBUG (uncompiled) script is being used,
         * so we'll provide a fake match that should work with whatever script was provided.
         */
        if (DEBUG) {
            matchScript = [sPCJS, "", sPCJS, ""];
        } else {
            Component.alertUser("Unsupported script");
            return;
        }
    }

    let res = Component.getMachineResources(idMachine), resNew = {}, sName;
    for (sName in res) {
        let data = res[sName];
        let sExt = StrLib.getExtension(sName);
        if (sExt == "xml") {
            /*
             * Look through this resource for <disk> entries whose paths do not appear as one of the
             * other machine resources, and remove those entries.
             */
            let matchDisk, reDisk = /[ \t]*<disk [^>]*path=(['"])(.*?)\1.*?<\/disk>\n?/g;
            while ((matchDisk = reDisk.exec(res[sName]))) {
                let path = matchDisk[2];
                if (path) {
                    if (res[path]) {
                        Component.printf("recording disk: \"%s\"\n", path);
                    } else {
                        data = data.replace(matchDisk[0], "");
                    }
                }
            }
            sXMLFile = sName = StrLib.getBaseName(sName);
        }
        else if (sExt == "xsl") {
            sXSLFile = sName = StrLib.getBaseName(sName);
        }
        Component.printf("saving resource: \"%s\" (%d bytes)\n", sName, data.length);
        resNew[sName] = data;
    }

    if (sCSS) {
        resNew[sName = 'css'] = sCSS;
        Component.printf("saving resource: \"%s\" (%d bytes)\n", sName, sCSS.length);
    }

    if (aMachineInfo[2]) {
        let sParms = resNew[sName = 'parms'] = aMachineInfo[2];
        Component.printf("saving resource: \"%s\" (%d bytes)\n", sName, sParms.length);
    }

    if (aMachineInfo[3]) {
        let sState = resNew[sName = 'state'] = aMachineInfo[3];
        Component.printf("saving resource: \"%s\" (%d bytes)\n", sName, sState.length);
    }

    if (sXMLFile && sXSLFile) {
        let sResources = JSON.stringify(resNew);

        sScript += ".js";
        sPCJS = matchScript[1] + "var resources=" + sResources + ";" + matchScript[2] + matchScript[3];
        Component.printf("saving machine: \"%s\" (%d bytes)\n", idMachine, sPCJS.length);

        /*
         * I don't recall exactly why I did this, because I just tested FireFox with copyright symbols intact,
         * and it seems to work fine.  And unfortunately, if we print any copyright strings containing the HTML
         * entity, the entity doesn't get translated prior to output.  So if it turns out we DO need this,
         * it's better to replace with the old-fashioned ASCII version.
         *
         *      sPCJS = sPCJS.replace(/\u00A9/g, "(C)");    // "&#xA9;" or "&copy;"
         */

        let sAlert = WebLib.downloadFile(sPCJS, "javascript", false, sScript);

        sAlert += ', copy it to your web server as "' + sScript + '", and then add the following to your web page:\n\n';
        sAlert += '<div id="' + idMachine + '"></div>\n';
        // sAlert += '...\n';
        sAlert += '<script src="' + sScript + '"></script>\n';

        /*
         * embedMachine() would use these defaults whenever the XML file was omitted, but that changed with the
         * introduction of JSON-based configs, so when using XML-based configs, those parameters must be explicit.
         *
         *      if (sXMLFile == "machine.xml" && sXSLFile == "components.xsl") {
         *          sXMLFile = sXSLFile = "";
         *      }
         */
        sXMLFile = ',"' + sXMLFile + '"';
        sXSLFile = ',"' + sXSLFile + '"';

        sAlert += '<script>embedPCx86("' + idMachine + '"' + sXMLFile + sXSLFile + ');</script>\n\n';
        sAlert += 'The machine should appear where the <div> is located.';
        Component.alertUser(sAlert);
        return;
    }
    Component.alertUser("This feature is not currently available for machines created directly from XML files.");
}

/**
 * Prevent the Closure Compiler from renaming functions we want to export, by adding them
 * as (named) properties of a global object.
 */
globals.window['savePC'] = savePC;
